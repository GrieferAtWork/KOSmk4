final global COPYRIGHT=
"/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */";

#ifdef __WINDOWS__
#define HOST_EXE(x)  x ".exe"
#else
#define HOST_EXE(x)  x
#endif

import fs;
import ipc;
import * from deemon;
import * from .kos.misc.libmagic.libmagic;
import * from .kos.misc.libmagic.steps.c;
import * from .kos.misc.libmagic.steps.mtools;
import * from .kos.misc.libmagic.steps.util;
import * from .kos.misc.libmagic.steps.elf;
import * from .kos.misc.libmagic.steps.custom;
import * from .kos.misc.libmagic.steps.keymap;
import * from .kos.misc.libmagic.toolchain.gcc;
import .kos.misc.magicemulator.options as emulator_options;
import AppExit from errors;

File.stdout.setbuf("line");
File.stderr.setbuf("line");

global CONFIG_MAX_COMPILERS: int = 12; /* TODO: Don't hardcode 12! - Calculate dynamically as the number of cores on our host machine */
global CONFIG_OPTIMIZE: bool = none;
global CONFIG_DEBUG: bool = none;
global TARGET_XARCH: string = none; /* Target cross-arch directory /include/$TARGET_XARCH-kos/... */
global TARGET_ARCH: string  = none; /* Target architecture name */
global TARGET_CPU: string   = none; /* Target cpu name */
global TARGET_NAME: string; /* Target configuration name */
global BINPATH: string;
global KERNEL_BINARY: string;
global CONFIG_EMULATOR_USED: string = "qemu"; /* none or "qemu" / "bochs" */
global CONFIG_EMULATOR_OPTIONS: {string: Object} = Dict();
global CONFIG_DONT_BUILD: bool = false;
global CONFIG_EMULATOR_STARTED_PATTERN: string = none;
global CONFIG_EMULATOR_GDB_MODE: string = none;
global requiredOutputWhiteList: {(bool,string)...} | none = none;
global requiredGroupWhiteList: {string...} | none = none;
global requiredGroupOfSourceFileWhiteList: {string...} | none = none;
global final EXE: string = "";
global final DLL: string = ".so";
global final TARGET_POINTER_SIZE: int;
global final TARGET_BITS_PER_POINTER: int;
global final CONFIG_FEATURE_FILE_SUFFIX = "";
global final config: Config = Config(LIBRARY_SUFFIX: DLL);
global final groups: {Group...} = [];
global final options: {string: Object} = Dict();
global final toolchain: Toolchain = GCCToolchain(config: config);


@@Returns (TARGET_ARCH, TARGET_CPU, TARGET_XARCH)
function parseTarget(target: string): (string, string, string) {
	return (
		target,
		{
			"i386" : "i686"
		}.get(target, target),
		{
			"x86_64" : "i386"
		}.get(target, target)
	);
}

function setTarget(target: string) {
	TARGET_ARCH, TARGET_CPU, TARGET_XARCH = parseTarget(target)...;
}

function parseConfig(config: string): (bool, bool) {
	return {
		"OD" : (true, true),
		"OnD" : (true, false),
		"nOD" : (false, true),
		"nOnD" : (false, false),
	}[config];
}

function setConfig(config: string) {
	CONFIG_OPTIMIZE, CONFIG_DEBUG = parseConfig(config)...;
}

function loadMissingSettings() {
	local target, config =
		import(".kos.misc.scripts.vsautoconfig")
			.parseCurrentVsConfiguration("kos/.vs/ProjectSettings.json")...;
	print "Automatically loaded settings:", repr target, repr config;
	local target_arch, target_cpu, target_xarch = parseTarget(target)...;
	if (TARGET_ARCH is none)
		TARGET_ARCH = target_arch;
	if (TARGET_CPU is none)
		TARGET_CPU = target_cpu;
	if (TARGET_XARCH is none)
		TARGET_XARCH = target_xarch;
	local config_optimize, config_debug = parseConfig(config)...;
	if (CONFIG_OPTIMIZE is none)
		CONFIG_OPTIMIZE = config_optimize;
	if (CONFIG_DEBUG is none)
		CONFIG_DEBUG = config_debug;
}


function getConfig(): string {
	return "{}{}".format({
		CONFIG_OPTIMIZE ? "O" : "nO",
		CONFIG_DEBUG ? "D" : "nD",
	});
}

function generateFile(filename: string, isRegEx: bool) {
	if (requiredOutputWhiteList is none)
		requiredOutputWhiteList = HashSet();
	if (!isRegEx) {
		if (filename.startswith("/"))
			filename = fs.abspath(filename.lstrip("/"), ROOTDIR);
		else {
			filename = fs.abspath(filename);
		}
		filename = normalizePath(filename, false);
	}
	requiredOutputWhiteList.insert((isRegEx, filename));
	CONFIG_EMULATOR_USED = none;
}

function generateGroup(name: string) {
	if (requiredGroupWhiteList is none)
		requiredGroupWhiteList = HashSet();
	requiredGroupWhiteList.insert(name);
	CONFIG_EMULATOR_USED = none;
}

function generateProjectOfInputFile(filename: string) {
	if (requiredGroupOfSourceFileWhiteList is none)
		requiredGroupOfSourceFileWhiteList = HashSet();
	filename = filename.startswith("/")
		? fs.abspath(filename.lstrip("/"), ROOTDIR)
		: fs.abspath(filename);
	filename = normalizePath(filename, false);
	requiredGroupOfSourceFileWhiteList.insert(filename);
	CONFIG_EMULATOR_USED = none;
}


function main(argv: {string...}) {
	local args = List(argv);
	print repr args;
	while (args) {
		local arg = args.pop(0);
		switch (arg) {
		case "-1":
		case "--single":
			CONFIG_MAX_COMPILERS = 1;
			break;
		case "-v":
		case "--verbose":
		case "--verbose=1":
			config.VERBOSE = true;
			break;
		case "--no-verbose":
		case "--verbose=0":
			config.VERBOSE = false;
			break;
		case "-E":
		case "--gen-pp":
			options.setdefault(OPT_COMPILE_SECONDARY, []).append("E");
			break;
		case "--no-gen-pp":
			options.get(OPT_COMPILE_SECONDARY).removeall("E");
			break;
		case "-S":
		case "--gen-asm":
			options.setdefault(OPT_COMPILE_SECONDARY, []).append("S");
			break;
		case "--no-gen-asm":
			options.get(OPT_COMPILE_SECONDARY).removeall("S");
			break;
		case "--run-only":
			CONFIG_DONT_BUILD = true;
			break;
		case "--build-only":
		case "--no-emulator":
			CONFIG_EMULATOR_USED = none;
			break;
		case "-f":
		case "--force":
			config.FORCE = true;
			break;
		case "--no-force":
			config.FORCE = false;
			break;
		case "--qemu-hosted":
			CONFIG_EMULATOR_OPTIONS[emulator_options.QEMU_HOSTED] = true;
			break;
		case "--no-qemu-hosted":
			CONFIG_EMULATOR_OPTIONS[emulator_options.QEMU_HOSTED] = false;
			break;
		case "--format-error-messages":
			config.FORMAT_ERRORS = true;
			break;
		case "--no-format-error-messages":
			config.FORMAT_ERRORS = false;
			break;
		case "--":
			CONFIG_EMULATOR_OPTIONS[emulator_options.QEMU_CMDLINE] = " ".join(args);
			args = { };
			break;
		default:
			if ("=" in arg) {
				local name, none, value = arg.partition("=")...;
				local final BOOLMAP = { "0": false, "1": true };
				switch (name) {
				case "--echo":
					print "ECHO:", repr(value);
					break;
				case "--feature-test":
					import(".kos.misc.libmagic.featuretest")
						.generateCompilerSpecs(toolchain, value, COPYRIGHT);
					AppExit.exit(0);
					break;
				case "-n":
				case "--compilers":
					CONFIG_MAX_COMPILERS = int(value);
					break;
				case "--emulator":
					CONFIG_EMULATOR_USED = value;
					break;
				case "--changed":
					addForceChanged(value);
					break;
				case "--verbose":
					config.VERBOSE = BOOLMAP[value];
					break;
				case "--gdb":
					CONFIG_EMULATOR_OPTIONS[emulator_options.QEMU_GDB] = value;
					break;
				case "--emulator-started-pattern":
					CONFIG_EMULATOR_STARTED_PATTERN = value;
					break;
				case "--target":
					setTarget(value);
					break;
				case "--config":
					setConfig(value);
					break;
				case "--vsgengroup":
					config.FORMAT_ERRORS = true;
				case "--gengroup":
					generateGroup(value);
					break;
				case "--vcautotargetconfig": {
					local target, config =
						import(".kos.misc.scripts.vsautoconfig")
						.parseCurrentVsConfiguration(value)...;
					setTarget(target);
					setConfig(config);
				}	break;

				case "--vsgengroup-of":
					config.FORMAT_ERRORS = true;
				case "--gengroup-of":
					generateProjectOfInputFile(value);
					break;

				case "--vsgen":
					config.FORMAT_ERRORS = true;
				case "--gen":
					generateFile(value, false);
					break;

				case "--vsregen":
					config.FORMAT_ERRORS = true;
				case "--regen":
					generateFile(value, true);
					break;
				default:
					goto _err_unknown_argument;
				}
			} else {
_err_unknown_argument:
				print "Unknown argument", repr arg;
				AppExit.exit(1);
			}
			break;
		}
	}
	fs.chdir(ROOTDIR);
	if (CONFIG_OPTIMIZE is none || CONFIG_DEBUG is none ||
	    TARGET_XARCH is none || TARGET_ARCH is none || TARGET_CPU is none)
		loadMissingSettings();
	TARGET_NAME = "{}-kos-{}".format({
		TARGET_ARCH,
		getConfig(),
	});

	{
		/* Make sure that the correct bin-config is selected. */
		local selConfig;
		local selConfigFile = "bin/{}-kos".format({ TARGET_ARCH });
		selConfig = cygwinReadLink(selConfigFile);
		if (selConfig !is string || selConfig != TARGET_NAME) {
			if (selConfig !is none)
				fs.unlink(selConfigFile);
			print "Changing libpath to", repr(TARGET_NAME);
			local p = ipc.Process("bash", [ "-c",
				"ln -s {!r} {!r}".format({ TARGET_NAME, selConfigFile })
			]);
			p.start();
			joinProcess(p);
		}
	}

#if 1 /* To speed up compilation, provide some known-good values
       * for standard library paths valid for the KOS toolchain */
	switch (TARGET_ARCH) {
	case "i386":
		/* TODO: This cache should be stored in a dynamically loaded
		 *       file `binutils/i386-kos/toolchain_cache.dee' */
		toolchain.provideStdlibCache(
			("c++", ("-fstack-protector-strong", )), (
				{	"binutils/i386-kos/lib/gcc/i686-kos/9.1.0",
					"binutils/i386-kos/i686-kos/lib",
					"binutils/i386-kos/lib",
					"bin/" + TARGET_NAME + "/lib" },
				{ "stdc++", "m", "ssp_nonshared", "ssp", "gcc", "c", "dl" },
				{ "bin/" + TARGET_NAME + "/lib/crt0.o" }
			));
		toolchain.provideStdlibCache(
			("c++", ()), (
				{	"binutils/i386-kos/lib/gcc/i686-kos/9.1.0",
					"binutils/i386-kos/i686-kos/lib",
					"binutils/i386-kos/lib",
					"bin/" + TARGET_NAME + "/lib" },
				{ "stdc++", "m", "gcc", "c", "dl" },
				{ "bin/" + TARGET_NAME + "/lib/crt0.o" }
			));
		toolchain.provideStdlibCache(
			("c", ("-fstack-protector-strong",)), (
				{	"binutils/i386-kos/lib/gcc/i686-kos/9.1.0",
					"binutils/i386-kos/i686-kos/lib",
					"binutils/i386-kos/lib",
					"bin/" + TARGET_NAME + "/lib" },
				{ "ssp_nonshared", "ssp", "gcc", "c", "dl" },
				{ "bin/" + TARGET_NAME + "/lib/crt0.o" }
			));
		toolchain.provideStdlibCache(
			("c", ()), (
				{	"binutils/i386-kos/lib/gcc/i686-kos/9.1.0",
					"binutils/i386-kos/i686-kos/lib",
					"binutils/i386-kos/lib",
					"bin/" + TARGET_NAME + "/lib" },
				{ "gcc", "c", "dl" },
				{ "bin/" + TARGET_NAME + "/lib/crt0.o" }
			));
		break;
	case "x86_64":
		toolchain.provideStdlibCache(
			("c++", ("-fstack-protector-strong", )), (
				{	"binutils/x86_64-kos/lib/gcc/x86_64-kos/9.1.0",
					"binutils/x86_64-kos/x86_64-kos/lib",
					"binutils/x86_64-kos/lib",
					"bin/" + TARGET_NAME + "/lib" },
				{ "stdc++", "m", "ssp_nonshared", "ssp", "gcc", "c", "dl" },
				{ "bin/" + TARGET_NAME + "/lib/crt0.o" }
			));
		toolchain.provideStdlibCache(
			("c++", ()), (
				{	"binutils/x86_64-kos/lib/gcc/x86_64-kos/9.1.0",
					"binutils/x86_64-kos/x86_64-kos/lib",
					"binutils/x86_64-kos/lib",
					"bin/" + TARGET_NAME + "/lib" },
				{ "stdc++", "m", "gcc", "c", "dl" },
				{ "bin/" + TARGET_NAME + "/lib/crt0.o" }
			));
		toolchain.provideStdlibCache(
			("c", ()), (
				{	"binutils/x86_64-kos/lib/gcc/x86_64-kos/9.1.0",
					"binutils/x86_64-kos/x86_64-kos/lib",
					"binutils/x86_64-kos/lib",
					"bin/" + TARGET_NAME + "/lib" },
				{ "gcc", "c", "dl" },
				{ "bin/" + TARGET_NAME + "/lib/crt0.o" }
			));
		break;
	default:
		break;
	}
#endif
	config.CROSS_PREFIX = "binutils/{}-kos/bin/{}-kos-".format({
		TARGET_ARCH,
		TARGET_CPU
	});
	config.BUILD_PATH = "build/" + TARGET_NAME;
	BINPATH = "bin/" + TARGET_NAME;
	KERNEL_BINARY = "/{}/os/kernel.bin".format({ BINPATH });
	TARGET_POINTER_SIZE = {
		"i386"   : 4,
		"x86_64" : 8,
	}[TARGET_ARCH];
	TARGET_BITS_PER_POINTER = TARGET_POINTER_SIZE * 8;
	if (TARGET_ARCH in ["i386", "x86_64"])
		CONFIG_FEATURE_FILE_SUFFIX = TARGET_BITS_PER_POINTER;

	/* Configure MTOOLS build steps */
	toolchain.options.setdefault(TOOLCHAIN_MTOOLS_EXE, HOST_EXE("binutils/build-mtools/mtools"));
	toolchain.options.setdefault(TOOLCHAIN_MTOOLS_DISK, BINPATH + "/disk.img");

	{
#define BEGIN           { local options = deepcopy __nth(2) options;
#define BEGIN_ANONYMOUS { local options = Dict();
#define END             }
#include "kos/.sources"
	}

	/* Automatically re-build changed sources */
	if (!CONFIG_DONT_BUILD) {
		/* Check that source generators are up-to-date. */
		import updateAutomaticSourcesOnDemand from .kos.misc.magicgenerator.ondemand;
		updateAutomaticSourcesOnDemand(
			TARGET_XARCH, TARGET_ARCH, TARGET_POINTER_SIZE);
		if (requiredOutputWhiteList !is none) {
			buildGroupsWithOutputWhitelist(
				toolchain:          toolchain,
				groups:             groups,
				outputWhiteList:    requiredOutputWhiteList,
				maxParallelSteps:   CONFIG_MAX_COMPILERS);
		} else if (requiredGroupWhiteList !is none) {
			buildGroupsWithGroupWhitelist(
				toolchain:          toolchain,
				groups:             groups,
				groupWhiteList:     requiredGroupWhiteList,
				maxParallelSteps:   CONFIG_MAX_COMPILERS);
		} else if (requiredGroupOfSourceFileWhiteList !is none) {
			buildGroupsWithGroupOfInputFileWhitelist(
				toolchain:          toolchain,
				groups:             groups,
				inputFileWhitelist: requiredGroupOfSourceFileWhiteList,
				maxParallelSteps:   CONFIG_MAX_COMPILERS);
		} else {
			buildGroups(
				toolchain:          toolchain,
				groups:             groups,
				maxParallelSteps:   CONFIG_MAX_COMPILERS);
		}
	}

	/* Start KOS with the selected emulator (if any). */
	if (CONFIG_EMULATOR_USED !is none) {
		if (CONFIG_EMULATOR_STARTED_PATTERN)
			print CONFIG_EMULATOR_STARTED_PATTERN;
		import(".kos.misc.magicemulator." + CONFIG_EMULATOR_USED).start(
			groups:         groups,
			config:         config,
			binPath:        BINPATH,
			kernelFile:     KERNEL_BINARY.lstrip("/"),
			targetArch:     TARGET_ARCH,
			targetCpu:      TARGET_CPU,
			diskFile:       toolchain.options[TOOLCHAIN_MTOOLS_DISK],
			options:        CONFIG_EMULATOR_OPTIONS,
		);
	}
}

#if defined(__MAIN__) && __BASE_FILE__ == __FILE__
try {
	main([...][1:]);
} @[interrupt] catch (e...) {
	print e;
	print repr Traceback.current;
	File.Buffer.sync();
	print "ERROR";
	AppExit.exit(1);
}
File.Buffer.sync();
print "DONE";
AppExit.exit(0);
#endif
















