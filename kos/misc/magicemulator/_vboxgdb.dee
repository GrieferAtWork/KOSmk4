/* Copyright (c) 2019-2022 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2022 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifdef __WINDOWS__
#define HOST_EXE(x)  x ".exe"
#else
#define HOST_EXE(x)  x
#endif

import * from deemon;
import * from ..libmagic.libmagic;
import ._options as opt;
import fs;
import net;
import ipc;

@@Log comunications and other verbose information
global CONFIG_VERBOSE;
global final DEFAULT_CONFIG_VERBOSE = false;

@@Timeout for the next byte in an on-going command (in microseconds)
@@When this timeout  is exceeded, the  current command is  discarded
global CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT;

@@Timeout for waiting for GDB to ACK a command (in microseconds)
@@When  this timeout is  exceeded, try to  send the packet again
global CONFIG_GDB_COMMAND_ACK_TIMEOUT;

@@Max   #  of  times  to  re-attempt  sending  a  response  to  GDB
@@the total # of attempts is @(CONFIG_GDB_SEND_MAX_RETRY_COUNT + 1)
global CONFIG_GDB_SEND_MAX_RETRY_COUNT;

@@Timeout (in microseconds) before re-attempting a telnet command,
@@or   assuming   that   the   command   completed   successfully.
global CONFIG_TELNET_RESPONSE_TIMEOUT;
global CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT;

@@Use VirtualBox's builtin (and broken) single-step
@@function,  rather  than  using  code   injection.
global final CONFIG_USE_NATIVE_STEP = false;

@@Keep the VM running during memory reads
global final CONFIG_KEEP_RUNNING_DURING_MEMORY_READ = false;

/* Options GDB features that are supported */
global CONFIG_GDBFEAT_VCONT: bool;
global CONFIG_GDBFEAT_KOS: bool; /* KOS-specific features (driver listings, etc.) */


/* The different types of break points */
global final GDB_BREAKPOINT_TYPE_SWBREAK   = 0; /* int3 */
global final GDB_BREAKPOINT_TYPE_HWBREAK   = 1; /* DRn-breakpoint */
global final GDB_BREAKPOINT_TYPE_WRITE     = 2; /* Break on write to `addr' */
global final GDB_BREAKPOINT_TYPE_READ      = 3; /* Break on read from `addr' */
global final GDB_BREAKPOINT_TYPE_READWRITE = 4; /* Break on read or write to/from `addr' */

/* Values for `_vboxgdb_trapctl.tc_ctrl` */
global final VBOXGDB_TRAPCTL_NTRAP = 0x00; /* Don't trap */
global final VBOXGDB_TRAPCTL_SSTEP = 0x01; /* Trap single-step events */
global final VBOXGDB_TRAPCTL_TRIGG = 0xff; /* Trap was triggered */

/* Offsets into `_vboxgdb_trapctl' */
global final tc_ctrl     = 0;
global final tc_cont     = 1;
global final tc_teaddr32 = 4;
global final tc_teaddr64 = 8;
global final tc_rstpst32 = 8;
global final tc_rstpst64 = 16;
global final tc_rstpen32 = 12;
global final tc_rstpen64 = 24;

/* Arguments passed to `startVboxGDBGlue()` */
global KERNEL: string;
global TARGET_ARCH: string;
global options: {string: Object};
global magic: Module;
global vmName: string;
global virtualBoxProc: ipc.Process;
global vbox: Module;
global vboxcmd: List;

@@Special kernel symbols needed by vboxgdb
global final KERNEL_ADDROF_NEEDED: {string...} = {
	"_vboxgdb_trapctl",
	"_vboxgdb_steploop",
};

@@Special kernel symbols needed by vboxgdb extensions for KOS
global final KERNEL_ADDROF_NEEDED_KOSEXT: {string...} = {
	"_vboxgdb_kos_driver_state",
};

@@Mapping of @(symbolName: (addr, size)) for special kernel symbols
global final KERNEL_ADDROF: {string: (int, int)} = Dict();

@@The socket through which we're connected to VirtualBox
global vBoxTelnetSocket: net.socket;

@@The gdb client socket
global gdbSocket: net.socket;

@@The server socket that is listening for GDB connections
global gdbServerSocket: net.socket;


global CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK: bool = false;
global CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK: bool = false;

@@Read in response  data until a  line is read  that doesn't contain  a
@@trailing line-feed and starts with @"VBoxDbg>". At that point, return
@@all previously read lines.
function vBoxTelnetGetResponse(timeout_microseconds: int = -1): Bytes {
	local result = none;
	for (;;) {
		local d = vBoxTelnetSocket.recv(-1, timeout_microseconds);
		if (d is none || (d is string && !d))
			break; /* Timeout */
		if (result is none) {
			result = d;
		} else {
			result += d;
		}
		if (!result.endswith("\n") && !result.endswith("\r")) {
			/* Find the start of the last line. */
			local n = result.rfind("\n");
			local r = result.rfind("\r");
			if (n < 0) {
				if (r < 0) {
					n = 0;
				} else {
					n = r + 1;
				}
			} else {
				if (r < 0) {
					++n;
				} else {
					if (r > n) {
						n = r + 1;
					} else {
						++n;
					}
				}
			}
			local final LASTLN_START = "VBoxDbg>";
			if (result.substr(n, n + #LASTLN_START) == LASTLN_START) {
				result = result[:n];
				break;
			}
		}
	}
	return result;
}

global GDBMain;

function getLines(fp: File): Bytes {
	local result = fp.read();
again:
	if (result &&
	    !result.endswith("\n") &&
	    !result.endswith("\r") &&
	    !result.endswith("\r\n")) {
		local d = fp.read();
		if (d) {
			result = result + d;
			goto again;
		}
	}
	return result;
}



@@Buffer of unread data from @gdbSocket
global gdbSocketBuffer: Bytes = "".bytes();

@@Receive a single byte from @gdbSocket
function gdbSocketGetc(
		timeout_microseconds: int = -1,
		gracefulTimeout: bool = false): int {
	local result;
	if (!gdbSocketBuffer) {
		gdbSocketBuffer = gdbSocket.recv(-1, timeout_microseconds);
		if (!gdbSocketBuffer) {
			if (timeout_microseconds == -1)
				throw Error("GDB Client gracefully disconnected");
			if (gracefulTimeout)
				return none;
			throw Error("Timeout while receiving data from GDB");
		}
	}
	result = gdbSocketBuffer[0];
	gdbSocketBuffer = gdbSocketBuffer[1:];
	return result;
}

function gdbSocketUngets(s: Bytes) {
	gdbSocketBuffer = s + gdbSocketBuffer;
}
function gdbSocketUngetc(c: int) {
	gdbSocketBuffer = Bytes({ c.u8 }) + gdbSocketBuffer;
}



/* Helper functions for controlling the VM */

function vBoxTelnetDiscardPendingData() {
	local data = vBoxTelnetSocket.recv(-1, 0);
	if (data) {
		do {
			data = vBoxTelnetSocket.recv(-1, 50000);
		} while (data);
	}
}

@@Execute a telnet command, wait for it to complete, and return its response
function vBoxTelnetExec(command: Bytes, restartOnTimeout: bool = true): Bytes {
again:
	vBoxTelnetDiscardPendingData();
	if (CONFIG_VERBOSE)
		print "[vboxgdb->telnet]", repr(command.rstrip("\r\n"));
	if (command.endswith("\r\n")) {
		vBoxTelnetSocket.send(command);
	} else {
		vBoxTelnetSocket.send(command.rstrip("\r\n") + "\r\n");
	}
	local result = vBoxTelnetGetResponse(CONFIG_TELNET_RESPONSE_TIMEOUT);
	if (result is none) {
		if (CONFIG_VERBOSE)
			print "[vboxgdb<-telnet] <Timeout>";
		if (restartOnTimeout)
			goto again;
	} else {
		if (CONFIG_VERBOSE)
			print "[vboxgdb<-telnet]", repr(result);
		/* This is an error that can happen sporadically for practically
		 * any  command. The solution is to try again when it happens... */
		if ("Invalid command event" in result)
			goto again;
		if ("Syntax error: Invalid command ''" in result)
			goto again;
	}
	return result;
}

function vBoxTelnetExecNoError(command: Bytes, restartOnTimeout: bool = true): Bytes {
	local response = vBoxTelnetExec(command, restartOnTimeout);
	if ("error:" in response || "Error:" in response) {
		local i = response.find("Failed to disassemble instruction");
		if (i >= 0) {
			response = response[:i].strip("\r\n") + "\r\n";
		} else {
			throw Error(f"Response for {repr command} indicates an error {repr response}");
		}
	}
	return response;
}



@@The current state of the VM (set using @vmResume() and @vmPause())
global vmIsRunning         = false; /* Paused via `stop' */
global _vmIsStepLoopPaused = none;  /* Paused via `_vboxgdb_steploop' (bool or none) */


@@The currently selected CPU core (set using @vmSetCurrentCpu())
global vmCurrentCpu = 0;

@@Change the currently selected CPU
function vmSetCurrentCpu(newCpu: int) {
	if (newCpu == vmCurrentCpu)
		return;
	vBoxTelnetExecNoError("cpu " + newCpu);
	vmCurrentCpu = newCpu;
}

function vmReadMemoryAt(addr: int | string): Bytes {
	/* NOTE: We use dd for reading memory (and not db), because
	 *       dd returns the same about  of bytes per line,  but
	 *       db also returns an ASCII representation that would
	 *       only make this parser more complicated.
	 *       Futhermore,  if the memory contains an ASCII string
	 *       equal to "error:",  our response processing  system
	 *       wouldn't be able to differentiate between something
	 *       like the ASCII string, and an actual error... */
	local hexaddr = addr;
	if (addr is int)
		hexaddr = addr.hex();
	local response = vBoxTelnetExec(
		"dd " + hexaddr).splitlines(false);
	local resultlen = 16 * #response;
	local result = Bytes(resultlen);
	local offset = 0;
	for (local l: response) {
		if (!l)
			continue;
		if ("error:" in l || "Error:" in l)
			break;
		local data = l[l.index(":") + 1:].lstrip();
		for (local dword: data.split(" ")) {
			if (!dword)
				continue;
			dword = int(dword, 16);
			if (offset + 4 >= resultlen) {
				resultlen = offset + 4;
				result = result.resized(resultlen);
			}
			result[offset] = dword & 0xff;
			++offset;
			result[offset] = (dword >> 8) & 0xff;
			++offset;
			result[offset] = (dword >> 16) & 0xff;
			++offset;
			result[offset] = (dword >> 24) & 0xff;
			++offset;
		}
	}
	if (!offset) {
		if (addr is int) {
			local offset = addr & 15;
			if (offset) {
				/* Virtualbox always  prints memory  in lines  of 16  bytes.
				 * If the given address isn't aligned by at least that much,
				 * there is a chance that part of those 16 bytes is  located
				 * somewhere  in  memory where  accessing it  is impossible.
				 * If this happens, VirtualBox will given us an error,  when
				 * in  fact it would  have been possible to  read at least a
				 * couple of leading bytes of memory.
				 * To work around this issue, we handle a read-error with
				 * an unaligned address by re-attempting the read with an
				 * aligned  address, thus allowing VirtualBox to at least
				 * read one line of memory successfully.
				 * HINT: In such a scenario, VirtualBox's response might look like:
				 * >> "%00000000ffffffe8: 07fa5023 00000000 07fa4023 00000000\r\n"
				 * >> "%00000000fffffff8: 07fa3023 00000000\r\n
				 * >> error: VERR_PAGE_TABLE_NOT_PRESENT:  Reading memory at %0000000100000000.\r\n"
				 */
				result = vmReadMemoryAt(addr - offset);
				if (offset > #result)
					return result[offset:];
				/* Fallthru to regular error handling */
			}
		}
		if ("error:" in response || "Error:" in response)
			throw Error(f"Response for {repr('dd ' + hexaddr)} indicates an error {repr response}");
		throw Error(f"Failed to read memory at {repr hexaddr} (response was {repr response})");
	}
	return result[:offset];
}

@@Read @count bytes of memory from @addr
function vmReadMemory(addr: int, count: int): Bytes {
	local result = vmReadMemoryAt(addr);
	while (count > #result) {
		/* Read more data */
		result += vmReadMemoryAt(addr + #result);
	}
	return result[:count];
}

#define vmWriteMemoryB(addr, value) vmWriteMemoryWord(addr, "b", value)
#define vmWriteMemoryW(addr, value) vmWriteMemoryWord(addr, "w", value)
#define vmWriteMemoryL(addr, value) vmWriteMemoryWord(addr, "d", value)
#define vmWriteMemoryQ(addr, value) vmWriteMemoryWord(addr, "q", value)

@@Write @data to memory at @addr
@@@param: wordType: One of @("b", "w", "d", "q")
function vmWriteMemoryWord(addr: string, wordType: string, value: int) {
	local resp;
	do {
		resp = vBoxTelnetExecNoError(f"e{wordType} {addr} {value.hex()}");
	} while (resp is none);
}

function insertWordLeInfoBytes(b: Bytes, offset: int, nBytes: int, v: int) {
	for (local j: [:nBytes]) {
		b[offset + j] = (v >> (j * 8)) & 0xff;
	}
}

function extractWordLeFromBytes(b: Bytes, offset: int, nBytes: int): int {
	local result = 0;
	for (local j: [:nBytes])
		result |= b[offset + j] << (j * 8);
	return result;
}

@@Write @data to memory at @addr
function vmWriteMemory(addr: int, data: Bytes) {
	local i = 0, len = #data;
	while (i < len) {
		local missing = len - i;
		local realAddr = (addr + i).hex();
		if (missing >= 8) {
			vmWriteMemoryWord(realAddr, "q", extractWordLeFromBytes(data, i, 8));
			i += 8;
		} else if (missing >= 4) {
			vmWriteMemoryWord(realAddr, "d", extractWordLeFromBytes(data, i, 4));
			i += 4;
		} else if (missing >= 2) {
			vmWriteMemoryWord(realAddr, "w", extractWordLeFromBytes(data, i, 2));
			i += 2;
		} else {
			vmWriteMemoryWord(realAddr, "b", data[i]);
			++i;
		}
	}
}

@@Set   of   currently   defined   breakpoints
@@Mapping is @(breakpointId: (typ, addr, len))
global vmDefinedBreakpoints: {int: (int, int, int)} = Dict();

@@Clear all defined breakpoints
function vmClearAllBreakpoints() {
	if (!vmDefinedBreakpoints)
		return;
	vBoxTelnetExecNoError("bc all");
	vmDefinedBreakpoints.clear();
}

@@Search for a  defined breakpoint and  returns
@@its ID, or @none if no such breakpoint exists
function vmFindDefinedBreakpoint(typ: int, addr: int, len: int): int | none {
	local packedData = (typ, addr, len);
	for (local id, data: vmDefinedBreakpoints) {
		if (data == packedData)
			return id;
	}
	return none;
}

@@Add/Remove a breakpoint
@@@param: typ: One of @(GDB_BREAKPOINT_TYPE_*)
function vmControlBreakpoint(add: bool, typ: int, addr: int, len: int) {
	local id;
	local response;
	if (typ == GDB_BREAKPOINT_TYPE_READ)
		typ = GDB_BREAKPOINT_TYPE_READWRITE;
	if (typ == GDB_BREAKPOINT_TYPE_SWBREAK) {
		len = 0;
	} else if (typ == GDB_BREAKPOINT_TYPE_HWBREAK) {
		if (TARGET_ARCH != "x86_64") {
			len = 1;
		} else if (len != 1 && len != 8) {
			throw Error("Invalid breakpoint exec-length: " + len);
		}
	} else {
		if (len !in [1, 2, 4, 8])
			throw Error("Invalid breakpoint data-length: " + len);
	}
	id  = vmFindDefinedBreakpoint(typ, addr, len);
	if (id !is none) {
		if (add)
			return; /* Already defined. */
		/* Delete this breakpoint */
again_delete_breakpoint:
		if (vBoxTelnetExecNoError("bc " + id) is none) {
			local idHex = id.hex()[2:].lower();
			for (local l: vBoxTelnetExecNoError("bl").splitlines()) {
				l = l.strip();
				if (!l)
					continue;
				l = l.lower();
				if (l.startswith("0x"))
					l = l[2:];
				if (l.startswith(idHex))
					goto again_delete_breakpoint;
			}
		}
		del vmDefinedBreakpoints[id];
		return;
	} else {
		if (!add)
			return; /* Doesn't exist. */
		if (typ == GDB_BREAKPOINT_TYPE_SWBREAK) {
			response = vBoxTelnetExecNoError("bp " + addr.hex());
			vmReadMemoryAt(addr);
		} else {
			response = vBoxTelnetExecNoError(f"ba { {
				GDB_BREAKPOINT_TYPE_HWBREAK   : 'e',
				GDB_BREAKPOINT_TYPE_READWRITE : 'r',
				GDB_BREAKPOINT_TYPE_WRITE     : 'w',
			}[typ]} {len} {addr.hex()}");
		}
	}
	response = response.strip().lower();
	local final PREFIX = "breakpoint ";
	response = response[response.index(PREFIX) + #PREFIX:].lstrip();
	local idEnd = 0;
	while (idEnd < #response && response.isnumeric(idEnd))
		++idEnd;
	if (!idEnd)
		throw Error(f"Invalid breakpoint id in response {repr response}");
	id = int(response[:idEnd]);
	vmDefinedBreakpoints[id] = (typ, addr, len);
}

@@Returns a lower-case hex-string without prefix
function _vmGetRegisterAsHex(name: string): Bytes {
	local resp = vBoxTelnetExecNoError("rg " + name, 1)
		.strip().splitlines(false);
	if (#resp != 1)
		throw Error(f"Unexpected # of lines in response to {repr('rg ' + name)} (response: {repr resp})");
	resp = resp[0];
	resp = resp[resp.index("=") + 1:].strip().lower();
	if (resp.startswith("0x"))
		resp = resp[2:];
	return resp;
}

function _vmGetRegister(name: string): int {
	return int(_vmGetRegisterAsHex(name), 16);
}

function _vmSetRegister(name: string, value: string | int) {
	if (value is int)
		value = value.hex();
	if (name in ["cs"]) {
		local oldval = str(_vmGetRegisterAsHex(name));
		oldval = oldval.lstrip("0");
		value = value.lower();
		if (value.startswith("0x"))
			value = value[2:];
		value = value.lstrip("0");
		if (oldval != value)
			throw Error(f"Cannot set register {repr name} = {repr value} (oldval = {repr oldval})");
		return;
	}
	vBoxTelnetExecNoError(f"rg {name} = {value}");
}

@@When @_vmIsStepLoopPaused is @none, determine its
@@proper value and  assign @true or  @false to  it.
function vmGetStepLoopPaused(rip: int = none): bool {
	if (_vmIsStepLoopPaused is none) {
		if (rip is none)
			rip = int(_vmGetRegisterAsHex("rip"), 16);
		local steploop = KERNEL_ADDROF["_vboxgdb_steploop"];
		_vmIsStepLoopPaused = rip >= steploop[0] &&
		                      rip <= steploop[0] + steploop[1];
	}
	return _vmIsStepLoopPaused;
}

@@When not @none, the new (E|R)IP value to set in @vmResume()
@@NOTE: Ignored when @vmGetStepLoopPaused() is @true
global _vmNewRip = none;
@@Same as @_vmNewRip, but for @"rflags"
global _vmNewRflags = none;

@@Returns a lower-case hex-string without prefix
function vmGetRegisterAsHex(name: string): Bytes {
	switch (name) {

	case "eip":
	case "rip": {
		if (_vmIsStepLoopPaused === false && _vmNewRip !is none)
			return _vmNewRip;
		local result = _vmGetRegisterAsHex(name);
		if (_vmIsStepLoopPaused is none)
			vmGetStepLoopPaused(int(result, 16));
		if (_vmIsStepLoopPaused) {
			local iret = vmReadMemoryAt("rsp");
			iret = extractWordLeFromBytes(iret, 0, TARGET_ARCH == "x86_64" ? 8 : 4);
			return iret.hex()[2:];
		} else if (_vmNewRip !is none) {
			result = _vmNewRip.hex()[2:];
		}
		return result;
	}

	case "cs":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 8, 2);
			} else {
				iret = extractWordLeFromBytes(iret, 4, 2);
			}
			return iret.hex()[2:];
		}
		break;

	case "eflags":
	case "rflags":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 16, 8);
			} else {
				iret = extractWordLeFromBytes(iret, 8, 4);
			}
			return iret.hex()[2:];
		} else if (_vmNewRflags !is none) {
			return _vmNewRflags.hex()[2:];
		}
		break;

	case "esp":
	case "rsp":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 24, 8);
			} else {
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					iret = extractWordLeFromBytes(iret, 12, 4);
				} else {
					/* Special case: Return a pointer to the ~true~ SP value,
					 *               which point to the end of the IRET tail. */
					return (_vmGetRegister("rsp") + 12).hex()[2:];
				}
			}
			return iret.hex()[2:];
		}
		break;

	case "ss":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 32, 8);
			} else {
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					iret = extractWordLeFromBytes(iret, 16, 2);
				} else {
					break;
				}
			}
			return iret.hex()[2:];
		}
		break;

	case "es":
	case "ds":
	case "fs":
	case "gs":
		if (TARGET_ARCH != "x86_64" && vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (extractWordLeFromBytes(iret, 10, 1) & 0x2) {
				/* VM86 iret return registers. */
				iret = extractWordLeFromBytes(iret, {
					"es" : 20,
					"ds" : 24,
					"fs" : 28,
					"gs" : 32,
				}[name], 2);
			} else {
				break;
			}
			return iret.hex()[2:];
		}
		break;

	default:
		break;
	}
	return _vmGetRegisterAsHex(name);
}

function vmGetRegister(name: string): int {
	return int(vmGetRegisterAsHex(name), 16);
}

function vmSetRegister(name: string, value: string | int) {
	switch (name) {

	case "eip":
	case "rip":
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("%rsp", value);
			} else {
				vmWriteMemoryL("%rsp", value);
			}
			return;
		} else {
			if (value !is int)
				value = int(value.lower().lstrip("0x"), 16);
			_vmNewRip = value;
			return;
		}
		break;

	case "cs":
		if (value !is int)
			value = int(value.lower().lstrip("0x"), 16);
		value = value & 0xffff;
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+8)", value);
			} else {
				vmWriteMemoryL("(%rsp+4)", value);
			}
			return;
		}
		break;

	case "eflags":
	case "rflags":
		if (vmGetStepLoopPaused()) {
			if (value !is int)
				value = int(value.lower().lstrip("0x"), 16);
			value = value & 0xffff;
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+0x10)", value);
			} else {
				vmWriteMemoryL("(%rsp+8)", value);
			}
			return;
		} else {
			if (value !is int)
				value = int(value.lower().lstrip("0x"), 16);
			_vmNewRflags = value;
			return;
		}
		break;

	case "esp":
	case "rsp":
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+0x18)", value);
			} else {
				local iret = vmReadMemoryAt("rsp");
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					vmWriteMemoryL("(%rsp+0xc)", value);
				} else {
					if (value !is int)
						value = int(value.lower().lstrip("0x"), 16);
					local oldSp = vmGetRegister("rsp");
					if (oldSp == value)
						return;
					throw Error(
						f"Cannot move kernel stack-pointer ("
						f"oldesp: 0x{oldSp.hex()[2:].zfill(8)}, "
						f"newesp: 0x{value.hex()[2:].zfill(8)})"
					);
				}
			}
			return;
		}
		break;

	case "ss":
		if (value !is int)
			value = int(value.lower().lstrip("0x"), 16);
		value = value & 0xffff;
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+0x20)", value);
			} else {
				local iret = vmReadMemoryAt("rsp");
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					vmWriteMemoryL("(%rsp+0x10)", value);
				} else {
					break;
				}
			}
			return;
		}
		break;

	case "es":
	case "ds":
	case "fs":
	case "gs":
		if (value !is int)
			value = int(value.lower().lstrip("0x"), 16);
		value = value & 0xffff;
		if (TARGET_ARCH != "x86_64" && vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (!(extractWordLeFromBytes(iret, 10, 1) & 0x2))
				break;
			vmWriteMemoryL("(%rsp+0x10)", value);
			return;
		}
		break;

	default:
		break;
	}
	_vmSetRegister(name, value);
}

function _vmGetRegisters(): {string: int} {
	local resp = vBoxTelnetExecNoError({
		"i386"   : "rg32",
		"x86_64" : "rg64",
	}[TARGET_ARCH]).unifylines(" ");
	for (;;) {
		local newresp = resp.replace("  ", " ");
		if (newresp == resp)
			break;
		resp = newresp;
	}
	resp = resp.replace("= ", "=").replace(" =", "=").lower();
	local result = Dict();
	for (local elem: resp.split(" ")) {
		local regnam, none, regval = elem.partition("=")...;
		if (!regnam || !regval)
			continue;
		try {
			regval = int(regval, 16);
		} catch (...) {
			continue;
		}
		if ((regnam.startswith("e") || regnam.startswith("r")) &&
		    (#regnam == 3 || regnam[1:] == "flags"))
			regnam = regnam[1:];
		result[regnam] = regval;
	}
	local final SEGMENT_REGISTERS = { "cs", "ds", "es", "fs", "gs" };
	local final MANDATORY_REGISTERS32 = {
		"ax", "bx", "cx", "dx", "si", "di", "sp", "bp", "ip", "flags",
		"cs", "ds", "es", "fs", "gs"
	};
	local final MANDATORY_REGISTERS64 = {
		"ax", "bx", "cx", "dx", "si", "di", "sp", "bp", "ip", "flags",
		"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
		"cs", "ds", "es", "fs", "gs"
	};
	for (local reg: TARGET_ARCH == "x86_64"
			? MANDATORY_REGISTERS64
			: MANDATORY_REGISTERS32) {
		if (reg !in result) {
			local regnam = reg;
			if (reg !in SEGMENT_REGISTERS && !reg.startswith("r"))
				reg = "r" + reg;
			result[regnam] = vmGetRegister(reg);
		}
	}
	return result;
}

@@Return a set of @(register, value) for the following registers:
@@   @"ax", @"bx", @"cx", @"dx", @"si", @"di", @"sp", @"bp", @"ip", @"flags"
@@   @"cs", @"ds", @"es", @"fs", @"gs"
@@On x86_64,  the   following  registers   are  also   contained:
@@   @"r8", @"r9", @"r10", @"r11", @"r12", @"r13", @"r14", @"r15"
@@The register names of the first line always have those names in the returned
@@mapping,  however will have had the one of @"foo", @"efoo" or @"rfoo" in the
@@original register list.
function vmGetRegisters(): {string: int} {
	local result = _vmGetRegisters();
	if (_vmIsStepLoopPaused is none)
		vmGetStepLoopPaused(result["ip"]);
	if (_vmIsStepLoopPaused) {
		/* Override registers with the step-loop IRet tail. */
		local iret = vmReadMemoryAt("rsp");
		if (TARGET_ARCH == "x86_64") {
			result["ip"]    = extractWordLeFromBytes(iret, 0, 8);
			result["cs"]    = extractWordLeFromBytes(iret, 8, 2);
			result["flags"] = extractWordLeFromBytes(iret, 16, 8);
			result["sp"]    = extractWordLeFromBytes(iret, 24, 8);
			result["ss"]    = extractWordLeFromBytes(iret, 32, 2);
		} else {
			result["ip"]    = extractWordLeFromBytes(iret, 0, 4);
			local cs        = extractWordLeFromBytes(iret, 4, 2);
			local eflags    = extractWordLeFromBytes(iret, 8, 4);
			result["cs"]    = cs;
			result["flags"] = eflags;
			if ((cs & 3) || (eflags & 0x00020000)) {
				/* user- or vm86- tail is present! */
				result["sp"] = extractWordLeFromBytes(iret, 12, 4);
				result["ss"] = extractWordLeFromBytes(iret, 16, 2);
				if (eflags & 0x00020000) {
					/* vm86-tail */
					result["es"] = extractWordLeFromBytes(iret, 20, 2);
					result["ds"] = extractWordLeFromBytes(iret, 24, 2);
					result["fs"] = extractWordLeFromBytes(iret, 28, 2);
					result["gs"] = extractWordLeFromBytes(iret, 32, 2);
				}
			} else {
				result["sp"] = result["sp"] + 12;
			}
		}
	} else {
		if (_vmNewRip !is none)
			result["ip"] = _vmNewRip;
		if (_vmNewRflags !is none)
			result["flags"] = _vmNewRflags;
	}
	return result;
}



function _vBoxManageControlVm(method: string, allowFailure: bool = false): int {
again:
	if (CONFIG_VERBOSE)
		print("[vboxgdb->VBoxManage] [\"controlvm\", ", repr(vmName), ", ", repr(method), "]");
	local error;
	error = vbox.runVBoxManageCommandEx(
		{ "controlvm", vmName, method },
		CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT);
	if (error is none) {
		if (CONFIG_VERBOSE)
			print "[vboxgdb<-VBoxManage] <Timeout>";
		if (allowFailure)
			return none;
		goto again;
	}
	if (CONFIG_VERBOSE)
		print "[vboxgdb<-VBoxManage] $? =", error;
	if (error != 0 && !allowFailure)
		goto again;
	return error;
}


global _vmIsUiPaused = false;

function _vmPauseUi() {
	if (!_vmIsUiPaused) {
		_vBoxManageControlVm("pause");
		_vmIsUiPaused = true;
	}
}

function _vmResumeUi() {
	if (_vmIsUiPaused) {
		_vBoxManageControlVm("resume");
		_vmIsUiPaused = false;
	}
}

@@Pause the VM through use of the debugger's "stop" command
function _vmPause0() {
again:
	local response = vBoxTelnetExec("stop");
	if ("The VM is already halted" in response) {
		/* ... */
	} else if ("error:" !in response && "Error:" !in response) {
		goto again;
	} else {
		throw Error("Failed to pause vm: " + repr(response));
	}
}

@@Pause the VM through use of the debugger's "stop" command
function _vmPause() {
	_vmPauseUi();
	_vmPause0();
}

function vmPause() {
	if (!vmIsRunning)
		return; /* Already paused */
	_vmPause();
	_vmIsStepLoopPaused = none; /* Unknown */
	vmIsRunning = false;
}

function _vmResume() {
	_vmPauseUi();
again:
	local response = vBoxTelnetExec("g");
	if ("already running" in response) {
		/* ... */
	} else if ("error:" !in response && "Error:" !in response) {
		goto again;
	} else {
		throw Error("Failed to resume vm: " + repr(response));
	}
	_vmResumeUi();
}

global GDBHandleVirtualBoxEvent;
global gdbStopReason;

@@Resume VM execution.  When @singleStep is  @true, only execute  a
@@single instruction and return once that instruction has finished,
@@alongside setting @gdbStopReason as appropriate
function vmResume(singleStep: bool = false) {
	if (vmIsRunning) {
		if (!singleStep)
			return; /* Already running */
		vmPause();
	}
	if (vmGetStepLoopPaused()) {
		if (!singleStep) {
do_resume_from_steploop:
			vmWriteMemoryW(KERNEL_ADDROF["_vboxgdb_trapctl"][0].hex(),
			               0x100 | VBOXGDB_TRAPCTL_NTRAP);
			goto do_resume;
		}
		/* VirtualBox's builtin single-step command is  busted.
		 * As  a   work-around,   use   ring0   code-injection.
		 * s.a. /kos/src/kernel/core/arch/i386/misc/vboxgdb32.S */
		local rflags = vmGetRegister("rflags");
		if (!(rflags & 0x00000100))
			vmSetRegister("rflags", rflags | 0x00000100); /* EFLAGS.TF = 1 */
set_trapctl_and_wait_for_single_step:
		vmWriteMemoryW(KERNEL_ADDROF["_vboxgdb_trapctl"][0].hex(),
		               0x100 | VBOXGDB_TRAPCTL_SSTEP);
		local usedDelay = 5000;
		if (CONFIG_KEEP_RUNNING_DURING_MEMORY_READ) {
			_vmResume();
			for (;;) {
				/* Wait for the program to step */
				Thread.yield();
				Thread.sleep(usedDelay);
				local trapctl = vmReadMemory(KERNEL_ADDROF["_vboxgdb_trapctl"][0], 1)[0];
				if (trapctl == VBOXGDB_TRAPCTL_TRIGG)
					break;
				/* Continue waiting */
				usedDelay += (usedDelay / 2);
			}
			_vmPause();
		} else {
			for (;;) {
				/* Wait for the program to step */
				_vmResume();
				Thread.yield();
				Thread.sleep(usedDelay);
				_vmPause();
				local trapctl = vmReadMemory(KERNEL_ADDROF["_vboxgdb_trapctl"][0], 1)[0];
				if (trapctl == VBOXGDB_TRAPCTL_TRIGG)
					break;
				/* Continue waiting */
				usedDelay += (usedDelay / 2);
			}
		}
		_vmIsStepLoopPaused = true;
		gdbStopReason = "T05"; /* SIGINT (used for single-step) */
		vmIsRunning = false;
		return;
	}
	if (_vmNewRip !is none) {
		if (_vmNewRip == _vmGetRegister("rip"))
			_vmNewRip = none;
	}
	if (_vmNewRflags !is none) {
		if (_vmNewRflags == _vmGetRegister("rflags"))
			_vmNewRflags = none;
	}
	if (singleStep) {
		if (_vmNewRip is none && _vmNewRflags is none && CONFIG_USE_NATIVE_STEP) {
			local resp = vBoxTelnetExecNoError("t");
			_vmResumeUi();
			if (!resp) {
				resp = vBoxTelnetGetResponse();
				if (CONFIG_VERBOSE)
					print "[vboxgdb<-telnet]", repr(resp);
			}
			_vmPauseUi();
			gdbStopReason = GDBHandleVirtualBoxEvent(resp);
			_vmIsStepLoopPaused = none; /* Unknown */
			vmIsRunning = false;
			return;
		}
		local rflags = vmGetRegister("rflags");
		if (!(rflags & 0x00000100))
			vmSetRegister("rflags", rflags | 0x00000100); /* EFLAGS.TF = 1 */
	}
	if (_vmNewRip !is none || _vmNewRflags !is none) {
		/* Setting rip or rflags directly doesn't work consistently.
		 * Instead, this  can  be  done via  ring0  code injection:
		 *          # Remember the old value of `*(u8 const *)%rip`
		 *    Tel>$ dd rip
		 *          # Insert a breakpoint instruction
		 *    Tel>$ eb rip 0xcc
		 *          # Tell  KOS to expect a breakpoint interrupt
		 *          # This causes a int3 from this address to be
		 *          # handled by entering _vboxgdb_steploop
		 *    Tel>$ ed <_vboxgdb_trapctl.tc_teaddr> <rip + 1>
		 *    do {
		 *        _vmResume();
		 *        Thread.yield();
		 *        Thread.sleep(5000);
		 *        _vmPause();
		 *    } while (!vmGetStepLoopPaused());
		 *          # Restore the overwritten instruction
		 *    Tel>$ eb <ORIG_RIP> <OLD_INSTR_BYTE>
		 *          # Overwrite RIP or RFLAGS within the IRET tail.
		 *    Tel>$ ed (%rsp+N) <_vmNewRip>
		 *    Tel>$ ed (%rsp+N) <_vmNewRflags>
		 *          # Allow the kernel to leave the step-loop
		 *    Tel>$ ew <KERNEL_ADDROF["_vboxgdb_trapctl"][0]> <0x100 | VBOXGDB_TRAPCTL_NTRAP>
		 *    _vmResume();
		 * Once we're  inside of  the step-loop,  we can  simply store  the
		 * overwrite values `_vmNewRip'  and `_vmNewRflags'  into the  iret
		 * tail that leads back to where the int3 instruction was injected. */
		local oldRip = vmGetRegister("rip");
		local oldInstruction = vmReadMemoryAt(oldRip);
		local trapCtl = KERNEL_ADDROF["_vboxgdb_trapctl"][0];
		vmWriteMemoryW(trapCtl.hex(),
		               0x100 | VBOXGDB_TRAPCTL_NTRAP);
		vmWriteMemoryB(oldRip.hex(), 0xcc);
		if (TARGET_ARCH == "x86_64") {
			vmWriteMemoryQ((trapCtl + tc_teaddr64).hex(), oldRip + 1);
		} else {
			vmWriteMemoryL((trapCtl + tc_teaddr32).hex(), oldRip + 1);
		}
		local usedDelay = 5000;
		for (;;) {
			_vmResume();
			Thread.yield();
			Thread.sleep(usedDelay);
			_vmPause();
			_vmIsStepLoopPaused = none;
			if (vmGetStepLoopPaused())
				break;
			/* Continue waiting */
			usedDelay += (usedDelay / 2);
		}
		/* We're now within the debugger step loop */
		vmWriteMemoryB(oldRip.hex(), oldInstruction[0]);
		/* Rewind the return-IP  to point to  the instruction that  was
		 * overwritten with int3 (must be done because int3 only causes
		 * an interrupt with IRET.EIP ==  ADDR_OF_INT3 + 1, so we  must
		 * re-wind to re-execute the original instruction following the
		 * temporary re-direct) */
		if (_vmNewRip is none)
			_vmNewRip = oldRip;
		if (TARGET_ARCH == "x86_64") {
			vmWriteMemoryQ("%rsp", _vmNewRip);
		} else {
			vmWriteMemoryL("%rsp", _vmNewRip);
		}
		_vmNewRip = none;
		if (_vmNewRflags !is none) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+0x10)", _vmNewRflags);
			} else {
				vmWriteMemoryL("(%rsp+8)", _vmNewRflags);
			}
			_vmNewRflags = none;
		}
		if (singleStep)
			goto set_trapctl_and_wait_for_single_step;
		goto do_resume_from_steploop;
	}
	if (singleStep)
		goto set_trapctl_and_wait_for_single_step;
do_resume:
	_vmResume();
	_vmIsStepLoopPaused = none; /* Unknown */
	vmIsRunning = true;
}

@@Wait for the VM to enter the step-loop and pause it
@@Use @vmResume() to continue execution at the step-loop's return location
function vmPauseAndWaitForStepLoop() {
	local usedDelay = 5000;
	for (;;) {
		vmPause();
		if (vmGetStepLoopPaused())
			break;
		vmResume();
		Thread.yield();
		Thread.sleep(usedDelay);
		usedDelay += (usedDelay / 2);
	}
}











@@The GDB stop reason (e.g. "T02")
@@This is the pre-fixed string returned by @gdbConstructStopReply()
global gdbStopReason: Bytes = none;

global gdbCurrentThreadForContinue: int = none;
global gdbCurrentThreadForGeneral: int = none;

function tohex(val: int): int {
	val = val & 0xf;
	if (val <= 9)
		return "0".ord() + val;
	return "a".ord() + val - 10;
}

function fromhex(ord: int): int {
	if (ord >= "0".ord() && ord <= "9".ord())
		return ord - "0".ord();
	if (ord >= "a".ord() && ord <= "f".ord())
		return 10 + ord - "a".ord();
	if (ord >= "A".ord() && ord <= "F".ord())
		return 10 + ord - "A".ord();
	throw Error("Invalid hex-character ordinal: " + repr(ord));
}

@@Calculate the correct checksum for a given GDB packet @data
function calculateGdbChecksum(data: Bytes): int {
	local result = 0;
	for (local d: data)
		result = (result + d) & 0xff;
	return result;
}

function gdbEncodeThreadId(id: int): Bytes {
	return vmCurrentCpu.hex()[2:].zfill(8).bytes();
}

function gdbDecodeThreadId(id: Bytes): int {
	local result = int(id.decode("utf-8"), 16);
	if (result < 0)
		return 0;
	return result;
}

function encodeHex4b(fp: File, s: int) {
	fp.putc(tohex(s >> 4));
	fp.putc(tohex(s));
	fp.putc(tohex(s >> 12));
	fp.putc(tohex(s >> 8));
	fp.putc(tohex(s >> 20));
	fp.putc(tohex(s >> 16));
	fp.putc(tohex(s >> 28));
	fp.putc(tohex(s >> 24));
}

function decodeHex(b: Bytes, i: int, nBytes: int): int {
	local result = 0;
	for (local j: [:nBytes]) {
		local c1 = fromhex(b[i + j * 2]);
		local c2 = fromhex(b[i + j * 2 + 1]);
		local c  = c1 << 4 | c2;
		result |= c << (j * 8);
	}
	return result;
}



@@Construct the response to-be returned by the '?' command (as well as \3 interrupts)
function gdbConstructStopReply(): Bytes {
	if (gdbStopReason is none)
		gdbStopReason = "T02"; /* SIGINT */
	return f"{gdbStopReason}thread:{gdbEncodeThreadId(vmCurrentCpu)};";
}



global final BASIC_REGISTER_COUNT64 = 24;
global final REGISTER_IDS64: {int: (int, string, string)} = {
	0x00 : (8, "ax", "rax"),       /* 64-bit [C] Accumulator register */
	0x01 : (8, "bx", "rbx"),       /* 64-bit [P] Base register */
	0x02 : (8, "cx", "rcx"),       /* 64-bit [C] Count register */
	0x03 : (8, "dx", "rdx"),       /* 64-bit [C] Data register */
	0x04 : (8, "si", "rsi"),       /* 64-bit [C] Source pointer */
	0x05 : (8, "di", "rdi"),       /* 64-bit [C] Destination pointer */
	0x06 : (8, "bp", "rbp"),       /* 64-bit [P] Frame base pointer */
	0x07 : (8, "sp", "rsp"),       /* 64-bit [P] Stack pointer */
	0x08 : (8, "r8",  "r8"),       /* 64-bit %r8 */
	0x09 : (8, "r9",  "r9"),       /* 64-bit %r9 */
	0x0a : (8, "r10", "r10"),      /* 64-bit %r10 */
	0x0b : (8, "r11", "r11"),      /* 64-bit %r11 */
	0x0c : (8, "r12", "r12"),      /* 64-bit %r12 */
	0x0d : (8, "r13", "r13"),      /* 64-bit %r13 */
	0x0e : (8, "r14", "r14"),      /* 64-bit %r14 */
	0x0f : (8, "r15", "r15"),      /* 64-bit %r15 */
	0x10 : (8, "ip", "rip"),       /* 64-bit Instruction pointer */
	0x11 : (4, "flags", "rflags"), /* 32-bit Flags register */
	0x12 : (4, "cs", "cs"),        /* 32-bit Code segment */
	0x13 : (4, "ss", "ss"),        /* 32-bit Stack segment */
	0x14 : (4, "ds", "ds"),        /* 32-bit D (destination) segment register */
	0x15 : (4, "es", "es"),        /* 32-bit E (source) segment register */
	0x16 : (4, "fs", "fs"),        /* 32-bit F segment register */
	0x17 : (4, "gs", "gs"),        /* 32-bit G segment register */
	/* NOTE: Reading/writing these registers could be done through use of code-injection! */
//TODO:#define GDB_REGISTER_X86_64_ST0    0x18 /* 80-bit %st(0) */
//TODO:#define GDB_REGISTER_X86_64_ST1    0x19 /* 80-bit %st(1) */
//TODO:#define GDB_REGISTER_X86_64_ST2    0x1a /* 80-bit %st(2) */
//TODO:#define GDB_REGISTER_X86_64_ST3    0x1b /* 80-bit %st(3) */
//TODO:#define GDB_REGISTER_X86_64_ST4    0x1c /* 80-bit %st(4) */
//TODO:#define GDB_REGISTER_X86_64_ST5    0x1d /* 80-bit %st(5) */
//TODO:#define GDB_REGISTER_X86_64_ST6    0x1e /* 80-bit %st(6) */
//TODO:#define GDB_REGISTER_X86_64_ST7    0x1f /* 80-bit %st(7) */
//TODO:#define GDB_REGISTER_X86_64_FCW    0x20 /* 32-bit fs_fcw (fctrl) */
//TODO:#define GDB_REGISTER_X86_64_FSW    0x21 /* 32-bit fs_fsw (fstat) */
//TODO:#define GDB_REGISTER_X86_64_FTW    0x22 /* 32-bit fs_ftw (ftag) */
//TODO:#define GDB_REGISTER_X86_64_FCS    0x23 /* 32-bit fs_fcs (fiseg) */
//TODO:#define GDB_REGISTER_X86_64_FIP    0x24 /* 32-bit fs_fip (fioff) */
//TODO:#define GDB_REGISTER_X86_64_FDS    0x25 /* 32-bit fs_fds (foseg) */
//TODO:#define GDB_REGISTER_X86_64_FDP    0x26 /* 32-bit fs_fdp (fooff) */
//TODO:#define GDB_REGISTER_X86_64_FOP    0x27 /* 32-bit fs_fop (fop) */
//TODO:#define GDB_REGISTER_X86_64_XMM0   0x28 /* 128-bit %xmm0 */
//TODO:#define GDB_REGISTER_X86_64_XMM1   0x29 /* 128-bit %xmm1 */
//TODO:#define GDB_REGISTER_X86_64_XMM2   0x2a /* 128-bit %xmm2 */
//TODO:#define GDB_REGISTER_X86_64_XMM3   0x2b /* 128-bit %xmm3 */
//TODO:#define GDB_REGISTER_X86_64_XMM4   0x2c /* 128-bit %xmm4 */
//TODO:#define GDB_REGISTER_X86_64_XMM5   0x2d /* 128-bit %xmm5 */
//TODO:#define GDB_REGISTER_X86_64_XMM6   0x2e /* 128-bit %xmm6 */
//TODO:#define GDB_REGISTER_X86_64_XMM7   0x2f /* 128-bit %xmm7 */
//TODO:#define GDB_REGISTER_X86_64_XMM8   0x30 /* 128-bit %xmm8 */
//TODO:#define GDB_REGISTER_X86_64_XMM9   0x31 /* 128-bit %xmm9 */
//TODO:#define GDB_REGISTER_X86_64_XMM10  0x32 /* 128-bit %xmm10 */
//TODO:#define GDB_REGISTER_X86_64_XMM11  0x33 /* 128-bit %xmm11 */
//TODO:#define GDB_REGISTER_X86_64_XMM12  0x34 /* 128-bit %xmm12 */
//TODO:#define GDB_REGISTER_X86_64_XMM13  0x35 /* 128-bit %xmm13 */
//TODO:#define GDB_REGISTER_X86_64_XMM14  0x36 /* 128-bit %xmm14 */
//TODO:#define GDB_REGISTER_X86_64_XMM15  0x37 /* 128-bit %xmm15 */
//TODO:#define GDB_REGISTER_X86_64_MXCSR  0x38 /* 32-bit %mxcsr */
//TODO:#define GDB_REGISTER_X86_64_FSBASE 0x40 /* 64-bit %fs.base */
//TODO:#define GDB_REGISTER_X86_64_GSBASE 0x41 /* 64-bit %gs.base */
};

global final BASIC_REGISTER_COUNT32 = 16;
global final REGISTER_IDS32: {int: (int, string, string)} = {
	0x00 : (4, "ax", "rax"),
	0x01 : (4, "cx", "rcx"),
	0x02 : (4, "dx", "rdx"),
	0x03 : (4, "bx", "rbx"),
	0x04 : (4, "sp", "rsp"),
	0x05 : (4, "bp", "rbp"),
	0x06 : (4, "si", "rsi"),
	0x07 : (4, "di", "rdi"),
	0x08 : (4, "ip", "rip"),
	0x09 : (4, "flags", "rflags"),
	0x0a : (4, "cs", "cs"),
	0x0b : (4, "ss", "ss"),
	0x0c : (4, "ds", "ds"),
	0x0d : (4, "es", "es"),
	0x0e : (4, "fs", "fs"),
	0x0f : (4, "gs", "gs"),
	/* NOTE: Reading/writing these registers could be done through use of code-injection! */
//TODO:#define GDB_REGISTER_I386_ST0    0x10 /* %st(0) */
//TODO:#define GDB_REGISTER_I386_ST1    0x11 /* %st(1) */
//TODO:#define GDB_REGISTER_I386_ST2    0x12 /* %st(2) */
//TODO:#define GDB_REGISTER_I386_ST3    0x13 /* %st(3) */
//TODO:#define GDB_REGISTER_I386_ST4    0x14 /* %st(4) */
//TODO:#define GDB_REGISTER_I386_ST5    0x15 /* %st(5) */
//TODO:#define GDB_REGISTER_I386_ST6    0x16 /* %st(6) */
//TODO:#define GDB_REGISTER_I386_ST7    0x17 /* %st(7) */
//TODO:#define GDB_REGISTER_I386_FCW    0x18 /* fs_fcw (fctrl) */
//TODO:#define GDB_REGISTER_I386_FSW    0x19 /* fs_fsw (fstat) */
//TODO:#define GDB_REGISTER_I386_FTW    0x1a /* fs_ftw (ftag) */
//TODO:#define GDB_REGISTER_I386_FCS    0x1b /* fs_fcs (fiseg) */
//TODO:#define GDB_REGISTER_I386_FIP    0x1c /* fs_fip (fioff) */
//TODO:#define GDB_REGISTER_I386_FDS    0x1d /* fs_fds (foseg) */
//TODO:#define GDB_REGISTER_I386_FDP    0x1e /* fs_fdp (fooff) */
//TODO:#define GDB_REGISTER_I386_FOP    0x1f /* fs_fop (fop) */
//TODO:#define GDB_REGISTER_I386_XMM0   0x20 /* %xmm0 */
//TODO:#define GDB_REGISTER_I386_XMM1   0x21 /* %xmm1 */
//TODO:#define GDB_REGISTER_I386_XMM2   0x22 /* %xmm2 */
//TODO:#define GDB_REGISTER_I386_XMM3   0x23 /* %xmm3 */
//TODO:#define GDB_REGISTER_I386_XMM4   0x24 /* %xmm4 */
//TODO:#define GDB_REGISTER_I386_XMM5   0x25 /* %xmm5 */
//TODO:#define GDB_REGISTER_I386_XMM6   0x26 /* %xmm6 */
//TODO:#define GDB_REGISTER_I386_XMM7   0x27 /* %xmm7 */
//TODO:#define GDB_REGISTER_I386_MXCSR  0x28 /* %mxcsr */
//TODO:#define GDB_REGISTER_I386_FSBASE 0x30 /* %fs.base */
//TODO:#define GDB_REGISTER_I386_GSBASE 0x31 /* %gs.base */
};


@@@return: * :    Text to return
@@@return: none:  Unknown @name
@@@return: false: Invalid @annex
function GDBEvaluateQXferRead(name: string, annex: string): Bytes | none {
	switch (name) {

	case "exec-file":
		if (annex)
			return false;
		return "/os/kernel.bin";

	case "libraries":
		if (!CONFIG_GDBFEAT_KOS)
			break;
		if (annex)
			return false;
		return import("._vboxgdbkos").printLibraryList();

	case "osdata": {
		local files = import("._vboxgdbinfo").OSDATAFILES;
		annex = annex.replace("\t", " ").strip();
		for (;;) {
			local newAnnex = annex.replace("  ", " ");
			if (newAnnex == annex)
				break;
			annex = newAnnex;
		}
		local argv = Tuple(annex.split(" "));
		if (!argv) {
			File.Writer result;
			result << "<osdata type=\"types\">";
			for (local name: files.keys) {
				local titleName = name.title();
				result << "<item>"
					"<column name=\"Type\">" << name << "</column>"
					"<column name=\"Description\">" << titleName << "</column>"
					"<column name=\"Title\">" << titleName << "</column>"
				"</item>";
			}
			result << "</osdata>";
			return result.string;
		}
		local res = files.get(argv[0]);
		if (res is none)
			return false;
		if (res !is string) {
			res = res(argv);
		} else {
			if (#argv != 1)
				return false;
		}
		return f"<osdata type=\"{annex}\">{res}</osdata>";
	}
	default:
		break;
	}
	return none;
}

@@Evaluate a given @cmd and return the intended response
function GDBEvaluateCommand(cmd: Bytes): Bytes {
	if (!cmd)
		goto unknown;
	local ch0 = cmd[0];
	switch (ch0) {

	case "?".ord():
		/* This query should only be issued during startup. Use it to clear breakpoints. */
		vmClearAllBreakpoints();
		return gdbConstructStopReply();

	case "C".ord():
		cmd = cmd[cmd.index(";") + 1:]; /* Skip the signal number */
	case "c".ord(): {
		local rip = cmd[1:];
		if (rip) {
			rip = int(rip, 16);
			vmSetCurrentCpu(gdbCurrentThreadForContinue);
			vmSetRegister("rip", rip);
		}
do_vmResume:
		vmResume();
		/* Check if the VM has already stopped once again. */
		if (!vmIsRunning)
			return gdbConstructStopReply();
		return none;
	}

	case "g".ord(): {
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		local regs = vmGetRegisters();
		File.Writer result;
		if (TARGET_ARCH == "x86_64") {
			for (local id: [:BASIC_REGISTER_COUNT64]) {
				local name = REGISTER_IDS64[id][1];
				encodeHex4b(result, regs[name]);
			}
		} else {
			for (local id: [:BASIC_REGISTER_COUNT32]) {
				local name = REGISTER_IDS32[id][1];
				encodeHex4b(result, regs[name]);
			}
		}
		return result.string;
	}

	case "G".ord(): {
		local data = cmd[1:];
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		local count, table;
		if (TARGET_ARCH == "x86_64") {
			count = BASIC_REGISTER_COUNT64;
			table = REGISTER_IDS64;
		} else {
			count = BASIC_REGISTER_COUNT32;
			table = REGISTER_IDS32;
		}
		local offset = 0;
		for (local id: [:count]) {
			local def = table[id];
			local size = def[0];
			vmSetRegister(def[2], decodeHex(data, offset, size));
			offset += size * 2;
		}
		return "OK";
	}

	case "p".ord(): {
		local id = int(cmd[1:], 16);
		local data, def;
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			def = REGISTER_IDS64[id];
		} else {
			def = REGISTER_IDS32[id];
		}
		data = vmGetRegisterAsHex(def[2]);
		local len = def[0] * 2;
		data = data.lstrip("0").zfill(len);
		if (#data > len)
			data = data[#data - len:];
		return data;
	}

	case "P".ord(): {
		local idEnd = cmd.index("=");
		local id    = int(cmd[1:idEnd], 16);
		local value = "0x" + cmd[idEnd + 1:];
		local def;
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			def = REGISTER_IDS64[id];
		} else {
			def = REGISTER_IDS32[id];
		}
		vmSetRegister(def[2], value);
		return "OK";
	}

	case "H".ord(): {
		local op = cmd[1];
		local id = gdbDecodeThreadId(cmd[2:]);
		if (op == "c".ord()) {
			vmSetCurrentCpu(id);
			gdbCurrentThreadForContinue = id;
		} else if (op == "g".ord()) {
			vmSetCurrentCpu(id);
			gdbCurrentThreadForGeneral = id;
		} else {
			goto unknown;
		}
		return "OK";
	}

	case "I".ord():
	case "S".ord():
		cmd = cmd[cmd.index(";") + 1:]; /* Skip the signal number */
	case "i".ord():
	case "s".ord(): {
		local rip = cmd[1:];
		if (rip) {
			rip = int(rip, 16);
			vmSetCurrentCpu(gdbCurrentThreadForContinue);
			vmSetRegister("rip", rip);
		}
		/* Do the single-step */
do_vmStep:
		vmResume(singleStep: true);
		return gdbConstructStopReply();
	}

	case "k".ord():
		print "[vboxgdb] GDB kill request";
		virtualBoxProc.terminate(1);
		return "OK";

	case "m".ord(): {
		local addr, none, length = cmd[1:].partition(",")...;
		addr   = int(addr, 16);
		length = int(length, 16);
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		local data = vmReadMemory(addr, length);
		local result = Bytes(length * 2);
		for (local i: [:length]) {
			local b = data[i];
			result[(i * 2)]     = tohex(b >> 4);
			result[(i * 2) + 1] = tohex(b);
		}
		return result;
	}

	case "M".ord(): {
		local addr_end   = cmd.index(",");
		local length_end = cmd.index(":", addr_end + 1);
		local addr   = cmd[1:addr_end];
		local length = cmd[addr_end + 1:length_end];
		local data = cmd[length_end + 1:];
		addr   = int(addr, 16);
		length = int(length, 16);
		if (length > #data / 2)
			throw Error("Too few data digits for memory write");
		local rawData = Bytes(length);
		for (local i: [:length]) {
			local lo = fromhex(data[i * 2]);
			local hi = fromhex(data[i * 2 + 1]);
			rawData[i] = (hi << 4) | lo;
		}
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		vmWriteMemory(addr, rawData);
		return "OK";
	}

	/* TODO: T */
	/* TODO: qSearch */
	/* TODO: qThreadExtraInfo */
	/* TODO: qfThreadInfo */
	/* TODO: qlThreadInfo */
	/* TODO: qNoAckMode */
	/* TODO: QStartNoAckMode */
	/* TODO: QNoAckMode */
	/* TODO: X */

	case "v".ord(): {
		local nameEnd = 1;
		while (nameEnd < #cmd &&
		       cmd[nameEnd] !in [";".ord(), "?".ord()])
			++nameEnd;
		switch (cmd[1:nameEnd]) {

		case "Cont": {
			if (!CONFIG_GDBFEAT_VCONT)
				break;
			if (cmd[nameEnd] == "?".ord())
				return "vCont;c;C;s;S;r";
			local shouldStep = false;
			local stepRangeStart = none;
			local stepRangeEnd = none;
			for (local act: cmd[nameEnd + 1:].split(";")) {
				local c = act[0];
				if (c in ["c".ord(), "C".ord()]) {
					/* ... */
				} else if (c in ["s".ord(), "S".ord()]) {
					shouldStep = true;
				} else if (c == "r".ord()) {
					shouldStep = true;
					local end = act.find(":");
					if (end < 0)
						end = #act;
					stepRangeStart, none, stepRangeEnd =
						act[1:end].partition(",")...;
					stepRangeStart = int(stepRangeStart, 16);
					stepRangeEnd   = int(stepRangeEnd, 16);
				}
			}
			if (!shouldStep)
				goto do_vmResume;
			if (stepRangeStart !is none) {
				local trapctl = KERNEL_ADDROF["_vboxgdb_trapctl"][0];
				if (TARGET_ARCH == "x86_64") {
					vmWriteMemoryQ((trapctl + tc_rstpst64).hex(), stepRangeStart);
					vmWriteMemoryQ((trapctl + tc_rstpen64).hex(), stepRangeEnd);
				} else {
					vmWriteMemoryL((trapctl + tc_rstpst32).hex(), stepRangeStart);
					vmWriteMemoryL((trapctl + tc_rstpen32).hex(), stepRangeEnd);
				}
			}
			goto do_vmStep;
		}

		default:
			break;
		}
		break;
	}

	case "q".ord(): {
		local nameEnd = 1;
		while (nameEnd < #cmd &&
		       cmd[nameEnd] !in [",".ord(), ":".ord(), ";".ord()])
			++nameEnd;
		switch (cmd[1:nameEnd]) {

		case "C":
			return "QC" + gdbEncodeThreadId(gdbCurrentThreadForGeneral);

		case "Xfer": {
			local i;
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local name = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local method = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local annex = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(",", i);
			local offset = int(cmd[i:nameEnd], 16);
			local size   = int(cmd[nameEnd + 1:], 16);
			if (method == "read") {
				local result = GDBEvaluateQXferRead(name, annex);
				if (result is none)
					return ""; /* Unknown */
				if (result === false)
					return "E02";
				local reslen = #result;
				if (offset >= reslen)
					return "l"; /* Out-of-bounds (empty last packet) */
				if (offset + size >= reslen)
					return "l" + result[offset:];
				return "m" + result[offset:offset + size];
			} else if (method == "write") {
				return "";
			} else {
				throw Error("Invalid qXfer method: " + repr(method));
			}
		}

		case "Supported": {
			local features = cmd[nameEnd + 1:];
			CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK = false;
			CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK = false;
			for (local feat: features.split(";")) {
				if (feat.endswith("+")) {
					feat = feat[:-1];
					if (feat == "swbreak") {
						CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK = true;
					} else if (feat == "hwbreak") {
						CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK = true;
					}
				}
			}
			File.Writer result;
			result << "PacketSize=100000";
			if (CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK)
				result << ";swbreak+";
			if (CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK)
				result << ";hwbreak+";
			result << ";qXfer:exec-file:read+";
			result << ";qXfer:osdata:read+";
			if (CONFIG_GDBFEAT_KOS)
				result << ";qXfer:libraries:read+";
			/* TODO: QNoAckMode */
			return result.string;
		}

		default:
			break;
		}
		break;
	}

	case "z".ord():
	case "Z".ord(): {
		local shouldAdd = cmd[0] == "Z".ord();
		local type_end = cmd.index(",");
		local addr_end = cmd.index(",", type_end + 1);
		local typ  = int(cmd[1:type_end], 16);
		local addr = int(cmd[type_end + 1:addr_end], 16);
		local len  = int(cmd[addr_end + 1:], 16);
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		vmControlBreakpoint(shouldAdd, typ, addr, len);
		return "OK";
	}

	default:
		break;
	}
unknown:
	return "";
}

@@Handle an event originating from the kernel as @"%{vboxgdb:<command>}"
@@@return: * :   Send this as a stop reply to GDB (value for @gdbStopReason)
@@@return: none: Ignore and resume execution
function GDBHandleVBoxCommand(command: Bytes): string {
	local name = command, args = "";
	if (":" in command)
		name, none, args = command.partition(":")...;
	switch (name) {

	case "library": {
		/* OS is notifying us that the library list has changed.
		 * Wait for the OS to enter the step-loop. */
		vmPauseAndWaitForStepLoop();
		/* Notify GDB that the list of drivers may have changed. */
		if (CONFIG_GDBFEAT_KOS)
			return "T05library:;";
		/* KOS features are disabled (ignore library-events) */
		vmResume();
		return none;
	}

	default:
		throw Error(f"Unknown command {repr name} in {repr command}");
		break;
	}
}

@@Handle an event message send by the VirtualBox debugger
@@@return: * :   Send this as a stop reply to GDB (value for @gdbStopReason)
@@@return: none: Ignore and resume execution
function GDBHandleVirtualBoxEvent(event: Bytes): string {
	/* TODO: Include registers (if given) from `event'
	 * NOTE: event normally looks like:
	 * >> "\r\n"
	 * >> "dbgf event: Single step! (other)\r\n"
	 * >> "eax=00000000 ebx=c0c85733 ecx=00000000 edx=00000504 esi=c0c85733 edi=c0c85656\r\n"
	 * >> "eip=c02e0aae esp=c0cb4a00 ebp=c0cb4aa4 iopl=0 nv up di pl nz na pe nc\r\n"
	 * >> "cs=0008 ds=0023 es=0023 fs=0040 gs=0033 ss=0010               eflags=00000002\r\n"
	 * >> "0008:c02e0aae 8b 45 f0                mov eax, dword [ebp-010h]\r\n".bytes()
	 * Which as you can see contains the same data as used by `vmGetRegisters()` */
	if ("Single step" in event)
		return "T05"; /* SIGINT */
	local i = event.find("Breakpoint ");
	if (i >= 0) {
		i += #"Breakpoint ";
		local id = event[i:].lstrip();
		local idEnd = 0;
		while (idEnd < #id && id.isnumeric(idEnd))
			++idEnd;
		if (!idEnd)
			throw Error(f"Invalid breakpoint id in event {repr event}");
		id = int(id[:idEnd]);
		local data = vmDefinedBreakpoints[id];

		if (data[0] == GDB_BREAKPOINT_TYPE_SWBREAK) {
			if (CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK)
				return "T05swbreak:;";
		} else {
			if (CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK)
				return "T05hwbreak:;";
		}
	}
	return "T05";
}

function GDBEnter() {
	/* Always make sure that the VM is paused when we get here! */
	vmPause();
	gdbCurrentThreadForContinue = vmCurrentCpu;
	gdbCurrentThreadForGeneral  = vmCurrentCpu;
}


@@The main function for the GDB glue driver
function GDBMain() {
	try {
		gdbSocket = gdbServerSocket.accept();
		if (CONFIG_VERBOSE)
			print "[vboxgdb] GDB connection established:", gdbSocket;
		for (;;) {
			local resp;
			local c;
wait_for_command:
			if (vmIsRunning) {
				local final CHECK_TIMEOUT_MICROSECONDS = 50000;
				for (;;) {
					if (vboxcmd) {
						local cmd = vboxcmd.popfront();
						if (CONFIG_VERBOSE)
							print "[vboxgdb<-kos] Request:", repr(cmd);
						local reason;
						try {
							reason = GDBHandleVBoxCommand(cmd);
						} catch (e...) {
							print "[vboxgdb] Warning: Error while handling OS request:", repr(cmd);
							print e;
							print repr Traceback.current;
							continue;
						}
						if (reason !is none) {
							gdbStopReason = reason;
							vmPause();
							goto do_send_stop_reply;
						}
						continue;
					}
					c = gdbSocketGetc(CHECK_TIMEOUT_MICROSECONDS,
					                  gracefulTimeout: true);
					if (c !is none)
						break;
					c = vBoxTelnetGetResponse(CHECK_TIMEOUT_MICROSECONDS);
					if (c !is none) {
						if (CONFIG_VERBOSE)
							print "[vboxgdb<-telnet] Event:", repr(c);
						if ("Invalid command event" in c) {
							/* This  can  happen if  a previous  resume attempt
							 * failed with a delayed error. - Re-try the resume */
							_vmResume();
							continue; /* Ignore... */
						}
						local reason = GDBHandleVirtualBoxEvent(c);
						if (reason !is none) {
							gdbStopReason = reason;
							vmPause();
							goto do_send_stop_reply;
						}
					}
				}
			} else {
				c = gdbSocketGetc();
			}
			if (c == 3) {
				GDBEnter();
				gdbStopReason = "T02"; /* SIGINT */
do_send_stop_reply:
				resp = gdbConstructStopReply();
				goto do_send_resp;
			} else if (c == "$".ord()) {
				{
					local i = 0, len = 256;
					local commandBuffer = Bytes(len);
					local hasEscapedBytes = false;
					for (;;) {
						c = gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT);
						if (c == "}".ord()) {
							/* Escape the next character. */
							while (i + 1 >= len) {
								len *= 2;
								commandBuffer = commandBuffer.resized(len);
							}
							commandBuffer[i] = c;
							++i;
							c = gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT);
							commandBuffer[i] = c;
							++i;
							hasEscapedBytes = true;
							continue;
						} else if (c == "#".ord()) {
							break;
						}
						if (i >= len) {
							len *= 2;
							commandBuffer = commandBuffer.resized(len);
						}
						commandBuffer[i] = c;
						++i;
					}
					commandBuffer = commandBuffer[:i];
					local chka = fromhex(gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT));
					local chkb = fromhex(gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT));
					local checksum = chka << 4 | chkb;
					local expectedChecksum = calculateGdbChecksum(commandBuffer);
					if (checksum != expectedChecksum) {
						print("[vboxgdb] WARNING: Bad checksum for packet ",
							repr(commandBuffer), " (expected: ", expectedChecksum.hex(),
							", got: ", checksum.hex(), ")");
						gdbSocket.send("-".bytes());
						goto wait_for_command;
					}
					/* Send the ACK */
					gdbSocket.send("+".bytes());
					if (hasEscapedBytes) {
						/* Unescape data. */
						len = #commandBuffer;
						local realCommandBuffer = Bytes(len);
						local realLen = 0;
						for (local i = 0; i < len; ++i) {
							local c = commandBuffer[i];
							if (c == "}".ord()) {
								++i;
								c = commandBuffer[i] ^ 0x20;
							}
							realCommandBuffer[realLen] = c;
							++realLen;
						}
						commandBuffer = realCommandBuffer.resized(realLen);
					}
					GDBEnter();
					try {
						if (CONFIG_VERBOSE)
							print "[vboxgdb<-gdb]", repr commandBuffer;
						resp = GDBEvaluateCommand(commandBuffer);
					} catch (e...) {
						if (CONFIG_VERBOSE) {
							print "[vboxgdb] WARNING: Error while executing command",
								repr(commandBuffer), ":", e;
							print repr Traceback.current;
						}
						resp = "E16"; /* 0x16 == 22 == EINVAL (on linux) */
					}
					if (resp is none)
						goto wait_for_command;
				}
do_send_resp:
				if (resp !is Bytes)
					resp = resp.bytes();
				local respLen = #resp;
				local fullResponse = Bytes(respLen + 4);
				fullResponse[0]             = "$".ord();
				fullResponse[1:1 + respLen] = resp;
				local checksum = calculateGdbChecksum(resp);
				fullResponse[respLen + 1] = "#".ord();
				fullResponse[respLen + 2] = tohex(checksum >> 4);
				fullResponse[respLen + 3] = tohex(checksum);
				if (CONFIG_VERBOSE)
					print "[vboxgdb->gdb]", repr fullResponse;
				local retry = CONFIG_GDB_SEND_MAX_RETRY_COUNT;
				for (;;) {
					gdbSocket.send(fullResponse);
					local resp = gdbSocketGetc(CONFIG_GDB_COMMAND_ACK_TIMEOUT);
					if (resp == "+".ord())
						break; /* Got it! */
					if (resp >= 0 && resp != "-".ord())
						print "[vboxgdb] WARNING: expected ACK/NACK, but got", resp.hex();
					if (!retry)
						throw Error("Too many NACKs sending response " + repr(fullResponse));
					--retry;
				}
			} else {
				print "[vboxgdb] WARNING: Unrecognized out-of-bad byte:", c.hex();
			}
		}
	} @[interrupt] catch (e...) {
		print "GDBMain() crashed:";
		print e;
		print repr Traceback.current;
		virtualBoxProc.terminate(1);
	}
}






function startVboxGDBGlue(
		KERNEL: string,
		TARGET_ARCH: string,
		options: {string: Object},
		magic: Module,
		gdbPort: string,
		vmName: string,
		virtualBoxProc: ipc.Process,
		vbox: Module,
		vboxcmd: List,
		connectedSemaphore: Object /* Semaphore from threading */) {
	/* Save some of the arguments to global variables. */
	global KERNEL = KERNEL;
	global TARGET_ARCH = TARGET_ARCH;
	global options = options;
	global magic = magic;
	global vmName = vmName;
	global vbox = vbox;
	global vboxcmd = vboxcmd;
	global virtualBoxProc = virtualBoxProc;

	/* Load configurations from emulator options */
	global CONFIG_VERBOSE =
		opt.getBool(options, "vboxgdb.verbose", DEFAULT_CONFIG_VERBOSE);
	global CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT =
		opt.getInt(options, "vboxgdb.gdb.command_timeout", 1000000);
	global CONFIG_GDB_COMMAND_ACK_TIMEOUT =
		opt.getInt(options, "vboxgdb.gdb.ack_timeout", 10000000);
	global CONFIG_GDB_SEND_MAX_RETRY_COUNT =
		opt.getInt(options, "vboxgdb.gdb.max_retry", 3);
	global CONFIG_TELNET_RESPONSE_TIMEOUT =
		opt.getInt(options, "vboxgdb.telnet.timeout", 100000);
	global CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT =
		opt.getInt(options, "vboxgdb.vboxmanage.timeout", 2000000);
	global CONFIG_GDBFEAT_VCONT =
		opt.getBool(options, "vboxgdb.gdb.feat.vcont", true);
	global CONFIG_GDBFEAT_KOS =
		opt.getBool(options, "vboxgdb.gdb.feat.kos", true);

	/* Figure out the addresses of some special vboxgdb control kernel symbols. */
	if (CONFIG_VERBOSE)
		print "[vboxgdb] Loading special kernel symbols...";
	{
		local readelf_bin = HOST_EXE(magic.toolchain.config.CROSS_PREFIX + "readelf");
		local readelf = ipc.Process(readelf_bin, { "-s", "-W", KERNEL });
		local r, w = ipc.Pipe.new()...;
		readelf.stdout = w;
		readelf.start();
		w.close();
		local foundSymbols = 0;
		local neededSymbols = #KERNEL_ADDROF_NEEDED;
		if (CONFIG_GDBFEAT_KOS)
			neededSymbols += #KERNEL_ADDROF_NEEDED_KOSEXT;
		while (local d = getLines(r))
		for (local l: d.splitlines()) {
			/*    Num:    Value  Size Type    Bind   Vis      Ndx Name */
			l = l.rstrip().replace("\t", " ");
			local i = l.find(":");
			if (i < 0)
				continue;
			local addr = l[i + 1:].lstrip();
			local addr, size;
			try {
				addr, size = addr.scanf("%[0-9a-fA-FxX] %[0-9a-fA-FxX]")...;
				addr = int(addr.lower().lstrip("0x"), 16);
				size = int(size.lower().lstrip("0x"), 16);
			} catch (...) {
				continue;
			}
			local nameStart = l.rfind(" ");
			if (nameStart < 0)
				continue;
			local name = l[nameStart + 1:];
			if (name !in KERNEL_ADDROF_NEEDED &&
			    (name !in KERNEL_ADDROF_NEEDED_KOSEXT || !CONFIG_GDBFEAT_KOS))
				continue; /* Not needed */
			if (name in KERNEL_ADDROF)
				continue; /* Already known. */
			KERNEL_ADDROF[name] = (addr, size);
			++foundSymbols;
			if (foundSymbols >= neededSymbols)
				break;
		}
		try {
			readelf.terminate(1);
			r.close();
		} catch (...) {
		}
		if (foundSymbols < neededSymbols) {
			local unknownSymbols = HashSet();
			for (local n: KERNEL_ADDROF_NEEDED) {
				if (n !in KERNEL_ADDROF)
					unknownSymbols.insert(n);
			}
			if (CONFIG_GDBFEAT_KOS) {
				for (local n: KERNEL_ADDROF_NEEDED_KOSEXT) {
					if (n !in KERNEL_ADDROF)
						unknownSymbols.insert(n);
				}
			}
			assert unknownSymbols;
			/* Try to remove symbols needed for KOS extensions... */
			if (CONFIG_GDBFEAT_KOS) {
				CONFIG_GDBFEAT_KOS = false;
				for (local x: KERNEL_ADDROF_NEEDED_KOSEXT) {
					print "[vboxgdb] KOS extensions symbol", x, "is missing ("
						"start with --emulator-setopt=vboxgdb.gdb.feat.kos=false)";
					unknownSymbols.remove(x);
				}
			}
			if (unknownSymbols) {
				unknownSymbols = unknownSymbols.sorted();
				throw Error("Failed to determine address of symbols: " +
					repr(unknownSymbols));
			}
		}
	}

	local final vboxTelnetAddr = "localhost:5000";
	local connectResponse;
	/* Try to  connect  20 times  with  a  delay of  0.1  seconds  in-between.
	 * In  theory  (and  practice),  this  succeeds  on  the  first  try,  but
	 * it only started doing so  after I added the  connectedSemaphore.wait();
	 * call in our caller to wait for  VirtualBox to connect to the log  pipe.
	 * And in theory, VirtualBox might open the debug server _much_ later than
	 * the opening of the log file (so better be safe here...) */
	if (CONFIG_VERBOSE)
		print "[vboxgdb] Connecting to telnet under", vboxTelnetAddr, "...";
	for (local i: [:20]) {
		vBoxTelnetSocket = net.socket("AF_INET", "SOCK_STREAM", "IPPROTO_TCP");
		try {
			vBoxTelnetSocket.connect(vboxTelnetAddr);
			connectResponse = vBoxTelnetGetResponse(100000); /* 0.1 seconds */
			if (connectResponse !is none)
				break;
		} catch (...) {
			if (i == 19)
				throw;
		}
		vBoxTelnetSocket.close();
	}
	if (connectResponse is none)
		throw Error("Failed to connect to VirtualBox telnet");
	if (CONFIG_VERBOSE) {
		/* The initial response is something like:
		 * >> "Welcome to the VirtualBox Debugger!\r\nCurrent VM is 089b0000, CPU #0\r\n".bytes() */
		print "[vboxgdb] Telnet connected. Initial response was:", repr connectResponse;
	}

	/* connectedSemaphore is once again posted to once the OS prints
	 * the %{vboxgdb:startup} control sequence */
	if (CONFIG_VERBOSE)
		print("[vboxgdb] Waiting for boot0 and _start",
			TARGET_ARCH == "x86_64" ? "64" : "32", " to complete...");
	connectedSemaphore.wait();

	/* Pause VM execution while we wait for GDB to become connected */
	_vmPause();
	/* Highly unlikely race condition... */
	while (!vmGetStepLoopPaused()) {
		_vmResume();
		/* Given the current instruction some time to complete */
		Thread.yield();
		Thread.sleep(100);
		_vmPause();
		_vmIsStepLoopPaused = none; /* Unknown */
	}

	if (CONFIG_VERBOSE)
		print("[vboxgdb] Starting GDB stub server...");

	/* At this point we've got full control over the VirtualBox VM, but we still
	 * have to launch our gdb-stub glue as a TCP server on `localhost:<gdbPort>`
	 * Once that one's up and running, we can invoke `magic.onEmulatorStarted()`
	 * to indicate that GDB is up and running! */
	gdbServerSocket = net.socket("AF_INET", "SOCK_STREAM", "IPPROTO_TCP");
	gdbServerSocket.bind("localhost:" + gdbPort);
	gdbServerSocket.listen(1);
	Thread(GDBMain).start();

	/* Inform magic that GDB is now accepting connection requests. */
	magic.onEmulatorStarted();
}
