/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifdef __WINDOWS__
#define HOST_EXE(x)  x ".exe"
#else
#define HOST_EXE(x)  x
#endif

import * from deemon;
import * from ..libmagic.libmagic;
import ._options as opt;
import fs;
import net;
import ipc;

@@Log comunications and other verbose information
global CONFIG_VERBOSE;

@@Timeout for the next byte in an on-going command (in microseconds)
@@When this timeout is exceeded, the current command is discarded
global CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT;

@@Timeout for waiting for GDB to ACK a command (in microseconds)
@@When this timeout is exceeded, try to send the packet again
global CONFIG_GDB_COMMAND_ACK_TIMEOUT;

@@Max # of times to re-attempt sending a response to GDB
@@the total # of attempts is @(CONFIG_GDB_SEND_MAX_RETRY_COUNT + 1)
global CONFIG_GDB_SEND_MAX_RETRY_COUNT;

@@Timeout (in microseconds) before re-attempting a telnet command,
@@or assuming that the command completed successfully.
global CONFIG_TELNET_RESPONSE_TIMEOUT;
global CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT;

@@Use VirtualBox's builtin (and broken) single-step
@@function, rather than using code injection.
global final CONFIG_USE_NATIVE_STEP = false;

@@Keep the VM running during memory reads
global final CONFIG_KEEP_RUNNING_DURING_MEMORY_READ = false;

/* The different types of break points */
global final GDB_BREAKPOINT_TYPE_SWBREAK   = 0; /* int3 */
global final GDB_BREAKPOINT_TYPE_HWBREAK   = 1; /* DRn-breakpoint */
global final GDB_BREAKPOINT_TYPE_WRITE     = 2; /* Break on write to `addr' */
global final GDB_BREAKPOINT_TYPE_READ      = 3; /* Break on read from `addr' */
global final GDB_BREAKPOINT_TYPE_READWRITE = 4; /* Break on read or write to/from `addr' */

/* Values for `_vboxgdb_trapctl` */
global final VBOXGDB_TRAPCTL_NTRAP = 0x00; /* Don't trap */
global final VBOXGDB_TRAPCTL_SSTEP = 0x01; /* Trap single-step events */
global final VBOXGDB_TRAPCTL_TRIGG = 0xff; /* Trap was triggered */



/* Arguments passed to `startVboxGDBGlue()` */
global KERNEL: string;
global TARGET_ARCH: string;
global options: {string: Object};
global magic: Module;
global vmName: string;
global virtualBoxProc: ipc.Process;
global vbox: Module;

@@The address of @"_vboxgdb_trapctl"
global KERNEL_ADDROF__vboxgdb_trapctl: int = none;

@@The address of @"_vboxgdb_steploop"
global KERNEL_ADDROF__vboxgdb_steploop: int = none;
global KERNEL_ADDROF__vboxgdb_steplooplen: int = none;

@@The socket through which we're connected to VirtualBox
global vBoxTelnetSocket: net.socket;

@@The gdb client socket
global gdbSocket: net.socket;

@@The server socket that is listening for GDB connections
global gdbServerSocket: net.socket;


global CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK: bool = false;
global CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK: bool = false;

@@Read in response data until a line is read that doesn't contain a
@@trailing line-feed and starts with @"VBoxDbg>". At that point, return
@@all previously read lines.
function vBoxTelnetGetResponse(timeout_microseconds: int = -1): Bytes {
	local result = none;
	for (;;) {
		local d = vBoxTelnetSocket.recv(-1, timeout_microseconds);
		if (d is none || (d is string && !d))
			break; /* Timeout */
		if (result is none)
			result = d;
		else {
			result += d;
		}
		if (!result.endswith("\n") && !result.endswith("\r")) {
			/* Find the start of the last line. */
			local n = result.rfind("\n");
			local r = result.rfind("\r");
			if (n < 0) {
				if (r < 0)
					n = 0;
				else {
					n = r + 1;
				}
			} else {
				if (r < 0) {
					++n;
				} else {
					if (r > n)
						n = r + 1;
					else {
						++n;
					}
				}
			}
			final local LASTLN_START = "VBoxDbg>";
			if (result.substr(n, n + #LASTLN_START) == LASTLN_START) {
				result = result[:n];
				break;
			}
		}
	}
	return result;
}

global GDBMain;

function getLines(fp: File): Bytes {
	local result = fp.read();
again:
	if (result &&
	    !result.endswith("\n") &&
	    !result.endswith("\r") &&
	    !result.endswith("\r\n")) {
		local d = fp.read();
		if (d) {
			result = result + d;
			goto again;
		}
	}
	return result;
}



@@Buffer of unread data from @gdbSocket
global gdbSocketBuffer: Bytes = "".bytes();

@@Receive a single byte from @gdbSocket
function gdbSocketGetc(
		timeout_microseconds: int = -1,
		graceFulTimeout: bool = false): int {
	local result;
	if (!gdbSocketBuffer) {
		gdbSocketBuffer = gdbSocket.recv(-1, timeout_microseconds);
		if (!gdbSocketBuffer) {
			if (timeout_microseconds == -1)
				throw Error("GDB Client gracefully disconnected");
			if (graceFulTimeout)
				return none;
			throw Error("Timeout while receiding data from GDB");
		}
	}
	result = gdbSocketBuffer[0];
	gdbSocketBuffer = gdbSocketBuffer[1:];
	return result;
}

function gdbSocketUngets(s: Bytes) {
	gdbSocketBuffer = s + gdbSocketBuffer;
}
function gdbSocketUngetc(c: int) {
	gdbSocketBuffer = Bytes({ c.u8 }) + gdbSocketBuffer;
}



/* Helper functions for controlling the VM */

function vBoxTelnetDiscardPendingData() {
	local data = vBoxTelnetSocket.recv(-1, 0);
	if (data) {
		do {
			data = vBoxTelnetSocket.recv(-1, 50000);
		} while (data);
	}
}

@@Execute a telnet command, wait for it to complete, and return its response
function vBoxTelnetExec(command: Bytes, restartOnTimeout: bool = true): Bytes {
again:
	vBoxTelnetDiscardPendingData();
	if (CONFIG_VERBOSE)
		print "[vboxgdb->telnet]", repr(command.rstrip("\r\n"));
	if (command.endswith("\r\n")) {
		vBoxTelnetSocket.send(command);
	} else {
		vBoxTelnetSocket.send(command.rstrip("\r\n") + "\r\n");
	}
	local result = vBoxTelnetGetResponse(CONFIG_TELNET_RESPONSE_TIMEOUT);
	if (result is none) {
		if (CONFIG_VERBOSE)
			print "[vboxgdb<-telnet] <Timeout>";
		if (restartOnTimeout)
			goto again;
	} else {
		if (CONFIG_VERBOSE)
			print "[vboxgdb<-telnet]", repr(result);
		/* This is an error that can happen sporadically for practically
		 * any command. The solution is to try again when it happens... */
		if ("Invalid command event" in result)
			goto again;
	}
	return result;
}

function vBoxTelnetExecNoError(command: Bytes, restartOnTimeout: bool = true): Bytes {
	local response = vBoxTelnetExec(command, restartOnTimeout);
	if ("error:" in response || "Error:" in response) {
		local i = response.find("Failed to disassemble instruction");
		if (i >= 0)
			response = response[:i].strip("\r\n") + "\r\n";
		else {
			throw Error("Response for {!r} indicates an error {!r}"
				.format({ command, response }));
		}
	}
	return response;
}



@@The current state of the VM (set using @vmResume() and @vmPause())
global vmIsRunning         = false; /* Paused via `stop' */
global _vmIsStepLoopPaused = none;  /* Paused via `_vboxgdb_steploop' (bool or none) */


@@The currently selected CPU core (set using @vmSetCurrentCpu())
global vmCurrentCpu = 0;

@@Change the currently selected CPU
function vmSetCurrentCpu(newCpu: int) {
	if (newCpu == vmCurrentCpu)
		return;
	vBoxTelnetExecNoError("cpu " + newCpu);
	vmCurrentCpu = newCpu;
}

@@Set of currently defined breakpoints
@@Mapping is @(breakpointId: (typ, addr, len))
global vmDefinedBreakpoints: {int: (int, int, int)} = Dict();

@@Clear all defined breakpoints
function vmClearAllBreakpoints() {
	if (!vmDefinedBreakpoints)
		return;
	vBoxTelnetExecNoError("bc all");
	vmDefinedBreakpoints.clear();
}

@@Search for a defined breakpoint and returns
@@its ID, or @none if no such breakpoint exists
function vmFindDefinedBreakpoint(typ: int, addr: int, len: int): int | none {
	local packedData = (typ, addr, len);
	for (local id, data: vmDefinedBreakpoints) {
		if (data == packedData)
			return id;
	}
	return none;
}

@@Add/Remove a breakpoint
@@@param: typ: One of @(GDB_BREAKPOINT_TYPE_*)
function vmControlBreakpoint(add: bool, typ: int, addr: int, len: int) {
	local id;
	local response;
	if (typ == GDB_BREAKPOINT_TYPE_READ)
		typ = GDB_BREAKPOINT_TYPE_READWRITE;
	if (typ == GDB_BREAKPOINT_TYPE_SWBREAK)
		len = 0;
	else if (typ == GDB_BREAKPOINT_TYPE_HWBREAK) {
		if (TARGET_ARCH != "x86_64")
			len = 1;
		else if (len != 1 && len != 8) {
			throw Error("Invalid breakpoint exec-length: " + len);
		}
	} else {
		if (len !in [1, 2, 4, 8])
			throw Error("Invalid breakpoint data-length: " + len);
	}
	id  = vmFindDefinedBreakpoint(typ, addr, len);
	if (id !is none) {
		if (add)
			return; /* Already defined. */
		/* Delete this breakpoint */
again_delete_breakpoint:
		if (vBoxTelnetExecNoError("bc " + id) is none) {
			local idHex = id.hex()[2:].lower();
			for (local l: vBoxTelnetExecNoError("bl").splitlines()) {
				l = l.strip();
				if (!l)
					continue;
				l = l.lower();
				if (l.startswith("0x"))
					l = l[2:];
				if (l.startswith(idHex))
					goto again_delete_breakpoint;
			}
		}
		del vmDefinedBreakpoints[id];
		return;
	} else {
		if (!add)
			return; /* Doesn't exist. */
		if (typ == GDB_BREAKPOINT_TYPE_SWBREAK) {
			response = vBoxTelnetExecNoError("bp " + addr.hex());
		} else {
			response = vBoxTelnetExecNoError("ba {} {} {}".format({
				{
					GDB_BREAKPOINT_TYPE_HWBREAK   : "e",
					GDB_BREAKPOINT_TYPE_READWRITE : "r",
					GDB_BREAKPOINT_TYPE_WRITE     : "w",
				}[typ], len, addr.hex()
			}));
		}
	}
	response = response.strip().lower();
	final local PREFIX = "breakpoint ";
	response = response[response.index(PREFIX) + #PREFIX:].lstrip();
	local idEnd = 0;
	while (idEnd < #response && response.isnumeric(idEnd))
		++idEnd;
	if (!idEnd) {
		throw Error("Invalid breakpoint id in response {!r}"
			.format({ response }));
	}
	id = int(response[:idEnd]);
	vmDefinedBreakpoints[id] = (typ, addr, len);
}

function vmReadMemoryAt(addr: int | string): Bytes {
	/* NOTE: We use dd for reading memory (and not db), because
	 *       dd returns the same about of bytes per line, but
	 *       db also returns an ASCII representation that would
	 *       only make this parser more complicated.
	 *       Futhermore, if the memory contains an ASCII string
	 *       equal to "error:", our response processing system
	 *       wouldn't be able to differenciate between something
	 *       like the ASCII string, and an actual error... */
	local hexaddr = addr;
	if (addr is int)
		hexaddr = addr.hex();
	local response = vBoxTelnetExec(
		"dd " + hexaddr).splitlines(false);
	local resultlen = 16 * #response;
	local result = Bytes(resultlen);
	local offset = 0;
	for (local l: response) {
		if (!l)
			continue;
		if ("error:" in l || "Error:" in l)
			break;
		local data = l[l.index(":") + 1:].lstrip();
		for (local dword: data.split(" ")) {
			if (!dword)
				continue;
			dword = int(dword, 16);
			if (offset + 4 >= resultlen) {
				resultlen = offset + 4;
				result = result.resized(resultlen);
			}
			result[offset] = dword & 0xff;
			++offset;
			result[offset] = (dword >> 8) & 0xff;
			++offset;
			result[offset] = (dword >> 16) & 0xff;
			++offset;
			result[offset] = (dword >> 24) & 0xff;
			++offset;
		}
	}
	if (!offset) {
		if (addr is int) {
			local offset = addr & 15;
			if (offset) {
				/* Virtualbox always prints memory in lines of 16 bytes.
				 * If the given address isn't aligned by at least that much,
				 * there is a chance that part of those 16 bytes is located
				 * somewhere in memory where accessing it is impossible.
				 * If this happens, VirtualBox will given us an error, when
				 * in fact it would have been possible to read at least a
				 * couple of leading bytes of memory.
				 * To work around this issue, we handle a read-error with
				 * an unaligned address by re-attempting the read with an
				 * aligned address, thus allowing VirtualBox to at least
				 * read one line of memory successfully.
				 * HINT: In such a szenario, VirtualBox's response might look like:
				 * >> "%00000000ffffffe8: 07fa5023 00000000 07fa4023 00000000\r\n"
				 * >> "%00000000fffffff8: 07fa3023 00000000\r\n
				 * >> error: VERR_PAGE_TABLE_NOT_PRESENT:  Reading memory at %0000000100000000.\r\n"
				 */
				result = vmReadMemoryAt(addr - offset);
				if (offset > #result)
					return result[offset:];
				/* Fallthru to regular error handling */
			}
		}
		if ("error:" in response || "Error:" in response)
			throw Error("Response for {!r} indicates an error {!r}"
				.format({ "dd " + hexaddr, response }));
		throw Error("Failed to read memory at {!r} (response was {!r})"
			.format({ hexaddr, response }));
	}
	return result[:offset];
}

@@Read @count bytes of memory from @addr
function vmReadMemory(addr: int, count: int): Bytes {
	local result = vmReadMemoryAt(addr);
	while (count > #result) {
		/* Read more data */
		result += vmReadMemoryAt(addr + #result);
	}
	return result[:count];
}


#define vmWriteMemoryB(addr, value) vmWriteMemoryWord(addr, "b", value)
#define vmWriteMemoryW(addr, value) vmWriteMemoryWord(addr, "w", value)
#define vmWriteMemoryL(addr, value) vmWriteMemoryWord(addr, "d", value)
#define vmWriteMemoryQ(addr, value) vmWriteMemoryWord(addr, "q", value)

@@Write @data to memory at @addr
@@@param: wordType: One of @("b", "w", "d", "q")
function vmWriteMemoryWord(addr: string, wordType: string, value: int) {
	local resp;
	do {
		resp = vBoxTelnetExecNoError("e{} {} {}"
			.format({ wordType, addr, value.hex() }));
	} while (resp is none);
}

function insertWordLeInfoBytes(b: Bytes, offset: int, nBytes: int, v: int) {
	for (local j: [:nBytes]) {
		b[offset + j] = (v >> (j * 8)) & 0xff;
	}
}

function extractWordLeFromBytes(b: Bytes, offset: int, nBytes: int): int {
	local result = 0;
	for (local j: [:nBytes])
		result |= b[offset + j] << (j * 8);
	return result;
}

@@Write @data to memory at @addr
function vmWriteMemory(addr: int, data: Bytes) {
	local i = 0, len = #data;
	while (i < len) {
		local missing = len - i;
		local realAddr = (addr + i).hex();
		if (missing >= 8) {
			vmWriteMemoryWord(realAddr, "q", extractWordLeFromBytes(data, i, 8));
			i += 8;
		} else if (missing >= 4) {
			vmWriteMemoryWord(realAddr, "d", extractWordLeFromBytes(data, i, 4));
			i += 4;
		} else if (missing >= 2) {
			vmWriteMemoryWord(realAddr, "w", extractWordLeFromBytes(data, i, 2));
			i += 2;
		} else {
			vmWriteMemoryWord(realAddr, "b", data[i]);
			++i;
		}
	}
}

@@Returns a lower-case hex-string without prefix
function _vmGetRegisterAsHex(name: string): Bytes {
	local resp = vBoxTelnetExecNoError("rg " + name, 1)
		.strip().splitlines(false);
	if (#resp != 1)
		throw Error("Unexpected # of lines in response to {!r} (response: {!r})"
			.format({ "rg " + name, resp }));
	resp = resp[0];
	resp = resp[resp.index("=") + 1:].strip().lower();
	if (resp.startswith("0x"))
		resp = resp[2:];
	return resp;
}

function _vmGetRegister(name: string): int {
	return int(_vmGetRegisterAsHex(name), 16);
}

function _vmSetRegister(name: string, value: string | int) {
	if (value is int)
		value = value.hex();
	if (name in ["cs"]) {
		local oldval = str(_vmGetRegisterAsHex(name));
		oldval = oldval.lstrip("0");
		value = value.lower();
		if (value.startswith("0x"))
			value = value[2:];
		value = value.lstrip("0");
		if (oldval != value)
			throw Error("Cannot set register {!r} = {!r} (oldval = {!r})"
				.format({ name, value, oldval }));
		return;
	}
	vBoxTelnetExecNoError("rg {} = {}".format({ name, value }));
}

@@When @_vmIsStepLoopPaused is @none, determine its
@@proper value and assign @true or @false to it.
function vmGetStepLoopPaused(rip: int = none): bool {
	if (_vmIsStepLoopPaused is none) {
		if (rip is none)
			rip = int(_vmGetRegisterAsHex("rip"), 16);
		_vmIsStepLoopPaused = rip >= KERNEL_ADDROF__vboxgdb_steploop &&
		                      rip <= KERNEL_ADDROF__vboxgdb_steploop +
		                             KERNEL_ADDROF__vboxgdb_steplooplen;
	}
	return _vmIsStepLoopPaused;
}

@@When not @none, the new (E|R)IP value to set in @vmResume()
@@NOTE: Ignored when @vmGetStepLoopPaused() is @true
global _vmNewRip = none;
@@Same as @_vmNewRip, but for @"rflags"
global _vmNewRflags = none;

@@Returns a lower-case hex-string without prefix
function vmGetRegisterAsHex(name: string): Bytes {
	switch (name) {

	case "eip":
	case "rip": {
		if (_vmIsStepLoopPaused === false && _vmNewRip !is none)
			return _vmNewRip;
		local result = _vmGetRegisterAsHex(name);
		if (_vmIsStepLoopPaused is none)
			vmGetStepLoopPaused(int(result, 16));
		if (_vmIsStepLoopPaused) {
			local iret = vmReadMemoryAt("rsp");
			iret = extractWordLeFromBytes(iret, 0, TARGET_ARCH == "x86_64" ? 8 : 4);
			return iret.hex()[2:];
		} else if (_vmNewRip !is none) {
			result = _vmNewRip.hex()[2:];
		}
		return result;
	}

	case "cs":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 8, 2);
			} else {
				iret = extractWordLeFromBytes(iret, 4, 2);
			}
			return iret.hex()[2:];
		}
		break;

	case "eflags":
	case "rflags":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 16, 8);
			} else {
				iret = extractWordLeFromBytes(iret, 8, 4);
			}
			return iret.hex()[2:];
		} else if (_vmNewRflags !is none) {
			return _vmNewRflags.hex()[2:];
		}
		break;

	case "esp":
	case "rsp":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 24, 8);
			} else {
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					iret = extractWordLeFromBytes(iret, 12, 4);
				} else {
					break;
				}
			}
			return iret.hex()[2:];
		}
		break;

	case "ss":
		if (vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (TARGET_ARCH == "x86_64") {
				iret = extractWordLeFromBytes(iret, 32, 8);
			} else {
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					iret = extractWordLeFromBytes(iret, 16, 2);
				} else {
					break;
				}
			}
			return iret.hex()[2:];
		}
		break;

	case "es":
	case "ds":
	case "fs":
	case "gs":
		if (TARGET_ARCH != "x86_64" && vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (extractWordLeFromBytes(iret, 10, 1) & 0x2) {
				/* VM86 iret return registers. */
				iret = extractWordLeFromBytes(iret, {
					"es" : 20,
					"ds" : 24,
					"fs" : 28,
					"gs" : 32,
				}[name], 2);
			} else {
				break;
			}
			return iret.hex()[2:];
		}
		break;

	default:
		break;
	}
	return _vmGetRegisterAsHex(name);
}

function vmGetRegister(name: string): int {
	return int(vmGetRegisterAsHex(name), 16);
}

function vmSetRegister(name: string, value: string | int) {
	switch (name) {

	case "eip":
	case "rip":
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("%rsp", value);
			} else {
				vmWriteMemoryL("%rsp", value);
			}
			return;
		} else {
			if (value !is int)
				value = int(value.lower().lstrip("0x"), 16);
			_vmNewRip = value;
			return;
		}
		break;

	case "cs":
		if (value !is int)
			value = int(value.lower().lstrip("0x"), 16);
		value = value & 0xffff;
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+8)", value);
			} else {
				vmWriteMemoryL("(%rsp+4)", value);
			}
			return;
		}
		break;

	case "eflags":
	case "rflags":
		if (vmGetStepLoopPaused()) {
			if (value !is int)
				value = int(value.lower().lstrip("0x"), 16);
			value = value & 0xffff;
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+0x10)", value);
			} else {
				vmWriteMemoryL("(%rsp+8)", value);
			}
			return;
		} else {
			if (value !is int)
				value = int(value.lower().lstrip("0x"), 16);
			_vmNewRflags = value;
			return;
		}
		break;

	case "esp":
	case "rsp":
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+0x18)", value);
			} else {
				local iret = vmReadMemoryAt("rsp");
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					vmWriteMemoryL("(%rsp+0xc)", value);
				} else {
					break;
				}
			}
			return;
		}
		break;

	case "ss":
		if (value !is int)
			value = int(value.lower().lstrip("0x"), 16);
		value = value & 0xffff;
		if (vmGetStepLoopPaused()) {
			if (TARGET_ARCH == "x86_64") {
				vmWriteMemoryQ("(%rsp+0x20)", value);
			} else {
				local iret = vmReadMemoryAt("rsp");
				if ((extractWordLeFromBytes(iret, 4, 1) & 3) ||
				    (extractWordLeFromBytes(iret, 10, 1) & 0x2)) {
					vmWriteMemoryL("(%rsp+0x10)", value);
				} else {
					break;
				}
			}
			return;
		}
		break;

	case "es":
	case "ds":
	case "fs":
	case "gs":
		if (value !is int)
			value = int(value.lower().lstrip("0x"), 16);
		value = value & 0xffff;
		if (TARGET_ARCH != "x86_64" && vmGetStepLoopPaused()) {
			local iret = vmReadMemoryAt("rsp");
			if (!(extractWordLeFromBytes(iret, 10, 1) & 0x2))
				break;
			vmWriteMemoryL("(%rsp+0x10)", value);
			return;
		}
		break;

	default:
		break;
	}
	_vmSetRegister(name, value);
}

function _vmGetRegisters(): {string: int} {
	local resp = vBoxTelnetExecNoError({
		"i386"   : "rg32",
		"x86_64" : "rg64",
	}[TARGET_ARCH]).unifylines(" ");
	for (;;) {
		local newresp = resp.replace("  ", " ");
		if (newresp == resp)
			break;
		resp = newresp;
	}
	resp = resp.replace("= ", "=").replace(" =", "=").lower();
	local result = Dict();
	for (local elem: resp.split(" ")) {
		local regnam, none, regval = elem.partition("=")...;
		if (!regnam || !regval)
			continue;
		try {
			regval = int(regval, 16);
		} catch (...) {
			continue;
		}
		if ((regnam.startswith("e") || regnam.startswith("r")) &&
		    (#regnam == 3 || regnam[1:] == "flags"))
			regnam = regnam[1:];
		result[regnam] = regval;
	}
	final local SEGMENT_REGISTERS = { "cs", "ds", "es", "fs", "gs" };
	final local MANDATORY_REGISTERS32 = {
		"ax", "bx", "cx", "dx", "si", "di", "sp", "bp", "ip", "flags",
		"cs", "ds", "es", "fs", "gs"
	};
	final local MANDATORY_REGISTERS64 = {
		"ax", "bx", "cx", "dx", "si", "di", "sp", "bp", "ip", "flags",
		"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
		"cs", "ds", "es", "fs", "gs"
	};
	for (local reg: TARGET_ARCH == "x86_64"
			? MANDATORY_REGISTERS64
			: MANDATORY_REGISTERS32) {
		if (reg !in result) {
			local regnam = reg;
			if (reg !in SEGMENT_REGISTERS && !reg.startswith("r"))
				reg = "r" + reg;
			result[regnam] = vmGetRegister(reg);
		}
	}
	return result;
}

@@Return a set of @(register, value) for the following registers:
@@   @"ax", @"bx", @"cx", @"dx", @"si", @"di", @"sp", @"bp", @"ip", @"flags"
@@   @"cs", @"ds", @"es", @"fs", @"gs"
@@The register names of the first line always have those names in the returned
@@mapping, however will have had the one of @"foo", @"efoo" or @"rfoo" in the
@@original register list.
function vmGetRegisters(): {string: int} {
	local result = _vmGetRegisters();
	if (_vmIsStepLoopPaused is none)
		vmGetStepLoopPaused(result["ip"]);
	if (_vmIsStepLoopPaused) {
		/* Override registers with the step-loop IRet tail. */
		local iret = vmReadMemoryAt("rsp");
		if (TARGET_ARCH == "x86_64") {
			result["ip"]    = extractWordLeFromBytes(iret, 0, 8);
			result["cs"]    = extractWordLeFromBytes(iret, 8, 2);
			result["flags"] = extractWordLeFromBytes(iret, 16, 8);
			result["sp"]    = extractWordLeFromBytes(iret, 24, 8);
			result["ss"]    = extractWordLeFromBytes(iret, 32, 2);
		} else {
			result["ip"]    = extractWordLeFromBytes(iret, 0, 4);
			local cs        = extractWordLeFromBytes(iret, 4, 2);
			local eflags    = extractWordLeFromBytes(iret, 8, 4);
			result["cs"]    = cs;
			result["flags"] = eflags;
			if ((cs & 3) || (eflags & 0x00020000)) {
				/* user- or vm86- tail is present! */
				result["sp"] = extractWordLeFromBytes(iret, 12, 4);
				result["ss"] = extractWordLeFromBytes(iret, 16, 2);
				if (eflags & 0x00020000) {
					/* vm86-tail */
					result["es"] = extractWordLeFromBytes(iret, 20, 2);
					result["ds"] = extractWordLeFromBytes(iret, 24, 2);
					result["fs"] = extractWordLeFromBytes(iret, 28, 2);
					result["gs"] = extractWordLeFromBytes(iret, 32, 2);
				}
			}
		}
	} else {
		if (_vmNewRip !is none)
			result["ip"] = _vmNewRip;
		if (_vmNewRflags !is none)
			result["flags"] = _vmNewRflags;
	}
	return result;
}



function _vBoxManageControlVm(method: string, allowFailure: bool = false): int {
again:
	if (CONFIG_VERBOSE)
		print("[vboxgdb->VBoxManage] [\"controlvm\", ", repr(vmName), ", ", repr(method), "]");
	local error;
	error = vbox.runVBoxManageCommandEx(
		{ "controlvm", vmName, method },
		CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT);
	if (error is none) {
		if (CONFIG_VERBOSE)
			print "[vboxgdb<-VBoxManage] <Timeout>";
		if (allowFailure)
			return none;
		goto again;
	}
	if (CONFIG_VERBOSE)
		print "[vboxgdb<-VBoxManage] $? =", error;
	if (error != 0 && !allowFailure)
		goto again;
	return error;
}


global _vmIsUiPaused = false;

function _vmPauseUi() {
	if (!_vmIsUiPaused) {
		_vBoxManageControlVm("pause");
		_vmIsUiPaused = true;
	}
}

function _vmResumeUi() {
	if (_vmIsUiPaused) {
		_vBoxManageControlVm("resume");
		_vmIsUiPaused = false;
	}
}

@@Pause the VM through use of the debugger's "stop" command
function _vmPause0() {
again:
	local response = vBoxTelnetExec("stop");
	if ("The VM is already halted" in response)
		;
	else if ("error:" !in response && "Error:" !in response)
		goto again;
	else {
		throw Error("Failed to pause vm: " + repr(response));
	}
}

@@Pause the VM through use of the debugger's "stop" command
function _vmPause() {
	_vmPauseUi();
	_vmPause0();
}

function vmPause() {
	if (!vmIsRunning)
		return; /* Already paused */
	_vmPause();
	_vmIsStepLoopPaused = none; /* Unknown */
	vmIsRunning = false;
}

function _vmResume() {
	_vmPauseUi();
again:
	local response = vBoxTelnetExec("g");
	if ("already running" in response)
		;
	else if ("error:" !in response && "Error:" !in response)
		goto again;
	else {
		throw Error("Failed to resume vm: " + repr(response));
	}
	_vmResumeUi();
}

global GDBHandleVirtualBoxEvent;
function vmResume(singleStep: bool = false) {
	if (vmIsRunning) {
		if (!singleStep)
			return; /* Already running */
		vmPause();
	}
	if (vmGetStepLoopPaused()) {
		if (!singleStep) {
			vmWriteMemoryW(KERNEL_ADDROF__vboxgdb_trapctl.hex(),
			               0x100 | VBOXGDB_TRAPCTL_NTRAP);
			goto do_resume;
		}
		/* VirtualBox's builtin single-step command is busted.
		 * As a work-around, use ring0 code-injection.
		 * s.a. /kos/src/kernel/core/arch/i386/misc/vboxgdb32.S */
		local rflags = vmGetRegister("rflags");
		if (!(rflags & 0x00000100))
			vmSetRegister("rflags", rflags | 0x00000100); /* EFLAGS.TF = 1 */
		vmWriteMemoryW(KERNEL_ADDROF__vboxgdb_trapctl.hex(),
		               0x100 | VBOXGDB_TRAPCTL_SSTEP);
wait_for_single_step:
		local usedDelay = 5000;
		if (CONFIG_KEEP_RUNNING_DURING_MEMORY_READ) {
			_vmResume();
			for (;;) {
				/* Wait for the program to step */
				Thread.yield();
				Thread.sleep(usedDelay);
				local trapctl = vmReadMemory(KERNEL_ADDROF__vboxgdb_trapctl, 1)[0];
				if (trapctl == VBOXGDB_TRAPCTL_TRIGG)
					break;
				/* Continue waiting */
				usedDelay += (usedDelay / 2);
			}
			_vmPause();
		} else {
			for (;;) {
				/* Wait for the program to step */
				_vmResume();
				Thread.yield();
				Thread.sleep(usedDelay);
				_vmPause();
				local trapctl = vmReadMemory(KERNEL_ADDROF__vboxgdb_trapctl, 1)[0];
				if (trapctl == VBOXGDB_TRAPCTL_TRIGG)
					break;
				/* Continue waiting */
				usedDelay += (usedDelay / 2);
			}
		}
		_vmIsStepLoopPaused = true;
		gdbStopReason = "T05"; /* SIGINT (used for single-step) */
		vmIsRunning = false;
		return;
	}
	if (_vmNewRip !is none) {
		if (_vmNewRip == _vmGetRegister("rip"))
			_vmNewRip = none;
	}
	if (_vmNewRflags !is none) {
		if (_vmNewRflags == _vmGetRegister("rflags"))
			_vmNewRflags = none;
	}
	if (singleStep) {
		if (_vmNewRip is none && _vmNewRflags is none && CONFIG_USE_NATIVE_STEP) {
			local resp = vBoxTelnetExecNoError("t");
			_vmResumeUi();
			if (!resp)
				resp = vBoxTelnetGetResponse();
			_vmPauseUi();
			gdbStopReason = GDBHandleVirtualBoxEvent(resp);
			_vmIsStepLoopPaused = none; /* Unknown */
			vmIsRunning = false;
			return;
		}
		local rflags = vmGetRegister("rflags");
		if (!(rflags & 0x00000100))
			vmSetRegister("rflags", rflags | 0x00000100); /* EFLAGS.TF = 1 */
		vmWriteMemoryW(KERNEL_ADDROF__vboxgdb_trapctl.hex(),
		               0x100 | VBOXGDB_TRAPCTL_SSTEP);
	}
	if (_vmNewRip !is none || _vmNewRflags !is none) {
		/* TODO: This can be done via ring0 code injection:
		 *          Remember the old value of `*(u8 *)%rip`
		 *    Tel>$ dd rip
		 *          Insert a breakpoint instruction
		 *    Tel>$ eb rip 0xcc
		 *          Tell KOS to expect a breakpoint interrupt
		 *          This causes a int3 from this address to be
		 *          handled by entering _vboxgdb_steploop
		 *    Tel>$ ed <_vboxgdb_trapctl.tc_teaddr>  <rip + 1>
		 *    do {
		 *        _vmResume();
		 *        Thread.yield();
		 *        Thread.sleep(5000);
		 *        _vmPause();
		 *    } while (!vmGetStepLoopPaused());
		 *    Tel>$ eb <ORIG_RIP> <OLD_INSTR_BYTE>
		 *    Tel>$ ed (%rsp+N) <_vmNewRip>
		 *    Tel>$ ed (%rsp+N) <_vmNewRflags>
		 *    _vmResume();
		 *
		 * The in-kernel int3-override looks like:
		 *     pushl  %eax
		 *     movl   OFFSET_IRREGS_EIP(%esp), %eax
		 *     cmpl   %eax, <_vboxgdb_trapctl.tc_teaddr>
		 *     je     1f
		 * 2:  popl   %eax
		 *     jmp    <normal_int3_handler>
		 * EXCEPT_HANDLERS_START
		 *     EXCEPT_HANDLERS_CATCHALL(
		 *         1f, // start
		 *         3f, // end
		 *         2b) // entry
		 * EXCEPT_HANDLERS_END
		 * 1:  movb   -1(%eax), %al  // This instruction is guarded against exceptions
		 * 3:  cmpb   $0xcc, %al
		 *     jne    2b
		 *     // Enter the debugger step-loop
		 *     movw   $(0x0000 | VBOXGDB_TRAPCTL_TRIGG), _vboxgdb_trapctl
		 *     jmp    _vboxgdb_steploop
		 *
		 * Once we're inside of the step-loop, we can simply store the
		 * overwrite values `_vmNewRip' and `_vmNewRflags' into the iret
		 * tail that leads back to where the int3 instruction was injected.
		 */
		_vmNewRip    = none;
		_vmNewRflags = none;
		throw Error("TODO: `rg rip = ...` and `rg rflags = ...` is highly "
		            "unreliable... (might be able to do some trickery with "
		            "code injection?)");
	}
	if (singleStep)
		goto wait_for_single_step;
do_resume:
	_vmResume();
	_vmIsStepLoopPaused = none; /* Unknown */
	vmIsRunning = true;
}






@@The GDB stop reason (e.g. "T02")
@@This is the pre-fixed string returned by @gdbConstructStopReply()
global gdbStopReason: Bytes = none;

global gdbCurrentThreadForContinue: int = none;
global gdbCurrentThreadForGeneral: int = none;

function tohex(val: int): int {
	val = val & 0xf;
	if (val <= 9)
		return "0".ord() + val;
	return "a".ord() + val - 10;
}

function fromhex(ord: int): int {
	if (ord >= "0".ord() && ord <= "9".ord())
		return ord - "0".ord();
	if (ord >= "a".ord() && ord <= "f".ord())
		return 10 + ord - "a".ord();
	if (ord >= "A".ord() && ord <= "F".ord())
		return 10 + ord - "A".ord();
	throw Error("Invalid hex-character ordinal: " + repr(ord));
}

@@Calculate the correct checksum for a given GDB packet @data
function calculateGdbChecksum(data: Bytes): int {
	local result = 0;
	for (local d: data)
		result = (result + d) & 0xff;
	return result;
}

function gdbEncodeThreadId(id: int): Bytes {
	return vmCurrentCpu.hex()[2:].zfill(8).bytes();
}

function gdbDecodeThreadId(id: Bytes): int {
	local result = int(id.decode("utf-8"), 16);
	if (result < 0)
		return 0;
	return result;
}

function encodeHex4b(fp: File, s: int) {
	fp.putc(tohex(s >> 4));
	fp.putc(tohex(s));
	fp.putc(tohex(s >> 12));
	fp.putc(tohex(s >> 8));
	fp.putc(tohex(s >> 20));
	fp.putc(tohex(s >> 16));
	fp.putc(tohex(s >> 28));
	fp.putc(tohex(s >> 24));
}

function decodeHex4b(b: Bytes, i: int): int {
	local result = 0;
	for (local j: [:4]) {
		local c1 = fromhex(b[i + j * 2]);
		local c2 = fromhex(b[i + j * 2 + 1]);
		local c  = c1 << 4 | c2;
		result |= c << (j * 8);
	}
	return result;
}



@@Construct the response to-be returned by the '?' command (as well as \3 interrupts)
function gdbConstructStopReply(): Bytes {
	if (gdbStopReason is none)
		gdbStopReason = "T02"; /* SIGINT */
	return "{}thread:{};".format({
		gdbStopReason,
		gdbEncodeThreadId(vmCurrentCpu)
	});
}




global final BASIC_REGISTER_COUNT32 = 16;
global final REGISTER_IDS32: {int: (int, string, string)} = {
	0x00 : (4, "eax", "rax"),
	0x01 : (4, "ecx", "rcx"),
	0x02 : (4, "edx", "rdx"),
	0x03 : (4, "ebx", "rbx"),
	0x04 : (4, "esp", "rsp"),
	0x05 : (4, "ebp", "rbp"),
	0x06 : (4, "esi", "rsi"),
	0x07 : (4, "edi", "rdi"),
	0x08 : (4, "eip", "rip"),
	0x09 : (4, "eflags", "rflags"),
	0x0a : (4, "cs", "cs"),
	0x0b : (4, "ss", "ss"),
	0x0c : (4, "ds", "ds"),
	0x0d : (4, "es", "es"),
	0x0e : (4, "fs", "fs"),
	0x0f : (4, "gs", "gs"),
//TODO:#define GDB_REGISTER_I386_ST0    0x10 /* %st(0) */
//TODO:#define GDB_REGISTER_I386_ST1    0x11 /* %st(1) */
//TODO:#define GDB_REGISTER_I386_ST2    0x12 /* %st(2) */
//TODO:#define GDB_REGISTER_I386_ST3    0x13 /* %st(3) */
//TODO:#define GDB_REGISTER_I386_ST4    0x14 /* %st(4) */
//TODO:#define GDB_REGISTER_I386_ST5    0x15 /* %st(5) */
//TODO:#define GDB_REGISTER_I386_ST6    0x16 /* %st(6) */
//TODO:#define GDB_REGISTER_I386_ST7    0x17 /* %st(7) */
//TODO:#define GDB_REGISTER_I386_FCW    0x18 /* fs_fcw (fctrl) */
//TODO:#define GDB_REGISTER_I386_FSW    0x19 /* fs_fsw (fstat) */
//TODO:#define GDB_REGISTER_I386_FTW    0x1a /* fs_ftw (ftag) */
//TODO:#define GDB_REGISTER_I386_FCS    0x1b /* fs_fcs (fiseg) */
//TODO:#define GDB_REGISTER_I386_FIP    0x1c /* fs_fip (fioff) */
//TODO:#define GDB_REGISTER_I386_FDS    0x1d /* fs_fds (foseg) */
//TODO:#define GDB_REGISTER_I386_FDP    0x1e /* fs_fdp (fooff) */
//TODO:#define GDB_REGISTER_I386_FOP    0x1f /* fs_fop (fop) */
//TODO:#define GDB_REGISTER_I386_XMM0   0x20 /* %xmm0 */
//TODO:#define GDB_REGISTER_I386_XMM1   0x21 /* %xmm1 */
//TODO:#define GDB_REGISTER_I386_XMM2   0x22 /* %xmm2 */
//TODO:#define GDB_REGISTER_I386_XMM3   0x23 /* %xmm3 */
//TODO:#define GDB_REGISTER_I386_XMM4   0x24 /* %xmm4 */
//TODO:#define GDB_REGISTER_I386_XMM5   0x25 /* %xmm5 */
//TODO:#define GDB_REGISTER_I386_XMM6   0x26 /* %xmm6 */
//TODO:#define GDB_REGISTER_I386_XMM7   0x27 /* %xmm7 */
//TODO:#define GDB_REGISTER_I386_MXCSR  0x28 /* %mxcsr */
//TODO:#define GDB_REGISTER_I386_FSBASE 0x30 /* %fs.base */
//TODO:#define GDB_REGISTER_I386_GSBASE 0x31 /* %gs.base */
};

global final OSDATAFILES: {string: string | Callable} = {
	"" :
	"<osdata type=\"types\">"
	"<item>"
		"<column name=\"Type\">breakpoints</column>"
		"<column name=\"Description\">Breakpoints</column>"
		"<column name=\"Title\">Breakpoints</column>"
	"</item>"
	"</osdata>",

	"keepstepping" : []{
		gdbSocket.send("$l#6c");
		for (;;) {
			print "begin:vmResume()";
			vmResume(singleStep: true);
			print "end:vmResume():";
		}
	},

	"breakpoints" : []{
		File.Writer fp;
		fp << "<osdata type=\"breakpoints\">";
		for (local l: vBoxTelnetExecNoError("bl").splitlines()) {
			fp << "<item><column name=\"line\">";
			fp << l.replace("<", "_").replace(">", "_");
			fp << "</column></item>";
		}
		fp << "</osdata>";
		return fp.string;
	},
};

function GDBEvaluateQXferRead(name: string, annex: string): Bytes | none {
	if (name == "exec-file") {
		if (annex)
			return false;
		return "/os/kernel.bin";
	}
	if (name == "osdata") {
		local res = OSDATAFILES.get(annex);
		if (res is none)
			return false;
		if (res !is string)
			res = res();
		return res;
	}
	return none;
}

@@Evaluate a given @cmd and return the intended response
function GDBEvaluateCommand(cmd: Bytes): Bytes {
	if (!cmd)
		goto unknown;
	local ch0 = cmd[0];
	switch (ch0) {

	case "?".ord():
		/* This query should only be issued during startup. Use it to clear breakpoints. */
		vmClearAllBreakpoints();
		return gdbConstructStopReply();

	case "C".ord():
		cmd = cmd[cmd.index(";") + 1:]; /* Skip the signal number */
	case "c".ord(): {
		local rip = cmd[1:];
		if (rip) {
			rip = int(rip, 16);
			vmSetCurrentCpu(gdbCurrentThreadForContinue);
			vmSetRegister("rip", rip);
		}
		vmResume();
		/* Check if the VM has already stopped once again. */
		if (!vmIsRunning)
			return gdbConstructStopReply();
		return none;
	}

	case "g".ord(): {
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		local regs = vmGetRegisters();
		File.Writer result;
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			for (local id: [:BASIC_REGISTER_COUNT32]) {
				local none, name32, name64 = REGISTER_IDS32[id]...;
				local usedName = name32;
				if (name32 != name64)
					usedName = name32[1:];
				encodeHex4b(result, regs[usedName]);
			}
		}
		return result.string;
	}

	case "G".ord(): {
		local data = cmd[1:];
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			if (#data < BASIC_REGISTER_COUNT32 * 8)
				throw Error("Register data blob is too small");
			local offset = 0;
			for (local id: [:BASIC_REGISTER_COUNT32]) {
				local name = REGISTER_IDS32[id][2];
				vmSetRegister(name, decodeHex4b(data, offset));
				offset += 8;
			}
		}
		return "OK";
	}

	case "p".ord(): {
		local id = int(cmd[1:], 16);
		local data;
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			local def = REGISTER_IDS32[id];
			data = vmGetRegisterAsHex(def[1]);
			data = data.zfill(def[0] * 2);
		}
		return data;
	}

	case "P".ord(): {
		local idEnd = cmd.index("=");
		local id    = int(cmd[1:idEnd], 16);
		local value = "0x" + cmd[idEnd + 1:];
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			local def = REGISTER_IDS32[id];
			vmSetRegister(def[2], value);
		}
		return "OK";
	}

	case "H".ord(): {
		local op = cmd[1];
		local id = gdbDecodeThreadId(cmd[2:]);
		if (op == "c".ord()) {
			vmSetCurrentCpu(id);
			gdbCurrentThreadForContinue = id;
		} else if (op == "g".ord()) {
			vmSetCurrentCpu(id);
			gdbCurrentThreadForGeneral = id;
		} else {
			goto unknown;
		}
		return "OK";
	}

	case "I".ord():
	case "S".ord():
		cmd = cmd[cmd.index(";") + 1:]; /* Skip the signal number */
	case "i".ord():
	case "s".ord(): {
		local rip = cmd[1:];
		if (rip) {
			rip = int(rip, 16);
			vmSetCurrentCpu(gdbCurrentThreadForContinue);
			vmSetRegister("rip", rip);
		}
		/* Do the single-step */
		vmResume(singleStep: true);
		return gdbConstructStopReply();
	}

	case "k".ord():
		print "[vboxgdb] GDB kill request";
		virtualBoxProc.terminate(1);
		return "OK";

	case "m".ord(): {
		local addr, none, length = cmd[1:].partition(",")...;
		addr   = int(addr, 16);
		length = int(length, 16);
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		local data = vmReadMemory(addr, length);
		local result = Bytes(length * 2);
		for (local i: [:length]) {
			local b = data[i];
			result[(i * 2)]     = tohex(b >> 4);
			result[(i * 2) + 1] = tohex(b);
		}
		return result;
	}

	case "M".ord(): {
		local addr_end   = cmd.index(",");
		local length_end = cmd.index(":", addr_end + 1);
		local addr   = cmd[1:addr_end];
		local length = cmd[addr_end + 1:length_end];
		local data = cmd[length_end + 1:];
		addr   = int(addr, 16);
		length = int(length, 16);
		if (length > #data / 2)
			throw Error("Too few data digits for memory write");
		local rawData = Bytes(length);
		for (local i: [:length]) {
			local lo = fromhex(data[i * 2]);
			local hi = fromhex(data[i * 2 + 1]);
			rawData[i] = (hi << 4) | lo;
		}
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		vmWriteMemory(addr, rawData);
		return "OK";
	}

	/* TODO: T */
	/* TODO: vCont */
	/* TODO: qSearch */
	/* TODO: qThreadExtraInfo */
	/* TODO: qfThreadInfo */
	/* TODO: qlThreadInfo */
	/* TODO: qNoAckMode */
	/* TODO: QStartNoAckMode */
	/* TODO: QNoAckMode */
	/* TODO: X */

	case "q".ord(): {
		local nameEnd = 1;
		while (nameEnd < #cmd &&
		       cmd[nameEnd] !in [",".ord(), ":".ord(), ";".ord()])
			++nameEnd;
		switch (cmd[1:nameEnd]) {

		case "C":
			return "QC" + gdbEncodeThreadId(gdbCurrentThreadForGeneral);

		case "Xfer": {
			local i;
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local name = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local method = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local annex = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(",", i);
			local offset = int(cmd[i:nameEnd], 16);
			local size   = int(cmd[nameEnd + 1:], 16);
			if (method == "read") {
				local result = GDBEvaluateQXferRead(name, annex);
				if (result is none)
					return ""; /* Unknown */
				if (result === false)
					return "E02";
				local reslen = #result;
				if (offset >= reslen)
					return "l"; /* Out-of-bounds (empty last packet) */
				if (offset + size >= reslen)
					return "l" + result[offset:];
				return "m" + result[offset:offset + size];
			} else if (method == "write") {
				return "";
			} else {
				throw Error("Invalid qXfer method: " + repr(method));
			}
		}

		case "Supported": {
			local features = cmd[nameEnd + 1:];
			CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK = false;
			CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK = false;
			for (local feat: features.split(";")) {
				if (feat.endswith("+")) {
					feat = feat[:-1];
					if (feat == "swbreak")
						CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK = true;
					else if (feat == "hwbreak")
						CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK = true;
				}
			}
			File.Writer result;
			result << "PacketSize=100000";
			if (CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK)
				result << ";swbreak+";
			if (CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK)
				result << ";hwbreak+";
			result << ";qXfer:exec-file:read+";
			result << ";qXfer:osdata:read+";
			/* TODO: QNoAckMode */
			return result.string;
		}

		default:
			break;
		}
		break;
	}

	case "z".ord():
	case "Z".ord(): {
		local shouldAdd = cmd[0] == "Z".ord();
		local type_end = cmd.index(",");
		local addr_end = cmd.index(",", type_end + 1);
		local typ  = int(cmd[1:type_end], 16);
		local addr = int(cmd[type_end + 1:addr_end], 16);
		local len  = int(cmd[addr_end + 1:], 16);
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		vmControlBreakpoint(shouldAdd, typ, addr, len);
		return "OK";
	}

	default:
		break;
	}
unknown:
	return "";
}

@@Handle an event message send by the VirtualBox debugger
@@@return: * :   Send this as a stop reply to GDB (value for @gdbStopReason)
@@@return: none: Ignore and resume execution
function GDBHandleVirtualBoxEvent(event: Bytes): string {
	/* TODO: Include registers (if given) from `event'
	 * NOTE: event normally looks like:
	 * >> "\r\n"
	 * >> "dbgf event: Single step! (other)\r\n"
	 * >> "eax=00000000 ebx=c0c85733 ecx=00000000 edx=00000504 esi=c0c85733 edi=c0c85656\r\n"
	 * >> "eip=c02e0aae esp=c0cb4a00 ebp=c0cb4aa4 iopl=0 nv up di pl nz na pe nc\r\n"
	 * >> "cs=0008 ds=0023 es=0023 fs=0040 gs=0033 ss=0010               eflags=00000002\r\n"
	 * >> "0008:c02e0aae 8b 45 f0                mov eax, dword [ebp-010h]\r\n".bytes()
	 * Which as you can see contains the same data as used by `vmGetRegisters()` */
	if ("Single step" in event)
		return "T05"; /* SIGINT */
	local i = event.find("Breakpoint ");
	if (i >= 0) {
		i += #"Breakpoint ";
		local id = event[i:].lstrip();
		local idEnd = 0;
		while (idEnd < #id && id.isnumeric(idEnd))
			++idEnd;
		if (!idEnd) {
			throw Error("Invalid breakpoint id in event {!r}"
				.format({ event }));
		}
		id = int(id[:idEnd]);
		local data = vmDefinedBreakpoints[id];

		if (data[0] == GDB_BREAKPOINT_TYPE_SWBREAK) {
			if (CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK)
				return "T05swbreak:;";
		} else {
			if (CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK)
				return "T05hwbreak:;";
		}
	}
	return "T05";
}

function GDBEnter() {
	/* Always make sure that the VM is paused when we get here! */
	vmPause();
	gdbCurrentThreadForContinue = vmCurrentCpu;
	gdbCurrentThreadForGeneral  = vmCurrentCpu;
}


@@The main function for the GDB glue driver
function GDBMain() {
	try {
		gdbSocket = gdbServerSocket.accept();
		if (CONFIG_VERBOSE)
			print "[vboxgdb] GDB connection established:", gdbSocket;
		for (;;) {
			local resp;
			local c;
wait_for_command:
			if (vmIsRunning) {
				final local CHECK_TIMEOUT_MICROSECONDS = 50000;
				for (;;) {
					c = gdbSocketGetc(CHECK_TIMEOUT_MICROSECONDS,
					                  graceFulTimeout: true);
					if (c !is none)
						break;
					c = vBoxTelnetGetResponse(CHECK_TIMEOUT_MICROSECONDS);
					if (c !is none) {
						if (CONFIG_VERBOSE)
							print "[vboxgdb<-telnet] Event:", repr(c);
						if ("Invalid command event" in c) {
							/* This can happen if a previous resume attempt
							 * failed with a delayed error. - Re-try the resume */
							_vmResume();
							continue; /* Ignore... */
						}
						local reason = GDBHandleVirtualBoxEvent(c);
						if (reason !is none) {
							gdbStopReason = reason;
							vmPause();
							goto do_send_stop_reply;
						}
					}
				}
			} else {
				c = gdbSocketGetc();
			}
			if (c == 3) {
				GDBEnter();
				gdbStopReason = "T02"; /* SIGINT */
do_send_stop_reply:
				resp = gdbConstructStopReply();
				goto do_send_resp;
			} else if (c == "$".ord()) {
				{
					local i = 0, len = 256;
					local commandBuffer = Bytes(len);
					local hasEscapedBytes = false;
					for (;;) {
						c = gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT);
						if (c == "}".ord()) {
							/* Escape the next character. */
							while (i + 1 >= len) {
								len *= 2;
								commandBuffer = commandBuffer.resized(len);
							}
							commandBuffer[i] = c;
							++i;
							c = gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT);
							commandBuffer[i] = c;
							++i;
							hasEscapedBytes = true;
							continue;
						} else if (c == "#".ord()) {
							break;
						}
						if (i >= len) {
							len *= 2;
							commandBuffer = commandBuffer.resized(len);
						}
						commandBuffer[i] = c;
						++i;
					}
					commandBuffer = commandBuffer[:i];
					local chka = fromhex(gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT));
					local chkb = fromhex(gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT));
					local checksum = chka << 4 | chkb;
					local expectedChecksum = calculateGdbChecksum(commandBuffer);
					if (checksum != expectedChecksum) {
						print("[vboxgdb] WARNING: Bad checksum for packet ",
							repr(commandBuffer), " (expected: ", expectedChecksum.hex(),
							", got: ", checksum.hex(), ")");
						gdbSocket.send("-".bytes());
						goto wait_for_command;
					}
					/* Send the ACK */
					gdbSocket.send("+".bytes());
					if (hasEscapedBytes) {
						/* Unescape data. */
						len = #commandBuffer;
						local realCommandBuffer = Bytes(len);
						local realLen = 0;
						for (local i = 0; i < len; ++i) {
							local c = commandBuffer[i];
							if (c == "}".ord()) {
								++i;
								c = commandBuffer[i] ^ 0x20;
							}
							realCommandBuffer[realLen] = c;
							++realLen;
						}
						commandBuffer = realCommandBuffer.resized(realLen);
					}
					GDBEnter();
					try {
						if (CONFIG_VERBOSE)
							print "[vboxgdb<-gdb]", repr commandBuffer;
						resp = GDBEvaluateCommand(commandBuffer);
					} catch (e...) {
						if (CONFIG_VERBOSE) {
							print "[vboxgdb] WARNING: Error while executing command",
								repr(commandBuffer), ":", e;
							print repr Traceback.current;
						}
						resp = "E16"; /* 0x16 == 22 == EINVAL (on linux) */
					}
					if (resp is none)
						goto wait_for_command;
				}
do_send_resp:
				if (resp !is Bytes)
					resp = resp.bytes();
				local respLen = #resp;
				local fullResponse = Bytes(respLen + 4);
				fullResponse[0]             = "$".ord();
				fullResponse[1:1 + respLen] = resp;
				local checksum = calculateGdbChecksum(resp);
				fullResponse[respLen + 1] = "#".ord();
				fullResponse[respLen + 2] = tohex(checksum >> 4);
				fullResponse[respLen + 3] = tohex(checksum);
				if (CONFIG_VERBOSE)
					print "[vboxgdb->gdb]", repr fullResponse;
				local retry = CONFIG_GDB_SEND_MAX_RETRY_COUNT;
				for (;;) {
					gdbSocket.send(fullResponse);
					local resp = gdbSocketGetc(CONFIG_GDB_COMMAND_ACK_TIMEOUT);
					if (resp == "+".ord())
						break; /* Got it! */
					if (resp >= 0 && resp != "-".ord())
						print "[vboxgdb] WARNING: expected ACK/NACK, but got", resp.hex();
					if (!retry)
						throw Error("Too many NACKs sending response " + repr(fullResponse));
					--retry;
				}
			} else {
				print "[vboxgdb] WARNING: Unrecognized out-of-bad byte:", c.hex();
			}
		}
	} @[interrupt] catch (e...) {
		print "GDBMain() crashed:";
		print e;
		print repr Traceback.current;
		virtualBoxProc.terminate(1);
	}
}






function startVboxGDBGlue(
		KERNEL: string,
		TARGET_ARCH: string,
		options: {string: Object},
		magic: Module,
		gdbPort: string,
		vmName: string,
		virtualBoxProc: ipc.Process,
		vbox: Module,
		connectedSemaphore: Object /* Semaphore from threading */) {
	/* Save some of the arguments to global variables. */
	global KERNEL = KERNEL;
	global TARGET_ARCH = TARGET_ARCH;
	global options = options;
	global magic = magic;
	global vmName = vmName;
	global vbox = vbox;
	global virtualBoxProc = virtualBoxProc;

	/* Load configurations from emulator options */
	global CONFIG_VERBOSE = opt.getBool(options, "vboxgdb.verbose", true);
	global CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT =
		opt.getInt(options, "vboxgdb.gdb.command_timeout", 1000000);
	global CONFIG_GDB_COMMAND_ACK_TIMEOUT =
		opt.getInt(options, "vboxgdb.gdb.ack_timeout", 10000000);
	global CONFIG_GDB_SEND_MAX_RETRY_COUNT =
		opt.getInt(options, "vboxgdb.gdb.max_retry", 3);
	global CONFIG_TELNET_RESPONSE_TIMEOUT =
		opt.getInt(options, "vboxgdb.telnet.timeout", 100000);
	global CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT =
		opt.getInt(options, "vboxgdb.vboxmanage.timeout", 2000000);

	/* Figure out the addresses of some special vboxgdb control kernel symbols. */
	if (CONFIG_VERBOSE)
		print "[vboxgdb] Loading special kernel symbols...";
	{
		local readelf_bin = HOST_EXE(magic.toolchain.config.CROSS_PREFIX + "readelf");
		local readelf = ipc.Process(readelf_bin, { "-s", "-W", KERNEL });
		local r, w = ipc.Pipe.new()...;
		readelf.stdout = w;
		readelf.start();
		w.close();
		while (local d = getLines(r))
		for (local l: d.splitlines()) {
			/*    Num:    Value  Size Type    Bind   Vis      Ndx Name */
			l = l.rstrip().replace("\t", " ");
			if (l.endswith(" _vboxgdb_trapctl") ||
			    l.endswith(" _vboxgdb_steploop")) {
				local addr = l[l.index(":") + 1:].lstrip();
				local addr, size = addr.scanf("%[0-9a-fA-FxX] %[0-9a-fA-FxX]")...;
				addr = int(addr.lower().lstrip("0x"), 16);
				size = int(size.lower().lstrip("0x"), 16);
				if (l.endswith(" _vboxgdb_trapctl"))
					KERNEL_ADDROF__vboxgdb_trapctl = addr;
				else {
					KERNEL_ADDROF__vboxgdb_steploop    = addr;
					KERNEL_ADDROF__vboxgdb_steplooplen = size;
				}
				if (KERNEL_ADDROF__vboxgdb_trapctl !is none &&
				    KERNEL_ADDROF__vboxgdb_steploop !is none)
					break;
			}
		}
		try {
			readelf.terminate(1);
			r.close();
		} catch (...) {
		}
		if (KERNEL_ADDROF__vboxgdb_trapctl is none)
			throw Error("Failed to determine address of symbol: _vboxgdb_trapctl");
		if (KERNEL_ADDROF__vboxgdb_steploop is none)
			throw Error("Failed to determine address of symbol: _vboxgdb_steploop");
	}

	final local vboxTelnetAddr = "localhost:5000";
	local connectResponse;
	/* Try to connect 20 times with a delay of 0.1 seconds in-between.
	 * In theory (and practice), this succeeds on the first try, but
	 * it only started doing so after I added the connectedSemaphore.wait();
	 * call in our caller to wait for VirtualBox to connect to the log pipe.
	 * And in theory, VirtualBox might open the debug server _much_ later than
	 * then opening of the log file (so better be safe here...) */
	if (CONFIG_VERBOSE)
		print "[vboxgdb] Connecting to telnet under", vboxTelnetAddr, "...";
	for (local i: [:20]) {
		vBoxTelnetSocket = net.socket("AF_INET", "SOCK_STREAM", "IPPROTO_TCP");
		try {
			vBoxTelnetSocket.connect(vboxTelnetAddr);
			connectResponse = vBoxTelnetGetResponse(100000); /* 0.1 seconds */
			if (connectResponse !is none)
				break;
		} catch (...) {
			if (i == 19)
				throw;
		}
		vBoxTelnetSocket.close();
	}
	if (connectResponse is none)
		throw Error("Failed to connect to VirtualBox telnet");
	if (CONFIG_VERBOSE) {
		/* The initial response is something like:
		 * >> "Welcome to the VirtualBox Debugger!\r\nCurrent VM is 089b0000, CPU #0\r\n".bytes() */
		print "[vboxgdb] Telnet connected. Initial response was:", repr connectResponse;
	}

	/* connectedSemaphore is once again posted to once the OS prints
	 * the %{vboxgdb:startup} control sequence */
	if (CONFIG_VERBOSE)
		print("[vboxgdb] Waiting for boot0 and _start",
			TARGET_ARCH == "x86_64" ? "64" : "32", " to complete...");
	connectedSemaphore.wait();

	/* Pause VM execution while we wait for GDB to become connected */
	_vmPause();
	/* Highly unlikely race condition... */
	while (!vmGetStepLoopPaused()) {
		_vmResume();
		/* Given the current instruction some time to complete */
		Thread.yield();
		Thread.sleep(100);
		_vmPause();
		_vmIsStepLoopPaused = none; /* Unknown */
	}

	if (CONFIG_VERBOSE)
		print("[vboxgdb] Starting GDB stub server...");

	/* At this point we've got full control over the VirtualBox VM, but we still
	 * have to launch our gdb-stub glue as a TCP server on `localhost:<gdbPort>`
	 * Once that one's up and running, we can invoke `magic.onEmulatorStarted()`
	 * to indicate that GDB is up and running! */
	gdbServerSocket = net.socket("AF_INET", "SOCK_STREAM", "IPPROTO_TCP");
	gdbServerSocket.bind("localhost:" + gdbPort);
	gdbServerSocket.listen();
	Thread(GDBMain).start();

	/* Inform magic that GDB is now accepting connection requests. */
	magic.onEmulatorStarted();
}



