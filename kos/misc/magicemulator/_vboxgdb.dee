/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from ..libmagic.libmagic;
import ._options as opt;
import fs;
import net;
import ipc;

/* TODO:
 * One big downside of vboxgdb is that setting breakpoints before the kernel has been
 * loaded into memory (i.e. before connecting GDB and waiting for boot0 to finish,
 * and _start32.S to have loaded the kernel page directory) won't work because before
 * that point memory locations can't actually be translated, so attempting to set
 * breakpoints will (correctly) trigger errors, causing gdb to go crazy and trying to
 * set the breakpoints itself, which only results in a bunch of more errors from trying
 * to access undefined memory locations...
 * The solution here would be to inject a piece of code into the kernel that is executed
 * just after pagedir_kernel is initialized for the kernel core, and loaded into %cr3.
 * This piece of code would then interact as follows:
 *   #1: The kernel tells us that it has fully initialized paging (via port `$0x504')
 *   #2: We start up the GDB server (Thread(GDBMain).start(), ...)
 *   #3: GDB does its initialization
 *   #4: GDB tells us to resume execution ($c#xx)
 *   #5: At this point we override the kernel's EIP (which still points at
 *       an idle loop within the injected code) to resume execution at the
 *       original code site (i.e. just after the initial "mov $pagedir_kernel, %cr3")
 * - The injection could be done by creating a special copy of ".kernel-flat.bin"
 *   in which we've added additional code (somewhere where it won't bother anyone,
 *   such as some .bss area that isn't located at the end of the kernel)
 */


@@Log comunications and other verbose information
global CONFIG_VERBOSE;

@@Timeout for the next byte in an on-going command (in microseconds)
@@When this timeout is exceeded, the current command is discarded
global CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT;

@@Timeout for waiting for GDB to ACK a command (in microseconds)
@@When this timeout is exceeded, try to send the packet again
global CONFIG_GDB_COMMAND_ACK_TIMEOUT;

@@Max # of times to re-attempt sending a response to GDB
@@the total # of attempts is @(CONFIG_GDB_SEND_MAX_RETRY_COUNT + 1)
global CONFIG_GDB_SEND_MAX_RETRY_COUNT;

@@Timeout (in microseconds) before re-attempting a telnet command,
@@or assuming that the command completed successfully.
global CONFIG_TELNET_RESPONSE_TIMEOUT;
global CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT;


/* The different types of break points */
global final GDB_BREAKPOINT_TYPE_SWBREAK   = 0; /* int3 */
global final GDB_BREAKPOINT_TYPE_HWBREAK   = 1; /* DRn-breakpoint */
global final GDB_BREAKPOINT_TYPE_WRITE     = 2; /* Break on write to `addr' */
global final GDB_BREAKPOINT_TYPE_READ      = 3; /* Break on read from `addr' */
global final GDB_BREAKPOINT_TYPE_READWRITE = 4; /* Break on read or write to/from `addr' */


/* Arguments passed to `startVboxGDBGlue()` */
global KERNEL: string;
global TARGET_ARCH: string;
global options: {string: Object};
global magic: Module;
global vmName: string;
global virtualBoxProc: ipc.Process;
global vbox: Module;

@@The socket through which we're connected to VirtualBox
global vBoxTelnetSocket: net.socket;

@@The gdb client socket
global gdbSocket: net.socket;

@@The server socket that is listening for GDB connections
global gdbServerSocket: net.socket;


global CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK: bool = false;
global CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK: bool = false;

@@Read in response data until a line is read that doesn't contain a
@@trailing line-feed and starts with @"VBoxDbg>". At that point, return
@@all previously read lines.
function vBoxTelnetGetResponse(timeout_microseconds: int = -1): Bytes {
	local result = none;
	for (;;) {
		local d = vBoxTelnetSocket.recv(-1, timeout_microseconds);
		if (d is none || (d is string && !d))
			break; /* Timeout */
		if (result is none)
			result = d;
		else {
			result += d;
		}
		if (!result.endswith("\n") && !result.endswith("\r")) {
			/* Find the start of the last line. */
			local n = result.rfind("\n");
			local r = result.rfind("\r");
			if (n < 0) {
				if (r < 0)
					n = 0;
				else {
					n = r + 1;
				}
			} else {
				if (r < 0) {
					++n;
				} else {
					if (r > n)
						n = r + 1;
					else {
						++n;
					}
				}
			}
			final local LASTLN_START = "VBoxDbg>";
			if (result.substr(n, n + #LASTLN_START) == LASTLN_START) {
				result = result[:n];
				break;
			}
		}
	}
	return result;
}

global GDBMain;

function startVboxGDBGlue(
		KERNEL: string,
		TARGET_ARCH: string,
		options: {string: Object},
		magic: Module,
		gdbPort: string,
		vmName: string,
		virtualBoxProc: ipc.Process,
		vbox: Module) {
	/* Save some of the arguments to global variables. */
	global KERNEL = KERNEL;
	global TARGET_ARCH = TARGET_ARCH;
	global options = options;
	global magic = magic;
	global vmName = vmName;
	global virtualBoxProc = virtualBoxProc;
	global vbox = vbox;

	/* Load configurations from emulator options */
	global CONFIG_VERBOSE = opt.getBool(options, "vboxgdb.verbose", true);
	global CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT =
		opt.getInt(options, "vboxgdb.gdb.command_timeout", 1000000);
	global CONFIG_GDB_COMMAND_ACK_TIMEOUT =
		opt.getInt(options, "vboxgdb.gdb.ack_timeout", 10000000);
	global CONFIG_GDB_SEND_MAX_RETRY_COUNT =
		opt.getInt(options, "vboxgdb.gdb.max_retry", 3);
	global CONFIG_TELNET_RESPONSE_TIMEOUT =
		opt.getInt(options, "vboxgdb.telnet.timeout", 100000);
	global CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT =
		opt.getInt(options, "vboxgdb.vboxmanage.timeout", 2000000);

	final local vboxTelnetAddr = "localhost:5000";
	local connectResponse;
	/* Try to connect 20 times with a delay of 0.1 seconds in-between.
	 * In theory (and practice), this succeeds on the first try, but
	 * it only started doing so after I added the connectedSemaphore.wait();
	 * call in our caller to wait for VirtualBox to connect to the log pipe.
	 * And in theory, VirtualBox might open the debug server _much_ later than
	 * then opening of the log file (so better be safe here...) */
	for (local i: [:20]) {
		vBoxTelnetSocket = net.socket("AF_INET", "SOCK_STREAM", "IPPROTO_TCP");
		try {
			vBoxTelnetSocket.connect(vboxTelnetAddr);
			connectResponse = vBoxTelnetGetResponse(100000); /* 0.1 seconds */
			if (connectResponse !is none)
				break;
		} catch (...) {
			if (i == 19)
				throw;
		}
		vBoxTelnetSocket.close();
	}
	if (connectResponse is none)
		throw Error("Failed to connect to VirtualBox telnet");
	print "[vboxgdb] Connected to telnet under", vboxTelnetAddr;

	if (CONFIG_VERBOSE) {
		/* The initial response is something like:
		 * >> "Welcome to the VirtualBox Debugger!\r\nCurrent VM is 089b0000, CPU #0\r\n".bytes() */
		print "[vboxgdb] Initial response was:", repr connectResponse;
	}

	/* At this point we've got full control over the VirtualBox VM, but we still
	 * have to launch our gdb-stub glue as a TCP server on `localhost:<gdbPort>`
	 * Once that one's up and running, we can invoke `magic.onEmulatorStarted()`
	 * to indicate that GDB is up and running! */
	gdbServerSocket = net.socket("AF_INET", "SOCK_STREAM", "IPPROTO_TCP");
	gdbServerSocket.bind("localhost:" + gdbPort);
	gdbServerSocket.listen();
	Thread(GDBMain).start();

	/* Inform magic that GDB is now accepting connection requests. */
	magic.onEmulatorStarted();
}


@@Buffer of unread data from @gdbSocket
global gdbSocketBuffer: Bytes = "".bytes();

@@Receive a single byte from @gdbSocket
function gdbSocketGetc(
		timeout_microseconds: int = -1,
		graceFulTimeout: bool = false): int {
	local result;
	if (!gdbSocketBuffer) {
		gdbSocketBuffer = gdbSocket.recv(-1, timeout_microseconds);
		if (!gdbSocketBuffer) {
			if (timeout_microseconds == -1)
				throw Error("GDB Client gracefully disconnected");
			if (graceFulTimeout)
				return none;
			throw Error("Timeout while receiding data from GDB");
		}
	}
	result = gdbSocketBuffer[0];
	gdbSocketBuffer = gdbSocketBuffer[1:];
	return result;
}

function gdbSocketUngets(s: Bytes) {
	gdbSocketBuffer = s + gdbSocketBuffer;
}
function gdbSocketUngetc(c: int) {
	gdbSocketBuffer = Bytes({ c.u8 }) + gdbSocketBuffer;
}



/* Helper functions for controlling the VM */

function vBoxTelnetDiscardPendingData() {
	local data = vBoxTelnetSocket.recv(-1, 0);
	if (data) {
		do {
			data = vBoxTelnetSocket.recv(-1, 50000);
		} while (data);
	}
}

@@Execute a telnet command, wait for it to complete, and return its response
function vBoxTelnetExec(command: Bytes, restartOnTimeout: bool = true): Bytes {
again:
	vBoxTelnetDiscardPendingData();
	if (CONFIG_VERBOSE)
		print "[vboxgdb->telnet]", repr(command.rstrip("\r\n"));
	if (command.endswith("\r\n")) {
		vBoxTelnetSocket.send(command);
	} else {
		vBoxTelnetSocket.send(command.rstrip("\r\n") + "\r\n");
	}
	local result = vBoxTelnetGetResponse(CONFIG_TELNET_RESPONSE_TIMEOUT);
	if (result is none) {
		if (CONFIG_VERBOSE && result !is none)
			print "[vboxgdb<-telnet] <Timeout>";
		if (restartOnTimeout)
			goto again;
	} else {
		if (CONFIG_VERBOSE && result !is none)
			print "[vboxgdb<-telnet]", repr(result);
		/* This is an error that can happen sporadically for practically
		 * any command. The solution is to try again when it happens... */
		if ("Invalid command event" in result)
			goto again;
	}
	return result;
}

function vBoxTelnetExecNoError(command: Bytes, restartOnTimeout: bool = true): Bytes {
	local response = vBoxTelnetExec(command, restartOnTimeout);
	if ("error:" in response || "Error:" in response) {
		local i = response.find("Failed to disassemble instruction");
		if (i >= 0)
			response = response[:i].strip("\r\n") + "\r\n";
		else {
			throw Error("Response for {!r} indicates an error {!r}"
				.format({ command, response }));
		}
	}
	return response;
}


@@The current state of the VM (set using @vmResume() and @vmPause())
global vmIsRunning = false;

global _vmIsUiPaused = true;
global _vmIsDebuggerPaused = false;

function _vBoxManageControlVm(method: string, allowFailure: bool = false): int {
again:
	if (CONFIG_VERBOSE)
		print("[vboxgdb->VBoxManage] [\"controlvm\", ", repr(vmName), ", ", repr(method), "]");
	local error;
	error = vbox.runVBoxManageCommandEx(
		{ "controlvm", vmName, method },
		CONFIG_VBOXMANAGE_COMPLETE_TIMEOUT);
	if (error is none) {
		if (CONFIG_VERBOSE)
			print "[vboxgdb<-VBoxManage] <Timeout>";
		if (allowFailure)
			return none;
		goto again;
	}
	if (CONFIG_VERBOSE)
		print "[vboxgdb<-VBoxManage] $? =", error;
	if (error != 0 && !allowFailure)
		goto again;
	return error;
}

function _vBoxTelnetExecContinue(): Bytes {
	local result;
	result = vBoxTelnetExec("g");
	if ("error:" !in result && "Error:" !in result)
		;
	else if ("already running" in result) {
		result = "\r\n".bytes();
	} else {
		throw Error("Failed to continue vm: " + repr(result));
	}
	return result;
}

function _vBoxTelnetExecStop(): Bytes {
	local result;
	result = vBoxTelnetExec("stop");
	if ("error:" !in result && "Error:" !in result)
		;
	else if ("The VM is already halted" in result)
		result = "".bytes();
	else {
		throw Error("Failed to stop vm: " + repr(result));
	}
	return result;
}

function vmPause() {
	if (!vmIsRunning)
		return; /* Already paused */
	if (!_vmIsUiPaused) {
		_vBoxManageControlVm("pause");
		_vmIsUiPaused = true;
	}
	if (!_vmIsDebuggerPaused) {
		_vBoxTelnetExecStop();
		_vmIsDebuggerPaused = true;
	}
	vmIsRunning = false;
}

function vmResume() {
	if (vmIsRunning)
		return; /* Already running */
	if (!_vmIsUiPaused) {
		_vBoxManageControlVm("pause");
		_vmIsUiPaused = true;
	}
	if (_vmIsDebuggerPaused) {
		_vBoxTelnetExecContinue();
		_vmIsDebuggerPaused = false;
	}
	if (_vmIsUiPaused) {
		_vBoxManageControlVm("resume");
		_vmIsUiPaused = false;
	}
	vmIsRunning = true;
}

global GDBHandleVirtualBoxEvent;
function vmSingleStep(): string {
	/* Single-stepping is kind-of busted.
	 * However doing it as this sequence of commands
	 * every time we want to step seems to work:
	 * [if !_vmIsUiPaused]       cmd>$ VBoxManage controlvm <vmName> pause
	 * [if !_vmIsDebuggerPaused] tel>$ stop
	 *                           tel>$ p
	 *                           cmd>$ VBoxManage controlvm <vmName> resume
	 *                           tel<$ dbgf event: Single step! (other)
	 *                           cmd>$ VBoxManage controlvm <vmName> pause
	 *                           tel>$ g
	 *                           tel>$ stop
	 * The idea here seems to be that we don't want to use `p` to resume
	 * VM execution, but only use it to set-up the VM for a single-step
	 * once we resume it manually. Then, once that's done re-suspend the
	 * VM globally, and toggle the debugger suspend sequence by invoking
	 * `g` followed by `stop` (thus fixing up the probably broken internal
	 * state of the VirtualBox debugger) */
	if (!_vmIsUiPaused) {
		_vBoxManageControlVm("pause");
		_vmIsUiPaused = true;
	}
	if (!_vmIsDebuggerPaused) {
		_vBoxTelnetExecStop();
		_vmIsDebuggerPaused = true;
	}
again_step:
	if (CONFIG_VERBOSE)
		print "[vboxgdb->telnet] \"p\"";
	/* The p command can be a bit stingy... */
	vBoxTelnetDiscardPendingData();
	vBoxTelnetSocket.send("p\r\n");
	local error = _vBoxManageControlVm("resume", allowFailure: true);
	local stepResponse;
	if (error is none || error != 0) {
		stepResponse = vBoxTelnetGetResponse(CONFIG_TELNET_RESPONSE_TIMEOUT);
		if (stepResponse is none)
			goto handle_bad_step_response;
	} else {
		stepResponse = vBoxTelnetGetResponse();
	}
	if (CONFIG_VERBOSE)
		print "[vboxgdb<-telnet] Step-response:", repr(stepResponse);
	if ("Invalid command event" in stepResponse) {
handle_bad_step_response:
		local error;
		error = _vBoxManageControlVm("pause", allowFailure: true);
		if (error is none) {
			_vBoxTelnetExecStop();
			goto again_step;
		}
		goto again_step;
	}
	_vBoxManageControlVm("pause");
	_vBoxTelnetExecContinue();
	_vBoxTelnetExecStop();
	_vmIsUiPaused       = true;
	_vmIsDebuggerPaused = true;
	vmIsRunning         = false;
	return GDBHandleVirtualBoxEvent(stepResponse);
}


@@The currently selected CPU core (set using @vmSetCurrentCpu())
global vmCurrentCpu = 0;

@@Change the currently selected CPU
function vmSetCurrentCpu(newCpu: int) {
	if (newCpu == vmCurrentCpu)
		return;
	vBoxTelnetExecNoError("cpu " + newCpu);
	vmCurrentCpu = newCpu;
}

@@Set of currently defined breakpoints
@@Mapping is @(breakpointId: (typ, addr, len))
global vmDefinedBreakpoints: {int: (int, int, int)} = Dict();

@@Clear all defined breakpoints
function vmClearAllBreakpoints() {
	if (!vmDefinedBreakpoints)
		return;
	vBoxTelnetExecNoError("bc all");
	vmDefinedBreakpoints.clear();
}

@@Search for a defined breakpoint and returns
@@its ID, or @none if no such breakpoint exists
function vmFindDefinedBreakpoint(typ: int, addr: int, len: int): int | none {
	local packedData = (typ, addr, len);
	for (local id, data: vmDefinedBreakpoints) {
		if (data == packedData)
			return id;
	}
	return none;
}

@@Add/Remove a breakpoint
@@@param: typ: One of @(GDB_BREAKPOINT_TYPE_*)
function vmControlBreakpoint(add: bool, typ: int, addr: int, len: int) {
	local id;
	local response;
	if (typ == GDB_BREAKPOINT_TYPE_READ)
		typ = GDB_BREAKPOINT_TYPE_READWRITE;
	if (typ == GDB_BREAKPOINT_TYPE_SWBREAK)
		len = 0;
	else if (typ == GDB_BREAKPOINT_TYPE_HWBREAK) {
		if (TARGET_ARCH != "x86_64")
			len = 1;
		else if (len != 1 && len != 8) {
			throw Error("Invalid breakpoint exec-length: " + len);
		}
	} else {
		if (len !in [1, 2, 4, 8])
			throw Error("Invalid breakpoint data-length: " + len);
	}
	id  = vmFindDefinedBreakpoint(typ, addr, len);
	if (id !is none) {
		if (add)
			return; /* Already defined. */
		/* Delete this breakpoint */
again_delete_breakpoint:
		if (vBoxTelnetExecNoError("bc " + id) is none) {
			local idHex = id.hex()[2:].lower();
			for (local l: vBoxTelnetExecNoError("bl").splitlines()) {
				l = l.strip();
				if (!l)
					continue;
				l = l.lower();
				if (l.startswith("0x"))
					l = l[2:];
				if (l.startswith(idHex))
					goto again_delete_breakpoint;
			}
		}
		del vmDefinedBreakpoints[id];
		return;
	} else {
		if (!add)
			return; /* Doesn't exist. */
		if (typ == GDB_BREAKPOINT_TYPE_SWBREAK) {
			response = vBoxTelnetExecNoError("bp " + addr.hex());
		} else {
			response = vBoxTelnetExecNoError("ba {} {} {}".format({
				{
					GDB_BREAKPOINT_TYPE_HWBREAK   : "e",
					GDB_BREAKPOINT_TYPE_READWRITE : "r",
					GDB_BREAKPOINT_TYPE_WRITE     : "w",
				}[typ], len, addr.hex()
			}));
		}
	}
	response = response.strip().lower();
	final local PREFIX = "breakpoint ";
	response = response[response.index(PREFIX) + #PREFIX:].lstrip();
	local idEnd = 0;
	while (idEnd < #response && response.isnumeric(idEnd))
		++idEnd;
	if (!idEnd) {
		throw Error("Invalid breakpoint id in response {!r}"
			.format({ response }));
	}
	id = int(response[:idEnd]);
	vmDefinedBreakpoints[id] = (typ, addr, len);
}

function vmGetRegister(name: string): Bytes {
	local resp = vBoxTelnetExecNoError("rg " + name, 1).splitlines(false);
	if (#resp != 1)
		throw Error("Unexpected # of lines in response to {!r} (response: {!r})"
			.format({ "rg " + name, resp }));
	resp = resp[0];
	resp = resp[resp.index("=") + 1:].strip();
	return resp;
}

function vmSetRegister(name: string, value: string | int) {
	if (value !is string)
		value = value.hex();
	if (name in ["cs"]) {
		local oldval = str(vmGetRegister(name));
		oldval = oldval.lower().lsstrip("0x").lstrip("0");
		value  = value.lower().lsstrip("0x").lstrip("0");
		if (oldval != value)
			throw Error("Cannot set register {!r} = {!r} (oldval = {!r})"
				.format({ name, value, oldval }));
		return;
	}
	local resp;
	do {
		resp = vBoxTelnetExecNoError(
			"rg {} = {}".format({ name, value }));
	} while (resp is none);
}

@@Return a set of @(register, value) for the following registers:
@@   @"ax", @"bx", @"cx", @"dx", @"si", @"di", @"sp", @"bp", @"ip", @"flags"
@@   @"cs", @"ds", @"es", @"fs", @"gs"
@@The register names of the first line always have those names in the returned
@@mapping, however will have had the one of @"foo", @"efoo" or @"rfoo" in the
@@original register list.
function vmGetRegisters(): {string: int} {
	local resp = vBoxTelnetExecNoError({
		"i386"   : "rg32",
		"x86_64" : "rg64",
	}[TARGET_ARCH]).unifylines(" ");
	for (;;) {
		local newresp = resp.replace("  ", " ");
		if (newresp == resp)
			break;
		resp = newresp;
	}
	resp = resp.replace("= ", "=").replace(" =", "=").lower();
	local result = Dict();
	for (local elem: resp.split(" ")) {
		local regnam, none, regval = elem.partition("=")...;
		if (!regnam || !regval)
			continue;
		try {
			regval = int(regval, 16);
		} catch (...) {
			continue;
		}
		if ((regnam.startswith("e") || regnam.startswith("r")) &&
		    (#regnam == 3 || regnam[1:] == "flags"))
			regnam = regnam[1:];
		result[regnam] = regval;
	}
	final local SEGMENT_REGISTERS = { "cs", "ds", "es", "fs", "gs" };
	final local MANDATORY_REGISTERS32 = {
		"ax", "bx", "cx", "dx", "si", "di", "sp", "bp", "ip", "flags",
		"cs", "ds", "es", "fs", "gs"
	};
	final local MANDATORY_REGISTERS64 = {
		"ax", "bx", "cx", "dx", "si", "di", "sp", "bp", "ip", "flags",
		"r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
		"cs", "ds", "es", "fs", "gs"
	};
	for (local reg: TARGET_ARCH == "x86_64"
			? MANDATORY_REGISTERS64
			: MANDATORY_REGISTERS32) {
		if (reg !in result) {
			local regnam = reg;
			if (reg !in SEGMENT_REGISTERS && !reg.startswith("r"))
				reg = "r" + reg;
			local regval = vmGetRegister(reg);
			if (regval.startswith("0x"))
				regval = regval[2:];
			result[regnam] = int(regval, 16);
		}
	}
	return result;
}


function vmReadMemoryAt(addr: int): Bytes {
	/* NOTE: We use dd for reading memory (and not db), because
	 *       dd returns the same about of bytes per line, but
	 *       db also returns an ASCII representation that would
	 *       only make this parser more complicated.
	 *       Futhermore, if the memory contains an ASCII string
	 *       equal to "error:", our response processing system
	 *       wouldn't be able to differenciate between something
	 *       like the ASCII string, and an actual error... */
	local response = vBoxTelnetExec(
		"dd " + addr.hex()).splitlines(false);
	local resultlen = 16 * #response;
	local result = Bytes(resultlen);
	local offset = 0;
	for (local l: response) {
		if (!l)
			continue;
		if ("error:" in l || "Error:" in l)
			break;
		local data = l[l.index(":") + 1:].lstrip();
		for (local dword: data.split(" ")) {
			if (!dword)
				continue;
			dword = int(dword, 16);
			if (offset + 4 >= resultlen) {
				resultlen = offset + 4;
				result = result.resized(resultlen);
			}
			result[offset] = dword & 0xff;
			++offset;
			result[offset] = (dword >> 8) & 0xff;
			++offset;
			result[offset] = (dword >> 16) & 0xff;
			++offset;
			result[offset] = (dword >> 24) & 0xff;
			++offset;
		}
	}
	if (!offset) {
		local offset = addr & 15;
		if (offset) {
			/* Virtualbox always prints memory in lines of 16 bytes.
			 * If the given address isn't aligned by at least that much,
			 * there is a chance that part of those 16 bytes is located
			 * somewhere in memory where accessing it is impossible.
			 * If this happens, VirtualBox will given us an error, when
			 * in fact it would have been possible to read at least a
			 * couple of leading bytes of memory.
			 * To work around this issue, we handle a read-error with
			 * an unaligned address by re-attempting the read with an
			 * aligned address, thus allowing VirtualBox to at least
			 * read one line of memory successfully.
			 * HINT: In such a szenario, VirtualBox's response might look like:
			 * >> "%00000000ffffffe8: 07fa5023 00000000 07fa4023 00000000\r\n"
			 * >> "%00000000fffffff8: 07fa3023 00000000\r\n
			 * >> error: VERR_PAGE_TABLE_NOT_PRESENT:  Reading memory at %0000000100000000.\r\n"
			 */
			result = vmReadMemoryAt(addr - offset);
			if (offset > #result)
				return result[offset:];
			/* Fallthru to regular error handling */
		}
		if ("error:" in response || "Error:" in response)
			throw Error("Response for {!r} indicates an error {!r}"
				.format({ "dd " + addr.hex(), response }));
		throw Error("Failed to read memory at {} (response was {!r})"
			.format({ addr.hex(), response }));
	}
	return result[:offset];
}

@@Read @count bytes of memory from @addr
function vmReadMemory(addr: int, count: int): Bytes {
	local result = vmReadMemoryAt(addr);
	while (count > #result) {
		/* Read more data */
		result += vmReadMemoryAt(addr + #result);
	}
	return result[:count];
}

@@Write @data to memory at @addr
@@@param: wordType: One of @("b", "w", "d", "q")
function vmWriteMemoryWord(addr: int, wordType: string, value: int) {
	local resp;
	do {
		resp = vBoxTelnetExecNoError("e{} {} {}"
			.format({ wordType, addr.hex(), value.hex() }));
	} while (resp is none);
}

function extractWordLeFromBytes(b: Bytes, i: int, nBytes: int): int {
	local result = 0;
	for (local j: [:nBytes])
		result |= b[i + j] << (j * 8);
	return result;
}

@@Write @data to memory at @addr
function vmWriteMemory(addr: int, data: Bytes) {
	local i = 0, len = #data;
	while (i < len) {
		local missing = len - i;
		local realAddr = addr + i;
		if (missing >= 8) {
			vmWriteMemoryWord(realAddr, "q", extractWordLeFromBytes(data, i, 8));
			i += 8;
		} else if (missing >= 4) {
			vmWriteMemoryWord(realAddr, "d", extractWordLeFromBytes(data, i, 4));
			i += 4;
		} else if (missing >= 2) {
			vmWriteMemoryWord(realAddr, "w", extractWordLeFromBytes(data, i, 2));
			i += 2;
		} else {
			vmWriteMemoryWord(realAddr, "b", data[i]);
			++i;
		}
	}
}




@@The GDB stop reason (e.g. "T02")
@@This is the pre-fixed string returned by @gdbConstructStopReply()
global gdbStopReason: Bytes = none;

global gdbCurrentThreadForContinue: int = none;
global gdbCurrentThreadForGeneral: int = none;

function tohex(val: int): int {
	val = val & 0xf;
	if (val <= 9)
		return "0".ord() + val;
	return "a".ord() + val - 10;
}

function fromhex(ord: int): int {
	if (ord >= "0".ord() && ord <= "9".ord())
		return ord - "0".ord();
	if (ord >= "a".ord() && ord <= "f".ord())
		return 10 + ord - "a".ord();
	if (ord >= "A".ord() && ord <= "F".ord())
		return 10 + ord - "A".ord();
	throw Error("Invalid hex-character ordinal: " + repr(ord));
}

@@Calculate the correct checksum for a given GDB packet @data
function calculateGdbChecksum(data: Bytes): int {
	local result = 0;
	for (local d: data)
		result = (result + d) & 0xff;
	return result;
}

function gdbEncodeThreadId(id: int): Bytes {
	return vmCurrentCpu.hex()[2:].zfill(8).bytes();
}

function gdbDecodeThreadId(id: Bytes): int {
	local result = int(id.decode("utf-8"), 16);
	if (result < 0)
		return 0;
	return result;
}

function encodeHex4b(fp: File, s: int) {
	fp.putc(tohex(s >> 4));
	fp.putc(tohex(s));
	fp.putc(tohex(s >> 12));
	fp.putc(tohex(s >> 8));
	fp.putc(tohex(s >> 20));
	fp.putc(tohex(s >> 16));
	fp.putc(tohex(s >> 28));
	fp.putc(tohex(s >> 24));
}

function decodeHex4b(b: Bytes, i: int): int {
	local result = 0;
	for (local j: [:4]) {
		local c1 = fromhex(b[i + j * 2]);
		local c2 = fromhex(b[i + j * 2 + 1]);
		local c  = c1 << 4 | c2;
		result |= c << (j * 8);
	}
	return result;
}



@@Construct the response to-be returned by the '?' command (as well as \3 interrupts)
function gdbConstructStopReply(): Bytes {
	if (gdbStopReason is none)
		gdbStopReason = "T02"; /* SIGINT */
	return "{}thread:{};".format({
		gdbStopReason,
		gdbEncodeThreadId(vmCurrentCpu)
	});
}




global final BASIC_REGISTER_COUNT32 = 16;
global final REGISTER_IDS32: {int: (int, string, string)} = {
	0x00 : (4, "eax", "rax"),
	0x01 : (4, "ecx", "rcx"),
	0x02 : (4, "edx", "rdx"),
	0x03 : (4, "ebx", "rbx"),
	0x04 : (4, "esp", "rsp"),
	0x05 : (4, "ebp", "rbp"),
	0x06 : (4, "esi", "rsi"),
	0x07 : (4, "edi", "rdi"),
	0x08 : (4, "eip", "rip"),
	0x09 : (4, "eflags", "rflags"),
	0x0a : (4, "cs", "cs"),
	0x0b : (4, "ss", "ss"),
	0x0c : (4, "ds", "ds"),
	0x0d : (4, "es", "es"),
	0x0e : (4, "fs", "fs"),
	0x0f : (4, "gs", "gs"),
//TODO:#define GDB_REGISTER_I386_ST0    0x10 /* %st(0) */
//TODO:#define GDB_REGISTER_I386_ST1    0x11 /* %st(1) */
//TODO:#define GDB_REGISTER_I386_ST2    0x12 /* %st(2) */
//TODO:#define GDB_REGISTER_I386_ST3    0x13 /* %st(3) */
//TODO:#define GDB_REGISTER_I386_ST4    0x14 /* %st(4) */
//TODO:#define GDB_REGISTER_I386_ST5    0x15 /* %st(5) */
//TODO:#define GDB_REGISTER_I386_ST6    0x16 /* %st(6) */
//TODO:#define GDB_REGISTER_I386_ST7    0x17 /* %st(7) */
//TODO:#define GDB_REGISTER_I386_FCW    0x18 /* fs_fcw (fctrl) */
//TODO:#define GDB_REGISTER_I386_FSW    0x19 /* fs_fsw (fstat) */
//TODO:#define GDB_REGISTER_I386_FTW    0x1a /* fs_ftw (ftag) */
//TODO:#define GDB_REGISTER_I386_FCS    0x1b /* fs_fcs (fiseg) */
//TODO:#define GDB_REGISTER_I386_FIP    0x1c /* fs_fip (fioff) */
//TODO:#define GDB_REGISTER_I386_FDS    0x1d /* fs_fds (foseg) */
//TODO:#define GDB_REGISTER_I386_FDP    0x1e /* fs_fdp (fooff) */
//TODO:#define GDB_REGISTER_I386_FOP    0x1f /* fs_fop (fop) */
//TODO:#define GDB_REGISTER_I386_XMM0   0x20 /* %xmm0 */
//TODO:#define GDB_REGISTER_I386_XMM1   0x21 /* %xmm1 */
//TODO:#define GDB_REGISTER_I386_XMM2   0x22 /* %xmm2 */
//TODO:#define GDB_REGISTER_I386_XMM3   0x23 /* %xmm3 */
//TODO:#define GDB_REGISTER_I386_XMM4   0x24 /* %xmm4 */
//TODO:#define GDB_REGISTER_I386_XMM5   0x25 /* %xmm5 */
//TODO:#define GDB_REGISTER_I386_XMM6   0x26 /* %xmm6 */
//TODO:#define GDB_REGISTER_I386_XMM7   0x27 /* %xmm7 */
//TODO:#define GDB_REGISTER_I386_MXCSR  0x28 /* %mxcsr */
//TODO:#define GDB_REGISTER_I386_FSBASE 0x30 /* %fs.base */
//TODO:#define GDB_REGISTER_I386_GSBASE 0x31 /* %gs.base */
};

global final OSDATAFILES: {string: string | Callable} = {
	"" :
	"<osdata type=\"types\">"
	"<item>"
		"<column name=\"Type\">breakpoints</column>"
		"<column name=\"Description\">Breakpoints</column>"
		"<column name=\"Title\">Breakpoints</column>"
	"</item>"
	"</osdata>",

	"breakpoints" : []{
		File.Writer fp;
		fp << "<osdata type=\"breakpoints\">";
		for (local l: vBoxTelnetExecNoError("bl").splitlines()) {
			fp << "<item><column name=\"line\">";
			fp << l.replace("<", "_").replace(">", "_");
			fp << "</column></item>";
		}
		fp << "</osdata>";
		return fp.string;
	},
};

function GDBEvaluateQXferRead(name: string, annex: string): Bytes | none {
	if (name == "exec-file") {
		if (annex)
			return false;
		return "/os/kernel.bin";
	}
	if (name == "osdata") {
		local res = OSDATAFILES.get(annex);
		if (res is none)
			return false;
		if (res !is string)
			res = res();
		return res;
	}
	return none;
}

@@Evaluate a given @cmd and return the intended response
function GDBEvaluateCommand(cmd: Bytes): Bytes {
	if (!cmd)
		goto unknown;
	local ch0 = cmd[0];
	switch (ch0) {

	case "?".ord():
		/* This query should only be issued during startup. Use it to clear breakpoints. */
		vmClearAllBreakpoints();
		return gdbConstructStopReply();

	case "C".ord():
		cmd = cmd[cmd.index(";") + 1:]; /* Skip the signal number */
	case "c".ord(): {
		local rip = cmd[1:];
		if (rip) {
			rip = int(rip, 16);
			vmSetCurrentCpu(gdbCurrentThreadForContinue);
			vmSetRegister("rip", rip);
		}
		vmResume();
		return none;
	}

	case "g".ord(): {
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		local regs = vmGetRegisters();
		File.Writer result;
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			for (local id: [:BASIC_REGISTER_COUNT32]) {
				local none, name32, name64 = REGISTER_IDS32[id]...;
				local usedName = name32;
				if (name32 != name64)
					usedName = name32[1:];
				encodeHex4b(result, regs[usedName]);
			}
		}
		return result.string;
	}

	case "G".ord(): {
		local data = cmd[1:];
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			if (#data < BASIC_REGISTER_COUNT32 * 8)
				throw Error("Register data blob is too small");
			local offset = 0;
			for (local id: [:BASIC_REGISTER_COUNT32]) {
				local name = REGISTER_IDS32[id][2];
				vmSetRegister(name, decodeHex4b(data, offset));
				offset += 8;
			}
		}
		return "OK";
	}

	case "p".ord(): {
		local id = int(cmd[1:], 16);
		local data;
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			local def = REGISTER_IDS32[id];
			data = vmGetRegister(def[1]);
			data = data.lower().lsstrip("0x");
			data = data.zfill(def[0] * 2);
		}
		return data;
	}

	case "P".ord(): {
		local idEnd = cmd.index("=");
		local id    = int(cmd[1:idEnd], 16);
		local value = "0x" + cmd[idEnd + 1:];
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		if (TARGET_ARCH == "x86_64") {
			throw Error("TODO");
		} else {
			local def = REGISTER_IDS32[id];
			vmSetRegister(def[2], value);
		}
		return "OK";
	}

	case "H".ord(): {
		local op = cmd[1];
		local id = gdbDecodeThreadId(cmd[2:]);
		if (op == "c".ord()) {
			vmSetCurrentCpu(id);
			gdbCurrentThreadForContinue = id;
		} else if (op == "g".ord()) {
			vmSetCurrentCpu(id);
			gdbCurrentThreadForGeneral = id;
		} else {
			goto unknown;
		}
		return "OK";
	}

	case "I".ord():
	case "S".ord():
		cmd = cmd[cmd.index(";") + 1:]; /* Skip the signal number */
	case "i".ord():
	case "s".ord(): {
		local rip = cmd[1:];
		if (rip) {
			rip = int(rip, 16);
			vmSetCurrentCpu(gdbCurrentThreadForContinue);
			vmSetRegister("rip", rip);
		}
		/* Do the single-step */
		vmSingleStep();
		/* Construct a new stop-reply */
		gdbStopReason = "T05"; /* SIGINT */
		return gdbConstructStopReply();
	}

	case "k".ord():
		print "[vboxgdb] GDB kill request";
		virtualBoxProc.terminate(1);
		return "OK";

	case "m".ord(): {
		local addr, none, length = cmd[1:].partition(",")...;
		addr   = int(addr, 16);
		length = int(length, 16);
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		local data = vmReadMemory(addr, length);
		local result = Bytes(length * 2);
		for (local i: [:length]) {
			local b = data[i];
			result[(i * 2)]     = tohex(b >> 4);
			result[(i * 2) + 1] = tohex(b);
		}
		return result;
	}

	case "M".ord(): {
		local addr_end   = cmd.index(",");
		local length_end = cmd.index(":", addr_end + 1);
		local addr   = cmd[1:addr_end];
		local length = cmd[addr_end + 1:length_end];
		local data = cmd[length_end + 1:];
		addr   = int(addr, 16);
		length = int(length, 16);
		if (length > #data / 2)
			throw Error("Too few data digits for memory write");
		local rawData = Bytes(length);
		for (local i: [:length]) {
			local lo = fromhex(data[i * 2]);
			local hi = fromhex(data[i * 2 + 1]);
			rawData[i] = (hi << 4) | lo;
		}
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		vmWriteMemory(addr, rawData);
		return "OK";
	}

	/* TODO: T */
	/* TODO: vCont */
	/* TODO: qSearch */
	/* TODO: qThreadExtraInfo */
	/* TODO: qfThreadInfo */
	/* TODO: qlThreadInfo */
	/* TODO: qNoAckMode */
	/* TODO: QStartNoAckMode */
	/* TODO: QNoAckMode */
	/* TODO: X */

	case "q".ord(): {
		local nameEnd = 1;
		while (nameEnd < #cmd &&
		       cmd[nameEnd] !in [",".ord(), ":".ord(), ";".ord()])
			++nameEnd;
		switch (cmd[1:nameEnd]) {

		case "C":
			return "QC" + gdbEncodeThreadId(gdbCurrentThreadForGeneral);

		case "Xfer": {
			local i;
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local name = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local method = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(":", i);
			local annex = cmd[i:nameEnd];
			i = nameEnd + 1;
			nameEnd = cmd.index(",", i);
			local offset = int(cmd[i:nameEnd], 16);
			local size   = int(cmd[nameEnd + 1:], 16);
			if (method == "read") {
				local result = GDBEvaluateQXferRead(name, annex);
				if (result is none)
					return ""; /* Unknown */
				if (result === false)
					return "E02";
				local reslen = #result;
				if (offset >= reslen)
					return "l"; /* Out-of-bounds (empty last packet) */
				if (offset + size >= reslen)
					return "l" + result[offset:];
				return "m" + result[offset:offset + size];
			} else if (method == "write") {
				return "";
			} else {
				throw Error("Invalid qXfer method: " + repr(method));
			}
		}

		case "Supported": {
			local features = cmd[nameEnd + 1:];
			CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK = false;
			CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK = false;
			for (local feat: features.split(";")) {
				if (feat.endswith("+")) {
					feat = feat[:-1];
					if (feat == "swbreak")
						CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK = true;
					else if (feat == "hwbreak")
						CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK = true;
				}
			}
			File.Writer result;
			result << "PacketSize=100000";
			if (CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK)
				result << ";swbreak+";
			if (CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK)
				result << ";hwbreak+";
			result << ";qXfer:exec-file:read+";
			result << ";qXfer:osdata:read+";
			/* TODO: QNoAckMode */
			return result.string;
		}

		default:
			break;
		}
		break;
	}

	case "z".ord():
	case "Z".ord(): {
		local shouldAdd = cmd[0] == "Z".ord();
		local type_end = cmd.index(",");
		local addr_end = cmd.index(",", type_end + 1);
		local typ  = int(cmd[1:type_end], 16);
		local addr = int(cmd[type_end + 1:addr_end], 16);
		local len  = int(cmd[addr_end + 1:], 16);
		vmSetCurrentCpu(gdbCurrentThreadForGeneral);
		vmControlBreakpoint(shouldAdd, typ, addr, len);
		return "OK";
	}

	default:
		break;
	}
unknown:
	return "";
}

@@Handle an event message send by the VirtualBox debugger
@@@return: * :   Send this as a stop reply to GDB (value for @gdbStopReason)
@@@return: none: Ignore and resume execution
function GDBHandleVirtualBoxEvent(event: Bytes): string {
	/* TODO: Include registers (if given) from `event'
	 * NOTE: event normally looks like:
	 * >> "\r\n"
	 * >> "dbgf event: Single step! (other)\r\n"
	 * >> "eax=00000000 ebx=c0c85733 ecx=00000000 edx=00000504 esi=c0c85733 edi=c0c85656\r\n"
	 * >> "eip=c02e0aae esp=c0cb4a00 ebp=c0cb4aa4 iopl=0 nv up di pl nz na pe nc\r\n"
	 * >> "cs=0008 ds=0023 es=0023 fs=0040 gs=0033 ss=0010               eflags=00000002\r\n"
	 * >> "0008:c02e0aae 8b 45 f0                mov eax, dword [ebp-010h]\r\n".bytes()
	 * Which as you can see contains the same data as used by `vmGetRegisters()` */
	if ("Single step" in event)
		return "T05"; /* SIGINT */
	local i = event.find("Breakpoint ");
	if (i >= 0) {
		i += #"Breakpoint ";
		local id = event[i:].lstrip();
		local idEnd = 0;
		while (idEnd < #id && id.isnumeric(idEnd))
			++idEnd;
		if (!idEnd) {
			throw Error("Invalid breakpoint id in event {!r}"
				.format({ event }));
		}
		id = int(id[:idEnd]);
		local data = vmDefinedBreakpoints[id];

		if (data[0] == GDB_BREAKPOINT_TYPE_SWBREAK) {
			if (CONFIG_GDB_REMOTE_SUPPORTS_SWBREAK)
				return "T05swbreak:;";
		} else {
			if (CONFIG_GDB_REMOTE_SUPPORTS_HWBREAK)
				return "T05hwbreak:;";
		}
	}
	return "T05";
}

function GDBEnter() {
	/* Always make sure that the VM is paused when we get here! */
	vmPause();
	gdbCurrentThreadForContinue = vmCurrentCpu;
	gdbCurrentThreadForGeneral  = vmCurrentCpu;
}


@@The main function for the GDB glue driver
function GDBMain() {
	try {
		gdbSocket = gdbServerSocket.accept();
		if (CONFIG_VERBOSE)
			print "[vboxgdb] GDB connection established:", gdbSocket;
		for (;;) {
			local resp;
			local c;
wait_for_command:
			if (vmIsRunning) {
				final local CHECK_TIMEOUT_MICROSECONDS = 50000;
				for (;;) {
					c = gdbSocketGetc(CHECK_TIMEOUT_MICROSECONDS,
					                  graceFulTimeout: true);
					if (c !is none)
						break;
					c = vBoxTelnetGetResponse(CHECK_TIMEOUT_MICROSECONDS);
					if (c !is none) {
						if (CONFIG_VERBOSE)
							print "[vboxgdb<-telnet] Event:", repr(c);
						local reason = GDBHandleVirtualBoxEvent(c);
						if (reason !is none) {
							gdbStopReason = reason;
							vmPause();
							goto do_send_stop_reply;
						}
					}
				}
			} else {
				c = gdbSocketGetc();
			}
			if (c == 3) {
				GDBEnter();
				gdbStopReason = "T02"; /* SIGINT */
do_send_stop_reply:
				resp = gdbConstructStopReply();
				goto do_send_resp;
			} else if (c == "$".ord()) {
				{
					local i = 0, len = 256;
					local commandBuffer = Bytes(len);
					local hasEscapedBytes = false;
					for (;;) {
						c = gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT);
						if (c == "}".ord()) {
							/* Escape the next character. */
							while (i + 1 >= len) {
								len *= 2;
								commandBuffer = commandBuffer.resized(len);
							}
							commandBuffer[i] = c;
							++i;
							c = gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT);
							commandBuffer[i] = c;
							++i;
							hasEscapedBytes = true;
							continue;
						} else if (c == "#".ord()) {
							break;
						}
						if (i >= len) {
							len *= 2;
							commandBuffer = commandBuffer.resized(len);
						}
						commandBuffer[i] = c;
						++i;
					}
					commandBuffer = commandBuffer[:i];
					local chka = fromhex(gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT));
					local chkb = fromhex(gdbSocketGetc(CONFIG_GDB_COMMAND_NEXTBYTE_TIMEOUT));
					local checksum = chka << 4 | chkb;
					local expectedChecksum = calculateGdbChecksum(commandBuffer);
					if (checksum != expectedChecksum) {
						print("[vboxgdb] WARNING: Bad checksum for packet ",
							repr(commandBuffer), " (expected: ", expectedChecksum.hex(),
							", got: ", checksum.hex(), ")");
						gdbSocket.send("-".bytes());
						goto wait_for_command;
					}
					/* Send the ACK */
					gdbSocket.send("+".bytes());
					if (hasEscapedBytes) {
						/* Unescape data. */
						len = #commandBuffer;
						local realCommandBuffer = Bytes(len);
						local realLen = 0;
						for (local i = 0; i < len; ++i) {
							local c = commandBuffer[i];
							if (c == "}".ord()) {
								++i;
								c = commandBuffer[i] ^ 0x20;
							}
							realCommandBuffer[realLen] = c;
							++realLen;
						}
						commandBuffer = realCommandBuffer.resized(realLen);
					}
					GDBEnter();
					try {
						if (CONFIG_VERBOSE)
							print "[vboxgdb<-gdb]", repr commandBuffer;
						resp = GDBEvaluateCommand(commandBuffer);
					} catch (e...) {
						if (CONFIG_VERBOSE) {
							print "[vboxgdb] WARNING: Error while executing command",
								repr(commandBuffer), ":", e;
							print repr Traceback.current;
						}
						resp = "E16"; /* 0x16 == 22 == EINVAL (on linux) */
					}
					if (resp is none)
						goto wait_for_command;
				}
do_send_resp:
				if (resp !is Bytes)
					resp = resp.bytes();
				local respLen = #resp;
				local fullResponse = Bytes(respLen + 4);
				fullResponse[0]             = "$".ord();
				fullResponse[1:1 + respLen] = resp;
				local checksum = calculateGdbChecksum(resp);
				fullResponse[respLen + 1] = "#".ord();
				fullResponse[respLen + 2] = tohex(checksum >> 4);
				fullResponse[respLen + 3] = tohex(checksum);
				if (CONFIG_VERBOSE)
					print "[vboxgdb->gdb]", repr fullResponse;
				local retry = CONFIG_GDB_SEND_MAX_RETRY_COUNT;
				for (;;) {
					gdbSocket.send(fullResponse);
					local resp = gdbSocketGetc(CONFIG_GDB_COMMAND_ACK_TIMEOUT);
					if (resp == "+".ord())
						break; /* Got it! */
					if (resp >= 0 && resp != "-".ord())
						print "[vboxgdb] WARNING: expected ACK/NACK, but got", resp.hex();
					if (!retry)
						throw Error("Too many NACKs sending response " + repr(fullResponse));
					--retry;
				}
			} else {
				print "[vboxgdb] WARNING: Unrecognized out-of-bad byte:", c.hex();
			}
		}
	} @[interrupt] catch (e...) {
		print "GDBMain() crashed:";
		print e;
		print repr Traceback.current;
		virtualBoxProc.terminate(1);
	}
}


