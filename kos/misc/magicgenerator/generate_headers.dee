/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from errors;
import * from threading;
import * from ..libgen.c.cheaders;
import * from ..libgen.c.escape;
import * from ..libgen.c.parser;
import * from ..libgen.c.writer;
import * from ..libgen.c.loader;
import * from ..libgen.c.globals;
import * from ..libgen.c.ppexpr;
import * from ..libgen.c.usersource;
import Function from ..libgen.c.cheaders;
import hash from hashlib;
import fs;

File.stdout.setbuf("line");
File.stderr.setbuf("line");

fs.chdir(fs.headof(__FILE__) + "/../../");

global final HASH_FUNCTION = "CRC-32";

@@Names of all of the functions unconditionally defined
@@via `__CRT_HAVE_*` in "/kos/src/libc/crt-features.h".
global knownUserspaceCrtFeaturesAlways: {string...} = HashSet();

@@Similar to @knownUserspaceCrtFeaturesAlways, but these
@@are    the    conditionally    available    functions.
global knownUserspaceCrtFeaturesConditionally: {string...} = HashSet();

@@Set of macro assumptions for KOS user-space.
global knownUserspaceMacroReplacements: {string: int | bool} = Dict({
	"__CRT_DOS" : true, /* Emulated by KOS, so defined */
	"__CRT_DOS_PRIMARY" : false,
	"__CRT_GLC" : true, /* Emulated by KOS, so defined */
	"__CRT_GLC_PRIMARY" : false,
	"__CRT_KOS" : true,
	"__CRT_KOS_PRIMARY" : true,
	"__CRT_CYG" : false,
	"__CRT_CYG_PRIMARY" : false,
	"__CRT_GENERIC" : false,
	"__CRT_KOS_KERNEL" : false, /* Only defined in kernel-space */
	"__CRT_FREESTANDING" : false,
	"__LIBC_BIND_CRTBUILTINS" : false,
	"_WIN32" : false,

	/* We're building with gcc, so these are always available */
	"alloca" : true,
	"__hybrid_alloca" : true,
	"__COMPILER_HAVE_PRAGMA_PUSHMACRO" : true,
});

class AutoFilePPAssume: PPAssume {
	this = super;

	@@Return the known value of a macro
	public function getMacro(name: string): int | bool | none {
		local result = this.macros.get(name);
		if (result is none && name != "__KERNEL__" &&
		    this.isMacroDefined("__KERNEL__") === false) {
			/* Optimization: __CRT_HAVE_* macros have  */
			if (name.startswith("__CRT_HAVE_")) {
				local symname = name[#"__CRT_HAVE_":];
				if (symname in knownUserspaceCrtFeaturesAlways)
					return true; /* Symbol is always available */
				if (symname !in knownUserspaceCrtFeaturesConditionally)
					return false; /* Symbol isn't conditionally available (--> not available at all) */
			}
			/* The macro may be known-defined in KOS user-space! */
			result = knownUserspaceMacroReplacements.get(name);
		}
		return result;
	}

	@@Return a copy of @this @PPAssume with the given assumption
	public function withAssumption(branch: PPBranch, value: int | bool = true): PPAssume {
		local result = AutoFilePPAssume(macros: this.macros);
		result.assumptions = copy this.assumptions;
		result.addAssumption(branch, value);
		return result;
	}
}

function createAutoFilePPAssume(macros: {string: (int | bool)} = none): PPAssume {
	return AutoFilePPAssume(macros: macros, assumptions: Dict());
}


@@Macro   definition  assumptions  that  may  be  made
@@in headers and <libc/local/...> implementation files
global final ppAssumeHeaderFiles: PPAssume = createPPAssume({
	"__BUILDING_LIBC" : false, /* not defined */
	"__SIZEOF_CHAR__" : 1,
});

@@Macro definition assumptions that may be made inside of libc
global final ppAssumeSourceFiles: PPAssume = createAutoFilePPAssume({
	"__BUILDING_LIBC" : 1,
	"__SIZEOF_CHAR__" : 1,
	"__KOS__"         : 1,
	"__KOS_VERSION__" : 400,
});

@@Macro definition assumptions that may be made inside of libc
global final ppAssumeUserSourceFiles: PPAssume = createPPAssume({
	"__KERNEL__"      : false, /* not defined */
	"__BUILDING_LIBC" : 1,
	"__SIZEOF_CHAR__" : 1,
	"__KOS__"         : 1,
	"__KOS_VERSION__" : 400,
});

@@Macro definition assumptions that may be made in DOSABI source files
global final ppAssumeDosAbiSourceFiles: PPAssume = createPPAssume({
	"__LIBCCALL_IS_LIBDCALL" : false, /* not defined */
	"__LIBDCALL_IS_LIBKCALL" : false, /* not defined */
	"__KERNEL__"             : false, /* not defined */
	"__BUILDING_LIBC"        : 1,
	"__SIZEOF_CHAR__"        : 1,
	"__KOS__"                : 1,
	"__KOS_VERSION__"        : 400,
});

@@Macro definition assumptions that may be made in crt-kos-kernel.h
global final ppAssumeCrtKosKernelFeatures: PPAssume = createPPAssume({
	"__LIBCCALL_IS_LIBDCALL" : false, /* not defined */
	"__LIBDCALL_IS_LIBKCALL" : false, /* not defined */
	"__KERNEL__"             : true,  /* is defined */
	"__SIZEOF_CHAR__"        : 1,
	"__KOS__"                : 1,
	"__KOS_VERSION__"        : 400,
});



@@The max # of tasks that may be run in parallel
global final MAX_RUNNING_TASKS = (cpu_count from posix)() * 2;

class CriticalSection {

	@@The # of threads inside the critical section
	public member counter: Cell with int = Cell(0);

	@@Enter the critical section
	public operator enter() {
		local oldval;
		do {
			for (;;) {
				oldval = counter.value;
				if (oldval != -1)
					break;
				Thread.operator . ("yield")();
			}
		} while (counter.cmpxch(oldval, oldval + 1) !== oldval);
	}

	@@Leave the critical section
	public operator leave() {
		local oldval;
		do {
			oldval = counter.value;
			assert oldval > 0;
		} while (counter.cmpxch(oldval, oldval - 1) !== oldval);
	}

	@@Exit  the application, but wait for all threads
	@@to have exited @this critical section first, as
	@@well  as prevent any threads from ever entering
	@@the section again
	function exitApplication(status: int) {
		local oldval;
		do {
			for (;;) {
				oldval = counter.value;
				if (oldval == 0)
					break;
				Thread.operator . ("yield")();
			}
		} while (counter.cmpxch(oldval, -1) !== oldval);
		File.stdout.flush();
		File.stderr.flush();
		Error.AppExit.exit(status);
	}
}

global final criticalSection = CriticalSection();
global numTotalTasks: int = 0;
global numCompletedTasks: Cell with int = Cell(0);
global pendingTasks: {(Callable, Tuple)...} = [];
global pendingTasksSem: Semaphore = Semaphore(0);
global completeAllTasksSem: Semaphore = Semaphore(0);

@@A prefix printed before all messages printed by @printMessage
global messagePrefix: string = "";

@@Lock for @printMessage
global messageLock: SharedLock = SharedLock();

@@Print a status message, including a leading progress indicator
function printMessage(msg: string) {
	with (messageLock) {
		local numCompl = numCompletedTasks.value;
		local complPercent = try (numCompl * 100) / numTotalTasks catch (...) 99;
		print("[", messagePrefix, "|", str(complPercent).zfill(2),
			"% (", numCompl, " / ", numTotalTasks, ")] ", msg);
	}
}


function incCompletedTasks(): int {
	local oldval;
	do {
		oldval = numCompletedTasks.value;
	} while (numCompletedTasks.cmpxch(oldval, oldval + 1) !== oldval);
	return oldval;
}

@@Thread-Main function for task service threads
function servicePendingTasks() {
	try {
		for (;;) {
			/* Wait for more tasks */
			pendingTasksSem.acquire();
			/* Execute pending tasks */
			while (pendingTasks) {
				local task: (Callable, Tuple);
				/* Take one task and start executing it */
				try {
					task = pendingTasks.popfront();
				} catch (IndexError) {
					continue;
				}
				/* Execute the task */
				task[0](task[1]...);
				local oldNumCompletedTasks = incCompletedTasks();
				if (oldNumCompletedTasks + 1 >= numTotalTasks)
					completeAllTasksSem.release();
			}
		}
	} catch (e...) {
		pendingTasks = none;
		print repr e;
		print Traceback.current;
		criticalSection.exitApplication(1);
	}
}


@@Start a new task that'll execute @cb with @args
function startTask(cb: Callable, args: {Object...} = ()) {
	pendingTasks.append((cb, args));
	pendingTasksSem.release();
	++numTotalTasks;
}

@@Wait for all running tasks to finish
function waitTasks() {
	while (numCompletedTasks.value < numTotalTasks)
		completeAllTasksSem.acquire();
	numCompletedTasks.value = 0;
	numTotalTasks           = 0;
}

/* Launch worker threads */
for (none: [:MAX_RUNNING_TASKS])
	Thread(servicePendingTasks).start();

function tryCreateDirectoryTree(path: string): bool {
	path = path.replace("\\", "/").rstrip("/");
again:
	try {
		fs.mkdir(path);
	} catch (FileExists) {
		return false;
	} catch (FileNotFound) {
		if (tryCreateDirectoryTree(fs.headof(path)))
			goto again;
		throw;
	}
	return true;
}

@@Update the contents of @filename, using a file-printer callback @cb
function updateHashedFile(filename: string, cb: Callable with File) {
	local fp: File = File.Writer();
	printMessage(f"Printing: {repr filename} (begin)");
	local result = cb(fp);
	printMessage(f"Printing: {repr filename} (end)");
	local newText: Bytes = fp.string.encode("utf-8");
	local newTextHash: int = hash(HASH_FUNCTION, newText);
again:
	try {
		fp = File.open(filename, "rb+");
	} catch (FileNotFound) {
again_create_new:
		try {
			fp = File.open(filename, "wbx");
		} catch (FileExists) {
			goto again;
		} catch (FileNotFound) {
			if (tryCreateDirectoryTree(fs.headof(filename)))
				goto again_create_new;
			throw;
		}
		/* Create a previously non-existent file */
		printMessage(f"Creating: {repr filename}");
		with (criticalSection) {
			try {
				with (fp) {
					fp << "/* HASH " << HASH_FUNCTION << ":" << newTextHash.hex() << " */\n";
					fp.write(newText);
				}
			} catch (...) {
				try {
					fs.unlink(filename);
				} catch (...) {
				}
				throw;
			}
		}
		goto done;
	}
	/* File already exists.
	 * -> Read in the existing file, and check if its contents match its hash.
	 *    If they don't, then throw an Error.
	 * -> If the contents match the new contents for the file, then don't do anything.
	 * -> If the contents did change, then re-write the new contents to the file */
	local oldText: Bytes;
	local oldTextHashFunction: string;
	local oldTextHash: int, oldTextRealHash: int;
	try {
		local oldTextWhole: Bytes = fp.readall();
		if (!oldTextWhole)
			goto do_update_file; /* Empty file (always override) */
		oldTextHashFunction, oldTextHash = oldTextWhole
			.scanf(" /* HASH %[^:]:%[0-9xXa-fA-F] */")...;
		oldText = oldTextWhole[oldTextWhole.index("\n") + 1:];
		oldTextHashFunction = oldTextHashFunction.strip().decode("utf-8");
		oldTextHash         = int(oldTextHash.strip());
		oldTextRealHash     = hash(oldTextHashFunction, oldText);
	} catch (...) {
		throw Error(f"File {repr filename} is lacking, or has a broken hash header");
	}
	if (oldTextHash != oldTextRealHash) {
		if (oldText == newText)
			goto do_update_file;
		throw Error(
			f"File {repr filename} has been modified (hash miss-match: "
			f"expected {repr oldTextRealHash.hex()}, but got {repr oldTextHash.hex()})"
		);
	}
	if (oldTextHash == newTextHash) {
		if (oldText == newText)
			goto done;
	}
do_update_file:
	try {
		printMessage(f"Updating: {repr filename}");
		fp.rewind();
		with (criticalSection) {
			with (fp) {
				fp << "/* HASH " << HASH_FUNCTION << ":" << newTextHash.hex() << " */\n";
				fp.write(newText);
				fp.trunc();
			}
		}
	} catch (...) {
		try {
			fs.unlink(filename);
		} catch (...) {
		}
		throw;
	}
done:
	return result;
}



@@Set of known user libc exports (populated by %[declare_user_export(...)])
global final knownUserExports: {string...} = HashSet();

@@Set of known kernel exports (populated by %[declare_kernel_export(...)])
global final knownKernelExports: {string...} = HashSet();
global final knownKernelOnlyExports: {string...} = HashSet();

@@Set of known libc section names
global final knownLibcSections: {string...} = HashSet();

@@Parse custom directives that are so obscure that
@@they shouldn't be  part of  the standard  loader
@@@return: * : Indicative of the directive having been recognized.
function customDirectivesParser(context: LoaderContext): bool {
	local self = context.self;
	local tok = self.tok;
	switch (tok) {

	case "define_ssp":
	case "define_ssp_builtin":
	case "define_ssp_undef":
	case "define_ssp_builtin_undef":
	case "define_ssp_crt":
	case "define_ssp_builtin_crt":
	case "define_ssp_undef_crt":
	case "define_ssp_builtin_undef_crt": {
		local define_builtin = "builtin" in tok;
		local undef_existing = "undef" in tok;
		local check_crt      = "crt" in tok;
		self.next();
		self.skip("(");
		local a = str self.parseCStringOrFunctionLikeExpression();
		self.skip("=");
		local b = str self.parseCStringOrFunctionLikeExpression();
		self.skip(")");
		local aName = a.partition("(")[0].strip();
		local baseFunctionName = b.lstrip("_").partition("_chk")[0];
		File.Writer fp;
		if (define_builtin) {
			fp << "#if (defined(__LIBC_BIND_CRTBUILTINS) && defined(__CRT_HAVE_" << baseFunctionName << ") && \\\n";
			fp << "     defined(__CRT_HAVE___" << baseFunctionName << "_chk) && __has_builtin(__builtin___" << baseFunctionName << "_chk))\n";
			if (undef_existing)
				fp << "#undef " << aName << "\n";
			local bos_start = b.index("__ssp_bos");
			local bos = b[bos_start:b.indexmatch("(", ")", b.index("(", bos_start) + 1) + 1].strip();
			fp << "#define " << a << (" " * ((#b + #bos + 31) - #a)) << " \\\n";
			fp << "\t(" << bos << " != (__SIZE_TYPE__)-1 ? __builtin_" << b << " \\\n";
			fp << "\t" << (" " * (#bos + 23)) << ": " << b << ")\n";
			if (check_crt) {
				fp << "#elif defined(__CRT_HAVE___" << baseFunctionName << "_chk)\n";
			} else {
				fp << "#else /* ... */\n";
			}
		} else {
			if (check_crt)
				fp << "#ifdef __CRT_HAVE___" << baseFunctionName << "_chk\n";
		}
		if (undef_existing)
			fp << "#undef " << aName << "\n";
		fp << "#define " << a << " " << b << "\n";
		if (define_builtin) {
			if (check_crt) {
				fp << "#endif /* ... */\n";
			} else {
				fp << "#endif /* !... */\n";
			}
		} else if (check_crt) {
			fp << "#endif /* __CRT_HAVE___" << baseFunctionName << "_chk */\n";
		}
		context.insertText_c(fp.string);
	}	break;

	case "assume_undefined_in_kos": /* TODO: Stuff defined with this can also be assumed in KOS kernel-space! */
	case "assume_undefined_in_kos_userspace":
		self.next();
		tok = self.skip("(");
		while (tok !in ["", ")"]) {
			local name = str self.parseCStringOrFunctionLikeExpression();
			knownUserspaceMacroReplacements[name] = false;
			if (self.tok != ",")
				break;
			tok = self.next();
		}
		self.skip(")");
		break;

	case "assume_defined_in_kos": /* TODO: Stuff defined with this can also be assumed in KOS kernel-space! */
	case "assume_defined_in_kos_userspace":
		self.next();
		tok = self.skip("(");
		while (tok !in ["", ")"]) {
			local name = str self.parseCStringOrFunctionLikeExpression();
			local value = true;
			if (self.tok == "=") {
				self.next();
				value = str self.parseCStringOrFunctionLikeExpression();
				value = try int(value) catch (...) true;
			}
			knownUserspaceMacroReplacements[name] = value;
			if (self.tok != ",")
				break;
			tok = self.next();
		}
		self.skip(")");
		break;

	case "declare_user_export":
	case "declare_user_import":
	case "declare_kernel_export":
	case "declare_kernel_only_export":
	case "declare_known_section_class": {
		local s = (tok == "declare_user_export" || tok == "declare_user_import")
			? knownUserExports
			: tok == "declare_kernel_export"
			? knownKernelExports
			: tok == "declare_kernel_only_export"
			? knownKernelOnlyExports
			: knownLibcSections;
		self.next();
		tok = self.skip("(");
		while (tok !in ["", ")"]) {
			local name = str self.parseCStringOrFunctionLikeExpression();
			s.insert(name);
			if (self.tok != ",")
				break;
			tok = self.next();
		}
		self.skip(")");
	}	break;

	default:
		return false;
	}
	return true;
}

@@Compile a given system header source file @filename
function compileSystemHeaderSourceFile(filename: string, headerName: string) {
	printMessage(f"Compiling: {repr filename} (begin)");
	local parser = CParser(File.open(filename), filename: filename);
	loadSystemHeaderDefinitions(
		self:                   parser,
		headerName:             headerName,
		customDirectivesParser: customDirectivesParser);
	printMessage(f"Compiling: {repr filename} (end)");
}



@@Print the file "/kos/src/libc/crt-features.h",
function doPrint_src_libc_crtFeatures(fp: File) {
	@@Mapping of feature-asmname to ppCond required for the feature to be defined
	local crtFeatureConditions: {string: string} = Dict();
	fp << COPYRIGHT << "\n\n";
	for (local x: knownKernelExports)
		crtFeatureConditions.setnew(str(x), "1");
	for (local x: knownUserExports)
		crtFeatureConditions.setnew(str(x), "!defined(__KERNEL__)");
	for (local x: knownKernelOnlyExports) {
		x = str(x);
		if (!crtFeatureConditions.setnew(x, "defined(__KERNEL__)"))
			crtFeatureConditions[x] = "1";
	}
	/* Now for the actual heart of the thing:
	 * Go through  all system  headers and  look at  the lists  of
	 * library  functions that are  being declared. Then, remember
	 * information about all of them within @crtFeatureConditions,
	 * including define-if requirements */
	for (local none, header: allSystemHeaders) {
		for (local parts: {
			header.order_libcAutoHeader,
			header.order_libcUserHeader
		}) {
			for (local part: parts) {
				if (part !is LibraryFunction)
					continue;
				local effectiveAsmName = str(part.name);
				if (effectiveAsmName.startswith("libc_")) {
					effectiveAsmName = effectiveAsmName[5:];
				} else if (effectiveAsmName.startswith("libd_")) {
					effectiveAsmName = "DOS$" + effectiveAsmName[5:];
				} else {
					continue; /* Shouldn't happen... */
				}
				local newCond = part.isImplementedPpCond;
				if (newCond == "0")
					continue; /* Shouldn't happen... */
				if (!crtFeatureConditions.setnew(effectiveAsmName, newCond)) {
					local oldCond = crtFeatureConditions[effectiveAsmName];
					if (oldCond == "1")
						continue; /* Already universal */
					if (newCond == "1") {
						crtFeatureConditions[effectiveAsmName] = "1";
						continue; /* New condition was universal */
					}
					/* Merge defined-if conditions */
					crtFeatureConditions[effectiveAsmName] = f"({oldCond})||({newCond})";
				}
			}
		}
	}
	local wrt = CWriter(fp);
	for (local name: crtFeatureConditions.keys.sorted()) {
		local cond = crtFeatureConditions[name];
		if (cond in ["1", "!defined(__KERNEL__)"]) {
			knownUserspaceCrtFeaturesAlways.insert(name);
		} else {
			knownUserspaceCrtFeaturesConditionally.insert(name);
		}
		CWriter_ppIfEscaped(wrt, cond, ESCAPE_MODE_NONE);
		wrt << "#define __CRT_HAVE_" << name << "\n";
		wrt.ppEndif();
	}
	wrt.flush();
}

@@Print the file "/kos/include/crt-features/crt-kos-kernel.h"
function doPrint_include_crtFeatures_crtKosKernel(fp: File) {
	fp << COPYRIGHT << "\n\n";
	local crtFeatureConditions: {string: string} = Dict();
	for (local x: knownKernelExports)
		crtFeatureConditions.setnew(str(x), "1");
	for (local x: knownKernelOnlyExports)
		crtFeatureConditions.setnew(str(x), "1");
	/* Go through all  library functions, as  well as their  exports,
	 * and filter out  the ones  that require  "!defined(__KERNEL__)"
	 * The ones that remain will be the symbol names that are defined
	 * when building libc as part of the kernel core.
	 * Also note that we can skip scanning of user-level source files,
	 * as  those don't even  get included as part  of the kernel build
	 * tree */
	local final NOT_DEFINED_KERNEL = "!defined(__KERNEL__)";
	for (local none, header: allSystemHeaders) {
		for (local part: header.order_libcAutoHeader) {
			if (part !is LibraryFunction)
				continue;
			local partPpCond = str(part.isImplementedPpCond);
			if (NOT_DEFINED_KERNEL in partPpCond)
				continue;
			if (partPpCond == "0")
				continue;
			for (local exportPpCond, exportAsmname: part.exportSymbolNames) {
				exportPpCond = str(exportPpCond);
				exportAsmname = str(exportAsmname);
				if (NOT_DEFINED_KERNEL in exportPpCond)
					continue;
				if (partPpCond != "1")
					exportPpCond = f"({partPpCond})&&({exportPpCond})";
				if (exportPpCond == "0")
					continue;
				if (!crtFeatureConditions.setnew(exportAsmname, exportPpCond)) {
					if (exportPpCond == "1") {
						crtFeatureConditions[exportAsmname] = "1";
					} else {
						crtFeatureConditions[exportAsmname] =
							f"({crtFeatureConditions[exportAsmname]})||({exportPpCond})";
					}
				}
			}
		}
	}
	local wrt = CWriter(fp, ppAssume: ppAssumeCrtKosKernelFeatures);
	for (local name: crtFeatureConditions.keys.sorted()) {
		local cond = crtFeatureConditions[name];
		if (cond == "1") {
			/* Speed up file printing in this simple case */
			wrt << "#define __CRT_HAVE_" << name << "\n";
		} else {
			CWriter_ppIfEscaped(wrt, cond, ESCAPE_MODE_FULL);
			wrt << "#define __CRT_HAVE_" << name << "\n";
			wrt.ppEndif();
		}
	}
	wrt.flush();
}

class WildcardRule {
	this = default;
	public member pattern: string;
	public member sections: {string...};
}

function resolveLine(line: {string | WildcardRule...}): {string...} {
	for (local e: line) {
		if (e is WildcardRule) {
			yield e.sections...;
		} else {
			yield e;
		}
	}
}


@@Update the file "/src/libc/crt-order.h"
function doPrint_src_libc_crtOrder() {
	local final ORDER_FILENAME = "src/libc/crt-order.h";
	printMessage(f"Parsing crt-order: {repr ORDER_FILENAME} (begin)");
	local usedSectionNames: HashSet with string = copy knownLibcSections;
	for (local header: allSystemHeaders.values) {
		for (local field: { "order_libcAutoSource", "order_libcDosabiSource", "order_libcUserSource" }) {
			for (local item: header.operator . (field)) {
				if (item !is LibraryFunction)
					continue;
				for (local binding/*: LibraryFunctionBinding*/ : item.functionBindings) {
					local sect = binding.implSection;
					if (sect !is none) {
						sect = str(sect);
						if (sect.startswith(".text"))
							usedSectionNames.insert(sect[5:]);
					}
				}
			}
		}
	}

	/* Remove a couple of special section names we may have picked up on. */
	for (local x: { "", ".unlikely", ".likely", ".hot", ".cold" })
		usedSectionNames.remove(x);

	/* Parse rules */
	local repeatRules: {string...} = [];     /* @REPEAT rules */
	local orderRules: {{string...}...} = []; /* Output order rules (one per line) */
	local oldData = File.open(ORDER_FILENAME, "rb").read();
	local data = oldData.decode("utf-8").unifylines();
	/* Find markers. */
	local dataRulesStart   = data.index("/*[[[order") + 10;
	local dataRulesEnd     = data.index("]]]*/", dataRulesStart);
	local orderOutputStart = dataRulesEnd + 5;
	local orderOutputEnd   = data.index("/*[[[end]]]*/", orderOutputStart);
	local i = dataRulesStart;
	while (i < dataRulesEnd) {
		if (data.isspace(i)) {
			++i;
			continue;
		}
		local eol = data.find("\n", i, dataRulesEnd);
		if (eol < 0)
			eol = dataRulesEnd;
		local com = data.find("#", i, eol);
		if (com < 0)
			com = eol;
		local line = data[i:com].rstrip();
		i = eol + 1;
		if (!line)
			continue;
		if (line.startswith("@REPEAT")) {
			line = line[7:].lstrip();
			repeatRules.append(line);
			continue;
		}
		local items = [];
		for (local el: line.split(" ")) {
			el = el.strip();
			if (el.startswith("!")) {
				usedSectionNames.append(el);
				el = el[1:];
			}
			items.append(el);
		}
		orderRules.append(items);
	}

	/* Apply repeat rules. */
	local order: {{string...}...} = copy orderRules;
	for (local prefix: repeatRules) {
		for (local block: orderRules) {
			order.append(Tuple(for (local r: block) prefix + r));
		}
	}

	@@Final output order of sections
	local sectionsOutputOrder: {{string...}...} = [];
	local wildcardRules: {WildcardRule...} = [];
	for (local block: order) {
		local blockSections = [];
		for (local rule: block) {
			if ("*" in rule || "?" in rule) {
				rule = WildcardRule(pattern: rule);
				blockSections.append(rule);
				wildcardRules.append(rule);
			} else {
				if (usedSectionNames.remove(rule))
					blockSections.append(rule);
			}
		}
		sectionsOutputOrder.append(blockSections);
	}
	/* Resolve wildcard rules. */
	wildcardRules.sort(key: x -> {
		x.pattern.length, /* Sort by length first... */
		x.pattern,        /* ... and then alphabetically */
	});
	for (local rule: wildcardRules) {
		local sections: {string...} = [];
		local pattern = rule.pattern;
again_search_wildcard:
		for (local name: usedSectionNames) {
			if (name.wmatch(pattern)) {
				usedSectionNames.remove(name);
				sections.append(name);
				goto again_search_wildcard;
			}
		}
		sections.sort();
		rule.sections = sections;
	}

	/* Check if there are any sections that don't appear int the output order */
	if (usedSectionNames) {
		for (local n: usedSectionNames.sorted())
			print File.stderr: "Unmapped section:", repr n;
		throw Error("Unmapped sections are present");
	}

	/* Print the section-order macro. */
	local newMacroText = File.Writer();
	newMacroText << "\n#define CRT_SECTIONS_LINKORDER(CB, PREFIX) \\\n";
	for (local line: sectionsOutputOrder) {
		line = Tuple(resolveLine(line));
		if (!line)
			continue;
		newMacroText << "\tCB("
			<< " ".join(for (local name: line) "PREFIX" + name)
			<< ") \\\n";
	}
	newMacroText = newMacroText.string[:-3] + "\n";
	local newData = f"{data[:orderOutputStart]}{newMacroText}{data[orderOutputEnd:]}".encode("utf-8");
	if (newData != oldData) {
		printMessage(f"Updating crt-order: {repr ORDER_FILENAME}");
		with (local fp = File.open(ORDER_FILENAME, "w"))
			fp.write(newData);
	}
	printMessage(f"Parsing crt-order: {repr ORDER_FILENAME} (end)");
}

@@Print the file "/kos/src/libc/libc/dosabi-functions.h"
function doPrint_src_libc_libc_dosabiFunctions(fp: File) {
	/* Define 2 generic headers:
	 * /kos/src/libc/libc/dosabi-functions.h:
	 *     >> #define DFUN(section, libd_name, libc_name, returnType, argc, argvTypes...)
	 *     >> DFUN(".text.crt.dos.database.aliases", libd_getaliasent_r, libc_getaliasent_r, TD, 4, TP, TP, TI, TP)
	 *     >> DFUN(".text.crt.dos.database.aliases", libd_getaliasbyname, libc_getaliasbyname, TP, 1, TP)
	 *     >> DFUN(".text.crt.dos.database.aliases", libd_getaliasbyname_r, libc_getaliasbyname_r, TD, 5, TP, TP, TP, TI, TP)
	 * Where returnType and argvTypes are each one of:
	 *     - TV     : void   (Only allowed for returnType)
	 *     - TP     : Pointer-type
	 *     - THH    : [signed|unsigned] char
	 *     - TH     : [unsigned] short
	 *     - TD     : [unsigned] int
	 *     - TL     : [unsigned] long
	 *     - TLL    : [unsigned] long long
	 *     - TF     : float
	 *     - TFD    : double
	 *     - TFL    : long double
	 *     - TI     : [s]size_t / ptrdiff_t
	 *     - TI8    : [u]int8_t
	 *     - TI16   : [u]int16_t
	 *     - TI32   : [u]int32_t
	 *     - TI64   : [u]int64_t
	 *     - TIn(s) : [u]int<s*8>_t
	 *     - TS(n)   : struct { ... };
	 *
	 * /kos/src/libc/libc/dosabi-exports.h:
	 *     >> DEFINE_PUBLIC_ALIAS(...)
	 *     All of the public aliases of symbols defined by "dosabi-functions.h"
	 *
	 * These 2 files can then be included by asm-wrappers on architectures that need them,
	 * whilst still allowing for a simple fallback C-implementation:
	 * >> #define DFUN_3(section, libd_name, libc_name, returnType, Ta, Tb, Tc)                 \
	 * >>     DECLARE_POSSIBLE_STRUCT_TYPE(r, returnType)                                       \
	 * >>     DECLARE_POSSIBLE_STRUCT_TYPE(a, Ta)                                               \
	 * >>     DECLARE_POSSIBLE_STRUCT_TYPE(b, Tb)                                               \
	 * >>     DECLARE_POSSIBLE_STRUCT_TYPE(c, Tc)                                               \
	 * >>     INTDEF TYPEFOR(r, returnType) LIBKCALL                                            \
	 * >>     UNIQUE(base)(TYPEFOR(a, Ta), TYPEFOR(b, Tb), TYPEFOR(c, Tc)) ASMNAME(#libc_name); \
	 * >>     INTERN ATTR_SECTION(section) TYPEFOR(r, returnType) LIBDKALL                      \
	 * >>     libd_name(TYPEFOR(a, Ta), TYPEFOR(b, Tb), TYPEFOR(c, Tc)) {                       \
	 * >>         RETURN_IF_NOT_VOID(returnType) UNIQUE(base)(a, b, c);                         \
	 * >>     }
	 * >>
	 * >> #define DFUN_...
	 * >>
	 * >> #define DFUN(section, libd_name, libc_name, returnType, argc, ...) \
	 * >>     DFUN_##argc(section, libd_name, libc_name, returnType, __VA_ARGS__)
	 *
	 * NOTE: And if you wanna argue about the difference this can make:
	 *                              Size        .text     .debug_info
	 * libc-no-dosabi.so.stripped   3.161.856   606.280   0
	 * libc.so.stripped             3.776.288   950.196   0
	 * libc-no-dosabi.so            5.112.112   606.280   937.006
	 * libc.so                      6.446.216   950.196   1.222.596
	 *
	 * NOTE: *-no-dosabi.so* was generated by excluding auto/dosabi/<*>.c sources
	 *
	 * So we're  talking about  about 1/3  of libc's  .text segment  here!
	 * Custom  assembly could  reduce this  to barely  anything by merging
	 * the cc-conversion wrappers for functions with compatible prototypes
	 */
	fp << COPYRIGHT << "\n"
		"#ifndef DFUN\n"
		"#define DFUN(section, libd_name, libc_name, returnType, argc, /*argvTypes*/...)\n"
		"#endif /* !DFUN */\n\n";
	local final DEFAULT_TIn_TYPES: {(string, string)...} = {
		("TP", "__SIZEOF_POINTER__"),
		("THH", "__SIZEOF_CHAR__"),
		("TH", "__SIZEOF_SHORT__"),
		("TD", "__SIZEOF_INT__"),
		("TL", "__SIZEOF_LONG__"),
		("TLL", "__SIZEOF_LONG_LONG__"),
		("TI", "__SIZEOF_SIZE_T__"),
		("TI8", "1"),
		("TI16", "2"),
		("TI32", "4"),
		("TI64", "8"),
	};
	for (local name, siz: DEFAULT_TIn_TYPES) {
		fp << "#ifndef " << name << "\n"
			"#define " << name << " TIn(" << siz << ")\n"
			"#endif /* !" << name << " */\n";
	}
	local cWriter = CWriter(fp, ppAssume: ppAssumeDosAbiSourceFiles);
	for (local name: allSystemHeaders.keys.sorted()) {
		local header: SystemHeader = allSystemHeaders[name];
		if (!header.order_libcDosabiSource)
			continue;
		cWriter << "\n/* " << name << " */\n";
		for (local part: header.order_libcDosabiSource) {
			try {
				local usedBindings: {LibraryFunctionBinding...} = part.functionBindings;
				if (!usedBindings)
					continue;
				CWriter_ppIfEscaped(cWriter, part.ppCond, ESCAPE_MODE_NONE);
				local proto: FunctionPrototype = part.functionPrototype;
				local isFirst = true;
				for (local b /*: LibraryFunctionBinding */: usedBindings) {
					local bind = b.functionBinding;
					if (isFirst) {
						CWriter_ppIfEscaped(cWriter, b.ppCond, ESCAPE_MODE_NONE);
						isFirst = false;
					} else {
						CWriter_ppElifEscaped(cWriter, b.ppCond, ESCAPE_MODE_NONE);
					}
					if (bind is FunctionImplementation) {
						local baseFunction = bind.name;
						/* #define DFUN(section, libd_name, libc_name, returnType, argc, argvTypes...) */
						cWriter << "DFUN(" << repr(b.implSection !is none ? str(b.implSection) : ".text")
							<< ", " << part.name << ", " << baseFunction
							<< ", " << proto.returnType.requireTypeClass
							<< ", ";
						local baseArgc = #proto.argv;
						local effectiveArgc = baseArgc;
						if (proto.hasEllipsis) {
							--baseArgc;
							effectiveArgc = baseArgc;
							assert proto.ellipsisArgumentTypes !is none;
							effectiveArgc += #proto.ellipsisArgumentTypes;
						}
						cWriter << effectiveArgc;
						for (local i: [:effectiveArgc]) {
							cWriter << ", ";
							local typ: CType;
							if (i < baseArgc) {
								typ = proto.argv[i].ctype;
							} else {
								typ = proto.ellipsisArgumentTypes[i - baseArgc];
							}
							cWriter << typ.requireTypeClass;
						}
						cWriter << ")\n";
					} else if (bind is MacroBinding) {
						/* Not bound here! */
					} else {
						cWriter << "DEFINE_INTERN_ALIAS("
							<< part.name << ", "
							<< bind << ");\n";
					}
				}
				if (!isFirst)
					cWriter.ppEndif();
				cWriter.ppEndif();
			} catch (...) {
				print "... While printing DFUN-binding for", repr(part.name);
				throw;
			}
		}
	}
	cWriter.flush();
}

@@Print the file "/kos/src/libc/libc/dosabi-exports.h"
function doPrint_src_libc_libc_dosabiExports(fp: File) {
	fp << COPYRIGHT << "\n"
		"#ifndef DEFINE_PUBLIC_ALIAS\n"
		"#define DEFINE_PUBLIC_ALIAS(new_name, old_name)\n"
		"#endif /* !DEFINE_PUBLIC_ALIAS */\n";
	local cWriter = CWriter(fp, ppAssume: ppAssumeDosAbiSourceFiles);
	for (local name: allSystemHeaders.keys.sorted()) {
		local header: SystemHeader = allSystemHeaders[name];
		if (!header.order_libcDosabiSource)
			continue;
		cWriter << "\n/* " << name << " */\n";
		for (local part: header.order_libcDosabiSource) {
			if (!part.exportSymbolNames)
				continue;
			CWriter_ppIfEscaped(cWriter, part.implementationPpCond, ESCAPE_MODE_NONE);
			for (local ppCond, asmname: part.exportSymbolNames) {
				CWriter_ppIfEscaped(cWriter, ppCond, ESCAPE_MODE_NONE);
				if (!asmname.issymbol())
					asmname = repr(asmname);
				cWriter << "DEFINE_PUBLIC_ALIAS("
					<< asmname << ", " << part.name << ");\n";
				cWriter.ppEndif();
			}
			cWriter.ppEndif();
		}
	}
	cWriter.flush();
}


@@Print the file "/kos/include/gnu/stubs.h"
function doPrint_include_gnu_stubs(fp: File) {
	fp << COPYRIGHT << "\n";
	local cWriter = CWriter(fp, ppAssume: ppAssumeUserSourceFiles);
	local stubsByName: {string: LibraryFunction} = Dict();
	for (local f: stubUserFunctions)
		stubsByName[f.name] = f;
	for (local name: stubsByName.keys.sorted()) {
		local f = stubsByName[name];
		CWriter_ppIfEscaped(cWriter, f.implementationPpCond, ESCAPE_MODE_FULL);
		for (local ppCond, symbolName: f.exportSymbolNames) {
			if (symbolName.startswith("?"))
				symbolName = symbolName.replace("?", "$Q").replace("@", "$A");
			if ("$" in symbolName)
				ppCond = f"({ppCond})&&!defined(__COMPILER_NO_DOLLAR_IN_SYMBOL)";
			CWriter_ppIfEscaped(cWriter, ppCond, ESCAPE_MODE_FULL);
			cWriter << "#define __stub_" << symbolName << "\n";
			cWriter.ppEndif();
		}
		cWriter.ppEndif();
	}
	cWriter.flush();
}

function handleSectionName(name: string) {
	if (name.startswith("\"") && name.endswith("\""))
		name = name[1:-1];
	for (local prefix: { ".text", ".data", ".rodata", ".bss" }) {
		if (name.startswith(prefix)) {
			name = str(name[#prefix:]);
			if (name)
				knownLibcSections.insert(name);
			return true;
		}
	}
	return false;
}

function scanFileForSectionNames(filename: string) {
	printMessage(f"Scanning for section names: {repr filename} (begin)");
	local data = File.open(filename, "rb").read();
	local i = 0, len = #data;
	while (i < len) {
		if (data.isspace(i)) {
			++i;
			continue;
		}
		local ch = data[i];
		++i;
		switch (ch) {

		case "A".ord(): {
			if (data.startswith("TTR_SECTION", i)) {
				i += 11;
				while (i < len && data.isspace(i))
					++i;
				if (i >= len)
					break;
				if (data[i] != "(".ord())
					break;
				do {
					++i;
				} while (i < len && data.isspace(i));
				if (data[i] != "\"".ord())
					break;
				++i;
				local sectionNameStart = i;
				i = data.find("\"", i);
				if (i < 0)
					goto done;
				handleSectionName(data[sectionNameStart:i]);
				++i;
			}
		}	break;

		case "D".ord(): {
			if (data.startswith("EFINE_NOREL_GLOBAL_META", i)) {
				i += 23;
				while (i < len && data.isspace(i))
					++i;
				if (i >= len)
					break;
				if (data[i] != "(".ord())
					break;
				local s = data.find("\"", i);
				if (s < 0)
					break;
				i = s + 1;
				local sectionNameStart = i;
				i = data.find("\"", i);
				if (i < 0)
					goto done;
				handleSectionName(".text" + data[sectionNameStart:i]);
				++i;
			}
		}	break;

		case ".".ord(): {
			while (i < len && data.isspace(i))
				++i;
			if (data.startswith("section", i)) {
				i += 7;
handle_asm_section_directive:
				if (i >= len)
					goto done;
				if (!data.isspace(i))
					break;
				do {
					++i;
				} while (i < len && data.isspace(i));
				if (i >= len)
					goto done;
				if (data[i] == "\"".ord()) {
					++i;
					local sectionNameStart = i;
					i = data.find("\"", i);
					if (i < 0)
						goto done;
					handleSectionName(data[sectionNameStart:i]);
					++i;
				} else {
					local sectionNameStart = i;
					while (i < len && (data.issymcont(i) || data[i] in ".$".ordinals))
						++i;
					if (i > sectionNameStart)
						handleSectionName(data[sectionNameStart:i]);
				}
			} else if (data.startswith("pushsection", i)) {
				i += 11;
				goto handle_asm_section_directive;
			}
		}	break;

		case "\"".ord():
		case "\'".ord(): {
			while (i < len) {
				local ch2 = data[i];
				++i;
				if (ch2 == ch)
					break;
				if (ch2 == "\\".ord())
					++i;
			}
		}	break;

		case "/".ord(): {
			if (i >= len)
				goto done;
			ch = data[i];
			if (ch == "/".ord()) {
				i = data.find("\n", i);
				if (i < 0)
					goto done;
			} else if (ch == "*".ord()) {
				i = data.find("*/", i+1);
				if (i < 0)
					goto done;
				i += 2;
			}
		}	break;

		case "#".ord(): {
			local eol = data.find("\n", i);
			if (eol < 0)
				eol = len;
			local com = data.find("/*", i, eol);
			if (com >= 0)
				eol = com;
			local line = data[i:eol].lstrip();
			if (line.startswith("define ")) {
				local name;
				line = line[7:].lstrip();
				name, none, line = line.partition(" ")...;
				name = name.strip();
				line = line.strip();
				if ("SECTION" in name && line) {
					local com = line.find("//");
					if (com >= 0)
						line = line[:com].rstrip();
					handleSectionName(line);
				}
			}
			i = eol;
		}	break;

		default:
			break;
		}
	}
done:
	printMessage(f"Scanning for section names: {repr filename} (end)");
}


function startScanSectionJobs(filenamePattern: string) {
	local head = fs.abspath(fs.headof(filenamePattern));
	for (local filename: fs.query(filenamePattern)) {
		startTask(scanFileForSectionNames, (head + "/" + filename,));
	}
}



try {

	messagePrefix = "1/4";
	/* Load all the definitions files */
	local LIBC_PATH = "src/libc/magic";
	for (local filename: fs.query(LIBC_PATH + "/*.c")) {
		local fullPath = fs.abspath(LIBC_PATH + "/" + filename);
		/* XXX: There are only a couple of ways by which different definition
		 *      files actually interact with each other:
		 *  - %[define_replacement(...)]
		 *  - %[define_wchar_replacement(...)]
		 *  - %[define_XXX_replacement(...)]
		 *  - %[insert:extern(...)]
		 *  - foo(*) = bar;
		 * We could create some sort of database that contains information about
		 * which source files define some feature/function, which might allow us
		 * to not have to re-compile everything anytime something changes!
		 */
		startTask(compileSystemHeaderSourceFile, (
			fullPath, fs.fileof(filename)));
	}

//	waitTasks();
//	local    f    =   allLibraryFunctionsByName["libc_memeq_nopf"];
//	local fp = CWriter(File.stdout, ppAssume: ppAssumeHeaderFiles);
//	for (local b: f.bindings)
//		print repr b;
//	print repr f.implementationPpCond;
//	fp << "\n\n";
//	fp.flush();
//	return;

	/* Scan libc source files for additional section names. */
	startTask(scanFileForSectionNames, ("src/libc/api.h",));
	startScanSectionJobs("src/libc/hybrid/arch/arm/*.h");
	startScanSectionJobs("src/libc/hybrid/arch/arm/*.c");
	startScanSectionJobs("src/libc/hybrid/arch/arm/*.S");
	startScanSectionJobs("src/libc/hybrid/arch/i386/*.h");
	startScanSectionJobs("src/libc/hybrid/arch/i386/*.c");
	startScanSectionJobs("src/libc/hybrid/arch/i386/*.S");
	startScanSectionJobs("src/libc/hybrid/*.c");
	startScanSectionJobs("src/libc/hybrid/*.h");
	startScanSectionJobs("src/libc/libc/arch/arm/*.h");
	startScanSectionJobs("src/libc/libc/arch/arm/*.c");
	startScanSectionJobs("src/libc/libc/arch/arm/*.S");
	startScanSectionJobs("src/libc/libc/arch/i386/*.h");
	startScanSectionJobs("src/libc/libc/arch/i386/*.c");
	startScanSectionJobs("src/libc/libc/arch/i386/*.S");
	startScanSectionJobs("src/libc/libc/*.c");
	startScanSectionJobs("src/libc/libc/*.h");
	startScanSectionJobs("src/libc/user/*.c");
	waitTasks();

	messagePrefix = "2/4";

	/* Define some special files */
	startTask(updateHashedFile, ("include/crt-features/crt-kos-kernel.h", doPrint_include_crtFeatures_crtKosKernel));
	startTask(updateHashedFile, ("src/libc/crt-features.h", doPrint_src_libc_crtFeatures));
	startTask(updateHashedFile, ("src/libc/libc/dosabi-functions.h", doPrint_src_libc_libc_dosabiFunctions));
	startTask(updateHashedFile, ("src/libc/libc/dosabi-exports.h", doPrint_src_libc_libc_dosabiExports));
	startTask(doPrint_src_libc_crtOrder);

	/* Generate the actual system headers (i.e. <string.h>) */
	for (local name /*: string*/, header /*: SystemHeader*/: allSystemHeaders) {
		startTask(updateHashedFile, (
			f"include/{name.replace('.', '/')}.h",
			(fp: File) -> {
				fp << COPYRIGHT << "\n";
				local cWriter = CWriter(fp, ppAssume: ppAssumeHeaderFiles);
				header.cprintHeader(cWriter, ESCAPE_MODE_PART);
				cWriter.flush();
			}));
	}

	/* Generate <libc/...> and <libc/core/...> headers */
	for (local name, header /*: SystemHeader*/: allSystemHeaders) {
		if (!header.order_libcHeader)
			continue;
		startTask(updateHashedFile, (
			f"include/libc/{name}.h",
			(fp: File) -> {
				fp << COPYRIGHT << "\n";
				local cWriter = CWriter(fp, ppAssume: ppAssumeHeaderFiles);
				header.cprintLibcHeader(cWriter);
				cWriter.flush();
			}));
		startTask(updateHashedFile, (
			f"include/libc/core/{name}.h",
			(fp: File) -> {
				fp << COPYRIGHT << "\n";
				local cWriter = CWriter(fp, ppAssume: ppAssumeHeaderFiles);
				header.cprintLibcCoreHeader(cWriter);
				cWriter.flush();
			}));
	}

	/* Need another barrier here because assumptions
	 * gathered  in   `doPrint_src_libc_crtFeatures' */
	waitTasks();
	messagePrefix = "3/4";

	/* TODO: When generating libc auto/user implementations, the keyword "static"
	 *       should be escaped by being suffixed by
	 *       "ATTR_SECTION(\".data\"\(CURRENT_TEXT_SECTION.lsstrip('.text')))"
	 * HINT: This can be done via keyEscape */

	/* Generate /src/libc/auto/<...>.h headers and sources */
	for (local name, header /*: SystemHeader*/: allSystemHeaders) {
		if (header.order_libcAutoHeader) {
			startTask(updateHashedFile, (
				f"src/libc/auto/{name}.h",
				(fp: File) -> {
					fp << COPYRIGHT << "\n";
					local cWriter = CWriter(fp, ppAssume: ppAssumeSourceFiles);
					header.cprintLibraryAutoHeader(cWriter);
					cWriter.flush();
				}));
		}
		if (header.order_libcAutoSource) {
			startTask(updateHashedFile, (
				f"src/libc/auto/{name}.c",
				(fp: File) -> {
					fp << COPYRIGHT << "\n";
					local cWriter = CWriter(fp, ppAssume: ppAssumeSourceFiles);
					header.cprintLibraryAutoSource(cWriter);
					cWriter.flush();
				}));
		}
	}

	/* Generate /src/libc/user/<...>.h headers, and update sources */
	for (local name, header /*: SystemHeader*/: allSystemHeaders) {
		if (header.order_libcUserHeader) {
			startTask(updateHashedFile, (
				f"src/libc/user/{name}.h",
				(fp: File) -> {
					fp << COPYRIGHT << "\n";
					local cWriter = CWriter(fp, ppAssume: ppAssumeSourceFiles);
					header.cprintLibraryUserHeader(cWriter);
					cWriter.flush();
				}));
			startTask(updateUserImplementationSourceFile, (
				f"src/libc/user/{name}.c",
				header, printMessage, criticalSection,
				HASH_FUNCTION, ppAssumeUserSourceFiles));
		}
	}

	waitTasks();
	messagePrefix = "4/4";

	startTask(updateHashedFile, ("include/gnu/stubs.h", doPrint_include_gnu_stubs));

	/* Generate all of the needed <libc/local/...> headers */
	local printedLocalFunctions: HashSet with LocalFunction = HashSet();
	for (;;) {
		for (local lfun /*: LocalFunction*/: neededLocalFunction) {
			if (lfun in printedLocalFunctions)
				continue;
			printedLocalFunctions.insert(lfun);
			startTask(updateHashedFile, (
				f"include/libc/local/{lfun.originalSystemHeaderName}/{lfun.name}.h",
				(fp: File) -> {
					local cWriter = CWriter(fp, ppAssume: ppAssumeHeaderFiles);
					lfun.cprintLocalFunctionHeader(
						cWriter, ESCAPE_MODE_FULL,
						/* XXX: This shouldn't be here!
						 *      The declaration of a function should be a member of cheaders.Function,
						 *      rather than be an exposure override configurable via  ExposedFunction! */
						dependencyDecl: "__LIBC",
						printCopyright: true);
					cWriter.flush();
				}));
		}
		waitTasks();
		/* Keep on printing until everything from @neededLocalFunction is apart of @printedLocalFunctions
		 * Note   that   this  check   if  fairly   simple,  because   we  already   know  that   at  any
		 * point   in   time,    @printedLocalFunctions   is   a    sub-set   of    @neededLocalFunction!
		 * Technically,  this   should   be   a  "=="   compare,   but   ">="  is   used   to   emphasize
		 * that    @printedLocalFunctions    grows   faster    than   @neededLocalFunction,    and   that
		 * @neededLocalFunction eventually stops growing altogether */
		if (#printedLocalFunctions >= #neededLocalFunction)
			break;
	}

	waitTasks(); /* Should be a no-op! */
} @[interrupt] catch (e...) {
	print repr e;
	print Traceback.current;
	criticalSection.exitApplication(1);
}
print "DONE";
criticalSection.exitApplication(0);
