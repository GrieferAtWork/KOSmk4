local copyright =
"/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */";

/* Auto-create STD-C functionality from files in /kos/src/libc/magic/[*]:
 * Example (/kos/src/libc/magic/string.c):
 *   - /kos/include/string.h
 *   - /kos/include/local/string/[*].h  (all of them; 222 files at the time of this being written)
 *   - /kos/include/libc/string.h
 *   - /kos/include/libc/slow/string.h
 *   - /kos/src/libc/auto/string.h
 *   - /kos/src/libc/auto/string.c
 *   - /kos/src/libc/user/string.h
 *
 * Using this, KOS is able provide an extremely versatile libc integration, as well as
 * substitue any missing functionality via local implementations of any function which
 * may be used by any piece of code (this isn't even bound to KOS, as KOS's headers
 * should be usable with any kind of CRT, so-long as that CRT provides a features File)
 */



#undef WARN_KNOWN_BUILTINS
#define WARN_KNOWN_BUILTINS 1
#undef WARN_KNOWN_ALIASES
#define WARN_KNOWN_ALIASES 1


import fs;
import * from deemon;
import hash from hashlib;


global hashfunc = "CRC-32";
global include_line_directives = true;
global single_line_local_wrappers = true;
global print_documention_strings = true;
//#define EXPORTS_USE_USER_HEADERS 1
global final nothrow_attributes = {
	"ATTR_NOTHROW",
	"ATTR_NOTHROW_NCX",
	"ATTR_NOTHROW_RPC",
	"ATTR_NOTHROW_RPC_KOS",
	"ATTR_NOTHROW_RPC_NOKOS",
	"ATTR_NOTHROW_RPC_PURE",
};

fs.chdir(fs.joinpath(fs.headof(__FILE__), "../.."));

function getFilenameForLog(filename: string): string {
	return fs.abspath(filename);
}


#ifdef WARN_KNOWN_BUILTINS
global final known_builtins = Dict();
with (local fp = try File.open("misc/scripts/gcc_builtins_known", "r") catch (...) none) {
	for (local l: fp) {
		l = l.strip().decode("utf-8");
		local b;
		l, none, b = l.partition(":")...;
		known_builtins[l] = b in ["true"];
	}
}
#endif /* WARN_KNOWN_BUILTINS */

#ifdef WARN_KNOWN_ALIASES
global final known_aliases = Dict();
with (local fp = try File.open("include/i386-kos/crt-features/crt-glc.h", "r") catch (...) none) {
	local known_functions = HashSet();
	for (local l: fp) {
		try {
			local n = l.scanf(" # define __CRT_HAVE_%[^ ]")...;
			known_functions.insert(n.strip().decode("utf-8"));
		} catch (...) {
		}
	}
	for (local f: known_functions) {
		if (f.startswith("__")) {
			local alt = f[2:];
			if (alt in known_functions)
				known_aliases[alt] = f;
		}
	}
}
#endif /* WARN_KNOWN_ALIASES */


function key_identity(x) {
	return x;
}
function key_underscore(x) {
#if 1
	if (x in ["argc", "argv", "envp"])
		return "___" + x;
	return "__" + x;
#else
	if (!x) return "__";
	return "_" + x[0].upper() + x[1:];
#endif
}
function key_libc(x) {
	return "__libc_" + x;
}
function key_libc_slow(x) {
	return "__libc_slow_" + x;
}
function key_libclocal(x) {
	return "__LIBC_LOCAL_NAME({})".format({ x.replace("-", "_") });
}
function key_fastimpl(x) {
	return "__LIBC_FAST_NAME({})".format({ x.replace("-", "_") });
}
function key_dependency(x) {
	return "__localdep_" + x;
}
function key_sanitize_for_guard(x) {
	return x.replace("-", "_").replace(".", "_").upper();
}
function key_libc_guard(x) {
	return "_LIBC_{}_H".format({ key_sanitize_for_guard(x) });
}
function key_libc_slow_guard(x) {
	return "_LIBC_SLOW_{}_H".format({ key_sanitize_for_guard(x) });
}
function key_std_guard(x) {
	return "_{}_H".format({ key_sanitize_for_guard(x) });
}
function key_cxx_guard(x) {
	return "_CXX_{}".format({ key_sanitize_for_guard(x) });
}
function key_cxx_stdonly_guard(x) {
	return "_CXX_STDONLY_{}".format({ key_sanitize_for_guard(x) });
}
function key_libc_auto_header_guard(x) {
	return "GUARD_LIBC_AUTO_{}_H".format({ key_sanitize_for_guard(x) });
}
function key_libc_user_header_guard(x) {
	return "GUARD_LIBC_USER_{}_H".format({ key_sanitize_for_guard(x) });
}
function key_libc_user_source_guard(x) {
	return "GUARD_LIBC_USER_{}_C".format({ key_sanitize_for_guard(x) });
}
function key_libc_auto_impl_guard(x) {
	return "GUARD_LIBC_AUTO_{}_C".format({ key_sanitize_for_guard(x) });
}
function key_libc_internal(x) {
	return "libc_" + x;
}
function key_libd_internal(x) {
	return "libd_" + x;
}
function key_libd_export(x) {
	return "DOS$" + x;
}
function key_libd_is_export(x) {
	return x.startswith("DOS$");
}
global all_crt_features = HashSet();
function key_crt_have(x) {
	all_crt_features.insert(x);
	return "defined(__CRT_HAVE_{})".format({ x });
}
function key_attr_header(x) {
	if (x.startswith("@") && x.endswith("@"))
		return x[1:-1];
	return "__" + x;
}
function key_attr_source(x) {
	local map = {
		"ATTR_WUNUSED" : "WUNUSED",
	};
	if (x.startswith("ATTR_NONNULL"))
		return x[#"ATTR_":];
	if (x.startswith("@") && x.endswith("@"))
		return x[1:-1];
	return map.get(x, x);
}


local argument_cast_omit_keyword_list = {
	"__restrict"
};

local macros = Dict();

#define WCHAR_MODE_DOS 0
#define WCHAR_MODE_KOS 1
function wchar_mode_for_key(key: Callable): int {
	return key === key_libd_internal ? WCHAR_MODE_DOS : WCHAR_MODE_KOS;
}
function cc_for_key(key: Callable): int {
	return key === key_libd_internal ? "LIBDCALL" : "LIBCCALL";
}

local wchar_replacements = {
	"wchar_t" : ("char16_t", "char32_t"),
};
local replacement_words = {
	"size_t" : "__SIZE_TYPE__",
	"ssize_t" : "__SSIZE_TYPE__",
	"intptr_t" : "__INTPTR_TYPE__",
	"uintptr_t" : "__UINTPTR_TYPE__",
	"ptrdiff_t" : "__PTRDIFF_TYPE__",
	"byte_t" : "__BYTE_TYPE__",
	"int8_t" : "__INT8_TYPE__",
	"int16_t" : "__INT16_TYPE__",
	"int32_t" : "__INT32_TYPE__",
	"int64_t" : "__INT64_TYPE__",
	"uint8_t" : "__UINT8_TYPE__",
	"uint16_t" : "__UINT16_TYPE__",
	"uint32_t" : "__UINT32_TYPE__",
	"uint64_t" : "__UINT64_TYPE__",
	"wchar_t" : "__WCHAR_TYPE__",
	"char16_t" : "__CHAR16_TYPE__",
	"char32_t" : "__CHAR32_TYPE__",
	"s8" : "__INT8_TYPE__",
	"s16" : "__INT16_TYPE__",
	"s32" : "__INT32_TYPE__",
	"s64" : "__INT64_TYPE__",
	"u8" : "__UINT8_TYPE__",
	"u16" : "__UINT16_TYPE__",
	"u32" : "__UINT32_TYPE__",
	"u64" : "__UINT64_TYPE__",
	"va_list" : "__builtin_va_list",
	"va_start" : "__builtin_va_start",
	"va_copy" : "__builtin_va_copy",
	"va_end" : "__builtin_va_end",
	"va_arg" : "__builtin_va_arg",
	"bool" : "__BOOL",
	"NULL" : "__NULLPTR",
};

local c_keywords = {
	"if",
	"else",
	"while",
	"for",
	"return",
	"do",
	"switch",
	"case",
	"default",
	"goto",
	"continue",
	"break",
	"sizeof",
	"struct",
	"union",
	"extern",
	"__restrict",
	"void",
	"char",
//	"char16_t",
//	"char32_t",
//	"wchar_t",
	"int",
	"short",
	"long",
	"signed",
	"unsigned",
	"defined",
	"ifdef",
	"ifndef",
	"elif",
	"endif",
	"const",
	"volatile",
	"static",
	"define",
	"include",
	"undef",
	"pragma",
	"_Pragma",
	"typedef",
	"float",
	"double",
};

#define REPLACE_TYPE_WORDS_HEADER  0 /* Only replace words starting with `$' */
#define REPLACE_TYPE_WORDS_LOCAL   1 /* Replace all words */
#define REPLACE_TYPE_WORDS_LIBC    2 /* Replace no words */
#define REPLACE_TYPE_WORDS_KEEP    3 /* Keep word prefixes */
function replace_word(
		word: string, mode: int = REPLACE_TYPE_WORDS_LOCAL,
		wchar_t_replacement: int = none): string {
	if (wchar_t_replacement !is none) {
		if (word.startswith("$")) {
			local repl = wchar_replacements.get(word[1:]);
			if (repl !is none)
				word = "$"+repl[wchar_t_replacement];
		} else {
			local repl = wchar_replacements.get(word);
			if (repl !is none)
				word = repl[wchar_t_replacement];
		}
	}
	if (word !in c_keywords && mode != REPLACE_TYPE_WORDS_KEEP) {
		if (word.startswith("$")) {
			word = word[1:];
			if (wchar_t_replacement !is none) {
				local repl = wchar_replacements.get(word);
				if (repl !is none)
					return repl[wchar_t_replacement];
			}
			if (mode != REPLACE_TYPE_WORDS_LIBC)
				word = replacement_words.get(word, word);
		} else if (mode == REPLACE_TYPE_WORDS_LOCAL) {
			word = replacement_words.get(word, word);
		}
	}
	return word;
}

function add_paren_if_necessary(text: string, used_for_logical_and: bool): string {
	local i = 0, end = #text;
	local blacklist = used_for_logical_and
		? "|+-*/"
		: "&+-*/"
		;
	while (i < end) {
		local ch = text[i];
		local map = {
			"(" : ")",
			"[" : "]",
			"{" : "}",
		};
		local ot = map.get(ch);
		if (ot !is none) {
			i = text.indexmatch(ch, ot, i + 1);
			++i;
			continue;
		}
		if (ch in blacklist) {
			return "({})".format({ text });
		}
		++i;
	}
	return text;
}



global Function;

class DirectivesEnvironment {
	this = default;
	public member values: {string: Object} = Dict();
	public property self: Function | none = {
		get(): Function | none {
			return values["env"].get("self");
		}
	}
	operator [](key: Object): Object {
		if (key is string && key.startswith("$"))
			return self.operator . (key[1:]);
		return values[key];
	}
	operator []= (key: Object, value: Object) {
		if (key is string && key.startswith("$")) {
			self.operator . (key[1:]) = value;
		} else {
			values[key] = value;
		}
	}
	operator del[] (key: Object) {
		if (key is string && key.startswith("$")) {
			self.operator . (key[1:]);
		} else {
			del values[key];
		}
	}
}

function split_words(
		text: string, env: {string: string} | Function = none,
		for_copy: bool = false): {(bool, string)...} {
	local length = #text;
	local i = 0;
	@@0: After if == true or elif == true
	@@1: After if == false + else
	local conditions_stack: {int...} = [];
	local saved_env: Cell with DirectivesEnvironment = Cell();
	function execExpression(expr: string): Object {
		local used_env;
		if (saved_env)
			used_env = saved_env.value;
		else {
			used_env = env;
			if (used_env !is DirectivesEnvironment) {
				if (used_env is Function)
					used_env = used_env.defaultEnv;
				used_env = DirectivesEnvironment(values: Dict { "env" : used_env });
			}
			saved_env.value = used_env;
		}
		return exec(expr, globals: used_env);
	}
	for (;;) {
		if (i >= length)
			break;
		local tok_start = i;
		if (text.issymstrt(i)) {
			do ++i;
			while (i < length && text.issymcont(i));
			local word = text[tok_start:i];
			local repl = macros.get(word);
			if (repl !is none) {
				yield split_words(repl, env, for_copy)...;
				continue;
			}
			yield (true, word);
			continue;
		} else if (text.isdecimal(i)) {
			do ++i;
			while (i < length && text.isalnum(i));
			yield (false, text[tok_start:i]);
			continue;
		} else if (text[i] == "@") {
			++tok_start;
			if (text[i + 1] == "@") {
				/* Directive */
				local directive_end = text.find("@@", i + 2);
				if (directive_end >= 0) {
					local directive = text[i + 2:directive_end].strip();
					i = directive_end + 2;
					local kwd_end = 0;
					while (kwd_end < #directive && directive.issymcont(kwd_end))
						++kwd_end;
					local cmd = directive[:kwd_end];
					directive = directive[kwd_end:].lstrip();
					switch (cmd) {
					case "exec":
						execExpression(directive);
						break;
					case "yield": {
						if (env is Function)
							env = env.defaultEnv;
						local val = execExpression(directive);
						if (val !is none)
							yield split_words(str val, env, for_copy)...;
					}	break;
					case "endif":
						if (!conditions_stack)
							throw "@@endif@@ without @@if ...@@ (in {!r})".format({ text });
						conditions_stack.popback();
						break;
					case "elif":
					case "else": {
						if (!conditions_stack)
							throw "@@elif ...@@ or @@else@@ without @@if ...@@ (in {!r})".format({ text });
						if (conditions_stack.last == 1)
							throw "@@elif ...@@ or @@else@@ after @@else@@ (in {!r})".format({ text });
						local start_i = i;
						for (;;) {
							i = text.find("@@", i);
							if (i < 0)
								return;
							i += 2;
							directive_end = text.find("@@", i);
							if (directive_end < 0)
								return;
							directive = text[i:directive_end].strip();
							i = directive_end + 2;
							kwd_end = 0;
							while (kwd_end < #directive && directive.issymcont(kwd_end))
								++kwd_end;
							if (directive[:kwd_end] == "endif")
								break;
						}
						conditions_stack.popback();
						start_i = text.count("\n", start_i, i);
						if (start_i)
							yield (false, "\n" * start_i);
					}	break;
					case "if": {
						if (execExpression(directive)) {
							conditions_stack.append(0);
							break;
						}
						local start_i = i;
						for (;;) {
							i = text.find("@@", i);
							if (i < 0)
								return;
							i += 2;
							directive_end = text.find("@@", i);
							if (directive_end < 0)
								return;
							directive = text[i:directive_end].strip();
							i = directive_end + 2;
							kwd_end = 0;
							while (kwd_end < #directive && directive.issymcont(kwd_end))
								++kwd_end;
							cmd = directive[:kwd_end];
							directive = directive[kwd_end:].lstrip();
							if (cmd == "else") {
								conditions_stack.append(1);
								break;
							}
							if (cmd == "elif") {
								if (execExpression(directive)) {
									conditions_stack.append(0);
									break;
								}
							}
							if (cmd == "endif")
								break;
						}
						start_i = text.count("\n", start_i, i);
						if (start_i)
							yield (false, "\n" * start_i);
					}	break;
					default:
						throw "Unknown directive {!r} (with {!r}) in {!r}".format({ cmd, directive, text });
					}
					continue;
				}
			}
			do ++i;
			while (i < length && text[i] != "@");
			if (for_copy) {
				yield (false, "@{}@".format({ text[tok_start:i] }));
			} else {
				yield (false, text[tok_start:i]);
			}
			if (i < length) ++i;
			continue;
		} else if (text[i] in ["\"", "\'"]) {
			local find_end = text[i];
			for (;;) {
				++i;
				if (i >= length)
					break;
				local ch = text[i];
				if (ch == "\\") {
					++i;
					continue;
				}
				if (ch == find_end)
					break;
			}
			if (i < length)
				++i;
		} else if (text[i:i+2] == "/*") {
			i = text.find("*/", i+2);
			if (i < 0)
				i = #text;
			else
				i += 2;
		} else if (text[i:i+2] == "//") {
			i = text.find("\n", i+2);
			if (i < 0)
				i = #text;
			else
				++i;
		} else {
			++i;
		}
		if (i != tok_start)
			yield (false, text[tok_start:i]);
	}
}

function replace_wchar_words(text: string, wchar_t_replacement: int, env: {string: string} = none): string {
	File.Writer tempfp;
	for (local is_word, word: split_words(text, env)) {
		if (is_word)
			word = replace_word(word, REPLACE_TYPE_WORDS_KEEP, wchar_t_replacement);
		tempfp << word;
	}
	return tempfp.string;
}

function replace_unify_words(text: string, env: {string: string} = none): string {
	File.Writer tempfp;
	for (local is_word, word: split_words(text, env)) {
		if (is_word)
			word = replace_word(word, REPLACE_TYPE_WORDS_LOCAL);
		tempfp << word;
	}
	return tempfp.string;
}


function is_implicitly_castable(src_type: string, dst_type: string): bool {
	if (src_type == dst_type)
		return true;
	/* Unify word replacements. */
	src_type = replace_unify_words(src_type);
	dst_type = replace_unify_words(dst_type);
	if (src_type == dst_type)
		return true;
	/* Only replace these keywords after the second-to-last `*'.
	 * Otherwise we'd think that `int **' is implicitly castable to `int const **', which it isn't */
	local max_replace = dst_type.rfind("*");
	if (max_replace >= 0)
		max_replace = dst_type.rfind("*", 0, max_replace);
	/* Try to get rid of modifiers that can implicitly be added during calls (e.g.: `int *' --> `int const *') */
	for (local x: { " const", "const ", " volatile", "volatile " }) {
		dst_type = max_replace >= 0
			? dst_type[:max_replace] + dst_type[max_replace:].replace(x, "")
			: dst_type.replace(x, "")
			;
		if (src_type == dst_type)
			return true;
	}
	return false;
}



local paren_match = {
	"(" : ")",
	"[" : "]",
	"{" : "}",
};

@@Split a given argument list into the individual arguments
function findfirstch_parenaware(
		text: string, find_chars: string,
		start: int = 0, end: int = -1): int {
	if (end < 0)
		end = #text;
	local i = start;
	while (i < end) {
		local ch = text[i];
		if (ch in find_chars)
			return i;
		if (ch in ["(", "[", "{"]) {
			i = text.indexmatch(ch, paren_match[ch], i + 1) + 1;
			continue;
		}
		if (ch == "/" && text.substr(i + 1, i + 2) == "*") {
			i = text.index("*/", i + 2) + 2;
			continue;
		}
		if (ch in ["\"", "\'"]) {
			++i;
			while (i < end) {
				local ch2 = text[i];
				if (ch2 == ch)
					break;
				if (ch2 == "\\") {
					++i;
					if (i >= end)
						break;
				}
				++i;
			}
			continue;
		}
		++i;
	}
	return -1;
}

@@Split a given argument list into the individual arguments
function split_argument_list_args(l: string): {string...} {
	local i = 0;
	local len = #l;
	local prev_start = 0;
	while (i < len) {
		local ch = l[i];
		if (ch in ["(", "[", "{"]) {
			i = l.indexmatch(ch, paren_match[ch], i + 1) + 1;
			continue;
		}
		if (ch == "/" && l.substr(i + 1, i + 2) == "*") {
			i = l.index("*/", i + 2) + 2;
			continue;
		}
		if (ch in ["\"", "\'"]) {
			++i;
			while (i < len) {
				local ch2 = l[i];
				if (ch2 == ch)
					break;
				if (ch2 == "\\") {
					++i;
					if (i >= len)
						break;
				}
				++i;
			}
			continue;
		}
		if (ch == ",") {
			if (prev_start < i) {
				local part = l.substr(prev_start, i).strip();
				if (part)
					yield part;
			}
			prev_start = i + 1;
		}
		++i;
	}
	if (prev_start < i) {
		local part = l.substr(prev_start, i).strip();
		if (part)
			yield part;
	}
}

@@Join 2 strings `int' and `x' into `int x'
function join_variable_name(typ: string, name: string): string {
	if (!name)
		return typ;
	local name_suffix = "";
	for (;;) {
		typ = typ.strip();
		if (typ.endswith("]")) {
			local st = typ.rindexmatch("[", "]", 0, #typ-1);
			name_suffix += typ[st:];
			typ = typ[:st];
			continue;
		}
		break;
	}
	if (!typ.endswith("*"))
		typ += " ";
	return typ + name.strip() + name_suffix;
}

@@Split a string `int x' into `int' and `x'
function split_variable_name(s: string): (string, string) {
	local name_end = #s;
	local typ_suffix = "";
	for (;;) {
		if (name_end && s[name_end - 1] == "]") {
			local st = s.rfindmatch("[", "]", 0, name_end - 1);
			if (st >= 0) {
				typ_suffix += s[st:name_end];
				name_end = st;
				continue;
			}
		}
		break;
	}
	local name_start = name_end;
	while (name_start) {
		--name_start;
		if (!s.issymcont(name_start)) {
			++name_start;
			break;
		}
	}
	return (
		s.substr(0, name_start).strip() + typ_suffix,
		s.substr(name_start, name_end).strip());
}


global split_argument_list;

@@Parse special annotations applied to a function return type
@@@param: args: A list of (typ, name) for each argument taken
function parse_return_type_annotations(return_type: string,
		args: {(string, string)...},
		function_attr: List with string = none,
		arglist_attributes: List with string = none,
		file: string = none, line: int = none): string {
	function err(message: string) {
		print getFilenameForLog(file),;
		print "(",;
		print line,;
		print ") : Error :", message;
		throw Error(message);
	}
	return_type = return_type.strip();
	while (return_type.startswith("[")) {
		local e = return_type.findmatch("[", "]", 1);
		if (e < 0)
			break;
		local attr_text = return_type[1:e].strip();
		return_type = return_type[e + 1:].lstrip();
		for (local attr: split_argument_list_args(attr_text)) {
			if (attr in ["nonnull", "notnull"] || attr.replace(" ", "") in ["1..1"]) {
				if ("ATTR_RETNONNULL" !in function_attr)
					function_attr.append("ATTR_RETNONNULL");
			} else if (attr in ["nullable"] || attr.replace(" ", "") in ["0..1"]) {
				;
			} else if (attr in ["wunused"]) {
				if ("ATTR_WUNUSED" !in function_attr)
					function_attr.append("ATTR_WUNUSED");
			} else if (attr in ["restrict"]) {
				if ("ATTR_MALLOC" !in function_attr)
					function_attr.append("ATTR_MALLOC");
			} else if (attr.startswith("malloc") || attr.startswith("realloc") ||
			           attr.startswith("realign") || attr.startswith("memalign")) {
				local is_memalign = attr.startswith("memalign");
				local is_realloc = attr.startswith("realloc");
				local is_realign = attr.startswith("realign");
				local argslist = attr[(is_memalign ? 8 : (is_realloc || is_realign) ? 7 : 6):].lstrip();
				local is_unaligned = argslist.startswith("_unaligned");
				if (is_unaligned)
					argslist = argslist[10:];
				if ("ATTR_WUNUSED" !in function_attr)
					function_attr.append("ATTR_WUNUSED");
				if (!is_realloc && !is_realign) {
					if ("ATTR_MALLOC" !in function_attr)
						function_attr.append("ATTR_MALLOC");
				} else {
					if ("ATTR_MALLOC" in function_attr)
						err("realloc()-like functions mustn't be declared with `ATTR_MALLOC'");
				}
				if (argslist.startswith("(") && argslist.endswith(")")) {
					argslist = argslist[1:-1];
					if (is_realloc || is_realign) {
						/* First argument is the pointer that gets reallocated */
						argslist = argslist.partition(",")[2];
						argslist = argslist.strip();
					}
					if (is_memalign || is_realign) {
						local alignment;
						alignment, none, argslist = argslist.partition(",")...;
						alignment = alignment.strip();
						argslist = argslist.strip();
						/* Check the argument list for an argument with the same name as `alignment'.
						* If it's not one of them, assume a fixed alignment annotation. */
						local alignment_argi = none;
						import enumerate from util;
						for (local i, data: enumerate(args)) {
							if (alignment == data[1]) {
								alignment_argi = i;
								break;
							}
						}
						if (alignment_argi !is none) {
							function_attr.append("ATTR_ALLOC_ALIGN({})".format({ alignment_argi + 1 }));
						} else if (alignment in ["PAGESIZE", "__SIZEOF_PAGE__"] ||
						           alignment.replace(" ", "") in ["getpagesize()"]) {
							function_attr.append("ATTR_MALL_PAGEALIGNED");
						} else {
							function_attr.append("ATTR_ASSUME_ALIGNED({})".format({ alignment }));
						}
					} else if (!is_unaligned) {
						/* Non-aligning functions get the default mall-alignment attribute */
						function_attr.append("ATTR_MALL_DEFAULT_ALIGNED");
					}
					/* Parse the second argument, which is the name of the argument
					* that describes the size of the data blob returned by the function.
					* Optionally, more than once argument may be specified like this:
					* >> calloc(size_t count, size_t num_bytes) -> [malloc(count * num_bytes)] void *; */
					local count_arg_indices = [];
					for (local n: argslist.split("*")) {
						n = n.strip();
						if (n in ["?"])
							continue;
						for (local i = 0;; ++i) {
							if (i >= #args)
								goto unknown_malloc_argument_size;
							local an = args[i][1];
							if (an == n) {
								count_arg_indices.append(i);
								break;
							}
						}
					}
					if (count_arg_indices) {
						function_attr.append("ATTR_ALLOC_SIZE(({}))"
							.format({ ", ".join(count_arg_indices.each + 1) }));
					}
unknown_malloc_argument_size:
					;
				} else if (argslist) {
					err("Unrecognized text after `[malloc' or `[memalign': " + repr(argslist));
				}
			} else if (attr.startswith("==")) {
				attr = attr[2:].lstrip();
				if ("+" in attr) /* Also allow some kind of offset from another argument. */
					attr = attr[:attr.index("+")].rstrip();
				if (attr.issymbol()) {
					/* Check if the named argument has the [nonnull] tag */
					import enumerate from util;
					for (local i, data: enumerate(args)) {
						if (data[1] == attr) {
							local str_i = str(i + 1);
							for (local x: arglist_attributes) {
								if (x.startswith("ATTR_NONNULL((") &&
								    x.endswith("))")) {
									for (local j: x[14:-2].split(",")) {
										j = j.strip();
										if (j == str_i) {
											if ("ATTR_RETNONNULL" !in function_attr)
												function_attr.append("ATTR_RETNONNULL");
											break;
										}
									}
								}
							}
							goto found_equals_argument;
						}
					}
				}
found_equals_argument:
				;
			} else {
				err("Unknown return-type attribute " + repr(attr));
			}
		}
	}
	return return_type;
}

@@Split a given argument list into the individual type+name
function split_argument_list(l: string,
		function_attr: List with string = none,
		file: string = none, line: int = none)
		: {(string, string)...} {
	l = l.strip();
	if (l == "void")
		return;
	local non_null_arguments = [];
	local i = 1;
	for (local arg: split_argument_list_args(l)) {
		local typ, nam = split_variable_name(arg.strip())...;
		while (typ.startswith("[")) {
			local e = typ.findmatch("[", "]", 1);
			if (e < 0)
				break;
			local attr_text = typ[1:e].strip();
			typ = typ[e + 1:].lstrip();
			for (local attr: split_argument_list_args(attr_text)) {
				if (attr in ["nonnull", "notnull"] || attr.replace(" ", "") in ["1..1"]) {
add_nonnull:
					non_null_arguments.append(i);
				} else if (attr in ["nullable"] || attr.replace(" ", "") in ["0..1"]) {
					;
				} else if (attr.startswith("inp(") && attr.endswith(")")) {
					goto add_nonnull;
				} else if (attr.startswith("outp(") && attr.endswith(")")) {
					goto add_nonnull;
				} else if (attr.startswith("inoutp(") && attr.endswith(")")) {
					goto add_nonnull;
				} else if (attr.startswith("inp_opt(") && attr.endswith(")")) {
					;
				} else if (attr.startswith("outp_opt(") && attr.endswith(")")) {
					;
				} else if (attr.startswith("inoutp_opt(") && attr.endswith(")")) {
					;
				} else {
					print getFilenameForLog(file),;
					print "(",;
					print line,;
					print ") : Error : Unknown argument attribute ",;
					print repr(attr);
					throw Error("Unknown argument attribute " + repr(attr));
				}
			}
		}
		yield (typ, nam);
		++i;
	}
	if (non_null_arguments)
		function_attr.append("ATTR_NONNULL(({}))".format({ ", ".join(non_null_arguments) }));
}

@@Sort function attributes
function sortFunctionAttributes(attr: List with string) {
	import predlo2key from functools;
	local a = List(attr.filter([](x) -> "(" !in x));
	local b = List(attr.filter([](x) -> "(" in x));
	a.sort();
	b.sort();
	attr.clear();
	attr.extend(a);
	attr.extend(b);
}


@@Scan the given docstring for `...' patterns and replace these sections with `replace(...)'
@@The given @replace is called as @replace(fp: file, text: string) and should write the new
@@text to the given fp
function replaceDocKeywords(docstring: string, replace: Callable): string {
	if (!docstring)
		return docstring;
	File.Writer fp;
	local i = 0;
	for (;;) {
		local pos = docstring.find("`", i);
		local pos2 = docstring.find(">>", i);
		if (pos < 0 && pos2 < 0)
			break;
		if (pos2 >= 0 && (pos2 < pos || pos < 0)) {
			pos2 += 2;
			local end = docstring.find("\n", pos2);
			if (end < 0)
				end = #docstring;
			fp << docstring[i:pos2];
			replace(fp, docstring[pos2:end]);
			i = end;
			continue;
		}
		++pos;
		local end = docstring.find("'", pos);
		if (end < 0)
			break;
		fp << docstring[i:pos];
		replace(fp, docstring[pos:end]);
		i = end;
	}
	if (i == 0)
		return docstring; /* Nothing to do here! */
	fp << docstring[i:];
	return fp.string;
}
@@Similar to @replaceDocKeywords, but @replace is invoked only for individual
@@keywords with `...' sections, rather than once for every such section
function replaceDocKeywordWords(docstring: string, replace: Callable, env: {string: string} = none): string {
	return replaceDocKeywords(docstring, [](fp: File, text: string) {
		for (local is_word, word: split_words(text, env)) {
			if (!is_word) {
				fp << word;
			} else {
				replace(fp, word);
			}
		}
	});
}



global components: {string: {Function...}};
global functions: {string: Function};
global function_body_conversions: {string: {string: Callable}} = Dict();
@@Map for c-header to c++-header ("string.h" : ("cstring", "_CXX_CCTYPE", "_CXX_STDONLY_CCTYPE"))
global ccompat_cpp_headers: {string: (string, string, string)} = Dict();
global functions_prototypes;
global known_libc_sections;
global unimplemented_functions;

class PrintStdNamespace { }
class FunctionAlias { member func; this = default; }
class UndefinedFunctionAlias { member name; this = default; }
class CopyFunctionBody {
	member name: string;
	@@Called as @(convert(oldfunc: Function, newfunc: Function, text: string): string)
	member convert: Callable;
	this = default;
}
class ExternFunction { member func; this = default; }
class IntermediateString {
	member string;
	member locations;
	this(s, l) {
		string = s;
		locations = l;
	}
}


class WeakReplacement { member repl: string; this = default; }

global str2wcs_keyword_replacements: {string: string | WeakReplacement} = Dict {
	"__SIZEOF_CHAR__" : "__SIZEOF_WCHAR_T__",
	"/*utf-8*/" : "",
};

function identitiyConverter(oldFunction: Function, newFunction: Function, text: string): string -> text;

function str2wcsReplaceTechnicalText(oldFunction: Function, newFunction: Function, fp: File, text: string) {
	local prev_word = none;
	for (local is_word, word: split_words(text, env: {
		"self" : newFunction,
		"oldFunction" : oldFunction,
		"newFunction" : newFunction,
	}, for_copy: true)) {
		if (!is_word) {
			if (prev_word) {
				if (word.isspace()) {
					prev_word = prev_word + word;
					continue;
				}
				fp << prev_word;
				prev_word = none;
			}
			fp << word;
			continue;
		}
		if (word in ["signed", "unsigned"]) {
			prev_word = word;
			continue;
		}
		if (word in ["char"]) {
			if (prev_word) {
				if (prev_word.startswith("signed "))
					prev_word = prev_word[#"signed ":].lstrip();
				else if (prev_word.startswith("unsigned "))
					prev_word = prev_word[#"unsigned":].lstrip();
				fp << prev_word;
				prev_word = none;
			}
			fp << "wchar_t";
		} else if (word == oldFunction.name) {
			fp << newFunction.name;
		} else {
			if (prev_word) {
				fp << prev_word;
				prev_word = none;
			}
			local repl = str2wcs_keyword_replacements.get(word);
			if (repl !is none) {
				if (repl is WeakReplacement)
					repl = repl.repl;
				fp << repl;
				continue;
			}
			if (word.endswith("_l")) {
				repl = str2wcs_keyword_replacements.get(word[:-2]);
				if (repl !is none) {
					if (repl is WeakReplacement)
						repl = repl.repl;
					fp << repl << "_l";
					continue;
				}
			}
			final local notFunctionNameKeywords: {string...} = {
				"string",
				"stringp",
				"stretch",
				"str",
				"struct",
			};
			if (word.startswith("str") && word !in notFunctionNameKeywords)
				word = "wcs" + word[3:];
			fp << word;
		}
	}
	if (prev_word)
		fp << prev_word;
}

/* A converter for transforming char-based functions to wchar_t-based ones. */
function_body_conversions["str2wcs"] = {
	"auto" : [](name: string): string | none {
		if (name.startswith("wcs"))
			return "str" + name[3:];
		return none;
	},
	"convert_body" : [](oldFunction: Function, newFunction: Function, text: string): string {
		File.Writer fp;
		str2wcsReplaceTechnicalText(oldFunction, newFunction, fp, text);
		return fp.string;
	},
	"convert_doc" : [](oldFunction: Function, newFunction: Function, docstring: string): string {
		return replaceDocKeywords(docstring, [](fp: File, text: string) {
			return str2wcsReplaceTechnicalText(oldFunction, newFunction, fp, text);
		});
	},
};
function_body_conversions["direct"] = {
	"auto" : [](name: string): string | none { return none; },
	"convert_body" : [](oldFunction: Function, newFunction: Function, text: string): string { return text; },
	"convert_doc" : [](oldFunction: Function, newFunction: Function, docstring: string): string { return docstring; },
};

local double2float_conversions: {string: string} = Dict {
	"double" : "float"
};
function_body_conversions["double2float"] = {
	"auto" : [](name: string): string | none {
		if (name.endswith("f"))
			return name[:-1];
		return none;
	},
	"convert_body" : [](oldFunction: Function, newFunction: Function, text: string): string {
		File.Writer fp;
		for (local is_word, word: split_words(text, env: {
			"self" : newFunction,
			"oldFunction" : oldFunction,
			"newFunction" : newFunction,
		}, for_copy: true)) {
			if (is_word) {
				word = double2float_conversions.get(word, word);
				if (word is WeakReplacement)
					word = word.repl;
			}
			fp << word;
		}
		return fp.string;
	},
	"convert_doc" : [](oldFunction: Function, newFunction: Function, docstring: string): string { return docstring; },
};

local double2ldouble_conversions: {string: string} = Dict {
	"double" : "long double"
};
function_body_conversions["double2ldouble"] = {
	"auto" : [](name: string): string | none {
		if (name.endswith("l"))
			return name[:-1];
		return none;
	},
	"convert_body" : [](oldFunction: Function, newFunction: Function, text: string): string {
		File.Writer fp;
		for (local is_word, word: split_words(text, env: {
			"self" : newFunction,
			"oldFunction" : oldFunction,
			"newFunction" : newFunction,
		}, for_copy: true)) {
			if (is_word) {
				word = double2ldouble_conversions.get(word, word);
				if (word is WeakReplacement)
					word = word.repl;
			}
			fp << word;
		}
		return fp.string;
	},
	"convert_doc" : [](oldFunction: Function, newFunction: Function, docstring: string): string { return docstring; },
};


//function byte2XReplaceTechnicalText(oldFunction: Function, newFunction: Function, fp: File, text: string, bits: int) {
//	for (local is_word, word: split_words(text, env: {
//		"self" : newFunction,
//		"oldFunction" : oldFunction,
//		"newFunction" : newFunction,
//	})) {
//		if (!is_word) {
//			fp << word;
//			continue;
//		}
//		switch (word) {
//		case "byte_t":
//			fp << "u" << bits;
//			break;
//		case "u8":
//		case "uint8_t":
//		case "__UINT8_TYPE__":
//			fp << "u" << bits;
//			break;
//		case "s8":
//		case "sint8_t":
//		case "__INT8_TYPE__":
//			fp << "s" << bits;
//			break;
//		default:
//			fp << word;
//			break;
//		}
//	}
//}
//
//function defineByte2XFunctions(name: string, tail: string, bits: int) {
//	function_body_conversions[name] = {
//		"auto" : [](name: string): string | none {
//			if (name.endswith(tail))
//				return name[:-#tail];
//			return none;
//		},
//		"convert_body" : [](oldFunction: Function, newFunction: Function, text: string): string {
//			File.Writer fp;
//			byte2XReplaceTechnicalText(oldFunction, newFunction, fp, text, bits);
//			return fp.string;
//		},
//		"convert_doc" : [](oldFunction: Function, newFunction: Function, docstring: string): string {
//			return replaceDocKeywords(docstring, [](fp: File, text: string) {
//				return byte2XReplaceTechnicalText(oldFunction, newFunction, fp, text, bits);
//			});
//		},
//	};
//}
//defineByte2XFunctions("byte2word", "w", 16);
//defineByte2XFunctions("byte2dword", "l", 32);
//defineByte2XFunctions("byte2qword", "q", 64);


class CrtBuiltin {
	this = default;
	public member name: string;
}


@@Yields an intermixed set of strings and functions to-be used to define
function parse_functions(filename: string, text: string): {string | Function...} {
	text = text.unifylines();
	local i = 0;
	local len = #text;
	local aliases = [];
	local intern_aliases = [];
	local alternate_names = [];
	local preferred_aliases = [];
	@@Array of (condition_expr, impl) for preferred function implementations
	local preferred_impl: {(string, string)...} = [];
	local function_attributes = [];
	local define_require_string = "";
	local std_guard = false;
	local dependency_string = none;
	local export_as_libc = false;
	local export_in_std = false;
	local export_in_kernel = false;
#ifdef EXPORTS_USE_USER_HEADERS
	local dont_export_symbol = false;
#else
	local dont_export_symbol = none;
#endif
	local guarded_function = false;
	local has_fast_implementation = false;
	local impl_prefix = "";
	local requires_prefix = "";
	local declaration_prefix = "";
	local dependency_prefix = "";
	local same_impl = false;
	local libc_impl = none;
	local user_impl = none;
	local allow_macros = false;
	local helper_function = false;
	local forced_dependencies = [];
	local alias_args = Dict();
	local function_may_throw = false;
	local function_throws_anno = [];
	local argument_names = none;
	local default_nosys_errno = "ENOSYS";
	local nosys_errno = default_nosys_errno;
	local nocrt = false;
	local nouser = false;
	local douser = false;
	local overload_alias = false;
	local uchar_function = none;
	local wchar_function = false;
	local uchar16_function_name = none;
	local uchar32_function_name = none;
	local vartypes = none;
	local impl_section = none;
	local default_impl_section = none;
	local define_as_builtin = none;
	local component_name = none;
	local dosnames = none;
	local doc = "";
	local pushed_macros: {{string...}...} = [];
	function err(i, message) {
		print getFilenameForLog(filename),;
		print "(",;
		print text.count("\n", 0, i) + 1,;
		print ") : Error : ",;
		print message;
		throw "Parsing Error";
	}
	while (i < len) {
		if (text.isspace(i)) {
			++i;
			continue;
		}
		if (text.substr(i, i+2) == "/*") {
			i = text.index("*/", i) + 2;
			continue;
		}
		if (text.substr(i, i+2) == "//") {
			i = text.find("\n", i);
			if (i < 0) break;
			++i;
			continue;
		}
		if (text.substr(i, i+2) == "@@") {
			local line_end = text.find("\n", i);
			if (line_end < 0)
				line_end = len;
			if (doc)
				doc += "\n";
			doc += text.substr(i+2, line_end);
			i = line_end;
			continue;
		}
		if (text[i] == "%") {
			++i;
			local preamble_begin;
			local ch = text[i];
			if (ch == "{") {
				/* STD-header re-export. */
				++i;
				preamble_begin = i;
				i = text.findmatch("{", "}", preamble_begin);
				if (i < 0)
					err(preamble_begin, "No matching `}' after `%{'");
				if (text.islf(preamble_begin))
					++preamble_begin;
				yield IntermediateString(text.substr(preamble_begin, i), pack "c");
				++i;
			} else if (ch == "(") {
				local group_start = i + 1;
				i = text.findmatch("(", ")", group_start);
				if (i < 0)
					err(group_start, "No matching `)' after `%('");
				local group_list = text.substr(group_start, i);
				++i;
				group_list = Tuple(for (local x: group_list.split(",")) x.strip());
				local ch = text[i];
				if (ch == "{") {
					++i;
					preamble_begin = i;
					i = text.findmatch("{", "}", preamble_begin);
					if (i < 0)
						err(preamble_begin, "No matching `}' for `{'");
					if (text.islf(preamble_begin))
						++preamble_begin;
					yield IntermediateString(text.substr(preamble_begin, i), group_list);
					++i;
				} else {
					preamble_begin = i;
					i = text.find("\n", i);
					if (i < 0) {
						i = len;
						yield IntermediateString(text.substr(preamble_begin, i) + "\n", group_list);
					} else {
						++i;
						yield IntermediateString(text.substr(preamble_begin, i), group_list);
					}
				}
			} else if (ch == "[") {
				++i;
				local directive_begin = i;
				i = text.findmatch("[", "]", i);
				if (i < 0)
					err(directive_begin, "No matching `]' for `%['");
				local directive = text.substr(directive_begin, i).strip();
				++i;
				if (directive == "insert:std") {
					yield PrintStdNamespace;
				} else if (directive.startswith("insert:extern")) {
					local extern_name = directive[#"insert:extern":];
					if (!extern_name.startswith("(") ||
					    !extern_name.endswith(")")) {
						err(directive_begin,
							"Expected operand of `insert:extern' to be surrounded by "
							"parenthesis, but is actually " + repr extern_name);
					}
					extern_name = extern_name.substr(1, #extern_name-1).strip();
					yield FunctionAlias(extern_name);
				} else if (directive.startswith("declare_known_section")) {
					directive = directive[#"declare_known_section":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[declare_known_section' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[declare_known_section" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[declare_known_section(...)': " + repr directive[defend:].strip());
					local sectname = directive[1:defend].strip();
					final local valid_prefixes = {
						".text.crt",
						".xdata.crt",
						".data.crt",
						".rodata.crt",
						".bss.crt"
					};
					for (local x: valid_prefixes) {
						if (sectname.startswith(x)) {
							sectname = sectname[#x:];
							goto got_section_prefix;
						}
					}
					err(directive_begin, "Section name {!r} does not have a valid prefix".format({ sectname }));
got_section_prefix:
					known_libc_sections.insert(sectname);
				} else if (directive.startswith("define_ccompat_header")) {
					directive = directive[#"define_ccompat_header":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[define_ccompat_header' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[define_ccompat_header" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[define_ccompat_header(...)': " + repr directive[defend:].strip());
					local cpp_header_name = directive[1:defend].strip();
					local cpp_header_name, none, guard = cpp_header_name.partition(",")...;
					local guard, none, std_only_guard = guard.partition(",")...;
					cpp_header_name = cpp_header_name.strip();
					guard = guard.strip();
					if (!guard)
						guard = key_cxx_guard(cpp_header_name);
					if (!std_only_guard)
						std_only_guard = key_cxx_stdonly_guard(cpp_header_name);
					local header_name = fs.fileof(filename).replace(".", "/") + ".h";
					ccompat_cpp_headers[header_name] = (cpp_header_name, guard, std_only_guard);
				} else if (directive.startswith("default_impl_section")) {
					directive = directive[#"default_impl_section":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[default_impl_section' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[default_impl_section" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[default_impl_section(...)': " + repr directive[defend:].strip());
					local new_impl_section = directive[1:defend].strip();
					if (!new_impl_section.startswith(".text.crt") && !new_impl_section.startswith("{.text.crt"))
						err(directive_begin, "Section name {!r} does not start with `.text.crt'".format({ new_impl_section }));
					if (impl_section === default_impl_section || impl_section is none)
						impl_section = new_impl_section;
					default_impl_section = new_impl_section;
				} else if (directive.startswith("nosys_errno")) {
					directive = directive[#"nosys_errno":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[nosys_errno' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[nosys_errno" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[nosys_errno(...)': " + repr directive[defend:].strip());
					directive = directive[1:defend].strip();
					if (nosys_errno === default_nosys_errno)
						nosys_errno = directive;
					default_nosys_errno = directive;
				} else if (directive.startswith("crt_feature")) {
					directive = directive[#"crt_feature":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[crt_feature' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[crt_feature" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[crt_feature(...)': " + repr directive[defend:].strip());
					directive = directive[1:defend].strip();
					for (local x: directive.split(","))
						all_crt_features.insert(x.strip());
				} else if (directive.startswith("define_wchar_replacement")) {
					directive = directive[#"define_wchar_replacement":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[define_wchar_replacement' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[define_wchar_replacement" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[define_wchar_replacement(...)': " + repr directive[defend:].strip());
					directive = directive[1:defend].strip();
					if ("=" !in directive)
						err(directive_begin, "Missing `=' in `%[define_wchar_replacement(" + repr directive + ")'");
					local a, none, b = directive.partition("=")...;
					if ("," !in b)
						err(directive_begin, "Missing `,' in `%[define_wchar_replacement(" + repr directive + ")'");
					a = a.strip();
					local mode0, none, mode1 = b.partition(",")...;
					b = (mode0.strip(), mode1.strip());
					if (a in wchar_replacements) {
						if (wchar_replacements[a] != b)
							err(directive_begin, "Conflicting wchar-replacement definition for `" + repr a + "' (new: " + repr b + ", old: " + repr wchar_replacements[a] + ")'");
					} else {
						wchar_replacements[a] = b;
					}
				} else if (directive.startswith("define_replacement")) {
					directive = directive[#"define_replacement":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[define_replacement' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[define_replacement" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[define_replacement(...)': " + repr directive[defend:].strip());
					directive = directive[1:defend].strip();
					if ("=" !in directive)
						err(directive_begin, "Missing `=' in `%[define_replacement(" + repr directive + ")'");
					local a, none, b = directive.partition("=")...;
					a = a.strip();
					b = b.strip();
					if (a in replacement_words) {
						if (replacement_words[a] != b)
							err(directive_begin, "Conflicting replacement definition for `" + repr a + "' (new: " + repr b + ", old: " + repr replacement_words[a] + ")'");
					} else {
						replacement_words[a] = b;
					}
				} else if (directive.startswith("define_str2wcs_replacement")) {
					directive = directive[#"define_str2wcs_replacement":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[define_str2wcs_replacement' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[define_str2wcs_replacement" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[define_str2wcs_replacement(...)': " + repr directive[defend:].strip());
					directive = directive[1:defend].strip();
					if ("=" !in directive)
						err(directive_begin, "Missing `=' in `%[define_str2wcs_replacement(" + repr directive + ")'");
					local a, none, b = directive.partition("=")...;
					a = a.strip();
					b = b.strip();
					if (a in str2wcs_keyword_replacements) {
						local o = str2wcs_keyword_replacements[a];
						if (o !is WeakReplacement && o != b)
							err(directive_begin, "Conflicting str2wcs replacement definition for `" + repr a + "' (new: " + repr b + ", old: " + repr replacement_words[a] + ")'");
					}
					str2wcs_keyword_replacements[a] = b;
				} else if (directive.startswith("push_macro")) {
					/* 'push_macro' ['(' groups ')'] [@option...] '(' macros... ')' */
					/* 'push_macro' ['(' groups ')'] [@option...] '{' macros... '}' */
					directive = directive[#"push_macro":].lstrip();
					local group_list = ("c", );
					if (directive.startswith("(")) {
						local group_end = directive.findmatch("(", ")", 1);
						if (group_end < 0)
							err(directive_begin, "No matching `)' after `%[push_macro('");
						group_list = directive.substr(1, group_end);
						group_list = Tuple(for (local x: group_list.split(",")) x.strip());
						directive = directive.substr(group_end + 1).lstrip();
					}
					local options = HashSet();
					while (directive.startswith("@")) {
						local optend = 1;
						while (optend < #directive && directive.issymcont(optend))
							++optend;
						local option = directive[1:optend];
						if (option !in ["undef"])
							err(directive_begin, "Unsupported option {!r}".format({ option }));
						options.insert(option);
						directive = directive[optend:].lstrip();
					}
					if ((directive.startswith("{") && directive.endswith("}")) ||
					    (directive.startswith("(") && directive.endswith(")")))
						directive = directive[1:-1];
					else {
						err(directive_begin, "Missing argument block in {!r}".format({ directive }));
					}
					local i = 0;
					local macro_names = [];
					while (i < #directive) {
						if (directive.isspace(i)) {
							++i;
							continue;
						}
						if (!directive.issymstrt(i))
							err(directive_begin, "Expected identifier, but got {!r}".format({ directive[i] }));
						local name_end = i + 1;
						while (name_end < #directive && directive.issymcont(name_end))
							++name_end;
						macro_names.append(directive[i:name_end]);
						i = name_end;
					}
					pushed_macros.append(macro_names);
					if (macro_names) {
						File.Writer tempfp;
						tempfp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
						for (local macro_name: macro_names)
							tempfp << "#pragma push_macro(" << repr(macro_name) << ")\n";
						tempfp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
						if ("undef" in options) {
							for (local macro_name: macro_names)
								tempfp << "#undef " << macro_name << "\n";
						}
						yield IntermediateString(tempfp.string, group_list);
					}
				} else if (directive.startswith("pop_macro")) {
					/* 'pop_macro' ['(' groups ')'] */
					directive = directive[#"pop_macro":].lstrip();
					if (!pushed_macros)
						err(directive_begin, "%[pop_macro] without %[push_macro { ... }]");
					local group_list = ("c", );
					if (directive.startswith("(")) {
						local group_end = directive.findmatch("(", ")", 1);
						if (group_end < 0)
							err(directive_begin, "No matching `)' after `%[push_macro('");
						group_list = directive.substr(1, group_end);
						group_list = Tuple(for (local x: group_list.split(",")) x.strip());
						directive = directive.substr(group_end + 1).lstrip();
					}
					if (directive)
						err(directive_begin, "Unsupported argument for pop_macro {!r}".format({ directive }));
					local macs = pushed_macros.pop(#pushed_macros - 1).reversed();
					if (macs) {
						File.Writer tempfp;
						tempfp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
						for (local m: macs)
							tempfp << "#pragma pop_macro(" << repr(m) << ")\n";
						tempfp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
						yield IntermediateString(tempfp.string, group_list);
					}
				} else if (directive.startswith("enum")) {
					local options = HashSet();
					local typedef_name = none;
					directive = directive[#"enum":].strip();
					local group_list = ("c", );
					if (directive.startswith("(")) {
						local group_end = directive.findmatch("(", ")", 1);
						if (group_end < 0)
							err(directive_begin, "No matching `)' after `%[enum('");
						group_list = directive.substr(1, group_end);
						group_list = Tuple(for (local x: group_list.split(",")) x.strip());
						directive = directive.substr(group_end + 1).lstrip();
					}
again_enum_name:
					local enum_name = none;
					if (directive && (directive.issymstrt(0) || directive.startswith("@"))) {
						local name_end = 1;
						while (name_end < #directive && directive.issymcont(name_end))
							++name_end;
						enum_name = directive[:name_end];
						directive = directive[name_end:].lstrip();
						if (enum_name.startswith("@")) {
							enum_name = enum_name[1:];
							if (enum_name == "typedef") {
								if (directive.startswith("(")) {
									/* Typedef name */
									name_end = directive.findmatch("(", ")", 1);
									if (name_end < 0)
										err(directive_begin, "Unmatched `(' after @typedef in {!r}".format({ directive }));
									typedef_name = directive[1:name_end].strip();
									directive = directive[name_end + 1:].lstrip();
									goto again_enum_name;
								}
							}
							if (enum_name !in ["undef", "macro", "guard"])
								err(directive_begin, "Unsupported option {!r}".format({ enum_name }));
							options.insert(enum_name);
							goto again_enum_name;
						}
					}
					if (!directive.startswith("{") || !directive.endswith("}"))
						err(directive_begin, "Missing {{}}-block in enum directive {!r}".format({ directive }));
					directive = directive[1:-1];
					@@List of enums as (name, value, comment)
					local enums: {string | (string, string, string)...} = [];
					local i = 0;
					while (i < #directive) {
						if (directive.isspace(i)) {
							++i;
							continue;
						}
						if (directive[i] == "%") {
							/* Immediate string */
							local block;
							if (i + 1 < #directive && directive[i + 1] == "{") {
								i += 2;
								local block_end = directive.findmatch("{", "}", i);
								if (block_end < 0)
									err(directive_begin, "Unmatched %{ in `%[enum { ...'");
								block = directive[i:block_end];
								if (block.startswith("\n"))
									block = block[1:];
								i = block_end + 1;
							} else {
								++i;
								local block_end = directive.find("\n", i);
								if (block_end < 0)
									block_end = #directive;
								else
									++block_end;
								block = directive[i:block_end];
								i = block_end;
							}
							enums.append(block);
							continue;
						}
						if (!directive.issymstrt(i))
							err(directive_begin, "Expected symbol start character in `%[enum {{ ...', but got {!r}"
								.format({ directive.substr(i, i+1) }));
						local name_start = i;
						++i;
						while (i < #directive && directive.issymcont(i))
							++i;
						local name = directive[name_start:i];
						while (i < #directive && directive.isspace(i))
							++i;
						if (i >= #directive || directive[i] != "=")
							err(directive_begin, "Expected '=' in `%[enum {{ ...', but got {!r}"
								.format({ directive.substr(i, i+1) }));
						++i;
						while (i < #directive && directive.isspace(i))
							++i;
						local value_start = i;
						while (i < #directive) {
							local ch = directive[i];
							local map = {
								"(" : ")",
								"[" : "]",
								"{" : "}",
							};
							if (ch in map) {
								i = directive.findmatch(ch, map[ch], i + 1);
								if (i < 0)
									err(directive_begin, "Unmatched {!r} in enum value".format({ ch }));
								++i;
								continue;
							}
							if (ch.isspace())
								break;
							++i;
						}
						local value = directive[value_start:i].rstrip(",");
						while (i < #directive && directive.isspace(i))
							++i;
						local doc = "";
						switch (directive.substr(i, i + 2)) {
						case "/*": {
							local doc_end = directive.find("*/", i+2);
							if (doc_end < 0)
								err(directive_begin, "Unmatched '/*' in enum comment");
							doc = directive[i + 2:doc_end].rstrip();
							File.Writer tempfp;
							for (local l: doc.splitlines(false)) {
								local stripped_l = l.lstrip();
								if (stripped_l.startswith("*"))
									l = stripped_l[1:];
								tempfp << l << "\n";
							}
							doc = tempfp.string;
							i = doc_end + 2;
						}	break;
						case "//": {
							do {
								local doc_end = directive.find("\n", i+2);
								if (doc_end < 0)
									doc_end = #directive;
								doc += directive[i:doc_end];
								i = doc_end;
								while (i < #directive && directive.isspace(i))
									++i;
							} while (directive.substr(i, i + 2) == "//");
						}	break;
						default:
							break;
						}
						if (doc) {
							local common_prefix = none;
							for (local l: doc.splitlines(false)) {
								if (!l.strip())
									continue;
								local n = 0;
								while (n < #l && l.isspace(n))
									++n;
								local prefix = l[:n];
								if (common_prefix is none) {
									common_prefix = prefix;
								} else {
									common_prefix = common_prefix[:common_prefix.common(prefix)];
									if (!common_prefix)
										break;
								}
							}
							if (common_prefix) {
								File.Writer tempfp;
								common_prefix = #common_prefix;
								for (local l: doc.splitlines(false))
									tempfp << l[common_prefix:] << "\n";
								doc = tempfp.string;
							}
						}
						enums.append((name, value, doc.lstrip("\n").rstrip()));
					}
					File.Writer tempfp;
					local longest_name_len = 0;
					local longest_value_len = 0;
					for (local data: enums) {
						if (data is string)
							continue;
						local name, value, none = data...;
						local temp = #name;
						if (longest_name_len < temp)
							longest_name_len = temp;
						local temp = #value;
						if (longest_value_len < temp)
							longest_value_len = temp;
					}
					if ("guard" in options) {
						local guard_name = typedef_name;
						if (guard_name is none)
							guard_name = enum_name;
						tempfp << "#ifndef __" << guard_name << "_defined\n";
						tempfp << "#define __" << guard_name << "_defined 1\n";
					}
					function print_doc_comment(fp: File, doc: string, prefix: string) {
						local is_first = true;
						if ("*/" in doc) {
							for (local l: doc.splitlines(false)) {
								if (is_first) {
									is_first = false;
								} else {
									fp << "\n" << prefix;
								}
								fp << "// ";
								l = l.rstrip();
								if (l)
									fp << " " << l.rstrip();
							}
						} else {
							for (local l: doc.splitlines(false)) {
								if (is_first) {
									fp << "/*";
									is_first = false;
								} else {
									fp << "\n" << prefix << " *";
								}
								l = l.rstrip();
								if (l)
									fp << " " << l.rstrip();
							}
							fp << " */";
						}
					}
					if ("undef" in options) {
						for (local data: enums) {
							if (data is string)
								tempfp << data;
							else {
								tempfp << "#undef " << data[0] << "\n";
							}
						}
					}
					tempfp << "#ifdef __CC__\n";
					if (typedef_name)
						tempfp << "typedef ";
					tempfp << "enum ";
					if (enum_name)
						tempfp << enum_name << " ";
					tempfp << "{\n";
					import enumerate from util;
					for (local i, data: enumerate(enums)) {
						if (data is string) {
							tempfp << data;
							continue;
						}
						local name, value, doc = data...;
						File.Writer tempfp2;
						tempfp << "\t";
						tempfp2 << name << (" " * (longest_name_len - #name));
						tempfp2 << " = " << value;
						local is_last_enum = true;
						for (local j: [i + 1:#enums]) {
							if (enums[j] !is string) {
								is_last_enum = false;
								break;
							}
						}
						if (!is_last_enum)
							tempfp2 << ",";
						if (doc) {
							tempfp2 << (" " * ((longest_value_len + 1) - #value));
							if (is_last_enum && (i == 0 || ((for (local j: [:i]) enums[j] is string) && ...)))
								tempfp2 << " ";
							tempfp2 = tempfp2.string;
							tempfp << tempfp2;
							print_doc_comment(tempfp, doc, "\t" + (" " * #tempfp2));
						} else {
							tempfp << tempfp2.string;
						}
						tempfp << "\n";
					}
					tempfp << "}";
					if (typedef_name)
						tempfp << " " << typedef_name;
					tempfp << ";\n";
					tempfp << "#endif /* __CC__ */\n";
					if ("macro" in options) {
						tempfp << "#ifdef __COMPILER_PREFERR_ENUMS\n";
						for (local data: enums) {
							if (data is string) {
								tempfp << data;
								continue;
							}
							local name, value, doc = data...;
							File.Writer tempfp2;
							tempfp2 << "#define ";
							tempfp2 << name << (" " * ((longest_name_len + 1) - #name));
							tempfp2 << name;
							if (doc) {
								tempfp2 << (" " * ((longest_name_len + 1) - #name));
								tempfp2 = tempfp2.string;
								tempfp << tempfp2;
								print_doc_comment(tempfp, doc, " " * #tempfp2);
							} else {
								tempfp << tempfp2.string;
							}
							tempfp << "\n";
						}
						tempfp << "#else /* __COMPILER_PREFERR_ENUMS */\n";
					} else {
						tempfp << "#ifndef __COMPILER_PREFERR_ENUMS\n";
					}
					for (local i, data: enumerate(enums)) {
						if (data is string)
							continue;
						local name, value, doc = data...;
						if (value.startswith("-") || value.startswith("+")) {
							value = "({})".format({ value });
							enums[i] = (name, value, doc);
						}
					}
					local longest_value_len = 0;
					for (local data: enums) {
						if (data is string)
							continue;
						local name, value, none = data...;
						local temp = #value;
						if (longest_value_len < temp)
							longest_value_len = temp;
					}
					for (local data: enums) {
						if (data is string) {
							tempfp << data;
							continue;
						}
						local name, value, doc = data...;
						File.Writer tempfp2;
						tempfp2 << "#define ";
						tempfp2 << name << (" " * ((longest_name_len + 1) - #name));
						tempfp2 << value;
						if (doc) {
							tempfp2 << (" " * ((longest_value_len + 1) - #value));
							tempfp2 = tempfp2.string;
							tempfp << tempfp2;
							print_doc_comment(tempfp, doc, " " * #tempfp2);
						} else {
							tempfp << tempfp2.string;
						}
						tempfp << "\n";
					}
					tempfp << "#endif /* !__COMPILER_PREFERR_ENUMS */\n";
					if ("guard" in options) {
						local guard_name = typedef_name;
						if (guard_name is none)
							guard_name = enum_name;
						tempfp << "#endif /* !__" << guard_name << "_defined */\n";
					}
					yield IntermediateString(tempfp.string, group_list);
				} else if (directive.startswith("define")) {
					directive = directive[#"define":].lstrip();
					if (!directive.startswith("("))
						err(directive_begin, "Expected `(' after `%[define' in " + repr directive);
					local defend = directive.findmatch("(", ")", 1);
					if (defend < 0)
						err(directive_begin, "Missing `)' after `%[define" + repr directive + "'");
					if (directive[defend + 1:].strip() != "")
						err(directive_begin, "Trailing text after `%[define(...)': " + repr directive[defend:].strip());
					directive = directive[1:defend].strip();
					local macro_name, none, macro_text = directive.partition("=")...;
					macro_name = macro_name.rstrip();
					macro_text = macro_text.lstrip();
					if (macro_name in macros) {
						local o = macros[macro_name];
						if (o != macro_text)
							err(directive_begin, "Macro {!r} re-defined (old: {!r}, new: {!r})"
								.format({ macro_name, o, macro_text }));
					} else {
						macros[macro_name] = macro_text;
					}
				} else {
					err(directive_begin, "Unknown directive: " + repr directive);
				}
			} else {
				preamble_begin = i;
				i = text.find("\n", i);
				if (i < 0) {
					i = len;
					yield IntermediateString(text.substr(preamble_begin, i) + "\n", pack "c");
				} else {
					++i;
					yield IntermediateString(text.substr(preamble_begin, i), pack "c");
				}
			}
			continue;
		}
		if (text[i] == "[") {
			local tag_start = i + 1;
			i = text.findmatch("[", "]", tag_start);
			if (i < 0)
				err(tag_start, "No matching `]' for `['");
			local tag_content = text.substr(tag_start, i);
			++i;
			local conditions = [];
			for (local part: split_argument_list_args(tag_content)) {
				part = part.strip();
				if (!part) continue;
				if (!part.issymstrt(0)) {
					err(tag_start, "Expected tag to start with a name, but tag is " + repr part);
					continue;
				}
				local name_end = 1;
				while (name_end < #part && part.issymcont(name_end))
					++name_end;
				local tag_name = part.substr(0, name_end);
				local tag_block = part.substr(name_end).lstrip();
				function get_tag_operand_nostrip() {
					if (!tag_block.startswith("(") && !tag_block.endswith(")")) {
						err(tag_start,
							"Expected the tag block " +
							repr tag_block +
							" to be surrounded by parenthesis");
					}
					return tag_block.substr(1, #tag_block - 1);
				}
				function get_tag_operand() {
					return get_tag_operand_nostrip().strip();
				}
				switch (tag_name) {
				case "attribute":
					function_attributes.append(get_tag_operand());
					break;
				case "ignore":
				case "helper":
					helper_function = true;
					break;
				case "no_helper":
					helper_function = false;
					break;
				case "libc":
					export_as_libc = true;
					break;
				case "std":
					export_in_std = true;
					break;
				case "kernel":
					export_in_kernel = true;
					break;
				case "autoexport":
#ifndef EXPORTS_USE_USER_HEADERS
					dont_export_symbol = "auto";
					break;
#endif
				case "noexport":
					dont_export_symbol = true;
					break;
				case "export":
					dont_export_symbol = false;
					break;
				case "export_alias":
					if (conditions)
						err(tag_start, "The `export_alias' tag cannot be used conditionally");
					for (local x: get_tag_operand().split(",")) {
						x = x.strip();
						if ("?" in x || "@" in x)
							continue; /* Ignore (for now...) */
						if (x !in alternate_names)
							alternate_names.append(x);
						aliases.append(("", x));
					}
					break;
				case "alternate_name":
				case "alternate_names":
					for (local x: get_tag_operand().split(",")) {
						x = x.strip();
						if (x !in alternate_names)
							alternate_names.append(x);
					}
					break;
					/* CP for stdio (because of libio, custom FILE cookies may throw exceptions)
					 * Used for functions that are already CP in their syscall form. */
				case "cp_stdio":
					/* STDIO functions that may throw because of custom FILE cookies. */
				case "stdio_throws":
				case "throws":
					if (tag_name == "throws" && tag_block) {
						local arg = get_tag_operand();
						if (!arg) {
							if (!function_throws_anno)
								function_throws_anno = false;
						} else {
							for (local x: arg.split(","))
								function_throws_anno.append(x.strip());
						}
					}
					function_may_throw = true;
					function_attributes.remove("ATTR_NOTHROW");
					function_attributes.remove("ATTR_NOTHROW_NCX");
					function_attributes.remove("ATTR_NOTHROW_RPC");
					function_attributes.remove("ATTR_NOTHROW_RPC_KOS");
					function_attributes.remove("ATTR_NOTHROW_RPC_NOKOS");
					function_attributes.remove("ATTR_NOTHROW_RPC_PURE");
					break;
				case "nothrow":
					if (!function_may_throw)
						function_attributes.append("ATTR_NOTHROW");
					break;
				case "nothrow_ncx":
					if (!function_may_throw)
						function_attributes.append("ATTR_NOTHROW_NCX");
					break;
				case "cp": /* Cancellation point */
				case "cancellation_point":
				case "rpc":
				case "nothrow_rpc":
					if (!function_may_throw)
						function_attributes.append("ATTR_NOTHROW_RPC");
					break;
				case "cp_kos":
					if (!function_may_throw)
						function_attributes.append("ATTR_NOTHROW_RPC_KOS");
					break;
				case "cp_nokos":
					if (!function_may_throw)
						function_attributes.append("ATTR_NOTHROW_RPC_NOKOS");
					break;
				case "rpc_pure":
				case "nothrow_rpc_pure":
					if (!function_may_throw)
						function_attributes.append("ATTR_NOTHROW_RPC_PURE");
					break;
				case "guard":
					guarded_function = true;
					break;
				case "noguard":
					guarded_function = false;
					std_guard = false;
					break;
				case "std_guard":
					std_guard = true;
					guarded_function = true;
					break;
				case "no_std_guard":
					std_guard = false;
					break;
				case "fast":
					has_fast_implementation = true;
					break;
				case "builtin":
					define_as_builtin = tag_block ? get_tag_operand() : "";
					break;
				case "crtbuiltin":
					define_as_builtin = CrtBuiltin(tag_block ? get_tag_operand() : "");
					break;
				case "nobuiltin":
					define_as_builtin = false;
					break;
				case "preferred_impl":
					preferred_impl.append((" && ".join(conditions), get_tag_operand().strip()));
					break;
				case "allow_macros":
					allow_macros = true;
					break;
				case "disallow_macros":
					allow_macros = false;
					break;
				case "nosys_errno":
					nosys_errno = get_tag_operand();
					break;
				case "no_nosys_errno":
					nosys_errno = none;
					break;
				case "argument_names":
					argument_names = Tuple(get_tag_operand().split(","));
					break;
				case "doc":
					if (doc)
						doc += "\n";
					doc += get_tag_operand_nostrip();
					break;
				case "doc_alias":
					doc = CopyFunctionBody(get_tag_operand(), identitiyConverter);
					break;
				case "if":
					conditions.append(get_tag_operand());
					break;
				case "vartypes":
					vartypes = Tuple(get_tag_operand().split(","));
					break;
				case "section":
					impl_section = get_tag_operand();
					if (!impl_section.startswith(".text.crt") && !impl_section.startswith("{.text.crt"))
						err(tag_start, "Section name {!r} does not start with `.text.crt'".format({ impl_section }));
					break;
				case "def_section":
					impl_section = none;
					break;
				case "dos_function":
					impl_section = "$dos";
					break;
				case "kos_function":
					impl_section = "$kos";
					break;
				case "dependency_string":
					dependency_string = get_tag_operand();
					break;
				case "autouser":
					nouser = false;
					douser = false;
					break;
				case "overload_alias":
					overload_alias = true;
					dont_export_symbol = true;
					nouser = false;
					douser = false;
					nocrt = true;
					function_attributes.append("*");
					aliases.append(("", "*"));
					break;
				case "nouser":
					nouser = true;
					douser = false;
					break;
				case "user":
					douser = true;
					nouser = false;
					break;
				case "dos_variant":
				case "wchar":
					wchar_function = true;
					break;
				case "nowchar":
					wchar_function = false;
					break;
				case "uchar16":
					uchar_function = 2;
					break;
				case "uchar32":
					uchar_function = 4;
					break;
				case "no_uchar":
					uchar_function = none;
					break;
				case "uchar16_function_name":
					uchar16_function_name = get_tag_operand();
					break;
				case "uchar32_function_name":
					uchar32_function_name = get_tag_operand();
					break;
				case "no_uchar16_function_name":
					uchar16_function_name = none;
					break;
				case "no_uchar32_function_name":
					uchar32_function_name = none;
					break;
				case "time64_variant_of": {
					local base_func = get_tag_operand();
					intern_aliases.append((
						"__SIZEOF_TIME32_T__ == __SIZEOF_TIME64_T__",
						Cell(base_func)
					));
					aliases.append((
						"__SIZEOF_TIME32_T__ == __SIZEOF_TIME64_T__",
						base_func
					));
					if (doc is string && doc == "")
						doc = CopyFunctionBody(base_func, identitiyConverter);
				}	break;
				case "off64_variant_of": {
					local base_func = get_tag_operand();
					intern_aliases.append((
						"__SIZEOF_OFF32_T__ == __SIZEOF_OFF64_T__",
						Cell(base_func)
					));
					aliases.append((
						"__SIZEOF_OFF32_T__ == __SIZEOF_OFF64_T__",
						base_func
					));
					if (doc is string && doc == "")
						doc = CopyFunctionBody(base_func, identitiyConverter);
				}	break;
				case "largefile64_variant_of": {
					local base_func = get_tag_operand();
					intern_aliases.append((
						"!defined(__O_LARGEFILE) || (__O_LARGEFILE+0) == 0",
						Cell(base_func)
					));
					aliases.append((
						"!defined(__O_LARGEFILE) || (__O_LARGEFILE+0) == 0",
						base_func
					));
					if (doc is string && doc == "")
						doc = CopyFunctionBody(base_func, identitiyConverter);
				}	break;
				case "dirent64_variant_of": {
					local base_func = get_tag_operand();
					intern_aliases.append((
						"defined(_DIRENT_MATCHES_DIRENT64)",
						Cell(base_func)
					));
					aliases.append((
						"defined(_DIRENT_MATCHES_DIRENT64)",
						base_func
					));
					if (doc is string && doc == "")
						doc = CopyFunctionBody(base_func, identitiyConverter);
				}	break;
				case "intern_alias":
					for (local x: get_tag_operand().split(","))
						intern_aliases.append((" && ".join(conditions), x.strip()));
					break;
				case "intern_alias_key":
					for (local x: get_tag_operand().split(","))
						intern_aliases.append((" && ".join(conditions), Cell(x.strip())));
					break;
				case "nocrt":       /* [nocrt] The function isn't exported under its primary name. */
				case "alias_only":  /* [alias_only] Only consider alias names */
					nocrt = true;
					break;
				case "alias":       /* [alias(foo)] Define the name of an alias of the function */
					for (local x: get_tag_operand().split(",")) {
						if ("?" in x || "@" in x)
							continue; /* Ignore (for now...) */
						aliases.append((" && ".join(conditions), x.strip()));
					}
					break;
				case "preferred_alias":
					for (local x: get_tag_operand().split(",")) {
						if ("?" in x || "@" in x)
							continue; /* Ignore (for now...) */
						preferred_aliases.append((" && ".join(conditions), x.strip()));
					}
					break;
				case "alias_args": {
					local op = get_tag_operand();
					if (":" !in op)
						err(tag_start, "Missing `:' in alias_args operand " +  repr op);
					local name, none, arglist = op.partition(":")...;
					arglist = arglist.strip();
					local param_end;
					if (!arglist.startswith("(") ||
					   (param_end = arglist.findmatch("(", ")", 1)) < 0)
						err(tag_start, "Missing `(...)' around alias_args operand " +  repr arglist);
					local tail = arglist.substr(param_end+1).lstrip();
					arglist = arglist.substr(1, param_end).strip();
					if (tail) {
						if (!tail.startswith("->"))
							err(tag_start, "Missing `->' before alias_args return type " +  repr tail);
						tail = tail[2:].lstrip();
					} else {
						//err(tag_start, "Missing return type in " + repr(arglist));
						tail = "void";
					}
					arglist = Tuple(split_argument_list(arglist));
					tail = parse_return_type_annotations(tail, arglist);
					local pck = (arglist, tail);
					for (local x: name.split(","))
						alias_args[x.strip()] = pck;
				}	break;
				case "impl_prefix":
					if (impl_prefix) impl_prefix += "\n";
					impl_prefix += get_tag_operand() + "\n";
					break;
				case "impl_include":
					if (impl_prefix) impl_prefix += "\n";
					impl_prefix += "#include @{}@\n".format({ get_tag_operand() });
					break;
				case "requires_prefix":
					if (requires_prefix) requires_prefix += "\n";
					requires_prefix += get_tag_operand() + "\n";
					break;
				case "requires_include":
					if (requires_prefix) requires_prefix += "\n";
					requires_prefix += "#include @{}@\n".format({ get_tag_operand() });
					break;
				case "decl_prefix":
				case "declaration_prefix":
					if (declaration_prefix) declaration_prefix += "\n";
					declaration_prefix += get_tag_operand() + "\n";
					break;
				case "decl_include":
				case "declaration_include":
					if (declaration_prefix) declaration_prefix += "\n";
					declaration_prefix += "#include @{}@\n".format({ get_tag_operand() });
					break;
				case "dependency_prefix":
					if (dependency_prefix) dependency_prefix += "\n";
					dependency_prefix += get_tag_operand() + "\n";
					break;
				case "dependency_include":
					if (dependency_prefix) dependency_prefix += "\n";
					dependency_prefix += "#include @{}@\n".format({ get_tag_operand() });
					break;
				case "no_libc_impl":
					libc_impl = none;
					break;
				case "no_user_impl":
					user_impl = none;
					break;
				case "same_impl":
					same_impl = true;
					break;
				case "no_same_impl":
					same_impl = false;
					break;
				case "libc_impl":
					libc_impl = get_tag_operand();
					break;
				case "user_impl":
					user_impl = get_tag_operand();
					break;
				case "default_component_name":
					component_name = none;
					break;
				case "component_name":
					component_name = get_tag_operand();
					break;
				case "dosname":
					if (dosnames is none)
						dosnames = [];
					for (local x: get_tag_operand().split(",")) {
						x = x.strip();
						if (x !in dosnames)
							dosnames.append(key_libd_export(x));
						if (x !in aliases)
							aliases.append(("", x));
					}
					break;
				case "component_name_alias":
					component_name = CopyFunctionBody(get_tag_operand(), identitiyConverter);
					break;
				case "private_impl":
					libc_impl = get_tag_operand();
					user_impl = libc_impl;
					break;
				case "dependency":
					forced_dependencies.append(get_tag_operand());
					break;
				case "requires":
					if (define_require_string)
						define_require_string += " && ";
					define_require_string += add_paren_if_necessary(get_tag_operand(), true);
#ifndef EXPORTS_USE_USER_HEADERS
					if (dont_export_symbol is none)
						dont_export_symbol = "auto";
#endif
					break;
				case "crt_requires":
					if (define_require_string)
						define_require_string += " && ";
					define_require_string += key_crt_have(get_tag_operand().strip());
#ifndef EXPORTS_USE_USER_HEADERS
					if (dont_export_symbol is none)
						dont_export_symbol = "auto";
#endif
					break;
				case "ATTR_MCONST":
					/* ATTR_CONST for math functions:
					 *   - The return value of these functions is constant, however
					 *     for specific input values `errno' may be modified, meaning
					 *     that the function can have side-effects other than the
					 *     return value.
					 *     For now, this TAG is simply ignored and doesn't cause any
					 *     code to be generated. */
					break;

				default: {
					local attr_name = tag_name.lstrip("_");
					if (attr_name.startswith("ATTR_")) {
						function_attributes.append(attr_name + tag_block);
					} else {
						err(tag_start, "Unknown tag: " + repr tag_name);
					}
				}	break;
				}
			}
			continue;
		}

		/* Scan the function name. */
		if (text.issymstrt(i)) {
			local funname_start = i;
			local extended_overloads = [];
			do ++i;
			while (text.issymcont(i));
			local funname = text.substr(funname_start, i);
			while (text.isspace(i)) ++i;
			if (text[i] != ":")
				err(i, "Expected \":\", but got " + repr text[i]);
			else ++i;
			while (text.isspace(i)) ++i;
			if (text[i] != "(")
				err(i, "Expected \"(\", but got " + repr text[i]);
			else ++i;
			local argument_list_start = i;
			i = text.indexmatch("(", ")", i);
			local argument_list = text.substr(argument_list_start, i);
			do ++i;
			while (text.isspace(i));
			local return_type = "void";
			if (text.substr(i, i + 2) == "->") {
				i += 2;
				local return_type_start = i;
				i = findfirstch_parenaware(text, "{=;%", return_type_start);
				if (i < 0)
					err(return_type_start, "Expected `;', `{', `%' or `=' after return type");
				local return_type_end = findfirstch_parenaware(text, "[", return_type_start, i);
				if (return_type_end >= 0) {
					for (;;) {
						local temp = return_type_end + 1;
						while (temp < i && text.isspace(temp))
							++temp;
						if (temp >= i) {
							return_type_end = i;
							break;
						}
						if (text[temp] == "(")
							break;
						return_type_end = text.findmatch("[", "]", temp, i);
						if (return_type_end < 0) {
							return_type_end = i;
							break;
						}
						++return_type_end;
						return_type_end = findfirstch_parenaware(text, "[", return_type_end, i);
						if (return_type_end < 0) {
							return_type_end = i;
							break;
						}
					}
					i = return_type_end;
				}
				return_type = text.substr(return_type_start, i).strip();
				if (return_type.startswith("[")) {
					local myline = text.count("\n", 0, argument_list_start) + 1;
					local arglist_attributes = List();
					local arglist = Tuple(split_argument_list(
						argument_list, arglist_attributes, filename, myline));
					return_type = parse_return_type_annotations(
						return_type, arglist,
						function_attributes,
						arglist_attributes, filename, myline);
				}
			}
			local ch = text[i];
			while (ch == "[") {
				local overload_tag_start = i + 1;
				i = text.indexmatch("[", "]", i + 1);
				local overload_block = text.substr(overload_tag_start, i);
				do ++i;
				while (text.isspace(i));
				local overload_i = 0;
				local overload_len = #overload_block;
				while (overload_block.isspace(overload_i))
					++overload_i;
				if (overload_block[overload_i] != "(") {
					err(overload_tag_start + overload_i,
						"Expected \"(\" for overload argument list, but got " +
						repr overload_block[overload_i]);
				} else {
					++overload_i;
				}
				local overload_argument_list_start = overload_i;
				overload_i = overload_block.indexmatch("(", ")", overload_i);
				local overload_argument_list = overload_block.substr(overload_argument_list_start, overload_i);
				++overload_i;
				local overload_return_type = overload_block.substr(overload_i).strip();
				if (overload_return_type.startswith("->")) {
					overload_return_type = overload_return_type.substr(2).lstrip();
				} else {
					if (overload_return_type)
						err(overload_tag_start + overload_i,
							"Expected \"->\" after overload argument list, but got " +
							repr overload_return_type);
					overload_return_type = "void";
				}
				overload_argument_list = Tuple(split_argument_list(overload_argument_list));
				overload_return_type = parse_return_type_annotations(overload_return_type, overload_argument_list);
				extended_overloads.append((overload_argument_list, overload_return_type));
				ch = text[i];
			}
			if (!function_may_throw &&
			   ("ATTR_NOTHROW" !in function_attributes &&
			    "ATTR_NOTHROW_NCX" !in function_attributes &&
			    "ATTR_NOTHROW_RPC" !in function_attributes &&
			    "ATTR_NOTHROW_RPC_KOS" !in function_attributes &&
			    "ATTR_NOTHROW_RPC_NOKOS" !in function_attributes &&
			    "ATTR_NOTHROW_RPC_PURE" !in function_attributes))
				function_attributes.append("ATTR_NOTHROW_NCX");
			local block_start = i;
			local block;
			if (ch == "=") {
				do ++i;
				while (text.isspace(i));
				local alias_name_begin = i;
				if (!text.issymstrt(i))
					err(i, "Expected an identifier after `=', but got " + repr text[i]);
				do ++i;
				while (text.issymcont(i));
				block = FunctionAlias(text.substr(alias_name_begin, i));
				while (text.isspace(i)) ++i;
				if (text[i] == "?") {
					/* This works similar to ASMNAME(), in that
					 * >> foo:(int x, int y) -> int = bar?;
					 * Can only be linked as:
					 * >> __CREDIRECT(,int,foo,(int x, int y),bar,(x,y)) */
					block = UndefinedFunctionAlias(block.func);
					do ++i;
					while (text.isspace(i));
				}
				if (text[i] == ";")
					++i;
				else {
					err(i, "Expected `;' after function alias, but got " + repr text[i]);
				}
			} else if (ch == ";") {
				block = none;
				++i;
			} else if (ch == "%") {
				/* Special block command */
				++i;
				if (i >= len || text[i] != "{")
					err(i, "Expected `{' after `%' while parsing a function block");
				++i;
				local block_end;
				block_end = text.findmatch("{", "}", i);
				if (block_end < 0)
					err(i, "Missing `}' after `%{'");
				block = text[i:block_end].strip();
				local par_start = block.find("(");
				if (par_start < 0)
					par_start = #block;
				local arg = block.substr(par_start);
				local cmd = block.substr(0, par_start).rstrip();
				function get_gen_arg() {
					if (!arg.startswith("(") || !arg.endswith(")"))
						err(i, "Expected the generator " + repr cmd + " to be used with parenthesis");
					return arg[1:#arg - 1].strip();
				}
				switch (cmd) {
				case "copy": {
					/* Copy the block of some other function */
					local name = get_gen_arg();
					local convert_body = identitiyConverter;
					local convert_doc = identitiyConverter;
					if ("," in name) {
						local conv_name;
						name, none, conv_name = name.partition(",")...;
						name = name.rstrip();
						conv_name = conv_name.lstrip();
						if (conv_name == "math") {
							if ("long double" in argument_list || "long double" in return_type) {
								conv_name = "double2ldouble";
							} else if ("float" in argument_list || "float" in return_type) {
								conv_name = "double2float";
							} else {
								err(i, "Failed to differenciate between ldouble and float math modes for {} (please specifiy explicitly)"
									.format({ funname }));
							}
						}
						local descr = function_body_conversions.get(conv_name);
						if (descr is none)
							err(i, "Unknown body converter {!r}".format({ conv_name }));
						if (name == "%auto") {
							name = descr["auto"](funname);
							if (name is none)
								err(i, "Failed to automatically determine bound function for {!r} with {!r}"
									.format({ funname, conv_name }));
						}
						local repl_dict = none;
						if (conv_name == "str2wcs") {
							repl_dict = str2wcs_keyword_replacements;
						} else if (conv_name == "double2float") {
							repl_dict = double2float_conversions;
						} else if (conv_name == "double2ldouble") {
							repl_dict = double2ldouble_conversions;
						}
						/* Automatically define replacement for function names. */
						for (local prefix: { "", "__CRT_HAVE_" }) {
							local usedName = prefix + name;
							if (usedName !in repl_dict)
								repl_dict[usedName] = WeakReplacement(prefix + funname);
						}
						convert_body = descr["convert_body"];
						convert_doc = descr["convert_doc"];
					}
					block = CopyFunctionBody(name, convert_body);
					if (doc !is CopyFunctionBody && !doc)
						doc = CopyFunctionBody(name, convert_doc);
				}	break;
				case "uchar":
				case "uchar16":
				case "uchar32": {
					/* User input:
					 * 	[ATTR_WUNUSED][ATTR_PURE][ATTR_NONNULL((1))]
					 * 	[uchar16][nocrt][noexport][nouser]
					 * 	[if(__SIZEOF_WCHAR_T__ == 2), preferred_alias(wcsend)]
					 * 	[alias(DOS$wcsend)]
					 * 	[component_name_alias(wcsend)]
					 * 	c16end:(char16_t const *__restrict string) -> char16_t *
					 * 		[(char16_t *__restrict string) -> char16_t *]
					 * 		[(char16_t const *__restrict string) -> char16_t const *]
					 * 		= wcsend;
					 * Same as:
					 * 	[ATTR_WUNUSED][ATTR_PURE][ATTR_NONNULL((1))]
					 * 	c16end:(char16_t const *__restrict string) -> char16_t *
					 * 		[(char16_t *__restrict string) -> char16_t *]
					 * 		[(char16_t const *__restrict string) -> char16_t const *]
					 * 		%{uchar(wcsend)}
					*/
					if (cmd == "uchar") {
						/* Automatically determine uchar mode */
						if ("16" in funname && "32" !in funname)
							cmd = "uchar16";
						else if ("16" !in funname && "32" in funname)
							cmd = "uchar32";
						else {
							err(i, "Unable to determine uchar mode for " + repr(funname));
						}
					}
					dont_export_symbol = true;
					nocrt = true;
					nouser = true;
					uchar_function = cmd == "uchar16" ? 2 : 4;
					local base_function = arg ? get_gen_arg() : "%auto";
					if (base_function == "%auto") {
						if (funname.startswith("c16") || funname.startswith("c32"))
							base_function = "wcs" + funname[3:];
						else {
							err(i, "Unable to determine bound wchar-function for " + repr(funname));
						}
					}
					//component_name = CopyFunctionBody(base_function, identitiyConverter);
					preferred_aliases.append(("__SIZEOF_WCHAR_T__ == " + uchar_function, base_function));
					if (uchar_function == 2) /* uchar16 automatically aliases the dos-variant */
						aliases.append(("", "DOS$*"));
					block = FunctionAlias(base_function);
				}	break;
				case "auto_block": {
					local mode = get_gen_arg();
					local par_start = mode.find("(");
					if (par_start < 0)
						par_start = #mode;
					local arg = mode.substr(par_start);
					local mode = mode.substr(0, par_start).rstrip();
					function get_mode_arg() {
						if (!arg.startswith("(") || !arg.endswith(")"))
							err(i, "Expected the auto_block generator " + repr mode + " to be used with parenthesis");
						return arg[1:#arg - 1].strip();
					}
					switch (mode) {
					case "any":
						block = get_mode_arg();
						if (libc_impl is none)
							libc_impl = block;
						if (user_impl is none)
							user_impl = block;
						break;
					case "printf": {
						local vprintf_function = get_mode_arg();
						local arglist = Tuple(split_argument_list(argument_list));
						local printf_pattern =
						"{{\n"
						"	{return_type} result;\n"
						"	va_list args;\n"
						"	va_start(args, {largarg});\n"
						"	result = {vprintf}({positional_args}, args);\n"
						"	va_end(args);\n"
						"	return result;\n"
						"}}";
						block = printf_pattern.format({
							"return_type" : return_type,
							"largarg" : arglist[#arglist-2][1],
							"vprintf" : vprintf_function,
							"positional_args" : ", ".join(arglist[:-1].each[1]),
						});
						if (libc_impl is none)
							libc_impl = block;
						if (user_impl is none)
							user_impl = block;
						if (!define_require_string) {
							/* Auto-define requirements to require the vprintf() function */
							define_require_string = "$has_function({})".format({ vprintf_function });
#ifndef EXPORTS_USE_USER_HEADERS
							if (dont_export_symbol is none)
								dont_export_symbol = "auto";
#endif
						}
					}	break;
					case "math": {
						/* sinf:(float x) -> float %{auto_block(math)} */
						local my_type = "double";
						local basefunc = funname;
						if (funname.endswith("f")) {
							my_type = "float";
							basefunc = basefunc[:-1];
						} else if (funname.endswith("l")) {
							my_type = "long double";
							basefunc = basefunc[:-1];
						}
						if (arg) {
							my_type, none, basefunc = get_mode_arg().partition(",")...;
							my_type = my_type.strip();
							basefunc = basefunc.strip();
						}
						if (my_type !in ["float", "double", "long double"] || !basefunc)
							err(i, "Invalid arguments for %{auto_block(math(...))}");
						if (my_type == "long double") {
							/* Add  */
							local new_aliases = [
								("__SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__", basefunc),
								];
							for (local c, n: aliases) {
								if (n.endswith("l")) {
									if (c)
										c = add_paren_if_necessary(c, true) + " && ";
									c += "__SIZEOF_LONG_DOUBLE__ == __SIZEOF_DOUBLE__";
									new_aliases.append((c, n[:-1]));
								}
							}
							aliases.extend(new_aliases);
						}
						local block_pattern =
						"{{\n"
						"	return ({return_type}){func}({args});\n"
						"}}";
						block = block_pattern.format({
							"return_type" : return_type,
							"func" : basefunc,
							"args" : ", ".join(
								for (local typ, nam: split_argument_list(argument_list))
									typ == my_type ? "(double)" + nam : nam)
						});
						if (libc_impl is none)
							libc_impl = block;
						if (user_impl is none)
							user_impl = block;
						if (!doc) /* Inherit the doc of the original function. */
							doc = CopyFunctionBody(basefunc, identitiyConverter);
						if (!define_require_string) {
							/* Auto-define requirements to require the underlying function */
							define_require_string = "$has_function({})".format({ basefunc });
#ifndef EXPORTS_USE_USER_HEADERS
							if (dont_export_symbol is none)
								dont_export_symbol = "auto";
#endif
						}
					}	break;
					default:
						err(i, "Unknown auto_block mode " + repr mode);
						break;
					}
				}	break;
				default:
					err(i, "Unknown block generator command " + repr cmd);
					break;
				}
				i = block_end + 1;
			} else {
				if (ch != "{")
					err(i, "Expected \";\", \"{\", \"%\" or \"=\", but got " + repr text[i]);
				else ++i;
				i = text.indexmatch("{", "}", i) + 1;
				block = text.substr(block_start, i).rstrip();
			}
			local fun = Function();
			/* Don't include nocrt functions in user-headers
			 * unless explicitly requested. */
			if (nocrt && !douser)
				nouser = true;
			fun.name = funname;
			fun.aliases = aliases;
			fun.intern_aliases = intern_aliases;
			fun.alternate_names = alternate_names;
			fun.preferred_aliases = preferred_aliases;
			fun.args = Tuple(split_argument_list(
				argument_list, function_attributes,
				filename, text.count("\n", 0, argument_list_start) + 1));
			sortFunctionAttributes(function_attributes);
			fun.attr_tags = function_attributes;
			fun.alias_args = alias_args;
			fun.return_type = return_type;
			fun.block = block;
			fun.forced_dependencies = forced_dependencies;
			fun.impl_prefix = impl_prefix;
			fun.requires_prefix = requires_prefix;
			fun.declaration_prefix = declaration_prefix;
			fun.dependency_prefix = dependency_prefix;
			if (same_impl && (block is string || block is CopyFunctionBody)) {
				if (libc_impl is none)
					libc_impl = block;
				if (user_impl is none)
					user_impl = block;
			}
			fun.libc_impl = libc_impl;
			fun.user_impl = user_impl;
			fun.define_require_string = define_require_string;
			fun.std_guard = std_guard;
			fun.nocrt = nocrt;
			fun.nouser = nouser;
			fun.douser = douser;
			fun.overload_alias = overload_alias;
			fun.wchar_function = wchar_function;
			fun.uchar_function = uchar_function;
			fun.uchar16_function_name = uchar16_function_name;
			fun.uchar32_function_name = uchar32_function_name;
			for (local tp, name: fun.args) {
				if (tp.startswith("..."))
					fun.args_is_varargs = true;
				if (!tp || !name) continue;
				fun.args_by_name[name] = tp;
			}
			fun.throws_decl = function_throws_anno;
			fun.export_as_libc = export_as_libc;
			fun.export_in_std = export_in_std;
			fun.export_in_kernel = export_in_kernel;
			fun.guarded_function = guarded_function;
			fun.has_fast_implementation = has_fast_implementation;
			fun.preferred_impl = preferred_impl;
			fun.extended_overloads = extended_overloads;
			fun.allow_macros = allow_macros;
			fun.argument_names = argument_names;
			fun.nosys_errno = nosys_errno;
			fun.vartypes = vartypes;
			if (component_name !is none)
				fun.component_name = component_name;
			if (dosnames is none) {
				dosnames = [];
				if (!nocrt)
					dosnames.append(key_libd_export(funname));
				for (local alt: alternate_names)
					dosnames.append(key_libd_export(alt));
			}
			fun.dosnames = dosnames;
			fun.impl_section = impl_section;
			fun.dependency_string = dependency_string;
			fun.helper_function = helper_function;
			if ((doc is string && !doc) && function_throws_anno) {
				/* Auto-generate one documentation line for every
				 * type of exception which may be thrown by the function */
				File.Writer throws_anno;
				for (local x: function_throws_anno)
					throws_anno << "@throws: " << x << ": ...\n";
				if (doc && !doc.endswith("\n"))
					doc += "\n";
				doc += throws_anno.string.strip();
			}
			fun.doc = doc;
			if (include_line_directives) {
				fun.block_starting_line = text.count("\n", 0, block_start);
				fun.block_definintions_file = filename;
			}
#ifndef EXPORTS_USE_USER_HEADERS
			if (dont_export_symbol is none)
				dont_export_symbol = "auto";
#endif
			fun.dont_export_symbol = dont_export_symbol;

			if (define_as_builtin === false)
				; /* Don't provide builtin function support */
			else if (define_as_builtin !is none) {
				local name = define_as_builtin;
				local needcrt = false;
				if (name is CrtBuiltin) {
					name = name.name;
					needcrt = true;
				}
				local builtin_name = name ? name : "__builtin_" + funname;
				local cond = "__has_builtin({})".format({ builtin_name });
				if (fun.args_is_varargs)
					cond = cond + " && __has_builtin(__builtin_va_arg_pack)";
				if (needcrt) {
					cond = cond + " && defined(__LIBC_BIND_CRTBUILTINS) && " + key_crt_have(funname);
#ifdef WARN_KNOWN_BUILTINS
					local uses_libc = known_builtins.get("__builtin_" + funname);
					if (uses_libc !is none && !uses_libc) {
						print getFilenameForLog(filename),;
						print "(",;
						print 1+text.count("\n", 0, funname_start),;
						print ") : Warning : Builtin function doesn't need CRT support:", repr(funname),
							"(consider annotating with [builtin] instead of [crtbuiltin])";
					}
#endif /* WARN_KNOWN_BUILTINS */
				}
#ifdef WARN_KNOWN_BUILTINS
				else {
					local uses_libc = known_builtins.get("__builtin_" + funname);
					if (uses_libc !is none && uses_libc) {
						print getFilenameForLog(filename),;
						print "(",;
						print 1+text.count("\n", 0, funname_start),;
						print ") : Warning : Builtin function needs CRT support:", repr(funname),
							"(consider annotating with [crtbuiltin] instead of [builtin])";
					}
				}
#endif /* WARN_KNOWN_BUILTINS */
				local canReturn = "ATTR_NORETURN" !in function_attributes;
				File.Writer blockfp;
				blockfp << "{ ";
				if (canReturn)
					blockfp << "return ";
				blockfp << "@" << builtin_name << "@";
				blockfp << "(";
				fun.print_argument_name_list(blockfp,
					fun.argument_names is none
						? fun.args
						: fun.args[:#fun.argument_names],
					key_identity);
				if (fun.args_is_varargs)
					blockfp << "__builtin_va_arg_pack()";
				blockfp << "); }";
				fun.preferred_impl.append((cond, blockfp.string));
			}
#ifdef WARN_KNOWN_BUILTINS
			else if (!overload_alias) {
				local uses_libc = known_builtins.get("__builtin_" + funname);
				if (uses_libc !is none) {
					print getFilenameForLog(filename),;
					print "(",;
					print 1+text.count("\n", 0, funname_start),;
					print ") : Warning : Function exists as a GCC builtin:", repr(funname),
						"(consider annotating with [{}builtin] or [nobuiltin])"
							.format({ uses_libc ? "crt" : "" });
				}
			}
#endif /* WARN_KNOWN_BUILTINS */
#ifdef WARN_KNOWN_ALIASES
			if (block !is UndefinedFunctionAlias) {
				local ka = known_aliases.get(funname);
				if (ka !is none && ka !in alternate_names) {
					/* Check if the alias is defined as a regular alias. */
					for (local none, name: aliases) {
						if (name == ka)
							goto known_alias_declared;
					}
					for (local none, name: preferred_aliases) {
						if (name == ka)
							goto known_alias_declared;
					}
					print getFilenameForLog(filename),;
					print "(",;
					print 1+text.count("\n", 0, funname_start),;
					print ") : Warning : Missing, known alias [export_alias(",;
					print ka,;
					print ")] for", repr(funname);
				}
			} else {
				local ka = known_aliases.get(block.name);
				if (ka !is none) {
					/* Check if the alias is defined as a regular alias. */
					for (local none, name: aliases) {
						if (name == ka)
							goto known_alias_declared;
					}
					for (local none, name: preferred_aliases) {
						if (name == ka)
							goto known_alias_declared;
					}
					print getFilenameForLog(filename),;
					print "(",;
					print 1+text.count("\n", 0, funname_start),;
					print ") : Warning : Missing, known alias [export_alias(",;
					print ka,;
					print ")] for", repr(block.name);
				}
			}
known_alias_declared:
#endif /* WARN_KNOWN_ALIASES */
			yield fun;
			aliases = [];
			intern_aliases = [];
			alternate_names = [];
			preferred_aliases = [];
			function_attributes = [];
			forced_dependencies = [];
			alias_args = Dict();
			define_require_string = "";
			std_guard = false;
			export_as_libc = false;
			export_in_std = false;
			export_in_kernel = false;
#ifndef EXPORTS_USE_USER_HEADERS
			dont_export_symbol = none;
#else
			dont_export_symbol = false;
#endif
			guarded_function = false;
			has_fast_implementation = false;
			preferred_impl = [];
			helper_function = false;
			impl_prefix = "";
			requires_prefix = "";
			declaration_prefix = "";
			dependency_prefix = "";
			same_impl = false;
			libc_impl = none;
			user_impl = none;
			function_may_throw = false;
			function_throws_anno = [];
			allow_macros = false;
			nocrt = false;
			nouser = false;
			douser = false;
			overload_alias = false;
			wchar_function = false;
			uchar_function = none;
			uchar16_function_name = none;
			uchar32_function_name = none;
			component_name = none;
			dosnames = none;
			argument_names = none;
			nosys_errno = default_nosys_errno;
			vartypes = none;
			impl_section = default_impl_section;
			dependency_string = none;
			doc = "";
			define_as_builtin = none;
			continue;
		}
		err(i, "Unexpected character " + repr text[i]);
		++i;
	}
}

function format_define_require_string(fp: File, text: string) {
	local i = 0;
	local len = #text;
	local flush_start = 0;
	while (i < len) {
		local ch = text[i];
		if (ch == "$") {
			fp << text.substr(flush_start, i);
			++i;
			local block;
			if (i < len && text[i] != "{") {
				local end = i;
				while (end < len) {
					if (text.issymstrt(end)) {
						++end;
						continue;
					}
					local ch = text[end];
					local map = {
						"(" : ")",
						"[" : "]",
						"{" : "}",
					};
					local ot = map.get(ch);
					if (ot is none)
						break;
					++end;
					local par_end = text.findmatch(ch, ot, end);
					if (par_end < 0)
						throw "Missing closing `" + ot + "' after `" + ch + "' in [requires(" + repr text + ")]";
					end = par_end + 1;
				}
				block = text.substr(i, end).strip();
				i = end;
			} else {
				++i;
				local end = text.findmatch("{", "}", i);
				if (end < 0)
					throw "Missing closing `}' after `${' in [requires(" + repr text + ")]";
				block = text.substr(i, end).strip();
				i = end + 1;
			}
			local arg_start = block.find("(");
			if (arg_start < 0)
				arg_start = #block;
			local cmd = block.substr(0, arg_start).rstrip();
			block = block.substr(arg_start);
			function get_tag_operand() {
				if (!block.startswith("(") && !block.endswith(")")) {
					throw "Expected the tag block " + repr block + " to be surrounded by parenthesis in [requires(" + repr text + ")]";
				}
				return block.substr(1, #block - 1).strip();
			}
			switch (cmd) {
			case "has_function": {
				local name = get_tag_operand();
				local func = functions_prototypes.get(name.rstrip("?"));
				if (func is none) {
					if (name.endswith("?")) {
						fp << key_crt_have(name.rstrip("?"));
						break;
					}
					throw "Unknown function " + repr name;
				}
				local old_string = fp.string.rstrip();
				local new_string = text.substr(i).lstrip();
				fp << add_paren_if_necessary(func.get_dependency_string(),
					(old_string && !old_string.endswith("||") && !old_string.endswith("(")) ||
					(i < len && !new_string.startswith("||") && !new_string.startswith(")")));
			}	break;
			default:
				throw "Unknown requires directive " + repr cmd + " in [requires(" + repr text + ")]";
			}
			flush_start = i;
			continue;
		}
		++i;
	}
	fp << text.substr(flush_start, len);
}
function format_define_require_string_comment(fp: File, text: string) {
	/* TODO: Special variant */
	format_define_require_string(fp, text);
}



class Function {
	@@Name of the function
	member name: string;

	@@Alternate names for @this Function
	member alternate_names: {string...};

	@@A string expression that must be true in order to allow definition of this function
	member define_require_string: string;

	@@Set to :true if the function's guard must be checked to exist when the function is imported from std
	member std_guard: bool;

	@@The name of a varargs function (e.g. $\"vprintf\" for $\"printf\")
	member varargs_name: string | none = none;

	@@Sequence of function attributes
	member attr_tags: {string...};

	@@Sequence of (condition, alias_name) for aliases of the function
	member aliases: {(string, string)...};

	@@Sequence of (condition, alias_name) for definition
	@@aliases within the libc implementation source files
	member intern_aliases: {(string, string)...};

	@@Sequence of (condition, alias_name) for preferred aliases of the function
	member preferred_aliases: {(string, string)...};

	@@Arguments taken by the function
	member args: {(string, string)...};

	@@Mapping for custom argument lists used by specific aliases
	member alias_args: {(string, ({(string, string)...}, string))...};

	@@The type returned by the function
	member return_type: string;

	@@Sequence of tuples (args, return_type) for extended C++ overloads
	@@Used to implement functions such as `strend()' or `memchr()'
	member extended_overloads: {({(string, string)...}, string)...};

	@@Mapping between argument names and types
	member args_by_name: {(string, string)...} = Dict();

	@@:true if @args contains a varargs argument
	member args_is_varargs: bool = false;

	@@:true if @this function should be exported as a
	@@__libc_* function in /include/libc/[component_name].h
	member export_as_libc: bool;

	@@:true if @this function should be exported as part of the c++ std:: namespace
	member export_in_std: bool;

	@@:true if @this function should be provided as part of the kernel
	member export_in_kernel: bool;

	@@:true if @this function should not be exported by libc
	member dont_export_symbol: bool;

	@@Set of exceptions to-be annotated in `__THROWS(throws_decl...)'
	member throws_decl: {string...} | FunctionAlias | bool;

	@@:true if @this function should have a guard within its standard header
	member guarded_function: bool;

	@@:true if @this function has a fast variant, optionally defined in <optimized/[component_name].h>
	member has_fast_implementation: bool;

	@@List of (condition_expr, impl) of preferred, inline implementations
	member preferred_impl: {(string, string)...};

	@@:true if @this function's base name isn't a valid alias
	member nocrt: bool;

	@@:true if @this function should not appear in src/libc/user headers
	member nouser: bool;

	@@:true if @this function should appear in src/libc/user headers
	member douser: bool;

	@@:true if @this function is a c++ overload alias (e.g. abs(long) = labs)
	member overload_alias: bool;

	@@:true if @this function needs a dos- and a kos-variant in libc
	member wchar_function: bool;

	@@Name for the u16-variant of this function (in case it is used as a uchar-function)
	member uchar16_function_name: string | none;

	@@Name for the u32-variant of this function (in case it is used as a uchar-function)
	member uchar32_function_name: string | none;

	@@2 or 4 if this is a uchar-function
	member uchar_function: int | none;

	@@:true if @this function is a helper (not exported, and doesn't appear in headers)
	member helper_function: bool;

	@@Tuple of the exact types of optional arguments passed through varargs
	member vartypes: {string...};

	@@The C-preprocessor dependency string of conditions that must be fulfilled in order for this function to be declared (when `none', automatically determine those conditions)
	member dependency_string: string | none;

	@@A human-readable string documenting this function's behavior
	member doc: string;

	@@The block used to implement the function
	member block: none | string | FunctionAlias | UndefinedFunctionAlias;

	@@Sequence of additional function names that @this function's implementation requires
	member forced_dependencies: {string...};

	@@A block of text that is emit prior to the functions's implementation
	member impl_prefix: string;

	@@A block of text that is emit prior to requires expressions in local definition files
	member requires_prefix: string;

	@@A block of text that is emit prior to declaring the function in local definition files
	member declaration_prefix: string;

	@@A block of text that is emit prior to entering the function's implementation namespace
	member dependency_prefix: string;

	@@An override for the function's libc implementation body
	member libc_impl: string | none;

	@@An override for the function's user implementation body
	member user_impl: string | none;

	@@0-based starting line number of @block
	member block_starting_line: int;

	@@Filename of the definitions file containing @block
	member block_definintions_file: string;

	member allow_macros: bool;

	member argument_names: {string...};

	member nosys_errno: string | none;

	@@Set to true if this function received a libc implementation
	member got_implementation: bool = false;

	@@Prefix for the libc implementation section of this function
	member impl_section: string | none;

	@@Name of the component that this function is apart of
	member component_name: string;

	@@DOS export names of this function (defaults to `[key_libd_export(name)]')
	member dosnames: {string...};

	operator str() -> name;
	operator repr() -> "Function({!r}, ...)".format({ name });

	private member m_dependencies: {Function...};
	private member m_dependencies_names: {string...};
	private member m_localvars: {string...};

	@@Returns the {(string, string)...} block of arguments for an alias `name'
	private function args_for(name) {
		local result;
		result = alias_args.get(name);
		if (result is none)
			return args;
		return result[0];
	}
	@@Returns the return type expression string for an alias `name'
	private function return_type_for(name) {
		local result;
		result = alias_args.get(name);
		if (result is none)
			return return_type;
		return result[1];
	}

	@@Returns the printf-like assembly name for `name', or none if no such name exists
	private function get_asmnamef_for(name) {
		/* TODO */
		return none;
	}

	@@Returns :true if the function itself should be skipped as a valid alias
	private property skip_self_alias = {
		get() {
			if (nocrt)
				return true;
			for (local none, x: aliases)
				if (x == name)
					return true;
			for (local none, x: preferred_aliases)
				if (x == name)
					return true;
			return false;
		}
	}

	function has_conditionless_alias(name) {
		for (local none, alias_name: aliases) {
			if (alias_name == name)
				return true;
		}
		return false;
	}

	@@Enumerate tuples (symbol_or_macro_name, conditions) of the different link options of @this function
	@@NOTE: Enumerate follows the same order in which the function would be linked in a header
	public function enum_link_conditions(): {(string, string)...} {
		local symbol_name = name;
		local symbol_has_fast_implementation = has_fast_implementation;
		local symbol_preferred_impl = preferred_impl;
		if (block is FunctionAlias) {
			symbol_name = block.func.name;
			symbol_has_fast_implementation = block.func.has_fast_implementation;
			symbol_preferred_impl = block.func.preferred_impl;
		} else if (block is UndefinedFunctionAlias) {
			symbol_name = block.name;
			symbol_has_fast_implementation = false;
			symbol_preferred_impl = {};
		}
		if (symbol_has_fast_implementation)
			yield (symbol_name, "defined(__fast_{}_defined)".format({ symbol_name }));
		if (symbol_preferred_impl) {
			for (local cond, none: symbol_preferred_impl)
				yield (symbol_name, cond);
		}
		for (local cond, alias_name: preferred_aliases) {
			if (has_conditionless_alias(alias_name))
				continue; /* Skip preferred aliases that appear again as regular ones. */
			if (cond in ["", "1"])
				yield (alias_name, key_crt_have(alias_name));
			else {
				yield (alias_name, "{} && {}".format({
					key_crt_have(alias_name),
					add_paren_if_necessary(cond, true)
				}));
			}
		}
		if (block is FunctionAlias)
			yield (name, key_crt_have(name));
		if (!skip_self_alias)
			yield (symbol_name, key_crt_have(symbol_name));
		for (local cond, alias_name: aliases) {
			if (cond in ["", "1"])
				yield (alias_name, key_crt_have(alias_name));
			else {
				yield (alias_name, "{} && {}".format({
					key_crt_have(alias_name),
					add_paren_if_necessary(cond, true)
				}));
			}
		}
	}

	@@Returns or generate the dependency string of @this function
	@@>> #if $get_dependency_string(foo)$
	@@>> #define FOO_IS_SUPPORTED 1
	@@>> #endif
	public function get_dependency_string(): string {
		if (dependency_string !is none)
			return dependency_string;
		File.Writer fp;
		local result;
		if (this.block is string) {
			/* A default implementation is being provided */
			if (define_require_string in ["", "1"])
				return "1";
			format_define_require_string(fp, define_require_string);
			local block_deps = fp.string;
			if (block_deps in ["", "1"])
				return "1";
			for (local none, cond: enum_link_conditions())
				fp << " || " << add_paren_if_necessary(cond, false);
			result = fp.string;
		} else {
			fp << "1";
			for (local none, cond: enum_link_conditions())
				fp << " || " << add_paren_if_necessary(cond, false);
			if (define_require_string) {
				File.Writer tempfp;
				format_define_require_string(tempfp, define_require_string);
				fp << " || " << add_paren_if_necessary(tempfp.string, false);
			} else if (this.block is FunctionAlias) {
				local temp = this.block.func.get_dependency_string();
				if (temp in ["", "1"])
					return "1";
				fp << " || " << temp;
			} else {
				local is_first = true;
				for (local d: this.dependencies) {
					local temp;
					temp = d.get_dependency_string();
					if (temp in ["", "1"])
						continue;
					if (is_first) {
						fp << " || (";
						is_first = false;
					} else {
						fp << " && ";
					}
					fp add_paren_if_necessary(temp, false);
				}
				if (!is_first)
					fp << ")";
			}
			result = fp.string;
			if (result.startswith("1 || "))
				result = result[#"1 || ":];
			if (result.startswith("(") &&
			    result.findmatch("(", ")", 1) == #result - 1)
				result = result[1:-1];
		}
		return result
			.replace("1 && ", "")
			.replace(" && 1", "");
	}

	public property defaultEnv: {string: Object} = {
		get(): {string: Object} {
			return { "self" : this };
		}
	}

	public function getThrowsAnnotations(): {string...} | bool {
		local result = throws_decl;
		if (result !is bool) {
			if (result is FunctionAlias) {
				result = result.func;
				if (result is string)
					result = functions[result];
				result = result.getThrowsAnnotations();
				throws_decl = result;
			}
		}
		return result;
	}

	public function getThrowsAnnotationsExpanded(): {string...} {
		local anno = getThrowsAnnotations();
		if (!anno)
			return anno;
		local usedAnno = [];
		for (local x: anno) {
			if (x.startswith("like:")) {
				local inner = functions[x[5:]].getThrowsAnnotationsExpanded();
				if (inner !is bool) {
					for (local a: inner) {
						if (a !in usedAnno)
							usedAnno.append();
					}
				}
			} else if (x !in usedAnno) {
				usedAnno.append(x);
			}
		}
		return usedAnno;
	}

	public function hasThrowsAnnotation() {
		local anno = getThrowsAnnotationsExpanded();
		if (!anno) {
			if (anno === false)
				return false;
			for (local at: attr_tags) {
				if (at.strip() in nothrow_attributes)
					return false; /* Function has a nothrow annotation */
			}
		}
		return true;
	}

	public function printThrowsAnnotation(fp: File, prefix: string = " ") {
		local anno = getThrowsAnnotationsExpanded();
		if (!anno) {
			if (anno === false)
				return false;
			for (local at: attr_tags) {
				if (at.strip() in nothrow_attributes)
					return; /* Function has a nothrow annotation */
			}
			anno = { "..." };
		}
		fp << prefix << "__THROWS(" << ", ".join(anno) << ")";
	}

	private function analyze_block() {
		m_dependencies = List();
		m_dependencies_names = HashSet();
		m_localvars = HashSet(args_by_name.keys);
		if (block !is string) return;
		for (local is_word, word: split_words(block, env: this)) {
			local dep;
			if (!is_word) continue;
			if (word in macros)
				continue;
			if (word.startswith("$"))
				continue;
			if (word in replacement_words)
				continue;
			if (word in args_by_name)
				continue;
			if (word in c_keywords)
				continue;
			dep = functions_prototypes.get(word, none);
			if (dep is none) {
				if (word.startswith("__"))
					continue;
				m_localvars.insert(word);
			} else if (word != name) {
				if (word !in m_dependencies_names) {
					m_dependencies_names.insert(word);
					m_dependencies.append(dep);
				}
			}
		}
		for (local word: forced_dependencies) {
			if (word !in m_dependencies_names) {
				m_dependencies_names.insert(word);
				local dep = functions_prototypes.get(word, none);
				if (dep is none) {
					print "Error: Dependency", repr word, "of", repr name, "could not be found";
					throw "Dependency could not be found";
				}
				m_dependencies.append(dep);
			}
		}
	}

	@@Functions that have been referenced by this one's block
	property dependencies: {Function...} = {
		get(): {Function...} {
			if (m_dependencies !is bound)
				analyze_block();
			return m_dependencies;
		}
	}

	@@Names of all the local variables and arguments
	property localvars: {string...} = {
		get(): {string...} {
			if (m_localvars !is bound)
				analyze_block();
			return m_localvars;
		}
	}

	@@Print @this function's documentation string to @fp
	function print_doc(fp: File, wchar_t_replacement: int = none) {
		if (!print_documention_strings)
			return;
		local used_doc = doc;
		if (wchar_t_replacement !is none) {
			/* Re-format documentation for uchar variants. */
			used_doc = replaceDocKeywordWords(used_doc, [](fp: File, word: string) {
				local referenced_function = functions.get(word);
				if (referenced_function is none || !referenced_function.wchar_function) {
					fp << word;
				} else {
					local uchar_name = wchar_t_replacement == WCHAR_MODE_DOS
						? referenced_function.uchar16_function_name
						: referenced_function.uchar32_function_name;
					if (!uchar_name) {
						print "Unknown uchar{}-variant of function {} referenced in documentation of {}"
							.format({ wchar_t_replacement == WCHAR_MODE_DOS ? 16 : 32, referenced_function.name, this.name });
						throw "Unknown uchar-function referenced in documentation";
					}
					fp << uchar_name;
				}
			});
		}
		local lines = List(used_doc.splitlines());
		if (!lines)
			return;
		fp << "/* " << lines[0].rstrip();
		if (#lines == 1) {
			fp << " */\n";
		} else {
			for (local l: lines[1:]) {
				l = l.rstrip();
				fp << "\n *";
				if (l)
					fp << " " << l;
			}
			fp << " */\n";
		}
	}

	function do_transform_block(
			fp: File, block: string, keydep: Callable, keyself: Callable,
			keyloc: Callable, repl_words: int, wchar_t_replacement: int = none) {
		if (keyself is none)
			keyself = keydep;
		if (keyloc is none)
			keyloc = keydep;
		if (m_localvars !is bound)
			analyze_block();
		local must_write_line = include_line_directives;
		for (local is_word, word: split_words(block, env: this)) {
			if (is_word) {
				if (word in m_localvars)
					word = keyloc(word);
				else if (word in m_dependencies_names) {
					if (keydep === key_libd_internal) {
						local fun = functions.get(word);
						if (fun is none || !fun.wchar_function)
							word = key_libc_internal(word);
						else if (!fun.has_fast_implementation) {
							word = keydep(word);
						}
					} else if (keydep === key_libc_internal) {
						local fun = functions.get(word);
						/* Don't redirect functions with potential fast-implementations.
						 * Since the libc_* prototypes don't account for those, we still
						 * want to be a use them if they exist, so don't redirect fast
						 * function calls. */
						if (fun is none || !fun.has_fast_implementation)
							word = keydep(word);
					} else {
						if (wchar_t_replacement !is none) {
							local dep;
							for (dep: m_dependencies)
								if (dep.name == word)
									break;
							assert dep.name == word, "word = {!r}".format({ word });
							if (dep.wchar_function) {
								word = wchar_t_replacement == WCHAR_MODE_DOS
									? dep.uchar16_function_name
									: dep.uchar32_function_name
									;
								assert word, "dep = {!r}".format({ dep.name });
							}
						}
						word = keydep(word);
					}
				} else if (word == name) {
					if (wchar_t_replacement !is none &&
					    keyself !== key_libc_internal &&
					    keyself !== key_libd_internal) {
						word = wchar_t_replacement == WCHAR_MODE_DOS
							? this.uchar16_function_name
							: this.uchar32_function_name;
					}
					word = keyself(word);
				} else {
					word = replace_word(word, repl_words, wchar_t_replacement);
				}
			} else if (must_write_line && "\n" in word) {
				local before, none, after = word.rpartition("\n")...;
				fp << before << "\n#line " << (block_starting_line + before.count("\n") + 2)
				   << " " << repr("kos/" + block_definintions_file)
				   << "\n" << after;
				must_write_line = false;
				continue;
			}
			fp << word;
		}
	}

	@@Transform the function's block, using @keydep to transform the names
	@@of dependencies and @keyloc to transform the names of local variables.
	function transform_block(
			fp: File, keydep: Callable, keyself: Callable = none,
			keyloc: Callable = none, repl_words: int = REPLACE_TYPE_WORDS_LOCAL,
			wchar_t_replacement: int = none) {
		do_transform_block(
			fp, block, keydep, keyself, keyloc,
			repl_words, wchar_t_replacement);
	}

	function print_dependency_prefix(
			fp: File, keydep: Callable, keyloc: Callable = none,
			repl_words: int = REPLACE_TYPE_WORDS_LOCAL,
			wchar_t_replacement: int = none) {
		local old = include_line_directives;
		include_line_directives = false;
		do_transform_block(fp, declaration_prefix, keydep, keydep, keyloc, repl_words, wchar_t_replacement);
		do_transform_block(fp, dependency_prefix, keydep, keydep, keyloc, repl_words, wchar_t_replacement);
		include_line_directives = old;
	}

	function print_impl_prefix(
			fp: File, keydep: Callable, keyloc: Callable = none,
			repl_words: int = REPLACE_TYPE_WORDS_LOCAL,
			wchar_t_replacement: int = none) {
		local old = include_line_directives;
		include_line_directives = false;
		do_transform_block(
			fp, impl_prefix, keydep, keydep,
			keyloc, repl_words, wchar_t_replacement);
		include_line_directives = old;
	}

	function print_argument_list(
			fp: File, args: {(string, string)...},
			keyarg: Callable, args_prefix: string = "",
			replace_type_words: int = REPLACE_TYPE_WORDS_LOCAL,
			wchar_t_replacement: int = none) {
		if (!args) {
			fp << "void";
			return;
		}
		for (local i = 0; i < #args; ++i) {
			local tp, nm = args[i]...;
			if (tp) {
				File.Writer tempfp;
				for (local is_word, word: split_words(tp, env: this)) {
					if (is_word)
						word = replace_word(word, replace_type_words, wchar_t_replacement);
					tempfp << word;
				}
				fp << join_variable_name(tempfp.string, nm ? keyarg(nm) : "");
			} else {
				for (local is_word, word: split_words(nm, env: this)) {
					if (is_word)
						word = replace_word(word, replace_type_words, wchar_t_replacement);
					fp << word;
				}
			}
			if (i < #args - 1) {
				if (args_prefix) {
					fp << ",\n" << args_prefix;
				} else {
					fp << ", ";
				}
			}
		}
	}

	function print_argument_name_list(
			fp: File, args: {(string, string)...},
			keyarg: Callable, incspc: bool = true) {
		for (local i = 0; i < #args; ++i) {
			local none, nm = args[i]...;
			if (!nm) {
				if (this.argument_names !is none)
					nm = this.argument_names[i];
			} else {
				nm = keyarg(nm);
			}
			fp << nm;
			if (i < #args - 1) {
				fp << ",";
				if (incspc)
					fp << " ";
			}
		}
	}

	function print_argument_cast_list(
			fp: File, args: {(string, string)...},
			keyarg: Callable, is_uchar_variant: bool = false,
			add_paren_during_cast: bool = false) {
		local my_args = this.args;
		if (block is FunctionAlias)
			my_args = block.func.args;
		for (local i = 0; i < #args; ++i) {
			local tp, nm = args[i]...;
			if (nm) {
				local my_type = my_args[i][0];
				if (is_uchar_variant)
					my_type = replace_wchar_words(my_type, uchar_function == 2 ? WCHAR_MODE_DOS : WCHAR_MODE_KOS, env: this);
				if (!is_implicitly_castable(tp, my_type)) {
					fp << "(";
					for (local is_word, word: split_words(my_type, env: this)) {
						if (is_word) {
							if (word in argument_cast_omit_keyword_list)
								continue;
							word = replace_word(word, REPLACE_TYPE_WORDS_LOCAL);
						}
						fp << word;
					}
					fp << ")";
					if (add_paren_during_cast)
						fp << "(";
					fp << keyarg(nm);
					if (add_paren_during_cast)
						fp << ")";
				} else {
					fp << keyarg(nm);
				}
			}
			if (i < #args - 1) fp << ", ";
		}
	}

	function must_cast_arguments_when_calling(
			args: {(string, string)...}, is_uchar_variant: bool = false) {
		local my_args = this.args;
		if (block is FunctionAlias)
			my_args = block.func.args;
		for (local i = 0; i < #args; ++i) {
			local tp, nm = args[i]...;
			if (nm) {
				local my_type = my_args[i][0];
				if (is_uchar_variant)
					my_type = replace_wchar_words(my_type, uchar_function == 2 ? WCHAR_MODE_DOS : WCHAR_MODE_KOS, env: this);
				if (!is_implicitly_castable(tp, my_type))
					return true;
			}
		}
		return false;
	}

	function must_cast_return_when_calling(
			return_type: string, is_uchar_variant: bool = false) {
		local my_return_type = this.return_type;
		if (block is FunctionAlias)
			my_return_type = block.func.return_type;
		if (is_uchar_variant)
			my_return_type = replace_wchar_words(my_return_type, uchar_function == 2 ? WCHAR_MODE_DOS : WCHAR_MODE_KOS, env: this);
		if (!is_implicitly_castable(return_type, my_return_type))
			return true;
		return false;
	}

	function getUcharVariant(wchar_t_replacement: int): Function {
		assert wchar_t_replacement == WCHAR_MODE_DOS || wchar_t_replacement == WCHAR_MODE_KOS;
		return functions.get(wchar_t_replacement == WCHAR_MODE_DOS ? uchar16_function_name : uchar32_function_name);
	}

	function generate_local_impl(
			fp: File, with_copyright: bool = true,
			wchar_t_replacement: int | none = none) {
		assert block is string;
		local used_name = name;
		if (wchar_t_replacement !is none) {
			if (wchar_t_replacement == WCHAR_MODE_DOS)
				used_name = this.uchar16_function_name;
			else if (wchar_t_replacement == WCHAR_MODE_KOS)
				used_name = this.uchar32_function_name;
		}
		if (with_copyright)
			fp << copyright << "\n";
		fp << "#ifndef __local_" << used_name << "_defined\n";
		if (define_require_string) {
			for (local none, word: split_words(requires_prefix, env: this))
				fp << word;
			fp << "#if ";
			format_define_require_string(fp, define_require_string);
			fp << "\n";
		}
		fp << "#define __local_" << used_name << "_defined 1\n";
		/* Include dependencies. */
		local fast_dependency_components = HashSet();
		local dependency_prefix_lines = List();
		if (hasThrowsAnnotation())
			dependency_prefix_lines.append("#include <kos/anno.h>");
		for (local f: dependencies) {
			if (f.declaration_prefix) {
				File.Writer tempfp;
				for (local none, word: split_words(f.declaration_prefix, env: f))
					tempfp << word;
				dependency_prefix_lines.extend(tempfp.string.splitlines());
			}
			if (!f.has_fast_implementation)
				continue;
			if (f.component_name !is bound)
				continue;
			fast_dependency_components.insert(f.component_name);
		}
		local known_includes = HashSet();
		for (local l: dependency_prefix_lines) {
			l = l.rstrip();
			if (!l.lstrip())
				continue;
			local include_filename = none;
			try include_filename = l.scanf(" # include <%[^>]>")...; catch (...);
			if (include_filename !is none) {
				if (include_filename in known_includes)
					continue;
				known_includes.insert(include_filename);
			}
			fp << l << "\n";
		}
		if (fast_dependency_components) {
			fast_dependency_components = List(fast_dependency_components);
			fast_dependency_components.sort();
			fp << "#ifdef __LIBC_BIND_OPTIMIZATIONS\n";
			for (local x: fast_dependency_components) {
				local include_filename = "optimized/{}.h".format({ x });
				if (include_filename !in known_includes)
					fp << "#include <" << include_filename << ">\n";
			}
			fp << "#endif /* __LIBC_BIND_OPTIMIZATIONS */\n";
		}
		print_dependency_prefix(fp, key_dependency, key_underscore, REPLACE_TYPE_WORDS_LOCAL, wchar_t_replacement);
		for (local f: dependencies) {
			fp << "/* Dependency: " << repr f.name;
			if (f.component_name is bound)
				fp << " from " << repr f.component_name;
			fp << " */\n";
			if (wchar_t_replacement !is none && f.wchar_function) {
				local repl = f.getUcharVariant(wchar_t_replacement);
				if (repl is none)
					throw "wchar function {!r} used by {!r} has no uchar{} variant"
						.format({ f.name, this.name, wchar_t_replacement == WCHAR_MODE_DOS ? "16" : "32" });
				f = repl;
			}
			f.generate_header_block(fp, key_dependency, none, false, true, true, REPLACE_TYPE_WORDS_LOCAL);
			fp << "\n";
		}
		fp << "__NAMESPACE_LOCAL_BEGIN\n";
		print_impl_prefix(fp, key_dependency, key_underscore, REPLACE_TYPE_WORDS_LOCAL, wchar_t_replacement);
		print_doc(fp, wchar_t_replacement);
		fp << "__LOCAL_LIBC(" << used_name << ") ";
		local is_nothrow = "";
		for (local at: attr_tags) {
			at = at.strip();
			if (at in nothrow_attributes) {
				is_nothrow = at[#"ATTR_":];
				continue;
			}
			fp << key_attr_header(at) << " ";
		}
		for (local is_word, word: split_words(return_type, env: this)) {
			if (is_word)
				word = replace_word(word, REPLACE_TYPE_WORDS_LOCAL, wchar_t_replacement);
			fp << word;
		}
		fp << "\n";
		local args_prefix = "({} {})(".format({
			args_is_varargs ? "__VLIBCCALL" : "__LIBCCALL",
			key_libclocal(used_name)
		});
		if (is_nothrow) args_prefix = "__" + is_nothrow + args_prefix;
		//if (is_nothrow) args_prefix = "__" + is_nothrow + "(" + args_prefix;
		fp << args_prefix;
		args_prefix = " " * #args_prefix;
		print_argument_list(fp, args, key_underscore, args_prefix, REPLACE_TYPE_WORDS_LOCAL, wchar_t_replacement);
		//if (is_nothrow) fp << ")";
		fp << ")";
		printThrowsAnnotation(fp);
		fp << " ";
		transform_block(fp, key_dependency, key_libclocal, key_underscore, REPLACE_TYPE_WORDS_LOCAL, wchar_t_replacement);
		fp << "\n__NAMESPACE_LOCAL_END\n";
		if (define_require_string) {
			fp << "#endif /* ";
			format_define_require_string_comment(fp, define_require_string);
			fp << " */\n";
		}
		fp << "#endif /* !__local_" << used_name << "_defined */\n";
		return fp;
	}

	function do_generate_libc_proto(fp: File, key: Callable) {
		print_doc(fp);
		if ((block is FunctionAlias || block is UndefinedFunctionAlias) && !douser) {
			fp	<< "#define "
				<< key(name) << " "
				<< key(block.func.name) << "\n";
			return;
		}
		fp << "INTDEF ";
		local is_nothrow = "";
		for (local at: attr_tags) {
			at = at.strip();
			if (at in nothrow_attributes) {
				is_nothrow = at[#"ATTR_":];
				continue;
			}
			fp << key_attr_source(at) << " ";
		}
		local wchar_mode = wchar_mode_for_key(key);
		File.Writer return_type_fp;
		File.Writer function_decl_fp;
		for (local is_word, word: split_words(return_type, env: this)) {
			if (is_word)
				word = replace_word(word, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
			return_type_fp << word;
		}
		function_decl_fp << is_nothrow << "(";
		if (args_is_varargs)
			function_decl_fp << "V";
		function_decl_fp << cc_for_key(key) << " " << key(name) << ")(";
		print_argument_list(
			function_decl_fp, args, key_identity, "", REPLACE_TYPE_WORDS_LIBC, wchar_mode);
		function_decl_fp << ")";
		printThrowsAnnotation(function_decl_fp);
		fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
		//if (is_nothrow) fp << ")";
		fp << ";\n";
	}

	function generate_libc_proto(fp: File) {
		do_generate_libc_proto(fp, key_libc_internal);
		if (wchar_function)
			do_generate_libc_proto(fp, key_libd_internal);
	}

	function get_section_prefix(wchar_mode: int) {
		if (impl_section !is none) {
			if (impl_section.startswith("$")) {
				switch (impl_section[1:]) {
				case "kos":
					goto do_return_crt;
				case "dos":
					goto do_return_dos;
				}
			}
			if (impl_section.startswith("{") && impl_section.endswith("}")) {
				assert "|" in impl_section;
				local a, none, b = impl_section[1:-1].partition("|")...;
				if (wchar_mode == WCHAR_MODE_DOS)
					return b.strip();
				return a.strip();
			}
			return impl_section;
		}
		if (wchar_mode == WCHAR_MODE_DOS) {
do_return_dos:
			return ".text.crt.dos.unsorted";
		}
do_return_crt:
		return ".text.crt.unsorted";
	}

	function generate_libc_impl(fp: File, key: Callable) {
		assert block is string;
		this.got_implementation = true;
		local wchar_mode = wchar_mode_for_key(key);
		print_dependency_prefix(fp, key, key_identity, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
		print_impl_prefix(fp, key, key_identity, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
		print_doc(fp);
		generate_libc_user_impl_proto_head(fp, key);
		fp << "INTERN ";
		local is_nothrow = "";
		local has_attributes = false;
		for (local at: attr_tags) {
			at = at.strip();
			if (at in nothrow_attributes) {
				is_nothrow = at[#"ATTR_":];
				continue;
			}
			if (has_attributes)
				fp << " ";
			has_attributes = true;
			fp << key_attr_source(at);
		}
		/* Auto implementations are defined weakly, each in its own section.
		 * That way, the linker can simply remove unused sections when the
		 * function has been overwritten by an arch-specific / better
		 * implementation! */
		if (has_attributes) fp << "\n";
		fp << "ATTR_WEAK ATTR_SECTION(\"{}.".format({
			get_section_prefix(wchar_mode)
		}) << name << "\") ";
		for (local is_word, word: split_words(return_type, env: this)) {
			if (is_word)
				word = replace_word(word, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
			fp << word;
		}
		fp << "\n";
		local args_prefix = "(" + (args_is_varargs ? "V" : "") + cc_for_key(key) + " " + key(name) + ")(";
		if (is_nothrow) args_prefix = is_nothrow + args_prefix;
		//if (is_nothrow) args_prefix = is_nothrow + "(" + args_prefix;
		fp << args_prefix;
		args_prefix = " " * #args_prefix;
		print_argument_list(
			fp, args, key_identity, args_prefix, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
		//if (is_nothrow) fp << ")";
		fp << ")";
		printThrowsAnnotation(fp);
		fp << " ";
		if (libc_impl !is none) {
			do_transform_block(
				fp, libc_impl, key, key, key_identity,
				REPLACE_TYPE_WORDS_LIBC, wchar_mode);
			//fp << libc_impl;
		} else {
			transform_block(fp, key, key, key_identity, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
		}
		fp << "\n";
		generate_libc_user_impl_proto_tail(fp);
	}

	function get_is_noreturn(): bool {
		return "ATTR_NORETURN" in attr_tags;
	}

	function print_default_body(fp: File, is_dos: bool) {
		if (user_impl !is none && user_impl) {
			fp << "/*AUTO*/";
			File.Writer tempfp;
			local o = include_line_directives;
			include_line_directives = false;
			local key = is_dos ? key_libd_internal : key_libc_internal;
			do_transform_block(
				tempfp, user_impl,
				key,
				key,
				key_identity,
				REPLACE_TYPE_WORDS_LIBC,
				is_dos ? WCHAR_MODE_DOS : WCHAR_MODE_KOS);
			include_line_directives = o;
			tempfp = tempfp.string;
			for (;;) {
				local new_tempfp = tempfp.replace("\n\n","\n");
				if (new_tempfp == tempfp)
					break;
				tempfp = new_tempfp;
			}
			fp << tempfp;
//			fp << tempfp.replace("\t", " ");
			if (!tempfp.endswith("\n"))
				fp << "\n";
			return;
		}
		if (name !in unimplemented_functions)
			unimplemented_functions.insert(name);
		fp << "{\n";
		fp << "\tCRT_UNIMPLEMENTED(" << repr(name) << "); /* TO"  "DO */\n";
		if (nosys_errno !is none)
			fp << "\tlibc_seterrno(" << nosys_errno << ");\n";
		if (get_is_noreturn()) {
			fp << "\tfor (;;) {\n";
			fp << "\t}\n";
		} else {
			local rt = get_default_return_expression();
			if (rt)
				fp << "\treturn " << rt << ";\n";
		}
		fp << "}\n";
	}


	function get_default_return_expression(): string {
		if (return_type == "void")
			return "";
		if (return_type.endswith("*"))
			return "NULL";
		if (return_type.lstrip("$") in [
			"int", "ssize_t", "pid_t", "fd_t",
			"long", "long int", "off_t", "off64_t",
			"short", "short int"])
			return "-1";
		return "0";
	}

	function generate_libc_user_impl_proto_head(fp: File, key: Callable) {
		if (intern_aliases) {
			local myname = key(name);
			fp << "#if";
			for (local cond, alias_name: intern_aliases) {
				if (alias_name is Cell)
					alias_name = key(alias_name.value);
				fp << " " << cond << "\n";
				fp << "DEFINE_INTERN_ALIAS(" << myname << ", " << alias_name << ");\n";
				fp << "#el";
			}
			fp << "se\n";
		}
	}
	function generate_libc_user_impl_proto_tail(fp: File) {
		if (intern_aliases)
			fp << "#endif /* MAGIC:alias */\n";
	}
	function generate_libc_user_impl_proto(fp: File, key: Callable) {
		print_doc(fp);
		generate_libc_user_impl_proto_head(fp, key);
		fp << "INTERN ";
		local is_nothrow = "";
		local has_attributes = false;
		local wchar_mode = wchar_mode_for_key(key);
		for (local at: attr_tags) {
			at = at.strip();
			if (at in nothrow_attributes) {
				is_nothrow = at[#"ATTR_":];
				continue;
			}
			if (has_attributes)
				fp << " ";
			has_attributes = true;
			fp << key_attr_source(at);
		}
		/* Auto implementations are defined weakly, each in its own section.
		 * That way, the linker can simply remove unused sections when the
		 * function has been overwritten by an arch-specific / better
		 * implementation! */
		if (has_attributes) fp << "\n";
		fp << "ATTR_WEAK ATTR_SECTION(\"{}.".format({
			get_section_prefix(wchar_mode)
		}) << name << "\") ";
		for (local is_word, word: split_words(return_type, env: this)) {
			if (is_word)
				word = replace_word(word, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
			fp << word;
		}
		fp << "\n";
		local args_prefix = "(" + (args_is_varargs ? "V" : "") + cc_for_key(key) + " " + key(name) + ")(";
		if (is_nothrow) args_prefix = is_nothrow + args_prefix;
		//if (is_nothrow) args_prefix = is_nothrow + "(" + args_prefix;
		fp << args_prefix;
		args_prefix = " " * #args_prefix;
		print_argument_list(
			fp, args, key_identity, args_prefix, REPLACE_TYPE_WORDS_LIBC, wchar_mode);
		//if (is_nothrow) fp << ")";
		fp << ")\n";
		if (hasThrowsAnnotation()) {
			printThrowsAnnotation(fp, "\t\t");
			fp << "\n";
		}
	}



	function print_macro_alias(
			fp: File, my_name: string, alias_name_expr: string, alias_name: string,
			transform_argument_types: int = REPLACE_TYPE_WORDS_LOCAL,
			is_uchar_variant: bool = false, dont_cast: bool = false) {
		print_doc(fp);
		if (dont_cast) {
			fp << "#define " << my_name << " " << alias_name_expr << "\n";
		} else if (args_is_varargs) {
#if 1 /* TODO: Account for leading argument types; TODO: Account for return type */
			fp << "#define " << my_name << " " << alias_name_expr << "\n";
#else
			fp << "#define " << my_name << "(";
			if (args_is_varargs)
				fp << "...) " << alias_name_expr << "(__VA_ARGS__)\n";
#endif
		} else {
			local a = args_for(alias_name);
			local must_cast_return =
				must_cast_return_when_calling(return_type_for(alias_name), is_uchar_variant) &&
				this.return_type !in ["", "void"];
			if (!must_cast_arguments_when_calling(a, is_uchar_variant)) {
				fp << "#define " << my_name << " ";
				if (must_cast_return) {
					fp << "(";
					for (local is_word, word: split_words(this.return_type, env: this)) {
						if (is_word)
							word = replace_word(word, transform_argument_types);
						fp << word;
					}
					fp << ")";
				}
				fp << alias_name_expr << "\n";
			} else {
				fp << "#define " << my_name << "(";
				print_argument_name_list(fp, a, key_identity);
				fp << ") ";
				if (must_cast_return) {
					fp << "(";
					for (local is_word, word: split_words(this.return_type, env: this)) {
						if (is_word)
							word = replace_word(word, transform_argument_types);
						fp << word;
					}
					fp << ")";
				}
				fp << alias_name_expr << "(";
				print_argument_cast_list(fp, a, key_identity, is_uchar_variant, true);
				fp << ")\n";
			}
		}
	}


	@@@param keyname Key function used to generate the name of the symbol to which the function will be bound
	@@@param namespace_name Name of the namespace within which to define the function (Used in $"__NAMESPACE_{}_BEGIN" and the like)
	@@@param include_overloads When :true, include C++ overloads
	@@@param with_guard When :true, surround with a $"#ifndef __{}_defined" guard
	@@@param allow_macros When :true, allow the function to be defined as a macro (requires @namespace_name set to :none)
	@@Generate the substitution string
	generate_header_block(
			fp: File, keyname: Callable = none, namespace_name: string = none,
			include_overloads: bool = true, with_guard: bool = true,
			allow_macros: bool = false,
			transform_argument_types: int = REPLACE_TYPE_WORDS_LOCAL) {
		local my_name = keyname is none ? name : keyname(name);
		local guard_name = none;
		local symbol_name = name;
		local symbol_component_name;
		local symbol_has_fast_implementation = has_fast_implementation;
		local symbol_preferred_impl = preferred_impl;
		local symbol_return_type = return_type;
		if (component_name is bound)
			symbol_component_name = component_name;
		if (block is FunctionAlias) {
			symbol_name = block.func.name;
			symbol_return_type = block.func.return_type;
			symbol_component_name = block.func.component_name;
			symbol_has_fast_implementation = block.func.has_fast_implementation;
			symbol_preferred_impl = block.func.preferred_impl;
		} else if (block is UndefinedFunctionAlias) {
			symbol_name = block.name;
			symbol_return_type = none;
			symbol_component_name = none;
			symbol_has_fast_implementation = false;
			symbol_preferred_impl = {};
		}
		if (with_guard) {
			guard_name = "__";
			if (namespace_name)
				guard_name += namespace_name.lower() + "_";
			guard_name += my_name;
			guard_name += "_defined";
			fp << "#ifndef " << guard_name << "\n"
			      "#define " << guard_name << " 1\n";
		}
		if (keyname === key_libc || keyname === key_libc_slow) {
			fp << "#";
		} else if (namespace_name !is none && guarded_function) {
			fp << "#ifdef __" << my_name << "_defined\n";
			fp << "__NAMESPACE_GLB_USING(" << my_name << ")\n";
			fp << "#el";
		} else if (namespace_name is none && std_guard && export_in_std) {
			fp << "#ifdef __std_" << my_name << "_defined\n";
			fp << "__NAMESPACE_STD_USING(" << my_name << ")\n";
			fp << "#el";
		} else {
			fp << "#";
		}
		if (include_overloads && extended_overloads) {
			fp << "if defined(__cplusplus) && defined(__CORRECT_ISO_CPP_" + component_name.upper().replace(".", "_") + "_H_PROTO)\n";
			function print_redirection(alias_name) {
				fp << "extern \"C++\" {\n";
				local is_nothrow = "";
				local attr_text = "";
				for (local at: attr_tags) {
					at = at.strip();
					if (at in nothrow_attributes) {
						is_nothrow = at[#"ATTR_":];
						continue;
					}
					if (attr_text) attr_text += " ";
					attr_text += key_attr_header(at);
				}
				for (local args, return_type: extended_overloads) {
					local is_void_return = false;
					if (return_type == "void")
						is_void_return = true;
					if (args_is_varargs) {
						/* TODO */
					} else {
						print_doc(fp);
						fp << "__CREDIRECT";
						if (is_void_return) fp << "_VOID";
						local asmname = alias_name;
						if (asmname.startswith("DOS$")) {
							fp << "_DOS";
							asmname = asmname[4:];
						}
						fp << "(" << attr_text << ",";
						if (!is_void_return) {
							for (local is_word, word: split_words(return_type, env: this)) {
								if (is_word)
									word = replace_word(word, transform_argument_types);
								fp << word;
							}
							fp << ",";
						}
						if (is_nothrow)
							fp << "__";
						fp << is_nothrow << "," << my_name << ",(";
						print_argument_list(fp, args, key_underscore, "", transform_argument_types);
						fp << ")," << asmname << ",(";
						print_argument_name_list(fp, args, key_underscore);
						fp << "))";
						printThrowsAnnotation(fp);
						fp << "\n";
					}
				}
				fp << "}\n";
			}
			/* Try to link an optimized version of the function */
			if (symbol_has_fast_implementation || symbol_preferred_impl) {
				local decl_prefix = "__FORCELOCAL ";
				local is_nothrow = "";
				for (local at: attr_tags) {
					at = at.strip();
					if (at in nothrow_attributes) {
						is_nothrow = at[#"ATTR_":];
						continue;
					}
					decl_prefix += key_attr_header(at) + " ";
				}
				local args_prefix = "(__LIBCCALL {})(".format({ my_name });
				if (is_nothrow) args_prefix = "__" + is_nothrow + args_prefix;
				if (symbol_preferred_impl) {
					local is_first = true;
					for (local cond, impl: symbol_preferred_impl) {
						fp << "#";
						if (!is_first)
							fp << "el";
						fp << "if ";
						is_first = false;
						fp << cond << "\n";
						fp << "extern \"C++\" {\n";
						for (local args, return_type: extended_overloads) {
							File.Writer return_type_fp;
							File.Writer function_decl_fp;
							for (local is_word, word: split_words(return_type, env: this)) {
								if (is_word)
									word = replace_word(word, transform_argument_types);
								return_type_fp << word;
							}
							function_decl_fp << args_prefix;
							print_argument_list(
								function_decl_fp, args, key_underscore,
								(single_line_local_wrappers ? "" : " " * #args_prefix),
								transform_argument_types);
							//if (is_nothrow) fp << ")";
							function_decl_fp << ")";
							printThrowsAnnotation(function_decl_fp);
							print_doc(fp);
							fp << decl_prefix;
							fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
							fp << " ";
							do_transform_block(
								fp, impl, key_identity, key_identity,
								key_underscore, transform_argument_types, none);
							fp << "\n";
						}
						fp << "}\n";
					}
					if (symbol_has_fast_implementation) {
						fp << "#elif defined(__fast_" << symbol_name << "_defined)\n";
						fp << "extern \"C++\" {\n";
					}
				} else {
					assert symbol_has_fast_implementation;
					fp << "#ifdef __fast_" << symbol_name << "_defined\n"
					      "extern \"C++\" {\n";
				}
				if (symbol_has_fast_implementation) {
					if (args_is_varargs) {
						/* TODO */
					} else {
						for (local args, return_type: extended_overloads) {
							File.Writer return_type_fp;
							File.Writer function_decl_fp;
							for (local is_word, word: split_words(return_type, env: this)) {
								if (is_word)
									word = replace_word(word, transform_argument_types);
								return_type_fp << word;
							}
							function_decl_fp << args_prefix;
							print_argument_list(
								function_decl_fp, args, key_underscore,
								(single_line_local_wrappers ? "" : " " * #args_prefix),
								transform_argument_types);
							//if (is_nothrow) fp << ")";
							function_decl_fp << ")";
							printThrowsAnnotation(function_decl_fp);
							print_doc(fp);
							fp << decl_prefix;
							fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
							fp << " {" << (single_line_local_wrappers ? " " : "\n    ");
							if (return_type != "void") {
								fp << "return ";
								if (!is_implicitly_castable(symbol_return_type, return_type)) {
									fp << "(";
									for (local is_word, word: split_words(return_type, env: this)) {
										if (is_word && word !in c_keywords)
											word = replace_word(word, transform_argument_types);
										fp << word;
									}
									fp << ")";
								}
							}
							fp << "(__NAMESPACE_FAST_SYM " << key_fastimpl(symbol_name) << ")(";
							print_argument_cast_list(fp, args, key_underscore);
							fp << (single_line_local_wrappers ? "); }\n" : ");\n}\n");
						}
					}
					fp << "}\n";
				}
				for (local cond, alias_name: preferred_aliases) {
					fp << "#elif " << key_crt_have(alias_name);
					if (cond) fp << " && (" << cond << ")";
					fp << "\n";
					print_redirection(alias_name);
				}
				if (block is FunctionAlias) {
					fp << "#elif " << key_crt_have(name) << "\n";
					print_redirection(name);
					fp << "#elif " << key_crt_have(symbol_name) << "\n";
					print_redirection(symbol_name);
				} else if (!skip_self_alias) {
					fp << "#elif " << key_crt_have(symbol_name) << "\n";
					print_redirection(symbol_name);
				}
			} else if (block is FunctionAlias) {
				local did_alias_primary = false;
				local is_first = true;
				for (local cond, alias_name: preferred_aliases) {
					fp << (is_first ? "#if " : "#elif ");
					is_first = false;
					fp << key_crt_have(alias_name);
					if (cond) fp << " && (" << cond << ")";
					fp << "\n";
					print_redirection(alias_name);
					if (alias_name == symbol_name)
						did_alias_primary = true;
				}
				if (!skip_self_alias) {
					fp << (is_first ? "#if " : "#elif ") << key_crt_have(name) << "\n";
					is_first = false;
					print_redirection(name);
				}
				if (!did_alias_primary) {
					fp << (is_first ? "#if " : "#elif ") << key_crt_have(symbol_name) << "\n";
					print_redirection(symbol_name);
				}
			} else if (skip_self_alias) {
				local is_first = true;
				for (local cond, alias_name: preferred_aliases) {
					fp << "#" << (is_first ? "" : "el") << "if "
						<< key_crt_have(alias_name);
					is_first = false;
					if (cond) fp << " && (" << cond << ")";
					fp << "\n";
					print_redirection(alias_name);
				}
				for (local cond, alias_name: aliases) {
					fp << "#" << (is_first ? "" : "el") << "if "
						<< key_crt_have(alias_name);
					is_first = false;
					if (cond) fp << " && (" << cond << ")";
					fp << "\n";
					print_redirection(alias_name);
				}
				goto skip_alias_redirections;
			} else {
				fp << "#";
				for (local cond, alias_name: preferred_aliases) {
					fp << "if " << key_crt_have(alias_name);
					if (cond) fp << " && (" << cond << ")";
					fp << "\n";
					print_redirection(alias_name);
					fp << "#el";
				}
				fp << "if " << key_crt_have(symbol_name) << "\n";
				print_redirection(symbol_name);
			}
			for (local cond, alias_name: aliases) {
				fp << "#elif " << key_crt_have(alias_name);
				if (cond) fp << " && (" << cond << ")";
				fp << "\n";
				print_redirection(alias_name);
			}
skip_alias_redirections:
			if (block !is UndefinedFunctionAlias && block !is none &&
			   (block !is FunctionAlias ||
			   (block.func.block !is UndefinedFunctionAlias &&
			    block.func.block !is none))) {
				function bind_local_function(symbol_name: string, is_uchar_variant: bool = false) {
					if (overload_alias)
						fp << "} /* extern \"C++\" { */\n";
					if (namespace_name !is none)
						fp << "__NAMESPACE_" << namespace_name << "_END\n";
					fp << "#include <local/" << symbol_component_name << "/" << symbol_name << ".h>\n";
					if (namespace_name !is none)
						fp << "__NAMESPACE_" << namespace_name << "_BEGIN\n";
					if (overload_alias)
						fp << "extern \"C++\" {\n";
					fp << "extern \"C++\" {\n";
					if (args_is_varargs) {
						/* TODO */
					} else {
						local decl_prefix = "__FORCELOCAL ";
						local is_nothrow = "";
						for (local at: attr_tags) {
							at = at.strip();
							if (at in nothrow_attributes) {
								is_nothrow = at[#"ATTR_":];
								continue;
							}
							decl_prefix += key_attr_header(at) + " ";
						}
						local args_prefix = "(__LIBCCALL {})(".format({ my_name });
						if (is_nothrow) args_prefix = "__" + is_nothrow + args_prefix;
						//if (is_nothrow) args_prefix = "__" + is_nothrow + "(" + args_prefix;
						for (local args, return_type: extended_overloads) {
							File.Writer return_type_fp;
							File.Writer function_decl_fp;
							for (local is_word, word: split_words(return_type, env: this)) {
								if (is_word && word !in c_keywords)
									word = replace_word(word, transform_argument_types);
								return_type_fp << word;
							}
							function_decl_fp << args_prefix;
							print_argument_list(
								function_decl_fp, args, key_underscore,
								(single_line_local_wrappers ? "" : " " * #args_prefix),
								transform_argument_types);
							//if (is_nothrow) function_decl_fp << ")";
							function_decl_fp << ")";
							printThrowsAnnotation(function_decl_fp);
							print_doc(fp);
							fp << decl_prefix;
							fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
							fp << " {" << (single_line_local_wrappers ? " " : "\n    ");
							if (return_type != "void") {
								fp << "return ";
								local used_symbol_return_type = symbol_return_type;
								if (is_uchar_variant)
									used_symbol_return_type = replace_wchar_words(used_symbol_return_type, uchar_function == 2 ? WCHAR_MODE_DOS : WCHAR_MODE_KOS, env: this);
								if (!is_implicitly_castable(used_symbol_return_type, return_type)) {
									fp << "(";
									for (local is_word, word: split_words(return_type, env: this)) {
										if (is_word && word !in c_keywords)
											word = replace_word(word, transform_argument_types);
										fp << word;
									}
									fp << ")";
								}
							}
							fp << "(__NAMESPACE_LOCAL_SYM " << key_libclocal(symbol_name) << ")(";
							print_argument_cast_list(fp, args, key_underscore, is_uchar_variant);
							fp << (single_line_local_wrappers ? "); }\n" : ");\n}\n");
						}
					}
					fp << "}\n";
				}
				local always_available = true;
				local effective_define_require = define_require_string;
				if (!effective_define_require && block is FunctionAlias)
					effective_define_require = block.func.define_require_string;
				if (uchar_function !is none) {
					if (effective_define_require) {
						File.Writer tempfp;
						format_define_require_string(tempfp, effective_define_require);
						tempfp = tempfp.string;
						if (tempfp !in ["", "1"]) {
							fp << "#elif " << tempfp << "\n";
							always_available = false;
						}
					}
					if (always_available) {
						fp << "#elif __SIZEOF_WCHAR_T__ == " << uchar_function << "\n";
						bind_local_function(symbol_name);
						fp << "#else /* LIBC: " << name << " */\n";
						bind_local_function(name, true);
					} else {
						fp << "#if __SIZEOF_WCHAR_T__ == " << uchar_function << "\n";
						bind_local_function(symbol_name);
						fp << "#else /* LIBC: " << name << " */\n";
						bind_local_function(name, true);
						fp << "#endif /* LIBC: " << name << " */\n";
					}
				} else {
					if (effective_define_require) {
						File.Writer tempfp;
						format_define_require_string(tempfp, effective_define_require);
						tempfp = tempfp.string;
						if (tempfp !in ["", "1"]) {
							fp << "#elif " << tempfp << "\n";
							always_available = false;
						}
					}
					if (always_available)
						fp << "#else /* LIBC: " << symbol_name << " */\n";
					bind_local_function(symbol_name);
				}
				if (!always_available && with_guard) {
					fp << "#else /* CUSTOM: " << symbol_name << " */\n"
						  "#undef " << guard_name << "\n";
				}
			} else if (with_guard) {
				fp << "#else /* LIBC: " << symbol_name << " */\n"
				      "#undef " << guard_name << "\n";
			}
			fp << "#endif /* " << name << "... */\n";
			fp << "#else /* __cplusplus && __CORRECT_ISO_CPP_"
				<< component_name.upper().replace(".", "_")
				<< "_H_PROTO */\n";
			fp << "#";
		}
		function print_redirection(alias_name) {
			function print_same_name_declaration() {
				print_doc(fp);
				fp << "__LIBC ";
				local is_nothrow = "";
				for (local at: attr_tags) {
					at = at.strip();
					if (at in nothrow_attributes) {
						is_nothrow = at[#"ATTR_":];
						continue;
					}
					fp << key_attr_header(at) << " ";
				}
				File.Writer return_type_fp;
				File.Writer function_decl_fp;
				local rt = return_type_for(alias_name);
				for (local is_word, word: split_words(rt, env: this)) {
					if (is_word)
						word = replace_word(word, transform_argument_types);
					return_type_fp << word;
				}
				if (is_nothrow)
					function_decl_fp << "__" << is_nothrow;
				function_decl_fp << "(__"
					<< (args_is_varargs ? "V" : "")
					<< (alias_name.startswith("DOS$") ? "LIBDCALL" : "LIBCCALL")
					<< " " << my_name << ")(";
				print_argument_list(function_decl_fp, args_for(alias_name), key_underscore, "", transform_argument_types);
				function_decl_fp << ")";
				printThrowsAnnotation(function_decl_fp);
				fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
			}
			if (args_is_varargs && (("DOS$" + my_name) == alias_name)) {
				fp << "\n";
				print_same_name_declaration();
				fp << " __CASMNAME_SAME_DOS(" << repr(my_name) << ");\n";
			} else if (my_name == alias_name) {
				if (args_is_varargs) {
					fp << "\n";
					print_same_name_declaration();
					fp << " __CASMNAME_SAME(" << repr(my_name) << ");\n";
				} else {
					local is_nothrow = "";
					local is_void_return = false;
					local attr_text = "";
					for (local at: attr_tags) {
						at = at.strip();
						if (at in nothrow_attributes) {
							is_nothrow = at[#"ATTR_":];
							continue;
						}
						if (attr_text) attr_text += " ";
						attr_text += key_attr_header(at);
					}
					local rt = return_type_for(alias_name);
					if (rt == "void")
						is_void_return = true;
					fp << "\n";
					print_doc(fp);
					fp << "__CDECLARE";
					if (is_void_return) fp << "_VOID";
					fp << "(" << attr_text << ",";
					if (!is_void_return) {
						for (local is_word, word: split_words(rt, env: this)) {
							if (is_word)
								word = replace_word(word, transform_argument_types);
							fp << word;
						}
						fp << ",";
					}
					if (is_nothrow)
						fp << "__" << is_nothrow;
					fp << "," << my_name << ",(";
					local a = args_for(alias_name);
					print_argument_list(fp, a, key_underscore, "", transform_argument_types);
					fp << "),(";
					print_argument_name_list(fp, a, key_underscore, false);
					fp << "))";
					printThrowsAnnotation(fp);
					fp << "\n";
				}
			} else {
				if (args_is_varargs) {
					if (vartypes) {
						local is_nothrow = "";
						local is_void_return = false;
						local attr_text = "";
						for (local at: attr_tags) {
							at = at.strip();
							if (at in nothrow_attributes) {
								is_nothrow = at[#"ATTR_":];
								continue;
							}
							if (attr_text) attr_text += " ";
							attr_text += key_attr_header(at);
						}
						local rt = return_type_for(alias_name);
						if (rt == "void")
							is_void_return = true;
						fp << "\n";
						print_doc(fp);
						fp << "__CVREDIRECT";
						if (is_void_return) fp << "_VOID";
						fp << "(" << attr_text << ",";
						if (!is_void_return) {
							for (local is_word, word: split_words(rt, env: this)) {
								if (is_word)
									word = replace_word(word, transform_argument_types);
								fp << word;
							}
							fp << ",";
						}
						if (is_nothrow)
							fp << "__" << is_nothrow;
						fp << "," << my_name << ",(";
						local a = args_for(alias_name)[:-1];
						print_argument_list(fp, a, key_underscore, "", transform_argument_types);
						fp << ")," << alias_name << ",(";
						print_argument_name_list(fp, a, key_underscore, false);
						fp << ")," << key_underscore(a[#a-1][1]) << "," << #vartypes << ",(";
						fp << ",".join(for (local t: vartypes)
							(for (local is_word, word: split_words(t, env: this))
								(is_word
									? replace_word(word, transform_argument_types)
									: word)) + ...);
						fp << "))";
						printThrowsAnnotation(fp);
						fp << "\n";
					} else if (get_asmnamef_for(alias_name) !is none) {
						local is_nothrow = "";
						local is_void_return = false;
						local attr_text = "";
						for (local at: attr_tags) {
							at = at.strip();
							if (at in nothrow_attributes) {
								is_nothrow = at[#"ATTR_":];
								continue;
							}
							if (attr_text) attr_text += " ";
							attr_text += key_attr_header(at);
						}
						local rt = return_type_for(alias_name);
						if (rt == "void")
							is_void_return = true;
						fp << "\n";
						print_doc(fp);
						fp << "__CVFREDIRECT";
						if (is_void_return) fp << "_VOID";
						fp << "(" << attr_text << ",";
						if (!is_void_return) {
							for (local is_word, word: split_words(rt, env: this)) {
								if (is_word)
									word = replace_word(word, transform_argument_types);
								fp << word;
							}
							fp << ",";
						}
						if (is_nothrow)
							fp << "__" << is_nothrow;
						fp << "," << my_name << ",(";
						local a = args_for(alias_name);
						print_argument_list(fp, a, key_underscore, "", transform_argument_types);
						fp << ")," << alias_name << "," << get_asmnamef_for(alias_name) << ",(";
						a = a[:-1];
						print_argument_name_list(fp, a, key_underscore, false);
						fp << ")," << key_underscore(a[#a-1][1]) << ")";
						printThrowsAnnotation(fp);
						fp << "\n";
					} else {
						fp << " && !defined(__NO_ASMNAME)\n";
						print_same_name_declaration();
						fp << " __CASMNAME";
						if (alias_name.startswith("DOS$")) {
							fp << "_DOS(" << repr(alias_name[4:]) << ");\n";
						} else {
							fp << "(" << repr(alias_name) << ");\n";
						}
					}
				} else {
					local is_nothrow = "";
					local is_void_return = false;
					local attr_text = "";
					for (local at: attr_tags) {
						at = at.strip();
						if (at in nothrow_attributes) {
							is_nothrow = at[#"ATTR_":];
							continue;
						}
						if (attr_text) attr_text += " ";
						attr_text += key_attr_header(at);
					}
					local rt = return_type_for(alias_name);
					if (rt == "void")
						is_void_return = true;
					fp << "\n";
					print_doc(fp);
					fp << "__CREDIRECT";
					if (is_void_return) fp << "_VOID";
					local asmname = alias_name;
					if (asmname.startswith("DOS$")) {
						fp << "_DOS";
						asmname = asmname[4:];
					}
					fp << "(" << attr_text << ",";
					if (!is_void_return) {
						for (local is_word, word: split_words(rt, env: this)) {
							if (is_word && word !in c_keywords)
								word = replace_word(word, transform_argument_types);
							fp << word;
						}
						fp << ",";
					}
					if (is_nothrow)
						fp << "__" << is_nothrow;
					fp << "," << my_name << ",(";
					local a = args_for(alias_name);
					print_argument_list(fp, a, key_underscore, "", transform_argument_types);
					fp << ")," << asmname << ",(";
					print_argument_name_list(fp, a, key_underscore, false);
					fp << "))";
					printThrowsAnnotation(fp);
					fp << "\n";
				}
			}
		}
		fp << "if";
		if (symbol_preferred_impl) {
			local is_first = true;
			for (local cond, impl: symbol_preferred_impl) {
				is_first = false;
				fp << " " << cond << "\n";
				print_doc(fp);
				fp << "__FORCELOCAL ";
				local is_nothrow = "";
				for (local at: attr_tags) {
					at = at.strip();
					if (at in nothrow_attributes) {
						is_nothrow = at[#"ATTR_":];
						continue;
					}
					fp << key_attr_header(at) << " ";
				}
				local args_prefix = "({} {})(".format({ args_is_varargs ? "__VLIBCCALL" : "__LIBCCALL", my_name });
				if (is_nothrow) args_prefix = "__" + is_nothrow + args_prefix;
				File.Writer return_type_fp;
				File.Writer function_decl_fp;
				for (local is_word, word: split_words(return_type, env: this)) {
					if (is_word)
						word = replace_word(word, transform_argument_types);
					return_type_fp << word;
				}
				function_decl_fp << args_prefix;
				print_argument_list(
					function_decl_fp, args, key_underscore,
					(single_line_local_wrappers ? "" : " " * #args_prefix),
					transform_argument_types);
				function_decl_fp << ")";
				printThrowsAnnotation(function_decl_fp);
				fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
				fp << " ";
				do_transform_block(
					fp, impl, key_identity, key_identity,
					key_underscore, transform_argument_types, none);
				fp << "\n#elif";
			}
		}
		/* Try to link an optimized version of the function */
		if (symbol_has_fast_implementation) {
			fp << " defined(__fast_" << symbol_name << "_defined)";
			if (args_is_varargs) {
				fp << " && defined(__cplusplus)\n";
				fp << "__NAMESPACE_FAST_USING(" << symbol_name << ")\n";
			} else {
				fp << "\n";
				if (allow_macros) {
					if (my_name == symbol_name) {
						fp << "#ifdef __cplusplus\n";
						fp << "__NAMESPACE_FAST_USING(" << symbol_name << ")\n";
						fp << "#else /* __cplusplus */\n";
					}
					print_macro_alias(fp, my_name, "(__NAMESPACE_FAST_SYM " + key_fastimpl(symbol_name) + ")", symbol_name);
					if (my_name == symbol_name)
						fp << "#endif /* !__cplusplus */\n";
				} else if (args_is_varargs) {
					if (my_name == symbol_name) {
						fp << "#ifdef __cplusplus\n";
						fp << "__NAMESPACE_FAST_USING(" << symbol_name << ")\n";
						fp << "#else /* __cplusplus */\n";
					}
					/* TODO */
					print_macro_alias(fp, my_name, "(__NAMESPACE_FAST_SYM " + key_fastimpl(symbol_name) + ")", symbol_name);
					if (my_name == symbol_name)
						fp << "#endif /* !__cplusplus */\n";
				} else {
					if (my_name == symbol_name) {
						if (single_line_local_wrappers) {
							print_doc(fp);
							fp << "__NAMESPACE_FAST_USING_OR_IMPL(" << symbol_name << ", ";
						} else {
							fp << "#ifdef __cplusplus\n";
							fp << "__NAMESPACE_FAST_USING(" << symbol_name << ")\n";
							fp << "#else /* __cplusplus */\n";
							print_doc(fp);
						}
					} else {
						print_doc(fp);
					}
					fp << "__FORCELOCAL ";
					local is_nothrow = "";
					for (local at: attr_tags) {
						at = at.strip();
						if (at in nothrow_attributes) {
							is_nothrow = at[#"ATTR_":];
							continue;
						}
						fp << key_attr_header(at) << " ";
					}
					local args_prefix = "({} {})(".format({ args_is_varargs ? "__VLIBCCALL" : "__LIBCCALL", my_name });
					if (is_nothrow) args_prefix = "__" + is_nothrow + args_prefix;
					//if (is_nothrow) args_prefix = "__" + is_nothrow + "(" + args_prefix;
					File.Writer return_type_fp;
					File.Writer function_decl_fp;
					for (local is_word, word: split_words(return_type, env: this)) {
						if (is_word)
							word = replace_word(word, transform_argument_types);
						return_type_fp << word;
					}
					function_decl_fp << args_prefix;
					print_argument_list(
						function_decl_fp, args, key_underscore,
						(single_line_local_wrappers ? "" : " " * #args_prefix),
						transform_argument_types);
					//if (is_nothrow) function_decl_fp << ")";
					function_decl_fp << ")";
					printThrowsAnnotation(function_decl_fp);
					fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
					fp << " {" << (single_line_local_wrappers ? " " : "\n    ");
					if (return_type != "void") {
						fp << "return ";
						if (!is_implicitly_castable(symbol_return_type, return_type)) {
							fp << "(";
							for (local is_word, word: split_words(return_type, env: this)) {
								if (is_word)
									word = replace_word(word, transform_argument_types);
								fp << word;
							}
							fp << ")";
						}
					}
					fp << "(__NAMESPACE_FAST_SYM " << key_fastimpl(symbol_name) << ")(";
					print_argument_cast_list(fp, args, key_underscore);
					if (my_name == symbol_name && single_line_local_wrappers) {
						fp << "); })\n";
					} else {
						fp << (single_line_local_wrappers ? "); }\n" : ");\n}\n");
						if (my_name == symbol_name)
							fp << "#endif /* !__cplusplus */\n";
					}
				}
			}
			for (local cond, alias_name: preferred_aliases) {
				fp << "#elif " << key_crt_have(alias_name);
				if (cond) fp << " && (" << cond << ")";
				print_redirection(alias_name);
			}
			if (block is FunctionAlias) {
				if (!skip_self_alias) {
					fp << "#elif " << key_crt_have(name);
					print_redirection(name);
				}
				fp << "#elif " << key_crt_have(symbol_name);
				print_redirection(symbol_name);
			} else if (!skip_self_alias) {
				fp << "#elif " << key_crt_have(symbol_name);
				print_redirection(symbol_name);
			}
		} else if (block is FunctionAlias) {
			local is_first = true;
			local did_alias_primary = false;
			for (local cond, alias_name: preferred_aliases) {
				if (!is_first)
					fp << "#elif";
				fp << " " << key_crt_have(alias_name);
				if (cond) fp << " && (" << cond << ")";
				print_redirection(alias_name);
				is_first = false;
				if (alias_name == symbol_name)
					did_alias_primary = true;
			}
			if (!skip_self_alias) {
				if (!is_first)
					fp << "#elif";
				is_first = false;
				fp << " " << key_crt_have(name);
				print_redirection(name);
			}
			if (!did_alias_primary) {
				if (!is_first)
					fp << "#elif";
				fp << " " << key_crt_have(symbol_name);
				print_redirection(symbol_name);
			}
		} else if (skip_self_alias) {
			local is_first = true;
			for (local cond, alias_name: preferred_aliases) {
				if (!is_first)
					fp << "#elif";
				is_first = false;
				fp << " " << key_crt_have(alias_name);
				if (cond) fp << " && (" << cond << ")";
				print_redirection(alias_name);
			}
			for (local cond, alias_name: aliases) {
				if (!is_first)
					fp << "#elif";
				is_first = false;
				fp << " " << key_crt_have(alias_name);
				if (cond) fp << " && (" << cond << ")";
				print_redirection(alias_name);
			}
			assert !is_first, "name = " + name;
			goto skip_alias_redirections2;
		} else {
			for (local cond, alias_name: preferred_aliases) {
				fp << " " << key_crt_have(alias_name);
				if (cond) fp << " && (" << cond << ")";
				print_redirection(alias_name);
				fp << "#elif";
			}
			fp << " " << key_crt_have(symbol_name);
			print_redirection(symbol_name);
		}
		for (local cond, alias_name: aliases) {
			fp << "#elif " << key_crt_have(alias_name);
			if (cond) fp << " && (" << cond << ")";
			print_redirection(alias_name);
		}
skip_alias_redirections2:
		if (block !is UndefinedFunctionAlias && block !is none &&
		   (block !is FunctionAlias ||
		   (block.func.block !is UndefinedFunctionAlias &&
		    block.func.block !is none))) {
			function bind_local_function(symbol_name: string, is_uchar_variant: bool = false) {
				if (args_is_varargs) {
					if (overload_alias)
						fp << "} /* extern \"C++\" { */\n";
					if (namespace_name !is none)
						fp << "__NAMESPACE_" << namespace_name << "_END\n";
					fp << "#include <local/" << symbol_component_name << "/" << symbol_name << ".h>\n";
					if (namespace_name !is none)
						fp << "__NAMESPACE_" << namespace_name << "_BEGIN\n";
					if (overload_alias)
						fp << "extern \"C++\" {\n";
					if (my_name == symbol_name) {
						fp << "#ifdef __cplusplus\n";
						fp << "__NAMESPACE_LOCAL_USING(" << symbol_name << ")\n";
						fp << "#else /* __cplusplus */\n";
					}
					if (allow_macros) {
						print_macro_alias(
							fp, my_name, "(__NAMESPACE_LOCAL_SYM " + key_libclocal(symbol_name) + ")",
							symbol_name, transform_argument_types, is_uchar_variant);
					} else {
						/* TODO */
						print_macro_alias(
							fp, my_name, "(__NAMESPACE_LOCAL_SYM " + key_libclocal(symbol_name) + ")",
							symbol_name, transform_argument_types, is_uchar_variant);
					}
					if (my_name == symbol_name)
						fp << "#endif /* !__cplusplus */\n";
				} else {
					if (overload_alias)
						fp << "} /* extern \"C++\" { */\n";
					if (namespace_name !is none)
						fp << "__NAMESPACE_" << namespace_name << "_END\n";
					fp << "#include <local/" << symbol_component_name << "/" << symbol_name << ".h>\n";
					if (namespace_name !is none)
						fp << "__NAMESPACE_" << namespace_name << "_BEGIN\n";
					if (overload_alias)
						fp << "extern \"C++\" {\n";
					if (allow_macros) {
						if (my_name == symbol_name) {
							fp << "#ifdef __cplusplus\n";
							fp << "__NAMESPACE_LOCAL_USING(" << symbol_name << ")\n";
							fp << "#else /* __cplusplus */\n";
						}
						print_macro_alias(
							fp, my_name, "(__NAMESPACE_LOCAL_SYM " + key_libclocal(symbol_name) + ")",
							symbol_name, transform_argument_types, is_uchar_variant);
						if (my_name == symbol_name)
							fp << "#endif /* !__cplusplus */\n";
					} else {
						if (!single_line_local_wrappers) {
							fp << "#ifdef __cplusplus\n";
							fp << "__NAMESPACE_LOCAL_USING(" << symbol_name << ")\n";
							fp << "#else /* __cplusplus */\n";
							print_doc(fp);
						} else if (my_name == symbol_name) {
							print_doc(fp);
							fp << "__NAMESPACE_LOCAL_USING_OR_IMPL(" << symbol_name << ", ";
						} else {
							print_doc(fp);
						}
						fp << "__FORCELOCAL ";
						local is_nothrow = "";
						for (local at: attr_tags) {
							at = at.strip();
							if (at in nothrow_attributes) {
								is_nothrow = at[#"ATTR_":];
								continue;
							}
							fp << key_attr_header(at) << " ";
						}
						local args_prefix = "(__LIBCCALL {})(".format({ my_name });
						if (is_nothrow) args_prefix = "__" + is_nothrow + args_prefix;
						//if (is_nothrow) args_prefix = "__" + is_nothrow + "(" + args_prefix;
						File.Writer return_type_fp;
						File.Writer function_decl_fp;
						for (local is_word, word: split_words(return_type, env: this)) {
							if (is_word)
								word = replace_word(word, transform_argument_types);
							return_type_fp << word;
						}
						function_decl_fp << args_prefix;
						print_argument_list(
							function_decl_fp, args, key_underscore,
							(single_line_local_wrappers ? "" : " " * #args_prefix),
							transform_argument_types);
						//if (is_nothrow) fp << ")";
						function_decl_fp << ")";
						printThrowsAnnotation(function_decl_fp);
						fp << join_variable_name(return_type_fp.string, function_decl_fp.string);
						fp << " {" << (single_line_local_wrappers ? " " : "\n    ");
						if (return_type != "void") {
							fp << "return ";
							local used_symbol_return_type = symbol_return_type;
							if (is_uchar_variant)
								used_symbol_return_type = replace_wchar_words(used_symbol_return_type, uchar_function == 2 ? WCHAR_MODE_DOS : WCHAR_MODE_KOS, env: this);
							if (!is_implicitly_castable(used_symbol_return_type, return_type)) {
								fp << "(";
								for (local is_word, word: split_words(return_type, env: this)) {
									if (is_word)
										word = replace_word(word, transform_argument_types);
									fp << word;
								}
								fp << ")";
							}
						}
						fp << "(__NAMESPACE_LOCAL_SYM " << key_libclocal(symbol_name) << ")(";
						print_argument_cast_list(fp, args, key_underscore, is_uchar_variant);
						if (single_line_local_wrappers && my_name == symbol_name) {
							fp << "); })\n";
						} else {
							fp << (single_line_local_wrappers ? "); }\n" : ");\n}\n");
							if (my_name == symbol_name)
								fp << "#endif /* !__cplusplus */\n";
						}
					}
				}
			}
			local effective_define_require = define_require_string;
			if (!effective_define_require && block is FunctionAlias)
				effective_define_require = block.func.define_require_string;
			local always_available = true;
			if (uchar_function !is none) {
				if (effective_define_require) {
					File.Writer tempfp;
					format_define_require_string(tempfp, effective_define_require);
					tempfp = tempfp.string;
					if (tempfp !in ["", "1"]) {
						fp << "#elif " << tempfp << "\n";
						always_available = false;
					}
				}
				if (always_available) {
					fp << "#elif __SIZEOF_WCHAR_T__ == " << uchar_function << "\n";
					bind_local_function(symbol_name);
					fp << "#else /* LIBC: " << name << " */\n";
					bind_local_function(name, true);
				} else {
					fp << "#if __SIZEOF_WCHAR_T__ == " << uchar_function << "\n";
					bind_local_function(symbol_name);
					fp << "#else /* LIBC: " << name << " */\n";
					bind_local_function(name, true);
					fp << "#endif /* LIBC: " << name << " */\n";
				}
			} else {
				if (effective_define_require) {
					File.Writer tempfp;
					format_define_require_string(tempfp, effective_define_require);
					tempfp = tempfp.string;
					if (tempfp in ["", "1"]) {
						fp << "#else /* LIBC: " << symbol_name << " */\n";
					} else {
						fp << "#elif " << tempfp << "\n";
						always_available = false;
					}
				} else {
					fp << "#else /* LIBC: " << symbol_name << " */\n";
				}
				bind_local_function(symbol_name);
			}
			if (!always_available && with_guard) {
				fp << "#else /* CUSTOM: " << symbol_name << " */\n"
				      "#undef " << guard_name << "\n";
			}
		} else if (with_guard) {
			fp << "#else /* LIBC: " << symbol_name << " */\n"
			      "#undef " << guard_name << "\n";
		}
		fp << "#endif /* " << name << "... */\n";
		if (include_overloads && extended_overloads)
			fp << "#endif /* !__cplusplus || !__CORRECT_ISO_CPP_" + component_name.upper().replace(".", "_") + "_H_PROTO */\n";
		if (guard_name !is none)
			fp << "#endif /* !" << guard_name << " */\n";
		return fp;
	}

}



@@Safely re-write a hashed file @filename, by calling ${fp_writer(fp: File)}
function write_hashed_file(filename: string, fp_writer: Callable) {
	local old_text = none;
	try {
		local firstline;
		with (local old_fp = File.open(filename, "r")) {
			firstline = old_fp.readline();
			old_text = old_fp.read();
		}
		if (!firstline)
			goto do_overwrite_file;
		local old_hash = firstline.decode("utf-8").scanf(" /* HASH %[^ *]")...;
		old_hash = old_hash.strip();
		local old_hash_name, none, old_hash_value = old_hash.partition(":")...;
		local expected_old_hash = hash(old_hash_name, old_text).hex();
		if (old_hash_value != expected_old_hash) {
			print "\n\n",;
			print getFilenameForLog(filename),;
			print ": Error: File", repr filename, "has been modified";
			print "\tStored hash:  ", old_hash_value;
			print "\tExpected hash:", expected_old_hash;
			throw "Don't overwrite modified File";
		}
	} catch (Error.SystemError.FSError.FileNotFound) {
		/* Fallthough -- Re-write the File. */
	} catch (Error.ValueError.UnpackError) {
		print "\n\n",;
		print getFilenameForLog(filename),;
		print ": Error: File", repr filename, "has been modified";
		print "\tNo hash information tag found within the File";
		throw "Don't overwrite modified File";
	}
do_overwrite_file:
	File.Writer contents;
	fp_writer(contents);
	contents = contents.string.encode("utf-8").bytes();
	if (old_text is none || old_text != contents) {
		with (local fp = File.open(filename, "w")) {
			local new_hash = hash(hashfunc, contents).hex();
			fp << "/* HASH " << hashfunc << ":" << new_hash << " */\n";
			fp.write(contents);
		}
	}
}

function write_hashed_file_l(filename: string, fp_writer: Callable) {
	print "Updating File: ", filename;
	return write_hashed_file(filename, fp_writer);
}


@@Mapping between component names and their respective functions
@@> components["string"] // { Function("memcpy", ...), Function("memmove", ...), ... }
global components: {string: {Function...}} = Dict();

@@Mapping between functions, and their names
@@> functions["memcpy"] // Function("memcpy", ...)
global functions: {string: Function} = Dict();

global functions_prototypes = Dict();
global all_functions = List();
@@The names of all of the known sections
global known_libc_sections: {string...} = HashSet();
global unimplemented_functions: {string...} = HashSet();

@@Load components
function load_dir(path: string, prefix: string) {
	for (local name: fs.dir(path)) {
		local filename = path + "/" + name;
		if (!filename.endswith(".c"))
			continue;
		if (fs.stat.isdir(filename)) {
			//load_dir(filename, prefix + name + ".");
			continue;
		}
		local text = File.open(filename).read().decode("utf-8");
		print "Parsing definitions File:", filename;
		local funcs = List(parse_functions(filename, text));
		local comname = prefix + fs.fileof(name);
		components[comname] = funcs;
		for (local f: funcs) {
			if (f !is Function) continue;
			if (f.helper_function) {
				if (f.name !in functions)
					functions[f.name] = f;
				if (f.component_name !is bound)
					f.component_name = comname;
				if (f.name !in functions_prototypes || functions_prototypes[f.name].overload_alias)
					functions_prototypes[f.name] = f;
				all_functions.append(f);
				continue;
			}
			if (!f.overload_alias) {
				functions_prototypes[f.name] = f;
				functions[f.name] = f;
			}
			all_functions.append(f);
			if (f.block is none)
				continue;
			if (f.component_name !is bound)
				f.component_name = comname;
		}
	}
}
load_dir("src/libc/magic", "");

/* Resolve doc aliases */
for (local func: all_functions) {
	if (func.doc is CopyFunctionBody) {
		local alias_func = functions.get(func.doc.name);
		if (alias_func is none) {
			print "Function", repr func.name, "is aliasing doc of unknown function", repr func.doc.name;
			throw "Failed to find aliased function";
		}
		if (alias_func.doc is CopyFunctionBody) {
			print "Function", repr func.name, "is aliasing doc of function", repr alias_func.name, "which is aliasing", repr func.doc.name;
			print "Recursive doc aliasing isn't allowed";
			throw "Failed to find aliased function";
		}
		func.doc = func.doc.convert(alias_func, func, alias_func.doc);
	}
}

local auto_reformat_doc_uchar_functions: {Function...} = HashSet();

global linkFunctionAliases;
function inheritFunctionArguments(func: Function, alias_func: Function, convert: Callable = none) {
	if (func.args == {("*", "")}) {
		linkFunctionAliases(alias_func);
		/* Inherit arguments. */
		func.args = alias_func.args;
		func.return_type = alias_func.return_type;
		func.args_is_varargs = alias_func.args_is_varargs;
		func.args_by_name = alias_func.args_by_name;
		func.extended_overloads = alias_func.extended_overloads;
		if (convert !is none) {
			func.args = List(for (local tp, nm: func.args) (
				convert(alias_func, func, tp),
				nm
			));
			func.return_type = convert(alias_func, func, func.return_type);
			func.extended_overloads = List(
				for (local args, return_type: func.extended_overloads) (
					List(for (local tp, nm: args) (
						convert(alias_func, func, tp),
						nm
					)),
					convert(alias_func, func, return_type)
				)
			);
		}
		if (func.uchar_function !is none && alias_func.wchar_function) {
			local wchar_mode = func.uchar_function == 2 ? WCHAR_MODE_DOS : WCHAR_MODE_KOS;
			func.args = List(for (local tp, nm: func.args) (
				replace_wchar_words(tp, wchar_mode, env: func),
				nm
			));
			func.return_type = replace_wchar_words(func.return_type, wchar_mode, env: func);
			func.extended_overloads = List(
				for (local args, return_type: func.extended_overloads) (
					List(for (local tp, nm: args) (
						replace_wchar_words(tp, wchar_mode, env: func),
						nm
					)),
					replace_wchar_words(return_type, wchar_mode, env: func)
				)
			);
		}
	}
}

function inheritFunctionAttributes(func: Function, alias_func: Function) {
	if ("*" in func.attr_tags) {
		linkFunctionAliases(alias_func);
		func.attr_tags.remove("*");
		func.attr_tags.extend(alias_func.attr_tags);
	}
}

function inheritAliases(dest: Function, aliases: {(string, string)...}): {(string, string)...} {
	if (dest.uchar_function !is none) {
		for (local cond, name: aliases) {
			cond = cond
				? cond + " && (__SIZEOF_WCHAR_T__ == " + dest.uchar_function + ")"
				: "__SIZEOF_WCHAR_T__ == " + dest.uchar_function
				;
			yield (cond, name);
		}
		if (dest.uchar_function == 2) {
			for (local cond, name: aliases)
				yield (cond, "DOS$" + name);
		}
	} else {
		yield aliases...;
	}
}
function inheritFunctionAliases(func: Function, alias_func: Function) {
	final local INHERIT_ALIASES_TAG = ("", "*");
	final local INHERIT_DOS_ALIASES_TAG = ("", "DOS$*");
	if (INHERIT_ALIASES_TAG in func.aliases) {
		linkFunctionAliases(alias_func);
		func.aliases.remove(INHERIT_ALIASES_TAG);
		func.aliases.extend(inheritAliases(func, alias_func.aliases));
		func.preferred_aliases.extend(inheritAliases(func, alias_func.preferred_aliases));
	}
	if (INHERIT_DOS_ALIASES_TAG in func.aliases) {
		linkFunctionAliases(alias_func);
		func.aliases.remove(INHERIT_DOS_ALIASES_TAG);
		for (local x: alias_func.dosnames)
			func.aliases.append(("", x));
	}
}


function inheritExplicitFields(func: Function, alias_func: Function) {
	inheritFunctionArguments(func, alias_func);
	inheritFunctionAttributes(func, alias_func);
	inheritFunctionAliases(func, alias_func);
	if (func.throws_decl) {
		if (func.throws_decl != alias_func.throws_decl) {
			print "[throws] tag of", repr func.name, "was explicitly specified, but doesn't";
			print "match the throws tag of the aliased function", repr alias_func.name;
			print (repr func.name)+":", repr func.throws_decl;
			print (repr alias_func.name)+":", repr alias_func.throws_decl;
			throw "Miss-matching throws_decl";
		}
	} else {
		func.throws_decl = alias_func.throws_decl;
	}
	if (func.define_require_string) {
		if (func.define_require_string != alias_func.define_require_string) {
			print "[requires] tag of", repr func.name, "was explicitly specified, but doesn't";
			print "match the requires tag of the aliased function", repr alias_func.name;
			print (repr func.name)+":", repr func.define_require_string;
			print (repr alias_func.name)+":", repr alias_func.define_require_string;
			throw "Miss-matching define_require_string";
		}
	} else {
		func.define_require_string = alias_func.define_require_string;
	}
	if (func.dependency_string) {
		if (!alias_func.dependency_string || func.dependency_string != alias_func.dependency_string) {
			print "[dependency_string] tag of", repr func.name, "was explicitly specified, but doesn't";
			print "match the dependency_string tag of the aliased function", repr alias_func.name;
			print (repr func.name)+":", repr func.dependency_string;
			print (repr alias_func.name)+":", repr alias_func.dependency_string;
			throw "Miss-matching dependency_string";
		}
	} else {
		func.dependency_string = alias_func.dependency_string;
	}
	if (alias_func.component_name !is bound) {
		func.block = none;
		if (func.uchar_function is none) {
			local pair = ("", alias_func.name);
			if (pair !in func.aliases && pair !in func.preferred_aliases)
				func.aliases.append(pair);
		}
	}
}

function linkFunctionAliases(func: Function) {
	if (func.component_name is bound && func.component_name is CopyFunctionBody) {
		local alias_func = functions.get(func.component_name.name);
		if (alias_func is none) {
			print "Function", repr func.name, "is aliasing the component name of unknown function", repr func.component_name.name;
			throw "Failed to find aliased function";
		}
		if (alias_func.component_name is bound) {
			func.component_name = func.component_name.convert(alias_func, func, alias_func.component_name);
		} else {
			del func.component_name;
		}
	}
	local funblock = func.block;
	if (funblock is CopyFunctionBody) {
		local alias_func = functions.get(funblock.name);
		if (alias_func is none) {
			print "Function", repr func.name, "is aliasing the body name of unknown function", repr funblock.name;
			throw "Failed to find aliased function";
		}
		local convert = func.block.convert;
		if (alias_func.block !is string) {
			if (alias_func.block is none) {
				/* Allow empty function blocks */
				func.block = none;
				goto inherit_explicit_fields;
			}
			print "Function", repr func.name, "is aliasing indirect function", repr alias_func.name;
			throw "Aliased function has no body";
		}
		/* Apply the function body transformation */
		local body = convert(alias_func, func, alias_func.block);
		if (func.libc_impl === func.block)
			func.libc_impl = body;
		if (func.user_impl === func.block)
			func.user_impl = body;
		if ((func.impl_prefix && func.impl_prefix != alias_func.impl_prefix) ||
		    (func.requires_prefix && func.requires_prefix != alias_func.requires_prefix) ||
		    (func.declaration_prefix && func.declaration_prefix != alias_func.declaration_prefix) ||
		    (func.dependency_prefix && func.dependency_prefix != alias_func.dependency_prefix)) {
			print "Function", repr func.name, "is aliasing function", repr alias_func.name, "but defines different prefixes";
			throw "Aliased function with different prefixes";
		}
		func.impl_prefix = alias_func.impl_prefix;
		func.requires_prefix = alias_func.requires_prefix;
		func.declaration_prefix = alias_func.declaration_prefix;
		func.dependency_prefix = alias_func.dependency_prefix;
		func.block = body;
		if (!func.define_require_string)
			func.define_require_string = convert(alias_func, func, alias_func.define_require_string);
		if (func.dont_export_symbol == "auto")
			func.dont_export_symbol = alias_func.dont_export_symbol;
		if (include_line_directives) {
			func.block_starting_line     = alias_func.block_starting_line;
			func.block_definintions_file = alias_func.block_definintions_file;
		}
inherit_explicit_fields:
		inheritFunctionArguments(func, alias_func, convert);
		inheritFunctionAttributes(func, alias_func);
		if (!func.doc)
			func.doc = alias_func.doc;
		return;
	}
	if (funblock !is FunctionAlias)
		return;
	if (funblock.func is Function)
		return; /* Already linked */
	assert funblock.func is string;
	local alias_func = functions.get(funblock.func);
	if (alias_func is none) {
		print "Function", repr func.name, "is aliasing unknown function", repr funblock.func;
		throw "Failed to find aliased function";
	}
	if (func.uchar_function !is none) {
		if (!alias_func.wchar_function) {
			print "Uchar-function", repr func.name, "is bound to non-[wchar] function", repr alias_func.name;
			throw "Uchar function bound to non-wchar function";
		}
		/* Bind uchar function names */
		if (func.uchar_function == 2) {
			if (!alias_func.uchar16_function_name)
				alias_func.uchar16_function_name = func.name;
			else if (alias_func.uchar16_function_name != func.name) {
				print "Varying names for uchar16-variant of function", repr(alias_func.name) + ":";
				print "\t" + repr alias_func.uchar16_function_name;
				print "\t" + repr func.name;
				throw "Varying uchar16 names";
			}
		} else if (func.uchar_function == 4) {
			if (!alias_func.uchar32_function_name)
				alias_func.uchar32_function_name = func.name;
			else if (alias_func.uchar32_function_name != func.name) {
				print "Varying names for uchar32-variant of function", repr(alias_func.name) + ":";
				print "\t" + repr alias_func.uchar32_function_name;
				print "\t" + repr func.name;
				throw "Varying uchar32 names";
			}
		}
	}
	inheritExplicitFields(func, alias_func);
	if (!func.doc) {
		func.doc = alias_func.doc;
		if (func.uchar_function !is none)
			auto_reformat_doc_uchar_functions.insert(func);
	}
	funblock.func = alias_func;
	func.nouser = true;
	if (func.name !in alias_func.alternate_names &&
	    func.dont_export_symbol !== true && !func.nocrt) {
		print "Found alternate name for", repr(alias_func.name), ":", repr(func.name);
		alias_func.alternate_names.append(func.name);
	}
}

/* Link function aliases */
for (local func: all_functions)
	linkFunctionAliases(func);

@@Automatically re-format inherited documentation strings of uchar functions:#
@@Within the doc, search for "`...'" patterns and if ... is the name of a wchar-
@@function, replace it with the name of the associated uN-function. */
function autoReformatUcharFunctionDoc(func: Function) {
	local doc = func.doc;
	if (!doc)
		return;
	func.doc = replaceDocKeywordWords(doc, [](fp: File, word: string) {
		local referenced_function = functions.get(word);
		if (referenced_function is none || !referenced_function.wchar_function) {
			fp << word;
		} else {
			local uchar_name = func.uchar_function == 2
				? referenced_function.uchar16_function_name
				: referenced_function.uchar32_function_name;
			if (!uchar_name) {
				print "Unknown uchar{}-variant of function {} referenced in documentation of {}"
					.format({ func.uchar_function*8, referenced_function.name, func.name });
				throw "Unknown uchar-function referenced in documentation";
			}
			fp << uchar_name;
		}
	});
}

for (local func: auto_reformat_doc_uchar_functions) {
	autoReformatUcharFunctionDoc(func);
	inheritExplicitFields(func, func.block.func);
}

for (local comnam, com: components) {
	local i;
	for (i = 0; i < #com; ++i) {
		local part = com[i];
		if (part !is FunctionAlias)
			continue;
		local alias_func = functions.get(part.func);
		if (alias_func is none) {
			print "External references to unknown function", repr part.func, "in", repr comnam;
			throw "Failed to find external function";
		}
		if (!alias_func.guarded_function ||
		   (alias_func.export_in_std && !alias_func.std_guard)) {
			print "Externally referenced function", repr part.func, "isn't guarded when used in", repr comnam;
			throw "Externally referenced function isn't guarded";
		}
		com[i] = ExternFunction(alias_func);
	}
}

#ifndef EXPORTS_USE_USER_HEADERS
{
	local is_first = true;
	for (local func: all_functions) {
		if (func.dont_export_symbol is string) {
			assert func.dont_export_symbol == "auto";
			func.dont_export_symbol = false;
			if (func.get_dependency_string() == "1") {
				if (is_first) {
					print;
					print "Implicitly exporting:";
					is_first = false;
				}
				print "\t",;
				if (func.component_name is bound) {
					print func.component_name,;
					print "::",;
				}
				print func.name;
			} else {
				func.dont_export_symbol = true;
			}
		}
	}
}
#endif


try fs.mkdir("include"); catch (...);
try fs.mkdir("include/local"); catch (...);
try fs.mkdir("include/libc"); catch (...);
try fs.mkdir("include/libc/slow"); catch (...);
try fs.mkdir("src"); catch (...);
try fs.mkdir("src/libc"); catch (...);
try fs.mkdir("src/libc/auto"); catch (...);
try fs.mkdir("src/libc/user"); catch (...);

for (local comnam, none: components) {
	if ("." !in comnam)
		continue;
	local part = "";
	for (local x: comnam.split(".")[:-1]) {
		part += "/";
		part += x;
		try fs.mkdir("include" + part); catch (...);
	}
}


/* Write local implementations of component functions. */
print;
for (local comnam, funcs: components) {
	print "Generating component:", comnam;
	local compath = "include/local/{}/".format({ comnam });
	local did_create_folder = false;
	for (local f: funcs) {
		if (f !is Function) continue;
		if (f.block !is string) continue;
		if (f.component_name != comnam) continue;
		if (!did_create_folder) {
			try fs.mkdir(compath); catch (...);
			did_create_folder = true;
		}
		local funpath = compath + f.name + ".h";
		print "\tfunction:", f.name;
		write_hashed_file(funpath, f.generate_local_impl);
		if (f.uchar16_function_name) {
			print "\t\tfunction:", f.uchar16_function_name;
			write_hashed_file(compath + f.uchar16_function_name + ".h", [](fp) -> f.generate_local_impl(fp, true, WCHAR_MODE_DOS));
		}
		if (f.uchar32_function_name) {
			print "\t\tfunction:", f.uchar32_function_name;
			write_hashed_file(compath + f.uchar32_function_name + ".h", [](fp) -> f.generate_local_impl(fp, true, WCHAR_MODE_KOS));
		}

	}
}

function write_libc_header(fp, comnam, functions, has_slow_header) {
	local guard_name = key_libc_guard(comnam);
	fp << copyright << "\n"
	      "#ifndef " << guard_name << "\n"
	      "#define " << guard_name << " 1\n"
	      "\n"
	      "#include <__stdinc.h>\n"
	      "#include <__crt.h>\n";
	local has_fast_functions = false;
	for (local f: functions) {
		if (f is ExternFunction)
			f = f.func;
		if (f !is Function)
			continue;
		if (f.helper_function)
			continue;
		if (!f.has_fast_implementation)
			continue;
		has_fast_functions = true;
		break;
	}
	if (has_fast_functions) {
		fp << "#ifdef __LIBC_BIND_OPTIMIZATIONS\n"
		      "#include <optimized/" << comnam << ".h>\n"
		      "#endif /* __LIBC_BIND_OPTIMIZATIONS */\n";
	}
	if (has_slow_header)
		fp << "#include \"slow/" << comnam << ".h\"\n";
	fp << "\n";
	for (local f: functions) {
		if (f is IntermediateString) {
			fp << f.string;
			continue;
		}
		if (f is ExternFunction)
			f = f.func;
		if (f !is Function)
			continue;
		if (f.helper_function)
			continue;
		if (f.component_name is bound && f.component_name != comnam)
			continue;
		print "\tfunction:", key_libc(f.name);
		if (f.has_fast_implementation) {
			local symbol_name = f.name;
			if (f.block is FunctionAlias) {
				symbol_name = f.block.func.name;
			} else if (f.block is UndefinedFunctionAlias) {
				symbol_name = f.block.name;
			}
			fp << "#ifdef __fast_" << symbol_name << "_defined\n";
			f.print_macro_alias(fp, key_libc(f.name), "(__NAMESPACE_FAST_SYM {})".format({ key_fastimpl(symbol_name) }), symbol_name, dont_cast: true);
			fp << "#else /* __fast_" << symbol_name << "_defined */\n";
			f.print_macro_alias(fp, key_libc(f.name), key_libc_slow(f.name), f.name, dont_cast: true);
			fp << "#endif /* !__fast_" << symbol_name << "_defined */\n";
		} else {
			f.print_macro_alias(fp, key_libc(f.name), key_libc_slow(f.name), f.name, dont_cast: true);
		}
	}
	fp << "\n"
	      "#endif /* !" << guard_name << " */\n";
}
function write_libc_slow_header(fp, comnam, functions) {
	local guard_name = key_libc_slow_guard(comnam);
	fp << copyright << "\n"
	      "#ifndef " << guard_name << "\n"
	      "#define " << guard_name << " 1\n"
	      "\n"
	      "#include <__stdinc.h>\n"
	      "#include <__crt.h>\n"
	      "#include <hybrid/typecore.h>\n";
	local needKosAnno = false;
	for (local f: functions) {
		if (f is IntermediateString)
			continue;
		if (f is ExternFunction)
			f = f.func;
		if (f !is Function || f.helper_function)
			continue;
		if (f.component_name is bound && f.component_name != comnam)
			continue;
		if (f.hasThrowsAnnotation()) {
			needKosAnno = true;
			break;
		}
	}
	if (needKosAnno)
		fp << "#include <kos/anno.h>\n";
	fp << "\n"
	      "__SYSDECL_BEGIN\n"
	      "\n"
	      ;
	for (local f: functions) {
		if (f is IntermediateString) {
			fp << f.string;
			continue;
		}
		if (f is ExternFunction)
			f = f.func;
		if (f !is Function || f.helper_function)
			continue;
		if (f.component_name is bound && f.component_name != comnam) continue;
		print "\tfunction:", key_libc(f.name);
		local old = f.has_fast_implementation;
		f.has_fast_implementation = false;
		f.generate_header_block(fp, key_libc_slow, none, false, false, true, REPLACE_TYPE_WORDS_LOCAL);
		f.has_fast_implementation = old;
	}
	fp << "\n__SYSDECL_END\n"
	      "\n"
	      "#endif /* !" << guard_name << " */\n";
}


/* Write the libc-export headers */
print;
for (local comnam, funcs: components) {
	local libc_fast_functions = [];
	local libc_slow_functions = [];
	for (local f: funcs) {
		if (f is IntermediateString) {
			if ("libc_fast" in f.locations || "libc" in f.locations)
				libc_fast_functions.append(f);
			if ("libc_slow" in f.locations || "libc" in f.locations)
				libc_slow_functions.append(f);
			continue;
		}
//		if (f is ExternFunction)
//			f = f.func;
		if (f !is Function)
			continue;
		if (f.helper_function)
			continue;
		if (f.export_as_libc) {
			libc_fast_functions.append(f);
			libc_slow_functions.append(f);
		}
	}
	if (!libc_fast_functions && !libc_slow_functions)
		continue;
	local compath = "include/libc/{}.h".format({ comnam });
	local slow_compath = "include/libc/slow/{}.h".format({ comnam });
	print "Creating combinatory libc-header: ", compath;
	if (libc_fast_functions || libc_slow_functions) {
		write_hashed_file(compath, [](fp) {
			write_libc_header(fp, comnam, libc_fast_functions, libc_slow_functions);
		});
	}
	if (libc_slow_functions) {
		write_hashed_file(slow_compath, [](fp) {
			write_libc_slow_header(fp, comnam, libc_slow_functions);
		});
	}
}


function generateCCompatCxxHeader(
		cxxHeaderName: string, cHeaderName: string,
		cxxHeaderGuard: string, cHeaderGuard: string) {
	print "Creating c++ wrapper header: ", cxxHeaderName;
	write_hashed_file(cxxHeaderName, [](fp) {
		local cHeaderNameForInclude = cHeaderName.lsstrip("include/");
		fp << copyright << "\n";
		fp << "#ifndef " << cxxHeaderGuard << "\n";
		fp << "#define " << cxxHeaderGuard << " 1\n";
		fp << "#ifndef " << cHeaderGuard << "\n";
		fp << "#ifdef __CXX_SYSTEM_HEADER\n";
		fp << "#include " << repr(cHeaderNameForInclude) << "\n";
		fp << "#else /* __CXX_SYSTEM_HEADER */\n";
		fp << "#include \"features.h\"\n";
		fp << "#ifndef __USE_BROKEN_CCOMPAT\n";
		fp << "#define __CXX_SYSTEM_HEADER 1\n";
		fp << "#endif /* !__USE_BROKEN_CCOMPAT */\n";
		fp << "#include " << repr(cHeaderNameForInclude) << "\n";
		fp << "#undef __CXX_SYSTEM_HEADER\n";
		fp << "#endif /* !__CXX_SYSTEM_HEADER */\n";
		fp << "#endif /* !" << cHeaderGuard << " */\n";
		fp << "#endif /* !" << cxxHeaderGuard << " */\n";
	});
}


function write_std_header(fp, comnam, funcs) {
	function printStdImport(f: Function) {
		if (f.block is none || f.block is UndefinedFunctionAlias || f.define_require_string || f.std_guard) {
			fp << "#if !defined(__" << f.name << "_defined) && defined(__std_" << f.name << "_defined)\n"
			   << "#define __" << f.name << "_defined 1\n"
			   << "__NAMESPACE_STD_USING(" << f.name << ")\n"
			   << "#endif /* !__" << f.name << "_defined && !__std_" << f.name << "_defined */\n";
		} else if (!f.guarded_function) {
			fp << "__NAMESPACE_STD_USING(" << f.name << ")\n";
		} else {
			fp << "#ifndef __" << f.name << "_defined\n"
			   << "#define __" << f.name << "_defined 1\n"
			   << "__NAMESPACE_STD_USING(" << f.name << ")\n"
			   << "#endif /* !__" << f.name << "_defined */\n";
		}
	}
	local guard_name = key_std_guard(comnam);
	fp << copyright << "\n"
	      "#ifndef " << guard_name << "\n"
	      "#define " << guard_name << " 1\n"
	      "\n";
	local headerName = comnam.replace(".", "/") + ".h";
	local ccompat = ccompat_cpp_headers.get(headerName);
	if (ccompat !is none) {
		local cppHeaderName, cppGuard, cStdOnlyDefinedGuard = ccompat...;
		/* Generate the c++ header */
		generateCCompatCxxHeader(
			"include/" + cppHeaderName,
			"include/" + headerName, cppGuard, guard_name);
		fp << "#ifdef " << cStdOnlyDefinedGuard << "\n";
		/* Only std:: symbols have been defined.
		 * If we're included from a c++ header, don't do anything.
		 * Otherwise, export all std:: symbols into the global namespace. */
		fp << "#ifdef __CXX_SYSTEM_HEADER\n";
		/* Make sure our header can be re-#included as <headerName>
		 * at which point all symbols that are currently std::-only will
		 * appear in the global namespace. */
		fp << "#undef " << guard_name << " /* Allow the C-header to be re-included to import all std::-symbols into the global namespace. */\n";
		fp << "#else /* __CXX_SYSTEM_HEADER */\n";
		/* Expose all std:: symbols within the global namespace. */
		fp << "/* Import all symbols into the global namespace when re-including "
		   << repr(headerName) << " after " << repr(cppHeaderName) << " */\n";
		for (local f: funcs) {
			if (f is Function) {
				if (f.helper_function)
					continue;
				if (f.export_in_std) {
					if (f.overload_alias && f.export_in_std)
						continue; /* Already imported elsewhere */
					printStdImport(f);
				}
			} else if (f is IntermediateString) {
				if ("ccompat" in f.locations)
					fp << f.string;
			}
		}
		fp << "#undef " << cStdOnlyDefinedGuard << "\n";
		fp << "#endif /* !__CXX_SYSTEM_HEADER */\n";
		fp << "#else /* " << cStdOnlyDefinedGuard << " */\n";
	}
	if ("/" in headerName) {
		fp << "#include <__stdinc.h>\n";
		fp << "#include <__crt.h>\n";
	} else {
		fp << "#include \"__stdinc.h\"\n";
		fp << "#include \"__crt.h\"\n";
	}
	local needKosAnno = false;
	for (local f: funcs) {
		local is_extern = false;
		if (f is ExternFunction) {
			is_extern = true;
			f = f.func;
		}
		if (f is Function) {
			if (f.helper_function)
				continue;
			if (f.export_in_std && !is_extern) {
				if (f.overload_alias && f.export_in_std)
					continue; /* Already imported elsewhere */
			}
			if (f.hasThrowsAnnotation()) {
				needKosAnno = true;
				break;
			}
		}
	}
	if (needKosAnno)
		fp << "#include <kos/anno.h>\n";
	fp << "\n";
	fp << "#ifdef __COMPILER_HAVE_PRAGMA_GCC_SYSTEM_HEADER\n";
	fp << "#pragma GCC system_header\n";
	fp << "#endif /* __COMPILER_HAVE_PRAGMA_GCC_SYSTEM_HEADER */\n";
	fp << "\n";
	local fast_headers = HashSet();
	for (local f: funcs) {
		if (f is ExternFunction)
			f = f.func;
		if (f !is Function)
			continue;
		if (f.helper_function)
			continue;
		if (!f.has_fast_implementation)
			continue;
		if (f.component_name !is bound)
			continue;
		fast_headers.insert(f.component_name);
	}
	if (fast_headers) {
		fast_headers = List(fast_headers);
		fast_headers.sort();
		fp << "#ifdef __LIBC_BIND_OPTIMIZATIONS\n";
		for (local n: fast_headers)
			fp << "#include <optimized/" << n << ".h>\n";
		fp << "#endif /* __LIBC_BIND_OPTIMIZATIONS */\n";
	}
	local in_cxx_system_header = false;
	for (local f: funcs) {
		local is_extern = false;
		if (f is ExternFunction) {
			is_extern = true;
			f = f.func;
		}
		if (f is Function) {
			if (f.helper_function)
				continue;
			print "\tfunction:", f.name;
			if (f.export_in_std && !is_extern) {
				if (f.overload_alias && f.export_in_std)
					continue; /* Already imported elsewhere */
				if (!in_cxx_system_header) {
					fp << "#ifndef __CXX_SYSTEM_HEADER\n";
					in_cxx_system_header = true;
				}
				printStdImport(f);
			} else {
				if (in_cxx_system_header) {
					fp << "#endif /* !__CXX_SYSTEM_HEADER */\n";
					in_cxx_system_header = false;
				}
				f.generate_header_block(
					fp, none, none, true,
					f.guarded_function || (f.export_in_std && f.std_guard),
					f.allow_macros, REPLACE_TYPE_WORDS_HEADER);
			}
		} else if (f === PrintStdNamespace) {
			if (in_cxx_system_header) {
				fp << "#endif /* !__CXX_SYSTEM_HEADER */\n";
				in_cxx_system_header = false;
			}
			local std_functions = [];
			for (local std_f: funcs) {
				if (std_f is IntermediateString) {
					if ("std" in std_f.locations)
						std_functions.append(std_f);
					continue;
				}
				if (std_f is ExternFunction)
					continue;
				if (std_f !is Function) continue;
				if (!std_f.export_in_std) continue;
				std_functions.append(std_f);
			}
			if (std_functions) {
				fp << "__NAMESPACE_STD_BEGIN\n";
				for (local std_f: std_functions) {
					if (std_f is IntermediateString) {
						fp << std_f.string;
						continue;
					}
					print "\tfunction:", "std::" + std_f.name;
					local need_guard = std_f.guarded_function;
					if ((std_f.block is none ||
					     std_f.block is UndefinedFunctionAlias ||
					     std_f.define_require_string) &&
					    (std_f.std_guard || !std_f.overload_alias))
						need_guard = true;
					std_f.generate_header_block(fp, none, "STD", true, need_guard, false, REPLACE_TYPE_WORDS_HEADER);
				}
				fp << "__NAMESPACE_STD_END\n";
			}
		} else if (f is IntermediateString) {
			if ("c" in f.locations) {
				if (in_cxx_system_header) {
					fp << "#endif /* !__CXX_SYSTEM_HEADER */\n";
					in_cxx_system_header = false;
				}
				fp << f.string;
			}
		}
	}
	if (ccompat !is none) {
		fp << "#ifdef __CXX_SYSTEM_HEADER\n";
		/* Allow our header to be re-included in the future in order
		 * to export all of our std:: symbols into the global namespace.
		 * In order for this to happen, the #include-site simply has to
		 * make sure that `__CXX_SYSTEM_HEADER' isn't defined. If we're
		 * included while it is still defined, that inclusion will be
		 * a no-op! */
		fp << "#define " << ccompat[2] << " 1\n";
		fp << "#undef " << guard_name << "\n";
		fp << "#endif /* __CXX_SYSTEM_HEADER */\n";
		fp << "#endif /* !" << ccompat[2] << " */\n";
	}
	fp << "#endif /* !" << guard_name << " */\n";
}

/* Write the top-level-export headers */
print;
for (local comnam, funcs: components) {
	local compath = "include/{}.h".format({ comnam.replace(".", "/") });
	print "Creating combinatory header: ", compath;
	write_hashed_file(compath, [](fp) {
		write_std_header(fp, comnam, funcs);
	});
}


function need_libc_auto_header(funcs, comnam) {
	for (local f: funcs) {
		if (f is IntermediateString) {
			if ("auto_kernel_header" in f.locations || "auto_header" in f.locations ||
			    "auto_kernel" in f.locations || "auto" in f.locations)
				return true;
			if ("auto_libc_header" in f.locations || "auto_header" in f.locations ||
			    "auto_libc" in f.locations || "auto" in f.locations)
				return true;
			continue;
		}
		if (f !is Function)
			continue;
		if (f.block !is string)
			continue;
		if (f.component_name != comnam)
			continue;
		if (f.dont_export_symbol)
			continue;
		return true;
	}
	return false;
}

function enum_user_header_functions(
	comnam, funcs, include_strings: bool = false,
	want_ignored_functions: bool = true) {
	for (local f: funcs) {
		if (f is IntermediateString) {
			if (include_strings && ("auto_user" in f.locations || "user" in f.locations))
				yield f;
			continue;
		}
		if (f !is Function)
			continue;
		if (f.douser) {
			yield f;
			continue;
		}
		if (!want_ignored_functions && f.helper_function)
			continue;
		if (f.component_name is bound &&
		    f.component_name != comnam)
			continue;
		if (f.nouser)
			continue;
		if (f.block is none ||
		   (f.dont_export_symbol &&
		    f.block !is FunctionAlias &&
		    f.block !is UndefinedFunctionAlias))
			yield f;
	}
}
function need_libc_user_header(comnam, funcs) {
	return !!enum_user_header_functions(comnam, funcs, true);
}


function write_libc_auto_header(fp, comnam, funcs) {
	local guard_name = key_libc_auto_header_guard(comnam);
	local libc_funcs = [];
	local kernel_funcs = [];
	for (local f: funcs) {
		if (f is IntermediateString) {
			if ("auto_kernel_header" in f.locations || "auto_header" in f.locations ||
			    "auto_kernel" in f.locations || "auto" in f.locations)
				kernel_funcs.append(f);
			if ("auto_libc_header" in f.locations ||
			    "auto_libc" in f.locations)
				libc_funcs.append(f);
			continue;
		}
		if (f !is Function)
			continue;
		if (f.block !is string && f.block !is FunctionAlias)
			continue;
		if (f.dont_export_symbol)
			continue;
		if (f.component_name != comnam)
			continue;
		if (f.export_in_kernel) {
			kernel_funcs.append(f);
		} else {
			libc_funcs.append(f);
		}
	}
	local needKosAnno = false;
	for (local f: kernel_funcs) {
		if (f is IntermediateString)
			continue;
		if (f.hasThrowsAnnotation()) {
			needKosAnno = true;
			break;
		}
	}
	if (!needKosAnno) {
		for (local f: libc_funcs) {
			if (f is IntermediateString)
				continue;
			if (f.hasThrowsAnnotation())
				needKosAnno = true;
		}
	}
	fp << copyright << "\n"
	      "#ifndef " << guard_name << "\n"
	      "#define " << guard_name << " 1\n"
	      "\n"
	      "#include \"../api.h\"\n"
	      "#include <hybrid/typecore.h>\n"
	      "#include <kos/types.h>\n"
	      "#include <" << comnam.replace(".", "/") << ".h>\n";
	if (needKosAnno)
		fp << "#include <kos/anno.h>\n";
	fp << "\n"
	      "DECL_BEGIN\n"
	      "\n"
	      ;
	for (local f: kernel_funcs) {
		if (f is IntermediateString) {
			fp << f.string;
			continue;
		}
		f.generate_libc_proto(fp);
	}
	if (libc_funcs) {
		fp << "#ifndef __KERNEL__\n";
		for (local f: libc_funcs) {
			if (f is IntermediateString) {
				fp << f.string;
				continue;
			}
			f.generate_libc_proto(fp);
		}
		fp << "#endif /* !__KERNEL__ */\n";
	}
	fp << "\n"
	      "DECL_END\n"
	      "\n"
	      "#endif /* !" << guard_name << " */\n";
}


function write_libc_user_header(fp, comnam, funcs) {
	local guard_name = key_libc_user_header_guard(comnam);
	fp << copyright << "\n"
	      "#ifndef " << guard_name << "\n"
	      "#define " << guard_name << " 1\n"
	      "\n"
	      "#include \"../api.h\"\n";
	if (need_libc_auto_header(funcs, comnam))
		fp << "#include \"../auto/" << comnam << ".h\"\n";
	local needKosAnno = false;
	for (local f: enum_user_header_functions(comnam, funcs, true)) {
		if (f is IntermediateString)
			continue;
		if (f.hasThrowsAnnotation()) {
			needKosAnno = true;
			break;
		}
	}
	if (needKosAnno)
		fp << "#include <kos/anno.h>\n";
	fp << "#include <hybrid/typecore.h>\n"
	      "#include <kos/types.h>\n"
	      "#include <" << comnam.replace(".", "/") << ".h>\n"
	      "\n"
	      "DECL_BEGIN\n"
	      "\n"
	      ;
	for (local f: enum_user_header_functions(comnam, funcs, true)) {
		if (f is IntermediateString) {
			fp << f.string;
			continue;
		}
		f.generate_libc_proto(fp);
	}
	fp << "\n"
	      "DECL_END\n"
	      "\n"
	      "#endif /* !" << guard_name << " */\n";
}


function generate_libc_user_exports(fp: File, comnam: string, funcs: {Function...}) {
	for (local f: enum_user_header_functions(comnam, funcs, false, false)) {
		if (f.allow_macros || f.args_is_varargs) {
			if (!f.nocrt)
				fp << "#undef " << f.name << "\n";
			for (local alt: f.alternate_names)
				fp << "#undef " << alt << "\n";
//			if (f.wchar_function) {
//				for (local name: f.dosnames)
//					fp << "#undef " << name << "\n";
//			}
		}
	}
	for (local f: enum_user_header_functions(comnam, funcs, false, false)) {
		if (!f.nocrt) {
			fp << "DEFINE_PUBLIC_WEAK_ALIAS(";
			fp << f.name << ", ";
			fp << key_libc_internal(f.name) << ");\n";
		}
		for (local alt: f.alternate_names) {
			fp << "DEFINE_PUBLIC_WEAK_ALIAS(";
			fp << alt << ", ";
			fp << key_libc_internal(f.name) << ");\n";
		}
		if (f.wchar_function) {
			for (local n: f.dosnames) {
				fp << "DEFINE_PUBLIC_WEAK_ALIAS(" << n << ", "
				   << key_libd_internal(f.name) << ");\n";
			}
		}
	}
}

function print_libc_user_exports(fp: File, comnam: string, funcs: {Function...}) {
	File.Writer tempfp;
	generate_libc_user_exports(tempfp, comnam, funcs);
	local s = tempfp.string;
	local h = hash(hashfunc, s.strip()).hex();
	fp << "/*[[[start:exports,hash:" << hashfunc << "=" << h << "]]]*/\n";
	fp << s;
	fp << "/*[[[end:exports]]]*/\n";
}

function generate_libc_user_source(fp: File, comnam: string, funcs: {Function...}) {
	local guard_name = key_libc_user_source_guard(comnam);
	fp	<< copyright << "\n"
		<< "#ifndef " << guard_name << "\n"
		<< "#define " << guard_name << " 1\n"
		<< "\n"
		<< "#include \"../api.h\"\n"
		<< "#include \"" << comnam << ".h\"\n"
		<< "\n"
		<< "DECL_BEGIN\n"
		<< "\n";
	fp << "\n" * 4;
	fp << "/*[[[start:implementation]]]*/\n";
	local names = HashSet();
	for (local f: enum_user_header_functions(comnam, funcs, false)) {
		local f_names = [false];
		f.got_implementation = true;
		if (f.wchar_function)
			f_names.append(true);
		for (local is_dos: f_names) {
			local n = f.name;
			if (is_dos)
				n = key_libd_export(n);
			if (n in names) {
				print "Error: Duplicate function", repr n, "in", comnam;
				throw Error("Duplicate function");
			}
			names.insert(n);
			File.Writer tempfp;
			f.generate_libc_user_impl_proto(tempfp,
				is_dos ? key_libd_internal : key_libc_internal);
			local s = tempfp.string;
			local h = hash(hashfunc, s.strip()).hex();
			fp << "\n";
			fp << "/*[[[head:" << n << ",hash:" << hashfunc << "=" << h << "]]]*/\n";
			fp << s;
			fp << "/*[[[body:" << n << "]]]*/\n";
			f.print_default_body(fp, is_dos);
			f.generate_libc_user_impl_proto_tail(fp);
			fp << "/*[[[end:" << n << "]]]*/\n";
		}
	}
	fp << "\n";
	fp << "/*[[[end:implementation]]]*/\n";
	fp << "\n";
	fp << "\n";
	fp << "\n";
	print_libc_user_exports(fp, comnam, funcs);
	fp << "\n";
	fp << "DECL_END\n";
	fp << "\n";
	fp << "#endif /* !" << guard_name << " */\n";
}

function is_empty_function_body(body) {
	body = body.replace("\n", " ").replace("\t", " ").strip();
	if (body.startswith("/*AUTO*/"))
		return true;
	local ignored_function_calls = {
		"CRT_UNIMPLEMENTED",
		"libc_seterrno",
	};
	for (;;) {
		local newbody;
continue_strip_body:
		newbody = body;
		if (newbody.startswith("{") && newbody.endswith("}"))
			newbody = newbody[1:-1];
		for (local c: " .,;(){}[]")
			newbody = newbody.replace(" " + c, c).replace(c + " ", c);
		if (newbody.startswith("/* TODO */")) {
			body = newbody[#"/* TODO */":];
			continue;
		}
		for (local f: ignored_function_calls) {
			if (newbody.startswith(f + "(")) {
				newbody = newbody[#f + 1:];
				local i = newbody.findmatch("(", ")");
				if (i < 0)
					return false;
				body = newbody[i+1:];
				goto continue_strip_body;
			}
		}
		newbody = newbody.strip().strip(";");
		if (body == newbody)
			break;
		body = newbody;
	}
	if (body in [
		"", "return", "return 0", "return -1",
		"return NULL", "for(;;){}", "for(;;)"])
		return true;
	return false;
}

function removeAutoAliasFromUserBody(body: string): string {
	local rstrip_body = body.rstrip();
	if (rstrip_body.endswith("*/")) {
		rstrip_body = rstrip_body[:-2].rstrip();
		if (rstrip_body.endswith("MAGIC:alias")) {
			rstrip_body = rstrip_body[:rstrip_body.rindex("/*")].rstrip();
			if (rstrip_body.endswith("#endif")) {
				/* Call recursively to automatically fix problems caused by
				 * the MAGIC:alias tag accidentally appearing more than once. */
				return removeAutoAliasFromUserBody(rstrip_body[:-6]);
			}
		}
	}
	return body;
}

function libc_user_update_implementation_section(
		filename: string, start_line: int, fp: File,
		text: string, comnam: string, funcs: {Function...}): {string...} {
	local i = 0;
	@@Mapping of function names --> text found leading its implementation
	local function_text_leading: {(string, (int, string))...} = Dict();
	local function_text_body: {(string, (int, string))...} = Dict();
	function err(off, message) {
		print getFilenameForLog(filename),;
		print "(",;
		print (1 + start_line + text.count("\n", 0, off)),;
		print "): Error: ", message;
		throw Error(message);
	}
	local user_function_order = [];
	local skipped_functions = HashSet();
	local custom_functions = HashSet();
	for (;;) {
		final local tag_start = "/*[[[";
		final local tag_ending = "]]]*/\n";
		local pos = text.find(tag_start, i);
		if (pos < 0)
			break;
		if (pos && !text.islf(pos - 1))
			err(pos, "Tag doesn't begin at the start of a line");
		local leading_text = text.substr(i, pos);
		pos += #tag_start;
		while (pos < #text && text.isspace(pos))
			++pos;
		local head_end = text.find(tag_ending, pos);
		if (head_end < 0)
			err(pos, "Missing " + repr(tag_ending));
		if (text.substr(pos, pos + 5) == "skip:") {
			local name = text.substr(pos+5, head_end).strip();
			user_function_order.append(name);
			skipped_functions.insert(name);
			i = head_end + #tag_ending;
			if (name in function_text_leading)
				err(pos, "Duplicate function name " + repr name);
			function_text_leading[name] = (i, leading_text);
			continue;
		}
		if (text.substr(pos, pos + 5) == "impl:") {
			local name = text.substr(pos+5, head_end).strip();
			user_function_order.append(name);
			custom_functions.insert(name);
			i = head_end + #tag_ending;
			if (name in function_text_leading)
				err(pos, "Duplicate function name " + repr name);
			function_text_leading[name] = (i, leading_text);
			continue;
		}
		if (text.substr(pos, pos + 5) != "head:")
			err(pos, "Unexpected tag `" + text.substr(pos, pos + 32) + "' (expected `head:')");
		pos += 5;
		local name_end = text.find(",", pos, head_end);
		if (name_end < 0)
			err(pos, "Missing `,' after `/*[[[head:...'");
		local name = text.substr(pos, name_end).strip();
		pos = name_end + 1;
		while (pos < #text && text.isspace(pos))
			++pos;
		if (text.substr(pos, pos + 5) != "hash:")
			err(pos, "Unexpected tag (expected `hash:' argument for `head:')");
		pos += 5;
		local hashstr = text.substr(pos, head_end).strip();
		head_end += #tag_ending;
		local tag_body = "/*[[[body:{}]]]*/\n".format({ name });
		pos = text.find(tag_body, head_end);
		if (pos < 0)
			err(head_end, "Missing " + repr tag_body);
		local head = text.substr(head_end, pos).strip();
		local hash_func, none, hash_value = hashstr.partition("=")...;
		hash_func = hash_func.strip();
		hash_value = try int(hash_value.strip()) catch (...) -1;
		local hash_real = hash(hash_func.decode("utf-8"), head);
		if ((hash_value != hash_real) && head)
			err(pos, "Miss-matching function {!r} header hash ({} != {})"
				.format({ name, hash_value.hex(), hash_real.hex() }));
		pos += #tag_body;
		local tag_end = "/*[[[end:{}]]]*/\n".format({ name });
		local body_end = text.find(tag_end, pos);
		if (body_end < 0)
			err(head_end, "Missing " + repr tag_end);
		local function_body = text.substr(pos, body_end);
		if (name in function_text_leading)
			err(pos, "Duplicate function name " + repr name);
		user_function_order.append(name);
		function_text_leading[name] = (i, leading_text);
		function_text_body[name]    = (pos, function_body);
		i = body_end + #tag_end;
	}
	local trailing_text = text.substr(i);
	local mandatory_functions = Dict();
	local mandatory_functions_order = List();
	local result_skipped_functions = copy skipped_functions;
	for (local f: enum_user_header_functions(comnam, funcs, false)) {
		f.got_implementation = true;
		mandatory_functions[f.name] = f;
		mandatory_functions_order.append(f.name);
		if (f.wchar_function) {
			local dnam = key_libd_export(f.name);
			mandatory_functions[dnam] = f;
			mandatory_functions_order.append(dnam);
		}
	}
	for (local name: user_function_order) {
		local f = mandatory_functions.pop(name, none);
		if (f is none) {
			fp << function_text_leading.pop(name, (none, ""))[1];
			continue;
		}
		if (name in result_skipped_functions) {
			skipped_functions.remove(name);
			fp << function_text_leading.pop(name, (none, ""))[1];
			fp << "/*[[[skip:" << name << "]]]*/\n";
			continue;
		}
		if (name in custom_functions) {
			custom_functions.remove(name);
			fp << function_text_leading.pop(name, (none, ""))[1];
			fp << "/*[[[impl:" << name << "]]]*/\n";
			continue;
		}
		fp << function_text_leading.pop(name, (none, "\n"))[1];
		File.Writer tempfp;
		f.generate_libc_user_impl_proto(tempfp,
			key_libd_is_export(name) ? key_libd_internal : key_libc_internal);
		local s = tempfp.string;
		local h = hash(hashfunc, s.strip()).hex();
		fp << "/*[[[head:" << name << ",hash:" << hashfunc << "=" << h << "]]]*/\n";
		fp << s;
		fp << "/*[[[body:" << name << "]]]*/\n";
		local body = function_text_body.pop(name, none)[1];
		local autoAliasStrip = removeAutoAliasFromUserBody(body);
		if (body !is none && !is_empty_function_body(autoAliasStrip))
			fp << autoAliasStrip;
		else {
			f.print_default_body(fp, key_libd_is_export(name));
		}
		f.generate_libc_user_impl_proto_tail(fp);
		fp << "/*[[[end:" << name << "]]]*/\n";
	}
	for (local name: mandatory_functions_order) {
		local f = mandatory_functions.get(name);
		if (f is none)
			continue;
		if (name in result_skipped_functions) {
			skipped_functions.remove(name);
			fp << function_text_leading.pop(name, (none, ""))[1];
			fp << "/*[[[skip:" << name << "]]]*/\n";
			continue;
		}
		if (name in custom_functions) {
			custom_functions.remove(name);
			fp << function_text_leading.pop(name, (none, ""))[1];
			fp << "/*[[[impl:" << name << "]]]*/\n";
			continue;
		}
		fp << function_text_leading.pop(name, (none, "\n"))[1];
		File.Writer tempfp;
		f.generate_libc_user_impl_proto(tempfp,
			key_libd_is_export(name) ? key_libd_internal : key_libc_internal);
		local s = tempfp.string;
		local h = hash(hashfunc, s.strip()).hex();
		fp << "/*[[[head:" << name << ",hash:" << hashfunc << "=" << h << "]]]*/\n";
		fp << s;
		fp << "/*[[[body:" << name << "]]]*/\n";
		local body = function_text_body.pop(name, none)[1];
		local autoAliasStrip = removeAutoAliasFromUserBody(body);
		if (body !is none && !is_empty_function_body(autoAliasStrip))
			fp << autoAliasStrip;
		else {
			f.print_default_body(fp, key_libd_is_export(name));
		}
		f.generate_libc_user_impl_proto_tail(fp);
		fp << "/*[[[end:" << name << "]]]*/\n";
	}
	if (skipped_functions) {
		print "Unused functions:", repr skipped_functions;
		throw "Unused functions";
	}
	if (custom_functions) {
		print "Unused functions:", repr custom_functions;
		throw "Unused functions";
	}
	/* Make sure that everything got re-used! */
	for (local name, data: function_text_body) {
		if (name in function_text_leading) {
			local pos, lead = function_text_leading[name]...;
			if (lead.strip())
				err(pos, "Unused leading text for function " + repr name);
		}
		local pos, body = data...;
		if (!is_empty_function_body(body))
			err(pos, "Unused body for function " + repr name);
	}
	/* Append trailing text. */
	fp << trailing_text;
	return result_skipped_functions;
}


function write_libc_user_source(filename: string, comnam: string, funcs: {Function...}) {
	local fp = try File.open(filename, "r") catch (...) none;
	if (fp is none) {
create_new_file:
		fp = File.open(filename, "w");
		try {
			generate_libc_user_source(fp, comnam, funcs);
		} catch (...) {
			fp.rewind();
			fp.trunc();
			fp.close();
			try fs.unlink(filename);
			catch (...);
			throw;
		}
		return;
	}
	local text = fp.read();
	fp.close();
	if (!text)
		goto create_new_file;
	final local s_impl_start    = "/*[[[start:implementation]]]*/\n";
	final local s_impl_end      = "/*[[[end:implementation]]]*/\n";
	final local s_export_start  = "/*[[[start:exports,hash:";
	final local s_export_start2 = "]]]*/";
	final local s_export_end    = "/*[[[end:exports]]]*/\n";
	local impl_start = text.find(s_impl_start);
	if (impl_start < 0) {
		print "Missing `/*[[[start:implementation]]]*/' tag in", repr filename;
		throw "Missing implementation block";
	}
	local impl_end = text.find(s_impl_end, impl_start + #s_impl_start);
	if (impl_end < 0) {
		print getFilenameForLog(filename),;
		print "(",;
		print 1 + text.count("\n", 0, impl_start),;
		print ") : Error: ",;
		print "Missing `/*[[[end:implementation]]]*/' tag";
		throw "Incomplete implementation block";
	}
	local export_start = text.find(s_export_start, impl_end + #s_impl_end);
	if (export_start < 0) {
		print getFilenameForLog(filename),;
		print "(",;
		print 1 + text.count("\n", 0, impl_end),;
		print ") : Error: ",;
		print "Missing `/*[[[start:exports,hash:...' tag";
		throw "Missing exports block";
	}
	local export_hash_end = text.find(s_export_start2, export_start + #s_export_start);
	if (export_hash_end < 0) {
		print getFilenameForLog(filename),;
		print "(",;
		print 1 + text.count("\n", 0, export_start),;
		print ") : Error: ",;
		print "Missing `/*[[[start:exports,hash:...' tag";
		throw "Missing exports block";
	}
	local exports_hash = text.substr(export_start + #s_export_start, export_hash_end);
	export_hash_end += #s_export_start2;
	local export_end = text.find(s_export_end, export_hash_end);
	if (export_end < 0) {
		print getFilenameForLog(filename),;
		print "(",;
		print 1 + text.count("\n", 0, export_start),;
		print ") : Error: ",;
		print "Missing `/*[[[end:exports]]]*/' tag";
		throw "Incomplete exports block";
	}
	local before_impl = text.substr(0, impl_start);
	local impl = text.substr(impl_start + #s_impl_start, impl_end);
	local before_exports = text.substr(impl_end + #s_impl_end, export_start);
	local exports = text.substr(export_hash_end, export_end);
	local after_exports = text.substr(export_end + #s_export_end);
	local exports_hash_func, none, exports_hash_value = exports_hash.partition("=")...;
	exports_hash_func = exports_hash_func.strip();
	exports_hash_value = try int(exports_hash_value.strip()) catch (...) 0;
	exports = exports.strip();
	local exports_hash_real = try hash(exports_hash_func.decode("utf-8"), exports) catch (...) 0;
	if ((exports_hash_value != exports_hash_real) && exports) {
		print getFilenameForLog(filename),;
		print "(",;
		print 1 + text.count("\n", 0, export_start),;
		print ") : Error: ",;
		print "exports section hash missmatch:",
			exports_hash_value.hex(), "!=", exports_hash_real.hex();
		throw "Modified exports section";
	}
	File.Writer tempfp;
	tempfp << before_impl;
	tempfp << s_impl_start;
	local skip = libc_user_update_implementation_section(
		filename,
		text.count("\n", 0, impl_start + #s_impl_start),
		tempfp,
		impl,
		comnam,
		funcs);
	tempfp << s_impl_end;
	tempfp << before_exports;
	print_libc_user_exports(tempfp, comnam,
		List(for (local f: funcs) if (f !is Function || f.name !in skip) f));
	tempfp << after_exports;
	tempfp = tempfp.string;
	if (text != tempfp) {
		fs.rename(filename, filename + ".old");
		local fp = File.open(filename, "w");
		fp.write(tempfp);
		fs.remove(filename + ".old");
		fp.close();
	}
}


/* Write the libc fallback headers. */
print;
for (local comnam, funcs: components) {
	if (need_libc_auto_header(funcs, comnam)) {
		local compath = "src/libc/auto/{}.h".format({ comnam });
		print "Creating libc auto-header: ", compath;
		write_hashed_file(compath, [](fp) {
			write_libc_auto_header(fp, comnam, funcs);
		});
	}
}

/* Write the libc user headers. */
print;

for (local comnam, funcs: components) {
	if (need_libc_user_header(comnam, funcs)) {
		local compath = "src/libc/user/{}.h".format({ comnam });
		print "Creating libc user-header: ", compath;
		write_hashed_file(compath, [](fp) {
			write_libc_user_header(fp, comnam, funcs);
		});
	}
}

/* Write the libc user sources. */
print;
for (local comnam, funcs: components) {
	for (local f: funcs) {
		if (f is IntermediateString)
			continue;
		if (f !is Function)
			continue;
		if (f.douser)
			goto do_create_libc_user_source;
		if (f.component_name is bound &&
		    f.component_name != comnam)
			continue;
		if (f.nouser)
			continue;
		if (f.block is none ||
		   (f.dont_export_symbol &&
		    f.block !is FunctionAlias &&
		    f.block !is UndefinedFunctionAlias))
			goto do_create_libc_user_source;
	}
	continue;
do_create_libc_user_source:
	local compath = "src/libc/user/{}.c".format({ comnam });
	print "Creating libc user-source: ", compath;
	write_libc_user_source(compath, comnam, funcs);
}



function write_libc_auto_implementation(fp, comnam, funcs) {
	local guard_name = key_libc_auto_impl_guard(comnam);
	fp << copyright << "\n"
	      "#ifndef " << guard_name << "\n"
	      "#define " << guard_name << " 1\n"
	      "\n"
	      "#include \"../api.h\"\n"
	      "#include <hybrid/typecore.h>\n"
	      "#include <kos/types.h>\n";
#ifdef EXPORTS_USE_USER_HEADERS
	if (need_libc_user_header(comnam, funcs)) {
		fp << "#ifdef __KERNEL__\n";
		fp << "#include \"" << comnam << ".h\"\n";
		fp << "#else /* __KERNEL__ */\n";
		fp << "#include \"../user/" << comnam << ".h\"\n";
		fp << "#endif /* !__KERNEL__ */\n";
	} else
#endif /* EXPORTS_USE_USER_HEADERS */
	{
		fp << "#include \"" << comnam << ".h\"\n";
	}
	local dep_components = List();
	for (local f: funcs) {
		if (f !is Function)
			continue;
		if (f.block !is string)
			continue;
		if (f.component_name != comnam)
			continue;
		if (f.dont_export_symbol)
			continue;
		for (local dep: f.dependencies) {
			if (dep.component_name !is bound)
				continue;
			dep = dep.component_name;
			if (dep !in dep_components)
				dep_components.append(dep);
		}
	}
	for (local dep: dep_components) {
		if (dep == comnam)
			continue;
		fp << "#include \"" << dep << ".h\"\n";
	}
	fp << "\n"
	      "DECL_BEGIN\n"
	      "\n"
	      ;
	local in_cxx_system_header = false;
	local user_funcs = [];
	local kernel_funcs = [];
	for (local f: funcs) {
		if (f is IntermediateString) {
			if ("auto_kernel_source" in f.locations || "auto_source" in f.locations ||
			    "auto_kernel" in f.locations || "auto" in f.locations)
				kernel_funcs.append(f);
			if ("auto_libc_source" in f.locations ||
			    "auto_libc" in f.locations)
				user_funcs.append(f);
			continue;
		}
		if (f !is Function)
			continue;
		if (f.block !is string)
			continue;
		if (f.component_name != comnam)
			continue;
		if (f.dont_export_symbol)
			continue;
		if (f.export_in_kernel) {
			kernel_funcs.append(f);
		} else {
			user_funcs.append(f);
		}
	}
	local has_kernel_wchar = false;
	for (local f: kernel_funcs) {
		if (f is IntermediateString) {
			fp << f.string;
			continue;
		}
		f.generate_libc_impl(fp, key_libc_internal);
		if (f.wchar_function)
			has_kernel_wchar = true;
		fp << "\n";
	}
	if (user_funcs || has_kernel_wchar) {
		fp << "#ifndef __KERNEL__\n";
		for (local f: kernel_funcs) {
			if (f is IntermediateString)
				continue;
			if (f.wchar_function) {
				f.generate_libc_impl(fp, key_libd_internal);
				fp << "\n";
			}
		}
		for (local f: user_funcs) {
			if (f is IntermediateString) {
				fp << f.string;
				continue;
			}
			f.generate_libc_impl(fp, key_libc_internal);
			if (f.wchar_function)
				f.generate_libc_impl(fp, key_libd_internal);
			fp << "\n";
		}
		fp << "#endif /* !__KERNEL__ */\n";
	}
	/* Weakly export the functions. */
	for (local f: kernel_funcs) {
		if (f is IntermediateString)
			continue;
		if (f.helper_function)
			continue;
		if (f.allow_macros || f.args_is_varargs) {
			fp << "#undef " << f.name << "\n";
			for (local alt: f.alternate_names)
				fp << "#undef " << alt << "\n";
		}
	}
	for (local f: kernel_funcs) {
		if (f is IntermediateString)
			continue;
		if (f.helper_function)
			continue;
		if (!f.nocrt) {
			fp << "DEFINE_PUBLIC_WEAK_ALIAS(";
			fp << f.name << ", ";
			fp << key_libc_internal(f.name) << ");\n";
		}
		for (local alt: f.alternate_names) {
			fp << "DEFINE_PUBLIC_WEAK_ALIAS("
			   << alt << ", "
			   << key_libc_internal(f.name) << ");\n";
		}
	}
	if (user_funcs) {
		fp << "#ifndef __KERNEL__\n";
//		for (local f: kernel_funcs) {
//			if (f is IntermediateString)
//				continue;
//			if (f.helper_function)
//				continue;
//			if (f.allow_macros || f.args_is_varargs) {
//				if (f.wchar_function) {
//					for (local n: f.dosnames)
//						fp << "#undef " << n << "\n";
//				}
//			}
//		}
		for (local f: kernel_funcs) {
			if (f is IntermediateString)
				continue;
			if (f.helper_function)
				continue;
			if (f.wchar_function) {
				for (local n: f.dosnames) {
					fp << "DEFINE_PUBLIC_WEAK_ALIAS(" << n << ", "
					   << key_libd_internal(f.name) << ");\n";
				}
			}
		}
		for (local f: user_funcs) {
			if (f is IntermediateString)
				continue;
			if (f.helper_function)
				continue;
			if (f.allow_macros || f.args_is_varargs) {
				fp << "#undef " << f.name << "\n";
				for (local alt: f.alternate_names)
					fp << "#undef " << alt << "\n";
//				if (f.wchar_function) {
//					for (local n: f.dosnames)
//						fp << "#undef " << n << "\n";
//				}
			}
		}
		for (local f: user_funcs) {
			if (f is IntermediateString) {
				fp << f.string;
				continue;
			}
			if (f.helper_function)
				continue;
			if (!f.nocrt) {
				fp << "DEFINE_PUBLIC_WEAK_ALIAS(";
				fp << f.name << ", ";
				fp << key_libc_internal(f.name) << ");\n";
			}
			for (local alt: f.alternate_names) {
				fp << "DEFINE_PUBLIC_WEAK_ALIAS(";
				fp << alt << ", ";
				fp << key_libc_internal(f.name) << ");\n";
			}
			if (f.wchar_function) {
				for (local n: f.dosnames) {
					fp << "DEFINE_PUBLIC_WEAK_ALIAS(" << n << ", "
					   << key_libd_internal(f.name) << ");\n";
				}
			}
		}
		fp << "#endif /* !__KERNEL__ */\n";
	}
	fp << "\n"
	      "DECL_END\n"
	      "\n"
	      "#endif /* !" << guard_name << " */\n";
}

/* Write the libc fallback implementations. */
print;
for (local comnam, funcs: components) {
	for (local f: funcs) {
		if (f is IntermediateString) {
			if ("auto_kernel_source" in f.locations || "auto_kernel_header" in f.locations ||
			    "auto_libc_source" in f.locations || "auto_libc_header" in f.locations ||
			    "auto_kernel" in f.locations || "auto_source" in f.locations ||
			    "auto_libc" in f.locations || "auto" in f.locations)
				goto do_create_libc_auto_impl;
			continue;
		}
		if (f !is Function)
			continue;
		if (f.block !is string)
			continue;
		if (f.component_name != comnam)
			continue;
		if (f.dont_export_symbol)
			continue;
		goto do_create_libc_auto_impl;
	}
	continue;
do_create_libc_auto_impl:
	local compath = "src/libc/auto/{}.c".format({ comnam });
	print "Creating libc auto-implementation: ", compath;
	write_hashed_file(compath, [](fp) {
		write_libc_auto_implementation(fp, comnam, funcs);
	});
}

print;

/* Write the crt-all-features header File. */
write_hashed_file_l("include/crt-features/all.h", [](fp) {
	local feat = List(all_crt_features);
	feat.sort();
	fp << copyright << "\n\n\n";
	for (local f: feat)
		fp << "#define __CRT_HAVE_" << f << " 1\n";
});


write_hashed_file_l("include/crt-features/crt-kos-sections.h", [](fp) {
	final local prefix_crt_section     = "__CRT_SECTION_";
	final local prefix_crt_dos_section = "__CRT_DOS_SECTION_";
	local sections_map = Dict();
	for (local name, func: functions) {
		if (!func.got_implementation)
			continue;
		local knam = func.get_section_prefix(WCHAR_MODE_KOS).lsstrip(".text.crt");
		sections_map.setdefault(knam, []).append((prefix_crt_section + func.name, func.name));
		if (func.wchar_function) {
			local dnam = func.get_section_prefix(WCHAR_MODE_DOS).lsstrip(".text.crt");
			sections_map.setdefault(dnam, []).append((prefix_crt_dos_section + func.name, func.name));
		}
	}
	local longest_function_name = 0;
	for (local none, names: sections_map) {
		for (local n, none: names) {
			local temp = #n;
			if (longest_function_name < temp)
				longest_function_name = temp;
		}
	}
	fp << copyright << "\n\n\n";
	known_libc_sections.update(sections_map.keys);
	local libc_sections = List(known_libc_sections);
	libc_sections.sort();
	import util;
	function sectinfo_name(name: string): string {
		return "__CRT_SECTINFO_{}".format({ name.lstrip(".").replace(".", "_") });
	}
	function sectinfo_symbol(name: string): string {
		return name.lstrip(".").replace(".", "_");
	}
	local longest_section_name = 0;
	for (local i, name: util.enumerate(libc_sections)) {
		local temp = #sectinfo_name(name);
		if (longest_section_name < temp)
			longest_section_name = temp;
	}
	for (local i, name: util.enumerate(libc_sections)) {
		local temp = sectinfo_name(name);
		fp << "#define " << temp << (" " * (longest_section_name - #temp));
		fp << " (" << i << ", " << name << ", " << sectinfo_symbol(name) << ")\n";
	}
	fp << "#define __CRT_ENUMERATE_SECTIONS(CB) \\\n";
	for (local name: libc_sections) {
		local temp = sectinfo_name(name);
		fp << "\tCB(" << temp << ")" << (" " * (longest_section_name - #temp)) << " \\\n";
	}
	fp << "/**/\n";
	fp << "\n";
	for (local section: libc_sections) {
		local names = sections_map.get(section);
		if (names is none)
			continue;
		names = names.sorted([](x) -> x[0]);
		fp << "/* .text.crt" << section << ".* */\n";
		for (local name, fname: names) {
			local spc = " " * (longest_function_name - #name);
			local sectinfo = sectinfo_name(section);
			fp << "#define " << name << spc << " " << sectinfo;
			fp << (" " * (longest_section_name - #sectinfo));
			fp << " /* .text.crt" << section << "." << fname << " */\n";
		}
		fp << "\n";
	}
});


local functions_sorted = List(functions.values);
functions_sorted.sort(Function.name);

write_hashed_file_l("include/crt-features/crt-kos-functions-attr.h", [](fp) {
	final local traced_attributes = {
		"ATTR_RETURNS_TWICE",
		"ATTR_NORETURN",
		"ATTR_NOTHROW",
		"ATTR_NOTHROW_NCX",
		"ATTR_NOTHROW_RPC",
		"ATTR_NOTHROW_RPC_KOS",
		"ATTR_NOTHROW_RPC_NOKOS",
		"ATTR_NOTHROW_RPC_PURE",
		"ATTR_PURE",
		"ATTR_CONST",
	};
	fp << copyright << "\n";
	for (local attr: traced_attributes) {
		local is_first = true;
		for (local f: functions_sorted) {
			if (attr !in f.attr_tags)
				continue;
			if (is_first) {
				fp << "\n\n/* " << attr << " */\n";
				is_first = false;
			}
			fp << "#define __CRT_" << attr << "_" << f.name << " 1\n";
		}
	}
});

write_hashed_file_l("include/crt-features/crt-kos-functions.h", [](fp) {
	fp << copyright << "\n\n\n";
	fp << "/* __CRT_FUNCTION(name, num_intern_aliases, intern_aliases, argc, args, return_type, ...)\n"
	      " * name:               <KEYWORD>\n"
	      " * num_intern_aliases: <INT>\n"
	      " * intern_aliases:     (pp_cond, name [, ...])\n"
	      " * argc:               <INT> / VA(<INT>: ARGC_BEFORE_ELLIPSIS)\n"
	      " * args:               (<TYPENAME:typeI>, <KEYWORD:nameI> [, ...])\n"
	      " * return_type:        <TYPENAME>\n"
	      " */\n";
	function printEnumerationArguments(f: Function, wchar_t_replacement: int) {
		fp << f.name << ",";
		fp << #f.intern_aliases << ",(";
		local is_first = true;
		for (local cond, alias_name: f.intern_aliases) {
			if (alias_name is Cell)
				alias_name = alias_name.value;
			if (!is_first)
				fp << ",";
			is_first = false;
			fp << cond.replace("defined", "IS_DEFINED") << "," << alias_name;
		}
		fp << "),";
		if (f.args_is_varargs) {
			fp << "VA(" << (#f.args-1) << ")";
		} else {
			fp << #f.args;
		}
		fp << ",(";
		local is_first = true;
		for (local typ,name: f.args_is_varargs ? f.args[:-1] : f.args) {
			if (!is_first)
				fp << ",";
			is_first = false;
			for (local is_word, word: split_words(typ, f)) {
				if (is_word)
					word = replace_word(word, REPLACE_TYPE_WORDS_LIBC, wchar_t_replacement);
				fp << word;
			}
			fp << "," << name;
		}
		fp << ")";
		fp << ",";
		for (local is_word, word: split_words(f.return_type, f)) {
			if (is_word)
				word = replace_word(word, REPLACE_TYPE_WORDS_LIBC, wchar_t_replacement);
			fp << word;
		}
	}
	fp << "/* Functions defined in headers, and exported from libc */\n";
	fp << "#ifdef __CRT_FUNCTION\n";
	for (local f: functions_sorted) {
		if (!f.got_implementation)
			continue;
		if (f.wchar_function)
			continue;
		fp << "__CRT_FUNCTION(";
		printEnumerationArguments(f, WCHAR_MODE_KOS);
		fp << ")\n";
	}
	fp << "#endif /* __CRT_FUNCTION */\n\n\n\n";
	fp << "/* Functions that don't have dedicated implementations in libc, but are\n"
	      " * exposed in headers (usually by being aliased to another function) */\n";
	fp << "#ifdef __CRT_FAKE_FUNCTION\n";
	for (local f: functions_sorted) {
		if (f.got_implementation)
			continue;
		if (f.helper_function)
			continue;
		fp << "__CRT_FAKE_FUNCTION(";
		printEnumerationArguments(f, WCHAR_MODE_KOS);
		fp << ")\n";
	}
	fp << "#endif /* __CRT_FAKE_FUNCTION */\n\n\n\n";
	fp << "#ifdef __CRT_KOS_WCHAR_FUNCTION\n";
	for (local f: functions_sorted) {
		if (!f.got_implementation)
			continue;
		if (!f.wchar_function)
			continue;
		fp << "__CRT_KOS_WCHAR_FUNCTION(";
		printEnumerationArguments(f, WCHAR_MODE_KOS);
		fp << ")\n";
	}
	fp << "#endif /* __CRT_KOS_WCHAR_FUNCTION */\n\n\n\n";
	fp << "#ifdef __CRT_DOS_WCHAR_FUNCTION\n";
	for (local f: functions_sorted) {
		if (!f.got_implementation)
			continue;
		if (!f.wchar_function)
			continue;
		fp << "__CRT_DOS_WCHAR_FUNCTION(";
		printEnumerationArguments(f, WCHAR_MODE_DOS);
		fp << ")\n";
	}
	fp << "#endif /* __CRT_DOS_WCHAR_FUNCTION */\n";
});

unimplemented_functions = unimplemented_functions.sorted();
function print_unimplemented_functions_header(fp: File, prefix: string) {
	fp << copyright << "\n";
	for (local n: unimplemented_functions) {
		fp << "#define " << prefix << n << " 1\n";
	}
}

write_hashed_file_l("include/crt-features/crt-kos-stubs.h", [](fp) {
	print_unimplemented_functions_header(fp, "__CRT_STUB_");
});
write_hashed_file_l("include/gnu/stubs.h", [](fp) {
	print_unimplemented_functions_header(fp, "__stub_");
});

print;

function update_sections_order(filename: string) {
	print "Loading sections order from: ", filename;
	final local start_pattern = "/*[[[order";
	final local end_pattern = "]]]*/";
	final local end2_pattern = "//[[[end]]]";
	local text = File.open(filename, "r")
		.read()
		.decode("utf-8")
		;
	local input_start = text.index(start_pattern) + #start_pattern;
	local input_end = text.index(end_pattern, input_start);
	local output_start = input_end + #end_pattern;
	local output_end = text.index(end2_pattern, output_start);
	local input = text[input_start:input_end].unifylines().expandtabs(4).replace("\\\n", "");
	function err(message) {
		print getFilenameForLog(filename), ":", "Error", ":", message;
		throw Error("Error : " + message);
	}
	local section_rules = [];
	local repeat_rules = [];
	for (local l: input.splitlines(false)) {
		l = l.strip();
		if (!l || l.startswith("#"))
			continue;
		local com_start = l.find("#");
		if (com_start >= 0)
			l = l[:com_start].rstrip();
		if (l.startswith("@")) {
			l = l[1:].lstrip();
			if (!l.startswith("REPEAT"))
				err("Expected REPEAT after `@' in {!r}".format({ l }));
			l = l[#"REPEAT":].lstrip();
			if (!l.endswith("*"))
				err("Releat rule {!r} does not end with `*'".format({ l }));
			l = l[:-1];
			if (" " in l)
				err("Releat rule {!r} contains spaces".format({ l }));
			repeat_rules.append(l);
			continue;
		}
		for (;;) {
			local newl = l.replace("  ", " ");
			if (newl == l)
				break;
			l = newl;
		}
		local section_parallel = [];
		for (local part: l.split(" ")) {
			part = part.strip();
			if (!part)
				continue;
			if (!part.endswith("*"))
				err("Match rule for section {!r} does not end with `*'".format({ part }));
			part = part[:-1];
			if (" " in part)
				err("Match rule {!r} contains spaces".format({ part }));
			section_parallel.append(part);
		}
		if (!section_parallel)
			continue;
		section_rules.append(section_parallel);
	}
	local full_section_rules = copy section_rules;
	for (local rr: repeat_rules) {
		for (local srs: section_rules) {
			local tab = [];
			for (local sr: srs)
				tab.append(rr + sr);
			full_section_rules.append(tab);
		}
	}
	section_rules = full_section_rules;
	@@Sorted list of section rules, sorted descendingly by rule length
	@@The first element describes the rule's index within the
	import enumerate from util;
	local sorted_section_rules: {(int, string)...} = List();
	for (local i, names: enumerate(section_rules)) {
		for (local n: names)
			sorted_section_rules.append((i, n));
	}
	sorted_section_rules.sort([](item) -> #item[1]);  /* Sort based on the length of the name */
	sorted_section_rules.reverse();
	@@Final list of sections, sorted by their link order
	local final_sections_mapping: {{string...}...} = List(for (local x: [:#section_rules]) []);
	local sections = copy known_libc_sections;
	while (sections) {
		local sect = sections.popitem().lsstrip(".text.crt");
		for (local index, sr: sorted_section_rules) {
			if (!sect.startswith(sr))
				continue;
			final_sections_mapping[index].append(sect);
			goto done_sect;
		}
		err("Unmatched section {!r}".format({ sect }));
done_sect:
		;
	}
	/* Output the final section ordering */
	File.Writer tempfp;
	tempfp << "\n#define __CRT_LINKORDER_SECTIONS(CB, PREFIX) \\\n";
	local written_sections = HashSet();
	for (local sects: final_sections_mapping) {
		if (!sects)
			continue;
		sects.sort();
		tempfp << "\tCB(";
		local is_first = true;
		local current_line = HashSet();
		for (local s: sects) {
			s += ".";
			for (local x: current_line) {
				if (s.startswith(x))
					goto next_section;
			}
			for (local x: written_sections) {
				if (s.startswith(x)) {
					err("Invalid section order. - Section {!r} cannot appear after {!r}\n"
					    "The later must either be removed, or be renamed to not be the start of the first"
					    .format({ s, x }));
				}
			}
			if (!is_first)
				tempfp << " ";
			is_first = false;
			tempfp << "PREFIX" << s << "*";
			written_sections.insert(s);
			current_line.insert(s);
next_section:
			;
		}
		tempfp << ") \\\n";
	}
	tempfp << "/**/\n";
	tempfp = tempfp.string;
	if (text[output_start:output_end] != tempfp) {
		print "\tUpdating sections order in: ", filename;
		text = "{}{}{}".format({
			text[:output_start],
			tempfp,
			text[output_end:]
		});
		File.open(filename, "w").write(text);
	}
}

update_sections_order("include/crt-features/crt-kos-sections-order.h");

print;
print "DONE";
print "    You may now resume programming";






