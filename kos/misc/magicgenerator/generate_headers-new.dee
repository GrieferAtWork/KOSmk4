global COPYRIGHT =
"/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */";

import * from deemon;
import * from ..libgen.c.cheaders;
import * from ..libgen.c.escape;
import * from ..libgen.c.parser;
import * from ..libgen.c.writer;
import * from ..libgen.c.loader;
import * from ..libgen.c.globals;
import Function from ..libgen.c.cheaders;
import fs;

@@Set of known kernel exports (populated by %[declare_kernel_export(...)])
global final knownKernelExports: {string...} = HashSet();

@@Parse custom directives that are so obscure that
@@they shouldn't be part of the standard loader
@@@return: * : Indicative of the directive having been recognized.
function customDirectivesParser(context: LoaderContext): bool {
	local self = context.self;
	local tok = self.tok;
	switch (tok) {

	case "declare_kernel_export":
		self.next();
		tok = self.skip("(");
		while (tok !in ["", ")"]) {
			local name = parseCStringOrFunctionLikeExpression(self);
			knownKernelExports.insert(name);
			if (self.tok != ",")
				break;
			tok = self.next();
		}
		self.skip(")");
		break;

	default:
		return false;
	}
	return true;
}

function compileSystemHeaderSourceFile(filename: string, headerName: string) {
	print "Compiling:", filename;
	local parser = CParser(File.open(filename), filename: filename);
	loadSystemHeaderDefinitions(
		self:                   parser,
		headerName:             headerName,
		customDirectivesParser: customDirectivesParser);

}

/* Load all the definitions files */
fs.chdir(fs.headof(__FILE__) + "/../../src/libc/magic");

try {
	for (local filename: fs.query("*.c")) {
		local fullPath = fs.abspath(filename);
		/* XXX: There are only a couple of ways by which different definition
		 *      files actually interact with each other:
		 *  - %[define_replacement(...)]
		 *  - %[define_wchar_replacement(...)]
		 *  - %[define_XXX_replacement(...)]
		 *  - %[insert:extern(...)]
		 *  - foo(*) = bar;
		 * We could create some sort of database that contains information about
		 * which source files define some feature/function, which might allow us
		 * to not have to re-compile everything anything something changes! */
		compileSystemHeaderSourceFile(fullPath, fs.fileof(filename));
	}
} catch (e...) {
	print repr e;
	print repr Traceback.current;
	Error.AppExit.exit(1);
}
Error.AppExit.exit(0);




#if 0
local startLine = __LINE__;
local headerDef = loadSystemHeaderDefinitions(CParser(r"

%{
__SYSDECL_BEGIN

}

//%[define_ccompat_header(cwchar)]
//%[insert:std]


@@Bla bla bla
[[if(__SIZEOF_WCHAR_T__ == 2), alias(memcpyw)]]
[[if(__SIZEOF_WCHAR_T__ == 4), alias(memcpyl)]]
[[wchar, nonnull, fast]] $wchar_t *
wmemcpy([[nonnull]] $wchar_t *__restrict dst,
        [[nonnull]] $wchar_t const *__restrict src,
        size_t num_chars) {
	size_t i;
	for (i = 0; i < num_chars; ++i)
		dst[i] = src[i];
	return dst;
}

%
%
c16memcpy(*) %{uchar(wmemcpy)}
c32memcpy(*) %{uchar(wmemcpy)}


%
%
c32memcpy_alias(*) = wmemcpy;


//%
//[[if(__SIZEOF_WCHAR_T__ == 2), alias(wmemcpy)]][[alias(DOS$wmemcpy)]]
//[[if(__SIZEOF_WCHAR_T__ == 2), bind_local_function(wmemcpy)]]
//[[nocrt, cc(LIBDCALL), nonnull]] char16_t *
//c16memcpy([[nonnull]] char16_t *__restrict dst,
//          [[nonnull]] char16_t const *__restrict src,
//          size_t num_chars) {
//	size_t i;
//	for (i = 0; i < num_chars; ++i)
//		dst[i] = src[i];
//	return dst;
//}

%{

__SYSDECL_END
}

".unifylines(), firstLineOffset: startLine), headerName: "wchar");

local fp = CWriter(File.stdout);

print "HEADER:";
headerDef.cprintHeader(fp, ESCAPE_MODE_PART);
fp.flush();

print #headerDef.functionsByName["c16memcpy"].functionBindings;
print #headerDef.functionsByName["c32memcpy"].functionBindings;

print "AUTO:";
headerDef.cprintLibraryAutoHeader(fp, ESCAPE_MODE_NONE);
headerDef.cprintLibraryAutoSourceImplementations(fp, ESCAPE_MODE_NONE);
headerDef.cprintLibraryAutoSourceExports(fp, ESCAPE_MODE_NONE);
fp.flush();

print "USER:";
headerDef.cprintLibraryUserHeader(fp, ESCAPE_MODE_NONE);
headerDef.cprintLibraryUserSourceImplementations(fp, ESCAPE_MODE_NONE);
headerDef.cprintLibraryUserSourceExports(fp, ESCAPE_MODE_NONE);
fp.flush();

//
//print "LOCAL:foo:";
//allLocalFunctionsByName["foo"].cprintLocalFunctionHeader(
//	fp, ESCAPE_MODE_FULL, "__LIBC", printCopyright: false);

//fp.namespace = "";
//for (local x: neededLocalFunction.sorted([](x) -> x.name)) {
//	x.cprintLocalFunctionHeader(
//		fp, ESCAPE_MODE_FULL, "__LIBC", false);
//}


print "DONE";
Error.AppExit.exit(0);

//localWcslen.implementations[0].dependencies["__localdep_wcslen"] = wcslen;
//localWcslen.cprintLocalFunctionHeader(writer, dependencyDecl: "__LIBC");
//print repr allSystemHeaders;


#endif
