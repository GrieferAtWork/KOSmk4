local copyright =
"/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */";

#undef IGNORE_HASH_DIFF
#if 0
#define IGNORE_HASH_DIFF 1
#endif

/*
 * Input:
 *  /kos/include/asm/syscalls.def
 *  /kos/include/{name}/asm/syscalls{suffix}.def
 *
 *
 * Output:
 *  /kos/include/kos/syscalls.h
 *  /kos/include/{name}/kos/syscalls{suffix}.h
 *       >> __CDECLARE_VOID_SC(ATTR_NORETURN,exit,(syscall_ulong_t status),(status))
 *
 *  /kos/include/crt-features/crt-kos-syscalls.h
 *  /kos/include/{name}/crt-features/crt-kos-syscalls{suffix}.h
 *       CRT feature definitions for syscall prototypes
 *       >> #define __CRT_HAVE_sys_exit 1
 *
 *  /kos/include/asm/syscalls.h
 *  /kos/include/asm/syscalls-proto.h
 *  /kos/include/asm/syscalls-trace.h
 *  /kos/include/{name}/asm/syscalls{suffix}.h
 *  /kos/include/{name}/asm/syscalls{suffix}_d.h
 *  /kos/include/{name}/asm/syscalls-proto{suffix}.h
 *  /kos/include/{name}/asm/syscalls-proto{suffix}_d.h
 *  /kos/include/{name}/asm/syscalls-trace{suffix}.h
 *  /kos/include/{name}/asm/syscalls-trace{suffix}_d.h
 *       Syscall ID and meta-data definitions
 *       >> #define __NR_exit 123
 *
 *  /kos/include/kos/syscalls.h
 *  /kos/include/{name}/kos/syscalls{suffix}.h
 *       Syscall implementation requests
 *       >> #define __ARCH_WANT_SYSCALL_NANOSLEEP 1
 *       >> #define __ARCH_WANT_COMPAT_SYSCALL_NANOSLEEP 1
 *
 *  /kos/include/asm/ls-syscalls.h
 *  /kos/include/{name}/asm/ls-syscalls{suffix}.h
 *       Enumerate system calls, and system call grounds
 *       >> __SYSCALL(exit)
 *
 *  /kos/include/bits/syscalls.h
 *  /kos/include/{name}/bits/syscalls{suffix}.h
 *       Define SYS_* aliases for __NR_* macros
 *       These headers are included by `<sys/syscall.h>'
 *       >> #define SYS_exit __NR_exit
 *
 *  /kos/src/kernel/core/arch/{name}/syscall/wrappers{suffix}.S
 *       Define assembly wrappers for invoking C-level system call functions
 *       >> INTERN_FUNCTION(__asm32_int80_exit) ...; call sys_exit
 *
 *  /kos/src/libc/libc/arch/{name}/syscalls{suffix}.S
 *       Define libc wrappers for invoking kernel-space system calls
 *       This is that libc uses to export all of the `sys_XXX' symbols.
 *       >> INTERN_FUNCTION(libc_sys_exit)
 *
 */

import fs;
import util;
import * from deemon;
import hash from hashlib;
import optimizePrintf from ..libgen.optiprintf;

global final HASHFUNCNAME = "CRC-32";
global final ABC = "abcdefghijklmnopqrstuvwxyz";

function getFilenameForLog(filename: string): string {
	return fs.abspath(filename);
}

@@Safely re-write a hashed file @filename, by calling ${fp_writer(fp: File)}
function writeHashedFile(filename: string, fp_writer: Callable) {
	print "Updating file:", filename;
#ifndef IGNORE_HASH_DIFF
	local old_text = none;
	try {
		local firstline;
		with (local old_fp = File.open(filename, "r")) {
			firstline = old_fp.readline();
			old_text = old_fp.read();
		}
		if (!firstline)
			goto do_overwrite_file;
		local old_hash = firstline.decode("utf-8").scanf(" /* HASH %[^ *]")...;
		old_hash = old_hash.strip();
		local old_hash_name, none, old_hash_value = old_hash.partition(":")...;
		local expected_old_hash = hash(old_hash_name, old_text).hex();
		if (old_hash_value != expected_old_hash) {
			print "\n\n",;
			print getFilenameForLog(filename),;
			print ": Error: File", repr filename, "has been modified";
			print "\tStored hash:  ", old_hash_value;
			print "\tExpected hash:", expected_old_hash;
			throw "Don't overwrite modified File";
		}
	} catch (Error.SystemError.FSError.FileNotFound) {
		/* Fallthough -- Re-write the File. */
	} catch (Error.ValueError.UnpackError) {
		print "\n\n",;
		print getFilenameForLog(filename),;
		print ": Error: File", repr filename, "has been modified";
		print "\tNo hash information tag found within the File";
		throw "Don't overwrite modified File";
	}
do_overwrite_file:
#endif /* !IGNORE_HASH_DIFF */
	File.Writer contents;
	fp_writer(contents);
	contents = contents.string.encode("utf-8").bytes();
#ifndef IGNORE_HASH_DIFF
	if (old_text is none || old_text != contents)
#endif /* !IGNORE_HASH_DIFF */
	{
		with (local fp = File.open(filename, "w")) {
			local new_hash = hash(HASHFUNCNAME, contents).hex();
			fp << "/* HASH " << HASHFUNCNAME << ":" << new_hash << " */\n";
			fp.write(contents);
		}
	}
}


@@Mapping between types and their respective origins
global syscallTypeDeclarationOrigins: {string: string} = Dict();
global syscallTypeMustPushMacro: HashSet with string = HashSet();

class CType {
	this = default;
	operator == (other: CType) {
		if (this === other)
			return true;
		return typename == other.typename &&
		       isReg64 == other.isReg64 &&
		       isReg128 == other.isReg128;
	}
	operator != (other: CType) {
		return !(this == other);
	}

	@@Name of the type (e.g. `string')
	member typename: string = "void";
	member isReg64: bool = false; /* [reg64] */
	member isReg128: bool = false; /* [reg128] */
	@@The body of the accompanying `[tostr(...)]' tag (if any)
	@@When @none, use the default method for @typename instead
	member tostrMethod: string = none;
	property typenameBase: string = {
		get(): string {
			local r = typename;
			if (r.endswith("]"))
				r = r[:r.rindex("[")] + " *";
			return r;
		}
	}
	property escapedTypenameBase: string = {
		get(): string {
			local r = escapedTypename;
			if (r.endswith("]"))
				r = r[:r.rindex("[")] + " *";
			return r;
		}
	}
	property escapedTypename: string = {
		get(): string {
			if (typename.startswith("struct "))
				return typename;
			if (typename && typename.issymstrt(0) && !typename.startswith("__")) {
				local e = 0;
				while (e < #typename && typename.issymcont(e))
					++e;
				local n = typename[:e];
				if (n !in ["int", "short", "long", "char",
				           "signed", "unsigned", "void"])
					return "__" + typename;
			}
			return typename;
		}
	}
	gatherUsedStructTypes(types: HashSet with string) {
		if (typename.startswith("struct ")) {
			local s = 7;
			local len = #typename;
			while (s < len && typename.isspace(s))
				++s;
			local e = s;
			while (e < len && typename.issymcont(e))
				++e;
			if (s < e)
				types.insert(typename[s:e]);
		}
	}
	gatherTypeOriginHeaders(headers: HashSet with string) {
		if (typename.startswith("struct ")) {
			local s = 7;
			local len = #typename;
			while (s < len && typename.isspace(s))
				++s;
			local e = s;
			while (e < len && typename.issymcont(e))
				++e;
			if (s < e) {
				local org = syscallTypeDeclarationOrigins.get(typename[s:e]);
				if (org !is none)
					headers.insert(org);
			}
			return;
		}
		if (typename && typename.issymstrt(0)) {
			local e = 0;
			while (e < #typename && typename.issymcont(e))
				++e;
			local n = typename[:e];
			if (n !in ["int", "short", "long", "char",
			           "signed", "unsigned", "void"]) {
				local org = syscallTypeDeclarationOrigins.get(n);
				if (org is none)
					org = syscallTypeDeclarationOrigins.get("__" + n);
				if (org !is none)
					headers.insert(org);
			}
		}
	}
	gatherPragmaPushMacroNames(names: HashSet with string) {
		if (typename.startswith("struct ")) {
			local s = 7;
			local len = #typename;
			while (s < len && typename.isspace(s))
				++s;
			local e = s;
			while (e < len && typename.issymcont(e))
				++e;
			if (s < e) {
				local n = typename[s:e];
				if (n in syscallTypeMustPushMacro)
					names.insert(n);
			}
			return;
		}
		if (typename && typename.issymstrt(0) && !typename.startswith("__")) {
			local e = 0;
			while (e < #typename && typename.issymcont(e))
				++e;
			local n = typename[:e];
			if (n !in ["int", "short", "long", "char",
			           "signed", "unsigned", "void"]) {
				n = "__" + n;
				if (n in syscallTypeMustPushMacro)
					names.insert(n);
			}
		}
	}
}

final global FUNCTION_RESTART_MODE_AUTO = 0;
final global FUNCTION_RESTART_MODE_DONT = 1;
final global FUNCTION_RESTART_MODE_MUST = 2;

class Function {
	this = default;
	operator < (other: Function) {
		return name < other.name;
	}
	operator > (other: Function) {
		return name > other.name;
	}
	operator == (other: Function) {
		if (this === other)
			return true;
		return name == other.name &&
		       returnType == other.returnType &&
		       args == other.args &&
		       doc == other.doc &&
		       restartMode == other.restartMode &&
		       isCp == other.isCp &&
		       isNoReturn == other.isNoReturn &&
		       isNoExcept == other.isNoExcept;
	}
	operator != (other: Function) {
		return !(this == other);
	}
	operator str(): string {
		File.Writer tempfp;
		printPrototype(tempfp);
		return tempfp.string;
	}

	@@Function name
	member name: string;

	@@Function return type
	member returnType: CType;

	@@Function argument list
	member args: {(CType, string)...} = [];

	@@Documentation string
	member doc: string = "";

	@@One of `FUNCTION_RESTART_MODE_*'
	member restartMode: int = FUNCTION_RESTART_MODE_AUTO;

	member declFilename: string;
	member declLine: int;
	member isCp: bool = false;       /* [cp] */
	member isNoReturn: bool = false; /* [noreturn] */
	member isNoExcept: bool = false; /* [noexcept] */

	getArgumentRegisterCount(registerSizeInBits: int): int {
		local r = #args;
		if (registerSizeInBits != 0) {
			for (local t, none: args) {
				if (t.isReg128 && registerSizeInBits < 128) {
					++r;
				} else if (t.isReg64 && registerSizeInBits < 64) {
					++r;
				}
			}
		}
		return r;
	}

	err(message: string) {
		print getFilenameForLog(declFilename),;
		print "(",;
		print declLine,;
		print ") : Error : ",;
		print message;
		throw Error(message);
	}
	printPrototype(fp: File) {
		fp << returnType.typename;
		if (!returnType.typename.endswith("*"))
			fp << " ";
		fp << name << "(";
		if (!args)
			fp << "void";
		else {
			local isFirst = true;
			for (local t, n: args) {
				if (!isFirst)
					fp << ", ";
				isFirst = false;
				fp << t.typename;
				if (!t.typename.endswith("*"))
					fp << " ";
				fp << n;
			}
		}
		fp << ")";
	}
	printDoc(fp: File) {
		local lines = List(doc.splitlines());
		if (!lines)
			return;
		fp << "/* " << lines[0].rstrip();
		if (#lines == 1) {
			fp << " */\n";
		} else {
			for (local l: lines[1:])
				fp << "\n * " << l.rstrip();
			fp << " */\n";
		}
	}
	gatherUsedStructTypes(types: HashSet with string) {
		returnType.gatherUsedStructTypes(types);
		for (local t, none: args)
			t.gatherUsedStructTypes(types);
	}
	gatherTypeOriginHeaders(headers: HashSet with string) {
		returnType.gatherTypeOriginHeaders(headers);
		for (local t, none: args)
			t.gatherTypeOriginHeaders(headers);
	}
	gatherPragmaPushMacroNames(names: HashSet with string) {
		returnType.gatherPragmaPushMacroNames(names);
		for (local t, none: args)
			t.gatherPragmaPushMacroNames(names);
	}
	printFunctionAttributes(fp: File) {
		if (isNoReturn)
			fp << "__ATTR_NORETURN";
	}
}

class ParserContext {
	this = default;
	operator copy(other: ParserContext) {
		kosHeaderIncludePrefix = "";
		functions              = copy other.functions;
		sysidMappings          = copy other.sysidMappings;
		nameMappings           = copy other.nameMappings;
	}
	@@String prefix that should be printed in <kos/syscall.h>
	member kosHeaderIncludePrefix: string = "";
	@@Explicitly declared functions.
	member functions: {string: Function} = Dict();
	@@Mapping of system call IDs to (filename, line, name)
	member sysidMappings: {int: (string, int, string)} = Dict();
	@@Mapping of system call name to id
	member nameMappings: {string: int} = Dict();

	errSysID(sysid: int, message: string) {
		local file, line, none = sysidMappings[sysid]...;
		print getFilenameForLog(file),;
		print "(",;
		print line,;
		print ") : Error : ",;
		print message;
		throw Error(message);
	}
}

@@Avaialble mappings for automatic type->str conversion
global syscallTostrExpressions: {string: string} = Dict();

@@Mapping for @{(aArchTypename: {(aArchName, bArchName, bArchTypename)...}}
@@Note that @(aArchName <= bArchName)
global xArchBinaryTypeCompatibilities:
	{string: HashSet with (string, string, string)} = Dict();

@@Mapping for @{typename: {archName: int}}
global xArchTypeSizes: {string: {string: int}} = Dict();

@@Mapping for @{functionName: {functionNames...}}
@@Maps any grouped function name to a set of all function names (including the
@@original group name) that do share functionality, and may share binary compatibility
@@and should therefor be checked if binary compatibility is present as well.
global possiblyCompatibleFunctionGroups: {string: HashSet with string} = Dict();


final local BOOL_MAP = {
	""      : true,
	"1"     : true,
	"true"  : true,
	"0"     : false,
	"false" : false,
};

function sanitizeIncludeGuard(guard: string): string {
	return guard.upper()
		.replace("/", "_")
		.replace("-", "_")
		.replace(".", "_");
}

@@Join 2 strings `int' and `x' into `int x'
function joinVariableName(typ: string, name: string): string {
	if (!name)
		return typ;
	local name_suffix = "";
	for (;;) {
		typ = typ.strip();
		if (typ.endswith("]")) {
			local st = typ.rindexmatch("[", "]", 0, #typ-1);
			name_suffix += typ[st:];
			typ = typ[:st];
			continue;
		}
		break;
	}
	if (!typ.endswith("*"))
		typ += " ";
	return typ + name.strip() + name_suffix;
}

@@Split a string `int x' into `int' and `x'
function splitVariableName(s: string): (string, string) {
	local name_end = #s;
	local typ_suffix = "";
	for (;;) {
		if (name_end && s[name_end - 1] == "]") {
			local st = s.rfindmatch("[", "]", 0, name_end - 1);
			if (st >= 0) {
				typ_suffix += s[st:name_end];
				name_end = st;
				continue;
			}
		}
		break;
	}
	local name_start = name_end;
	while (name_start) {
		--name_start;
		if (!s.issymcont(name_start)) {
			++name_start;
			break;
		}
	}
	return (
		s.substr(0, name_start).strip() + typ_suffix,
		s.substr(name_start, name_end).strip());
}


@@Parse a type expression at @i
@@@return Tuple of (type_expr, var_name_or_empty_string, end_index)
function parseTypeExpression(
		filename: string, text: string,
		i: int, hasVarName: bool): (CType, string, int) {
	local len = #text;
	function err(i: int, message: string) {
		print getFilenameForLog(filename),;
		print "(",;
		print text.count("\n", 0, i) + 1,;
		print ") : Error : ",;
		print message;
		throw Error(message);
	}
	local returnType: CType = CType();
	local returnName: string = "";
	while (i < len) {
		local ch = text[i];
		++i;
		if (ch.isspace())
			continue;
		if (ch == "[") {
			for (;;) {
				while (i < len && text.isspace(i))
					++i;
				if (i >= len)
					err(i, "Unexpected EOF in attribute");
				local name_start = i;
				ch = text[i];
				++i;
				if (ch == "]")
					break;
				if (!ch.issymstrt())
					err(i - 1, "Unexpected character {!r} in attribute".format({ ch }));
				do {
					++i;
				} while (i < len && text.issymcont(i));
				local directive_name = text[name_start:i];
				while (i < len && text.isspace(i))
					++i;
				if (i >= len)
					err(i, "Unexpected EOF in attribute {!r}".format({ directive_name }));
				ch = text[i];
				local directive_args = "";
				if (ch == "(") {
					++i;
					local args_end = text.findmatch("(", ")", i);
					if (args_end < 0)
						err(i, "Unmatched `(' in attribute {!r}".format({ directive_name }));
					directive_args = text[i:args_end].strip();
					i = args_end + 1;
					while (i < len && text.isspace(i))
						++i;
					if (i >= len)
						err(i, "Unexpected EOF after attribute {!r}".format({ directive_name }));
				}
				function argsToBool() {
					local r = BOOL_MAP.get(directive_args);
					if (r !is none)
						return r;
					err(i, "Invalid bool constant: {!r}".format({ directive_args }));
				}
				switch (directive_name) {
				case "reg64": returnType.isReg64 = argsToBool(); break;
				case "reg128": returnType.isReg128 = argsToBool(); break;
				case "tostr": returnType.tostrMethod = directive_args; break;
				default:
					err(name_start, "Unknown attribute {!r}".format({ directive_name }));
				}
				ch = text[i];
				if (ch == "]")
					break;
				if (ch != ",")
					err(name_start, "Unknown character after attribute {!r}: {!r}"
						.format({ directive_name, ch }));
				++i;
			}
			++i;
			continue;
		}
		--i;
		break;
	}
	local typeExprStart = i;
	while (i < len) {
		local ch = text[i];
		++i;
		if (ch in "([{") {
			local end = text.findmatch(ch, {
				"(" : ")",
				"[" : "]",
				"{" : "}",
			}[ch], i);
			if (end < 0)
				err(i, "Unmatched {!r}".format({ ch }));
			i = end + 1;
			continue;
		}
		if (ch in ",)]};%") {
			--i;
			break;
		}
	}
	local typeExpr = text[typeExprStart:i].strip();
	if (hasVarName) /* Split the type expression */
		typeExpr, returnName = splitVariableName(typeExpr)...;
	returnType.typename = typeExpr;
	return (returnType, returnName, i);
}

function parseTypeCompatTypeList(text: string, start: int): (int, {string...} | none) {
	local textLen = #text;
	if (text.issymstrt(start)) {
		local nameEnd = start + 1;
		while (nameEnd < textLen && text.issymcont(nameEnd))
			++nameEnd;
		return (nameEnd, { text[start:nameEnd] });
	}
	if (text[start] != "[")
		return (start, none);
	local result: {string...} = HashSet();
	++start;
	while (start < textLen) {
		while (start < textLen && text.isspace(start))
			++start;
		if (start >= textLen)
			break;
		if (text[start] == "]")
			break;
		if (!text.issymstrt(start))
			return (start, none);
		local typenameStart = start;
		++start;
		while (start < textLen && text.issymcont(start))
			++start;
		result.insert(text[typenameStart:start]);
		while (start < textLen && text.isspace(start))
			++start;
		if (text[start] != ",")
			break;
		++start;
	}
	if (text[start] != "]")
		return (start, none);
	++start;
	return (start, result);
}

function registerXArchBinaryTypeCompatibility(
		aArchName: string, aArchTypename: string,
		bArchName: string, bArchTypename: string) {
	assert aArchName <= bArchName;
	local existCompatDefsForA: HashSet with (string, string, string);
	local existCompatDefsForB: HashSet with (string, string, string);
	existCompatDefsForA = xArchBinaryTypeCompatibilities.get(aArchTypename);
	existCompatDefsForB = xArchBinaryTypeCompatibilities.get(bArchTypename);
	local newCompatDef = (aArchName, bArchName, bArchTypename);
	if (existCompatDefsForA !is none) {
		if (newCompatDef in existCompatDefsForA)
			return;
		existCompatDefsForA.insert(newCompatDef);
	} else {
		existCompatDefsForA = HashSet({ newCompatDef });
		xArchBinaryTypeCompatibilities[aArchTypename] = existCompatDefsForA;
	}
	for (local altAn, altBn, AltBt: existCompatDefsForB) {
		/* altAt == bArchTypename */
		if (altAn != bArchName)
			continue;
		/* Found an existing compatibility:
		 * (bArchName,bArchTypename) <=> (altBn,AltBt) */
		registerXArchBinaryTypeCompatibility(aArchName, aArchTypename, altBn, AltBt);
	}
}




function registerXArchBinaryTypeCompatibilities(
		aArchName: string, aArchTypeList: {string...},
		bArchName: string, bArchTypeList: {string...}) {
	if (aArchName == "*")
		aArchName = "";
	if (bArchName == "*")
		bArchName = "";
	if (bArchName < aArchName) {
		local temp = bArchName;
		bArchName = aArchName;
		aArchName = temp;
		local temp = aArchTypeList;
		aArchTypeList = bArchTypeList;
		bArchTypeList = temp;
	} else if (aArchName == bArchName) {
		local total = HashSet(aArchTypeList);
		total.update(bArchTypeList);
		aArchTypeList = total;
		bArchTypeList = total;
	}
	for (local aArchTypename: aArchTypeList) {
		for (local bArchTypename: bArchTypeList) {
			registerXArchBinaryTypeCompatibility(
				aArchName, aArchTypename,
				bArchName, bArchTypename);
		}
	}
}

function getTypeSizeWithArch(typename: string, archName: string): int | none {
again:
	local typenameMap = xArchTypeSizes.get(typename);
	local r = typenameMap.get(archName);
	if (r is none)
		r = typenameMap.get("");
	if (r is string) {
		typename = r;
		goto again;
	}
	return r;
}

function areXArchTypesCompatibile(
		aArchName: string, aArchTypename: string,
		bArchName: string, bArchTypename: string) {
	if (aArchName > bArchName) {
		local temp = bArchName;
		bArchName = aArchName;
		aArchName = temp;
		local temp = aArchTypename;
		aArchTypename = bArchTypename;
		bArchTypename = temp;
	}
	local compatArchList: HashSet with (string, string, string);
	compatArchList = xArchBinaryTypeCompatibilities.get(aArchTypename);
	if (compatArchList !is none) {
		if ((aArchName, bArchName, bArchTypename) in compatArchList)
			return true;
		if ((aArchName, "", bArchTypename) in compatArchList)
			return true;
		if (("", bArchName, bArchTypename) in compatArchList)
			return true;
		if (("", "", bArchTypename) in compatArchList)
			return true;
	}
	/* Fallback: Check if both types have the same size */
	local aSize = getTypeSizeWithArch(aArchTypename, aArchName);
	if (aSize !is none) {
		local bSize = getTypeSizeWithArch(bArchTypename, bArchName);
		if (bSize !is none && aSize == bSize)
			return true;
	}
	return false;
}

function areCTypeNamesCompatible(
		aTypename: string, aContext: ParserContext, aArch/*: SyscallArch*/, aArchName: string,
		bTypename: string, bContext: ParserContext, bArch/*: SyscallArch*/, bArchName: string): bool {
	if (!aTypename.endswith("*") && !bTypename.endswith("*")) {
		/* Non-pointer (aka. literal) types are compatible when one of:
		 *  - sizeof(aArchName:aTypename) >= sizeof(bArchName:bTypename)
		 * Where `aArchName' is the ~real~ arch, and `bArchName' is the
		 * arch for which compatibility is attempted. */
		local aSize = getTypeSizeWithArch(aTypename, aArchName);
		local bSize = getTypeSizeWithArch(bTypename, bArchName);
		return aSize >= bSize;
	}
again:
	if (aTypename.endswith("*") && bTypename.endswith("*")) {
		local aBaseType = aTypename[:-1].rstrip();
		local bBaseType = bTypename[:-1].rstrip();
		if ("*" in aBaseType || "*" in bBaseType) {
			if (aArch.platformPointerSizeInBytes != bArch.platformPointerSizeInBytes)
				return false; /* Pointer-to-pointer, but different sizeof(void *) */
		}
		/* Check if pointed-to types are compatible */
		if (areXArchTypesCompatibile(aArchName, aBaseType,
		                             bArchName, bBaseType)) {
			return true;
		}
		aTypename = aBaseType;
		bTypename = bBaseType;
		goto again;
	}
	return false;
}

function removeWord(x: string, word: string): string {
	for (;;) {
		if (x.startswith(word + " ")) {
			x = x[#word:];
			continue;
		}
		if (x.endswith(" " + word)) {
			x = x[:-#word];
			continue;
		}
		local new_x = x.replace(" " + word + " ", "  ");
		if (new_x != x) {
			x = new_x;
			continue;
		}
		return x;
	}
}

function simpifyTypeName(x: string): string {
	x = removeWord(x, "const");
	x = removeWord(x, "volatile");
	x = removeWord(x, "struct");
	x = x.replace("[]", "*");
	for (;;) {
		local r = x.replace("  ", "");
		if (r.endswith("]"))
			r = r[:r.rindex("[")] + "*";
		r = r.replace(" *", "*").replace("* ", "*");
		if (r == x)
			break;
		x = r;
	}
	return x.strip();
}

function getSizeofCType(cType: CType, archName: string, pointerSize: int): int | none {
	local typename = simpifyTypeName(cType.typename);
	if (typename.endswith("*"))
		return pointerSize;
	return getTypeSizeWithArch(typename, archName);
}

function areCTypesCompatible(
		a: CType, aContext: ParserContext, aArch/*: SyscallArch*/, aArchName: string,
		b: CType, bContext: ParserContext, bArch/*: SyscallArch*/, bArchName: string): bool {
	return areCTypeNamesCompatible(
		simpifyTypeName(a.typename), aContext, aArch, aArchName,
		simpifyTypeName(b.typename), bContext, bArch, bArchName);
}

function areFunctionsBinaryCompatible(
		a: Function, aContext: ParserContext, aArch/*: SyscallArch*/, aArchName: string,
		b: Function, bContext: ParserContext, bArch/*: SyscallArch*/, bArchName: string): bool {
#define PRINT_COMPAT(...) print __VA_ARGS__
	PRINT_COMPAT("areFunctionsBinaryCompatible(a: ",);
	PRINT_COMPAT(repr str a,);
	PRINT_COMPAT(", aArchName: ",);
	PRINT_COMPAT(repr aArchName,);
	PRINT_COMPAT(", b: ",);
	PRINT_COMPAT(repr str b,);
	PRINT_COMPAT(", bArchName: ",);
	PRINT_COMPAT(repr bArchName,);
	PRINT_COMPAT(")... ",);
	if (a.isNoExcept != b.isNoExcept) {
		PRINT_COMPAT("No: isNoExcept");
		return false;
	}
//	if (a.isCp != b.isCp) {
//		PRINT_COMPAT("No: isCp");
//		return false;
//	}
	if (a.isNoReturn != b.isNoReturn) {
		PRINT_COMPAT("No: isNoReturn");
		return false;
	}
	if (!areCTypesCompatible(a.returnType, aContext, aArch, aArchName,
	                         b.returnType, bContext, bArch, bArchName)) {
		PRINT_COMPAT("No: returnType");
		return false;
	}
	local aArgs: {(CType, string)...} = a.args;
	local bArgs: {(CType, string)...} = b.args;
	if (#aArgs != #bArgs) {
		PRINT_COMPAT("No: argc");
		return false;
	}
	for (local i: [:#aArgs]) {
		local aArgType: CType = aArgs[i][0];
		local bArgType: CType = bArgs[i][0];
		if (!areCTypesCompatible(aArgType, aContext, aArch, aArchName,
		                         bArgType, bContext, bArch, bArchName)) {
			PRINT_COMPAT("No: arg",i,":",repr aArgType.typename,"!=",repr bArgType.typename);
			return false;
		}
	}
	PRINT_COMPAT("Yes");
	return true;
}

function skipComments(text: string, pos: int): int {
	if (pos + 1 < #text && text[pos] == "/") {
		local n = text[pos + 1];
		if (n == "*")
			return text.index("*/", pos + 2) + 2;
		if (n == "/")
			return text.index("\n", pos + 2) + 1;
	}
	return pos;
}

function skipSpace(text: string, pos: int): int {
	pos = skipComments(text, pos);
	while (pos < #text && text.isspace(pos)) {
		++pos;
		pos = skipComments(text, pos);
	}
	return pos;
}


function parseSyscallDefs(context: ParserContext, text: string, filename: string) {
	local i = 0;
	local len = #text;
	local currentFunction: Function | none = none;
	local currentFunctionPos: int = -1;
	local disallowFunctionOverride: HashSet with string = HashSet();
	local currentGroup: HashSet with string = none;
	local currentGroupPos: int = none;
	function err(i: int, message: string) {
		print getFilenameForLog(filename),;
		print "(",;
		print text.count("\n", 0, i) + 1,;
		print ") : Error : ",;
		print message;
		throw Error(message);
	}
	while (i < len) {
		local ch = text[i];
		++i;
		if (ch.isspace())
			continue;
		if (ch == "/" && i < len) {
			ch = text[i];
			if (ch == "/") {
				i = text.find("\n", i + 1);
				if (i < 0)
					break;
				i += 1;
				continue;
			}
			if (ch == "*") {
				local end = text.find("*/", i + 1);
				if (i < 0)
					err(i, "Missing */ after /*");
				i = end + 2;
				continue;
			}
		}
		if (ch == "%") {
			while (i < len && text.isspace(i))
				++i;
			if (i >= len)
				err(i, "Unexpected EOF after `%'");
			ch = text[i];
			if (ch == "[") {
				++i;
				for (;;) {
					while (i < len && text.isspace(i))
						++i;
					if (i >= len)
						err(i, "Unexpected EOF in directive");
					local name_start = i;
					ch = text[i];
					++i;
					if (ch == "]")
						break;
					if (!ch.issymstrt())
						err(i - 1, "Unexpected character {!r} in directive".format({ ch }));
					do {
						++i;
					} while (i < len && text.issymcont(i));
					local directive_name = text[name_start:i];
					while (i < len && text.isspace(i))
						++i;
					if (i >= len)
						err(i, "Unexpected EOF in directive {!r}".format({ directive_name }));
					ch = text[i];
					local directive_args = "";
					if (ch == "(") {
						++i;
						local args_end = text.findmatch("(", ")", i);
						if (args_end < 0)
							err(i, "Unmatched `(' in directive {!r}".format({ directive_name }));
						directive_args = text[i:args_end].strip();
						i = args_end + 1;
						while (i < len && text.isspace(i))
							++i;
						if (i >= len)
							err(i, "Unexpected EOF after directive {!r}".format({ directive_name }));
					}
					switch (directive_name) {

					case "define_tostr": {
						local typename, expr;
						if ("=" !in directive_args)
							err(i, "Missing `=' in define_tostr argument");
						typename, none, expr = directive_args.partition("=")...;
						typename = typename.strip();
						expr = expr.strip();
						if (typename in syscallTostrExpressions &&
						    syscallTostrExpressions[typename] != expr) {
							err(i, "define_tostr: redefined for {!r} (was: {!r}, is: {!r})"
								.format({ typename, syscallTostrExpressions[typename], expr }));
						}
						syscallTostrExpressions[typename] = expr;
					}	break;

					case "clear_syscall_id_table":
						context.sysidMappings.clear();
						context.nameMappings.clear();
						break;

					case "mustundef": {
						for (local x: directive_args.split(","))
							syscallTypeMustPushMacro.insert(x.strip());
					}	break;

					case "startgroup": {
						if (currentGroup !is none)
							err(i, "Already within a group");
						currentGroup = HashSet();
						currentGroupPos = i;
					}	break;

					case "endgroup": {
						if (currentGroup is none)
							err(i, "Not inside of a group");
						for (local x: currentGroup) {
							if (x in possiblyCompatibleFunctionGroups)
								err(i, "Function {!r} is already apart of different group {!r}"
									.format({ x, possiblyCompatibleFunctionGroups[x] }));
							possiblyCompatibleFunctionGroups[x] = currentGroup;
						}
						currentGroup = none;
						currentGroupPos = none;
					}	break;
					case "group": {
						/* Define a set of function names to share identical semantics,
						 * such that binary compatibility ~may~ be possible. */
						local group = HashSet(directive_args.split(",").each.strip());
						for (local x: group) {
							if (x in possiblyCompatibleFunctionGroups)
								err(i, "Function {!r} is already apart of different group {!r}"
									.format({ x, possiblyCompatibleFunctionGroups[x] }));
							possiblyCompatibleFunctionGroups[x] = group;
						}
					}	break;

					case "typecompat": {
						/* in i386-kos/asm/syscalls32.def:
						 * >> %[typecompat(i386:time64_t = x86_64:[time32_t,time64_t])]
						 * Syntax:
						 *  TYPELIST ::= (typename | ('[' ',' ~~ typename... ']'))
						 *  ',' ~~ (aArchName ':' TYPELIST '=' bArchName ':' TYPELIST)...
						 */
						local j = 0;
						local dlen = #directive_args;
						while (j < dlen) {
							j = skipSpace(directive_args, j);
							if (j >= dlen)
								break;
							local aArchNameStart = j;
							if (!directive_args.issymstrt(j) && directive_args[j] != "*")
								err(i + j, "Expected aArchName after %[typecompat(, but got {!r}"
									.format({ directive_args[j] }));
							++j;
							while (j < dlen && directive_args.issymcont(j))
								++j;
							local aArchName = directive_args[aArchNameStart:j];
							j = skipSpace(directive_args, j);
							if (j >= dlen || directive_args[j] != ":")
								err(i + j, "Expected ':' after aArchName, but got {!r}"
									.format({ directive_args.substr(j, j + 1) }));
							++j;
							j = skipSpace(directive_args, j);
							local aArchTypeList: {string...};
							j, aArchTypeList = parseTypeCompatTypeList(directive_args, j)...;
							if (aArchTypeList is none)
								err(i + j, "Expected 'aArchTypeList', but got {!r}"
									.format({ directive_args.substr(j) }));
							j = skipSpace(directive_args, j);
							if (j >= dlen || directive_args[j] != "=")
								err(i + j, "Expected '=' after aArchTypeList, but got {!r}"
									.format({ directive_args.substr(j, j + 1) }));
							++j;
							j = skipSpace(directive_args, j);
							if (j >= dlen || (!directive_args.issymstrt(j) && directive_args[j] != "*"))
								err(i + j, "Expected bArchName after `%[typecompat({}:{} =' but got {!r}"
									.format({ aArchName, List(aArchTypeList), directive_args.substr(j, j + 1) }));
							local bArchNameStart = j;
							++j;
							while (j < dlen && directive_args.issymcont(j))
								++j;
							local bArchName = directive_args[bArchNameStart:j];
							j = skipSpace(directive_args, j);
							if (j >= dlen || directive_args[j] != ":")
								err(i + j, "Expected ':' after bArchName, but got {!r}"
									.format({ directive_args.substr(j, j + 1) }));
							++j;
							j = skipSpace(directive_args, j);
							local bArchTypeList: {string...};
							j, bArchTypeList = parseTypeCompatTypeList(directive_args, j)...;
							if (bArchTypeList is none)
								err(i + j, "Expected 'bArchTypeList', but got {!r}"
									.format({ directive_args.substr(j) }));
							registerXArchBinaryTypeCompatibilities(
								aArchName, aArchTypeList, bArchName, bArchTypeList);
							j = skipSpace(directive_args, j);
							if (j >= dlen)
								break;
							if (directive_args[j] != ",")
								err(i + j, "Expected ',' to define further type compatibilities, but got {!r}"
									.format({ directive_args[j] }));
							++j;
						}
					}	break;

					case "typesize": {
						/* in i386-kos/asm/syscalls32.def:
						 * >> %[typesize(i386:size_t = 4)]
						 * Syntax:
						 *  TYPELIST ::= (typename | ('[' ',' ~~ typename... ']'))
						 *  ',' ~~ (aArchName ':' TYPELIST '=' INTVAL)...
						 */
						local j = 0;
						local dlen = #directive_args;
						while (j < dlen) {
							j = skipSpace(directive_args, j);
							if (j >= dlen)
								break;
							local archNameStart = j;
							if (!directive_args.issymstrt(j) && directive_args[j] != "*")
								err(i + j, "Expected archName after %[typesize(, but got {!r}"
									.format({ directive_args[j] }));
							++j;
							while (j < dlen && directive_args.issymcont(j))
								++j;
							local archName = directive_args[archNameStart:j];
							j = skipSpace(directive_args, j);
							if (j >= dlen || directive_args[j] != ":")
								err(i + j, "Expected ':' after archName, but got {!r}"
									.format({ directive_args.substr(j, j + 1) }));
							++j;
							j = skipSpace(directive_args, j);
							local archTypeList: {string...};
							j, archTypeList = parseTypeCompatTypeList(directive_args, j)...;
							if (archTypeList is none)
								err(i + j, "Expected 'archTypeList', but got {!r}"
									.format({ directive_args.substr(j) }));
							j = skipSpace(directive_args, j);
							if (j >= dlen || directive_args[j] != "=")
								err(i + j, "Expected '=' after archTypeList, but got {!r}"
									.format({ directive_args.substr(j, j + 1) }));
							++j;
							j = skipSpace(directive_args, j);
							if (j >= dlen || (!directive_args.isnumeric(j) && !directive_args.issymstrt(j)))
								err(i + j, "Expected integer after `%[typesize({}:{} =' but got {!r}"
									.format({ archName, List(archTypeList), directive_args.substr(j, j + 1) }));
							local archTypeSizeStart = j;
							++j;
							while (j < dlen && directive_args.issymcont(j))
								++j;
							local archTypeSize = directive_args[archTypeSizeStart:j];
							if (archTypeSize.isnumeric()) {
								archTypeSize = try int(archTypeSize) catch (...) none;
								if (archTypeSize is none)
									err(i + j, "Malformed integer: {!r}"
										.format({ directive_args[archTypeSizeStart:j] }));
							}
							local usedArchName = { "*" : "" }.get(archName, archName);
							for (local typ: archTypeList) {
								local archMaps = xArchTypeSizes.get(typ);
								if (archMaps is none)
									xArchTypeSizes[typ] = archMaps = Dict();
								local archValue = archMaps.get(usedArchName);
								if (archValue !is none && (
								    type(archValue) != type(archTypeSize) || archValue != archTypeSize)) {
									err(i + j, "Incompatible {}:sizeof({}) (was {!r}, now {!r})"
										.format({ archName, typ, archValue, archTypeSize }));
								}
								archMaps[usedArchName] = archTypeSize;
							}
							j = skipSpace(directive_args, j);
							if (j >= dlen)
								break;
							if (directive_args[j] != ",")
								err(i + j, "Expected ',' to define further type sizes, but got {!r}"
									.format({ directive_args[j] }));
							++j;
						}
					}	break;

					case "typeorg": {
						if (":" !in directive_args)
							err(i, "Missing `:' in typeorg argument");
						local headerName, none, types =
							directive_args.partition(":")...;
						headerName = headerName.strip();
						for (local x: types.split(",")) {
							x = x.strip();
							if (x in syscallTypeDeclarationOrigins) {
								if (syscallTypeDeclarationOrigins[x] != headerName)
									err(i, "Origin of type {!r} redefined (was: {!r}, is: {!r})"
										.format({ x, syscallTypeDeclarationOrigins[x], headerName }));
							} else {
								syscallTypeDeclarationOrigins[x] = headerName;
							}
						}
					}	break;

					default:
						err(name_start, "Unknown directive {!r}".format({ directive_name }));
					}
					ch = text[i];
					if (ch == "]")
						break;
					if (ch != ",")
						err(name_start, "Unknown character after directive {!r}: {!r}"
							.format({ directive_name, ch }));
					++i;
				}
				++i;
				continue;
			}
		}
		if (ch.isnumeric()) {
			/* System call mapping  */
			local line = text.count("\n", 0, i - 1) + 1;
			local number_start = i - 1;
			while (i < len && text.issymcont(i))
				++i;
			local syscall_number = text[number_start:i];
			try {
				syscall_number = int(syscall_number);
			} catch (e...) {
				err(number_start, "Invalid number: " + repr(e));
			}
			while (i < len && text.isspace(i))
				++i;
			if (i >= len)
				err(number_start, "Unexpected EOF in syscall mapping decl");
			if (text[i] != ":")
				err(number_start, "Expected `:' after integer for syscall mapping");
			++i;
			while (i < len && text.isspace(i))
				++i;
			if (i >= len)
				err(number_start, "Unexpected EOF in syscall mapping decl");
			if (!text.issymstrt(i))
				err(number_start, "Expected syscall name after integer in syscall mapping decl");
			local name_start = i;
			do {
				++i;
			} while (i < len && text.issymcont(i));
			local syscall_name = text[name_start:i];
			local existing = context.sysidMappings.get(syscall_number);
			if (existing !is none) {
				if (existing[2] != syscall_name) {
					err(name_start, "Syscall vector {} redefined (was: {}:{}, is: {}:{})"
						.format({ syscall_number.hex(),
						          syscall_number.hex(), existing[2],
						          syscall_number.hex(), syscall_name }));
				}
			}
			local existing = context.nameMappings.get(syscall_name);
			if (existing !is none) {
				if (existing != syscall_number) {
					err(name_start, "Syscall name {} redefined (was: {}:{}, is: {}:{})"
						.format({ syscall_name,
						          existing.hex(), syscall_name,
						          syscall_number.hex(), syscall_name }));
				}
			}
			context.sysidMappings[syscall_number] = (filename, line, syscall_name);
			context.nameMappings[syscall_name] = (syscall_number);
			continue;
		}
		if (ch == "@" && i < len && text[i] == "@") {
			if (currentFunction is none) {
				currentFunction = Function();
				currentFunctionPos = i;
			}
			++i;
			if (currentFunction.doc)
				currentFunction.doc += "\n";
			local line_start = i;
			i = text.find("\n", i);
			if (i < 0)
				i = len;
			currentFunction.doc += text[line_start:i].rstrip();
			++i;
			continue;
		}
		if (ch == "[") {
			if (currentFunction is none) {
				currentFunction = Function();
				currentFunctionPos = i;
			}
			for (;;) {
				while (i < len && text.isspace(i))
					++i;
				if (i >= len)
					err(i, "Unexpected EOF in attribute");
				local name_start = i;
				ch = text[i];
				++i;
				if (ch == "]")
					break;
				if (!ch.issymstrt())
					err(i - 1, "Unexpected character {!r} in attribute".format({ ch }));
				do {
					++i;
				} while (i < len && text.issymcont(i));
				local directive_name = text[name_start:i];
				while (i < len && text.isspace(i))
					++i;
				if (i >= len)
					err(i, "Unexpected EOF in attribute {!r}".format({ directive_name }));
				ch = text[i];
				local directive_args = "";
				if (ch == "(") {
					++i;
					local args_end = text.findmatch("(", ")", i);
					if (args_end < 0)
						err(i, "Unmatched `(' in attribute {!r}".format({ directive_name }));
					directive_args = text[i:args_end].strip();
					i = args_end + 1;
					while (i < len && text.isspace(i))
						++i;
					if (i >= len)
						err(i, "Unexpected EOF after attribute {!r}".format({ directive_name }));
				}
				function argsToBool() {
					local r = BOOL_MAP.get(directive_args);
					if (r !is none)
						return r;
					err(i, "Invalid bool constant: {!r}".format({ directive_args }));
				}
				switch (directive_name) {

				case "cp": currentFunction.isCp = argsToBool(); break;
				case "noreturn": currentFunction.isNoReturn = argsToBool(); break;
				case "noexcept": currentFunction.isNoExcept = argsToBool(); break;
				case "doc_alias": {
					local alias = context.functions.get(directive_args);
					if (alias is none)
						err(name_start, "Unknown function {!r}".format({ directive_args }));
					currentFunction.doc = alias.doc;
				}	break;

				case "restart": {
					final local MODE_NAMES = {
						"auto" : FUNCTION_RESTART_MODE_AUTO,
						"dont" : FUNCTION_RESTART_MODE_DONT,
						"must" : FUNCTION_RESTART_MODE_MUST,
					};
					local mode = MODE_NAMES.get(directive_args);
					if (mode is none)
						err(name_start, "Unknown restart mode: {!r}".format({ directive_args }));
					currentFunction.restartMode = mode;
				}	break;

				default:
					err(name_start, "Unknown attribute {!r}".format({ directive_name }));
				}
				ch = text[i];
				if (ch == "]")
					break;
				if (ch != ",")
					err(name_start, "Unknown character after attribute {!r}: {!r}"
						.format({ directive_name, ch }));
				++i;
			}
			++i;
			continue;
		}
		if (ch.issymstrt()) {
			if (currentFunction is none) {
				currentFunction = Function();
				currentFunctionPos = i;
			}
			/* Function definition */
			local nameStart = i - 1;
			while (i < len && text.issymcont(i))
				++i;
			currentFunction.declFilename = filename;
			currentFunction.declLine = text.count("\n", 0, nameStart) + 1;
			currentFunction.name = text[nameStart:i];
			while (i < len && text.isspace(i))
				++i;
			if (i >= len)
				err(i, "Unexpected EOF in definition of function {!r}".format({ currentFunction.name }));
			ch = text[i];
			if (ch == "=") {
				/* Function alias definition:
				 * >> my_chown = chown;
				 * Same as:
				 * >> [ATTRIBUTES_OF(chown)]
				 * >> my_chown:(ARGUMENTS_OF(chown)) -> RETURN_TYPE_OF(chown); */
				currentFunction = currentFunction.name;
				++i;
				while (i < len && text.isspace(i))
					++i;
				if (i >= len)
					err(i, "Unexpected EOF in definition of function {!r}".format({ currentFunction }));
				if (!text.issymstrt(i))
					err(i, "Expected alias name after `{}='".format({ currentFunction }));
				local aliasStart = i;
				do {
					++i;
				} while (i < len && text.issymcont(i));
				local aliasName = text[aliasStart:i];
				while (i < len && text.isspace(i))
					++i;
				if (i >= len)
					err(i, "Unexpected EOF in definition of function {!r}".format({ currentFunction }));
				if (text[i] != ";")
					err(i, "Expected `;' after definition of function alias `{} = {}', but got {!r}"
						.format({ currentFunction, aliasName, text[i] }));
				local aliasFunc = context.functions.get(aliasName);
				if (aliasFunc is none)
					err(i, "Cannot alias `{} = {}'. Function {!r} isn't defined"
						.format({ currentFunction, aliasName, aliasName }));
				if (currentFunction != aliasName) {
					if (currentFunction in disallowFunctionOverride &&
					    currentFunction in context.functions)
						err(i, "Function {!r} was already defined".format({ currentFunction }));
					aliasFunc = copy aliasFunc;
					aliasFunc.name = currentFunction;
					context.functions[currentFunction] = aliasFunc;
					disallowFunctionOverride.insert(currentFunction);
				}
				currentGroup.insert(currentFunction);
				currentFunction = none;
				currentFunctionPos = -1;
				++i;
				continue;
			}
			if (currentFunction.name in disallowFunctionOverride &&
			    currentFunction.name in context.functions)
				err(i, "Function {!r} was already defined".format({ currentFunction.name }));
			if (ch != ":")
				err(i, "Expected `:' after function name {!r}".format({ currentFunction.name }));
			++i;
			while (i < len && text.isspace(i))
				++i;
			if (i >= len)
				err(i, "Unexpected EOF in definition of function {!r}".format({ currentFunction.name }));
			if (text[i] != "(")
				err(i, "Expected `:' after function name {!r}".format({ currentFunction.name }));
			++i;
			while (i < len && text.isspace(i))
				++i;
			if (i >= len)
				err(i, "Unexpected EOF in argument list of function {!r}".format({ currentFunction.name }));
			ch = text[i];
			if (ch != ")") {
				if (text.substr(i, i + 4) == "void") {
					local e = i + 4;
					while (e < len && text.isspace(e))
						++e;
					if (e < len && text[e] == ")") {
						i = e + 1;
						goto done_argument_list;
					}
				}
				for (;;) {
					local argumentType, argumentName;
					argumentType, argumentName, i =
						parseTypeExpression(filename, text, i, true)...;
					currentFunction.args.append((argumentType, argumentName));
					while (i < len && text.isspace(i))
						++i;
					if (i >= len)
						err(i, "Unexpected EOF in argument list of function {!r}".format({ currentFunction.name }));
					ch = text[i];
					if (ch == ")")
						break;
					if (ch != ",")
						err(i, "Unexpected character {!r} in argument listof function {!r}"
							.format({ ch, currentFunction.name }));
					++i;
					while (i < len && text.isspace(i))
						++i;
				}
			}
			++i;
done_argument_list:
			while (i < len && text.isspace(i))
				++i;
			if (i >= len)
				err(i, "Unexpected EOF in definition of function {!r}".format({ currentFunction.name }));
			if (text.substr(i, i + 2) == "->") {
				i += 2;
				while (i < len && text.isspace(i))
					++i;
				if (i >= len)
					err(i, "Unexpected EOF in definition of function {!r}".format({ currentFunction.name }));
				currentFunction.returnType, none, i =
					parseTypeExpression(filename, text, i, false)...;
			}
			if (currentFunction.returnType !is bound)
				currentFunction.returnType = CType();
			if (text[i] != ";")
				err(i, "Expected `;' after definition of function {!r}, but got {!r}"
					.format({ currentFunction.name, text[i] }));
			++i;
			print filename,;
			print ": function:", currentFunction.name;
			context.functions[currentFunction.name] = currentFunction;
			currentGroup.insert(currentFunction.name);
			disallowFunctionOverride.insert(currentFunction.name);
			currentFunction = none;
			currentFunctionPos = -1;
			continue;
		}
		err(i - 1, "Unexpected character: {!r}".format({ ch }));
	}
	if (currentFunction !is none)
		err(currentFunctionPos, "Unused function meta-data");
	if (currentGroup !is none)
		err(currentGroupPos, "Group wasn't terminated");
}

function parseSyscallDefsFile(context: ParserContext, filename: string) {
	local text;
	with (local fp = File.open(filename, "r"))
		text = fp.read().decode("utf-8");
	parseSyscallDefs(context, text, filename);
}

function printSyscallDeclarations(
		fp: File, decls: {Function...}) {
	local usedStructTypes: HashSet with string = HashSet();
	local pragmaPushMacroNames: HashSet with string = HashSet();
	decls = List(decls);
	for (local x: decls) {
		x.gatherUsedStructTypes(usedStructTypes);
		x.gatherPragmaPushMacroNames(pragmaPushMacroNames);
		local used_name = "sys_" + x.name;
		if (used_name in syscallTypeMustPushMacro)
			pragmaPushMacroNames.insert(used_name);
		if (!x.isNoExcept) {
			used_name = "sys_X" + x.name;
			if (used_name in syscallTypeMustPushMacro)
				pragmaPushMacroNames.insert(used_name);
		}
	}
	if (pragmaPushMacroNames) {
		pragmaPushMacroNames = pragmaPushMacroNames.sorted();
		fp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
		for (local x: pragmaPushMacroNames)
			fp << "#pragma push_macro(" << repr(x) << ")\n";
		fp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
		for (local x: pragmaPushMacroNames)
			fp << "#undef " << x << "\n";
		fp << "\n";
	}
	if (usedStructTypes) {
		usedStructTypes = usedStructTypes.sorted();
		for (local x: usedStructTypes)
			fp << "struct " << x << ";\n";
		fp << "\n";
	}
	decls.sort();
	for (local conditionalX: { "", "X" }) {
		for (local x: decls) {
			if (conditionalX == "X" && x.isNoExcept)
				continue;
			fp << "#if __CRT_HAVE_" << conditionalX << "SC(" << x.name << ")\n";
			x.printDoc(fp);
			local usedReturnType = x.returnType.escapedTypenameBase;
			fp << "__CDECLARE_";
			if (usedReturnType == "void") {
				fp << "VOID_";
				usedReturnType = "";
			}
			fp << conditionalX << "SC(";
			x.printFunctionAttributes(fp);
			if (usedReturnType)
				fp << "," << usedReturnType;
			fp << "," << x.name << ",(";
			if (x.args) {
				fp << ", ".join(
					for (local t, n: x.args)
						joinVariableName(t.escapedTypenameBase, "__" + n));
			} else {
				fp << "void";
			}
			fp << "),(" << ",".join(for (local none, n: x.args) "__" + n) << "))\n";
			fp << "#endif /* __CRT_HAVE_" << conditionalX << "SC(" << x.name << ") */\n";
		}
	}
	if (pragmaPushMacroNames) {
		fp << "\n";
		fp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
		pragmaPushMacroNames.reverse();
		for (local x: pragmaPushMacroNames)
			fp << "#pragma pop_macro(" << repr(x) << ")\n";
		fp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
		fp << "\n";
	}
}

function printMessageBox(fp: File, message: string) {
	fp << "/************************************************************************/\n";
	fp << "/* " << message;
	fp << "                                                                     */\n"[#message:];
	fp << "/************************************************************************/\n";
}

function generateKosSyscallHeader(
		fp: File, commonSyscalls: {Function...},
		guard: string, isBase: bool) {
	local typeOriginHeaders: HashSet with string = HashSet();
	for (local sc: commonSyscalls)
		sc.gatherTypeOriginHeaders(typeOriginHeaders);
	fp << copyright << "\n";
	fp << "#ifndef " << guard << "\n";
	fp << "#define " << guard << " 1\n";
	fp << "\n";
	fp << "#include <__stdinc.h>\n";
	fp << "#include <kos/asm/syscall.h>\n";
	if (isBase)
		fp << "#include <kos/bits/syscalls.h>\n";
	fp << "\n";
	if (typeOriginHeaders) {
		typeOriginHeaders = typeOriginHeaders.sorted();
		for (local x: typeOriginHeaders)
			fp << "#include " << x << "\n";
		fp << "\n";
	}
	fp << "\n";
	fp << "#ifndef __CDECLARE_SC\n";
	fp << "#include <__crt.h>\n";
	fp << "#if 1 /* TODO: cancellation_point-system calls aren't nothrow! - All others are. */\n";
	fp << "#define __CDECLARE_SC(attr, Treturn, name, param, args)  __CDECLARE(attr,Treturn,,sys_##name,param,args)\n";
	fp << "#define __CDECLARE_VOID_SC(attr, name, param, args)      __CDECLARE_VOID(attr,,sys_##name,param,args)\n";
	fp << "#else\n";
	fp << "#define __CDECLARE_SC(attr, Treturn, name, param, args)  __CDECLARE(attr,Treturn,__NOTHROW,sys_##name,param,args)\n";
	fp << "#define __CDECLARE_VOID_SC(attr, name, param, args)      __CDECLARE_VOID(attr,__NOTHROW,sys_##name,param,args)\n";
	fp << "#endif\n";
	fp << "#define __CDECLARE_XSC(attr, Treturn, name, param, args) __CDECLARE(attr,Treturn,,sys_X##name,param,args)\n";
	fp << "#define __CDECLARE_VOID_XSC(attr, name, param, args)     __CDECLARE_VOID(attr,,sys_X##name,param,args)\n";
	fp << "#define __PRIVATE_CRT_HAVE_PLACEHOLDER_1         ,\n";
	fp << "#define __PRIVATE_CRT_HAVE_ARG_IMPL(x, val, ...) val\n";
	fp << "#define __PRIVATE_CRT_HAVE_ARG(x)  __PRIVATE_CRT_HAVE_ARG_IMPL x\n";
	fp << "#define __PRIVATE_CRT_HAVE3(...)   __PRIVATE_CRT_HAVE_ARG((__VA_ARGS__ 1,0))\n";
	fp << "#define __PRIVATE_CRT_HAVE2(x)     __PRIVATE_CRT_HAVE3(__PRIVATE_CRT_HAVE_PLACEHOLDER_##x)\n";
	fp << "#define __PRIVATE_CRT_ISDEFINED(x) __PRIVATE_CRT_HAVE2(x)\n";
	fp << "#define __CRT_HAVE_SC(name)        __PRIVATE_CRT_ISDEFINED(__CRT_HAVE_sys_##name)\n";
	fp << "#define __CRT_HAVE_XSC(name)       __PRIVATE_CRT_ISDEFINED(__CRT_HAVE_sys_X##name)\n";
	fp << "#endif /* !__CDECLARE_SC */\n";
	fp << "\n";
	fp << "#ifdef __CC__\n";
	fp << "__SYSDECL_BEGIN\n";
	fp << "\n";
	printSyscallDeclarations(fp, commonSyscalls);
	fp << "\n";
	fp << "__SYSDECL_END\n";
	fp << "#endif /* __CC__ */\n";
	fp << "\n";
	fp << "#endif /* !" << guard << " */\n";
}

function generateCrtFeaturesCrtKosSyscallsHeader(
		fp: File, availableSystemCalls: {Function...}) {
	fp << copyright << "\n";
	availableSystemCalls = availableSystemCalls.sorted();
	for (local sc: availableSystemCalls)
		fp << "#define __CRT_HAVE_sys_" << sc.name << " 1\n";
	for (local sc: availableSystemCalls) {
		if (!sc.isNoExcept)
			fp << "#define __CRT_HAVE_sys_X" << sc.name << " 1\n";
	}
}

function sysnoHexRepr(x: int): string {
	if (x <= 0xffff)
		return x.hex();
	if (x > 0xffffffff)
		return "__UINT64_C({})".format({ x.hex() });
	return "__UINT32_C({})".format({ x.hex() });
}


@@Return the min/max ID pairs that should be
@@used to describe system call table ranges.
@@@param ids:  Sorted list of used system call IDs
@@@param arch: The arch for which to calcuate ranges
function calculateSyscallTableRanges(ids: {int...}, arch/*: SyscallArch*/): {(int, int)...} {
	@@Mapping between gaps sizes, and their starting IDs
	local syscallTableGaps: {int: {int...}} = Dict();
	local tableCount = arch.platformSyscallTableCount;
	if (!tableCount)
		tableCount = 1;
	local prevId = none;
	for (local id: ids) {
		if (prevId is none) {
			prevId = id;
			continue;
		}
		local dist = id - prevId;
		if (dist > 1) {
			--dist;
			local l = syscallTableGaps.get(dist);
			if (l is none)
				syscallTableGaps[dist] = l = [];
			l.append(prevId + 1);
		}
		prevId = id;
	}
	local sizes = syscallTableGaps.keys;
	local usedGaps: {(int, int)...} = [];
	if (sizes) {
		sizes = List(sizes);
		sizes.sort();
		sizes.reverse();
		while (#usedGaps < tableCount - 1) {
			local l;
			local s = sizes[0];
			for (;;) {
				l = syscallTableGaps[s];
				if (l)
					break;
				del sizes[0];
			}
			local gapStart = l.pop(0);
			usedGaps.append((gapStart, gapStart + s - 1));
		}
	}
	/* Sort by gap starting index. */
	usedGaps.sort([](x) -> x[0]);
	local result = [];
	local prevEnd = ids.first;
	for (local min, max: usedGaps) {
		result.append((prevEnd, min - 1));
		prevEnd = max + 1;
	}
	while (#result < tableCount) {
		result.append((prevEnd, prevEnd));
	}
	/* The last range must end with the max used sysno */
	result.last = (result.last.first, ids.last);
	assert #result == tableCount;
	/* Optimization: If the first system call range is close enough,
	 *               then simply make it so that it starts at `0', thus
	 *               preventing the need of checking `ID >= MINID' when
	 *               routing the ID in kernel-space. */
	if (result.first.first < 16)
		result.first = (0, result.first.last);
	local sysmax = arch.platformMaxPossibleSysno;
	if (sysmax !is none) {
		if (result.last.last > sysmax - 16)
			result.last = (result.last.first, sysmax);
	}
	return result;
}


@@Generate include/asm/syscalls.h
function generateAsmSyscallsHeaders(
		fp: File, context: ParserContext,
		arch/*: SyscallArch*/, prefix: string = "__NR") {
	fp << copyright << "\n\n";
	local ids = context.sysidMappings.keys.sorted();
	if (!ids)
		return;
	local longestNameLen = 0;
	local longestHexLen = 0;
	for (local sysno: ids) {
		local temp = #context.sysidMappings[sysno][2];
		if (longestNameLen < temp)
			longestNameLen = temp;
		local temp = #sysnoHexRepr(sysno);
		if (longestHexLen < temp)
			longestHexLen = temp;
	}
	printMessageBox(fp, "SYSCALL IDS");
	local firstName = context.sysidMappings[ids.first][2];
	fp << "#ifndef " << prefix << "_" << firstName << "\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		f.printDoc(fp);
		fp << "#define " << prefix << "_" << f.name << " " * (longestNameLen - #f.name);
		sysno = sysnoHexRepr(sysno);
		fp << " " << sysno << " " * (longestHexLen - #sysno);
		fp << " /* ";
		f.printPrototype(fp);
		fp << " */\n";
	}
	fp << "\n\n";
	local ranges = calculateSyscallTableRanges(ids, arch);
	printMessageBox(fp, "SYSCALL LIMITS");
	fp << "#define " << prefix << "FEAT_SYSCALL_TABLE_COUNT " << #ranges << "\n";
	fp << "#define " << prefix << "FEAT_SYSCALL_TABLE_FOREACH(callback) \\\n";
	for (local i: [:#ranges]) {
		fp << "\tcallback(" << i << ") ";
		if (i != #ranges - 1)
			fp << (" " * #prefix) << "                             \\";
		fp << "\n";
	}
	for (local i, data: util.enumerate(ranges)) {
		local min, max = data...;
		fp << "#define " << prefix << "_syscall" << i << "_min " << sysnoHexRepr(min) << "\n";
		fp << "#define " << prefix << "_syscall" << i << "_max " << sysnoHexRepr(max) << "\n";
		fp << "#define " << prefix << "_syscall" << i << "_cnt " << sysnoHexRepr((max - min) + 1) << "\n";
	}
	fp << "#endif /* !" << prefix << "_" << firstName << " */\n";
	fp << "\n\n";
	printMessageBox(fp, "SYSCALL RESTART MODES");
	fp << "#ifdef __WANT_SYSCALL_RESTART_MODES\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_RESTART_MODES\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_RESTART_MODES 1\n";
	fp << "/* Restart modes:\n";
	fp << " * " << FUNCTION_RESTART_MODE_AUTO << " (auto):\n";
	fp << " *   - Always restart after an `E_INTERRUPT_USER_RPC'\n";
	fp << " *   - Restart from sigreturn() if the signal handler had the `SA_RESTART' flag set\n";
	fp << " * " << FUNCTION_RESTART_MODE_DONT << " (dont):\n";
	fp << " *   - Never restart. - Always propagate `E_INTERRUPT_USER_RPC'\n";
	fp << " *   - The only case when the system call should still be restarted,\n";
	fp << " *     is when an RPC with `RPC_SCHEDULE_FLAG_SYSRESTART' was used\n";
	fp << " * " << FUNCTION_RESTART_MODE_MUST << " (must):\n";
	fp << " *   - Always restart, even from `sigreturn()' when the\n";
	fp << " *     handler didn't have the `SA_RESTART' flag set\n";
	fp << " *   - The only case when the system call shouldn't be restarted,\n";
	fp << " *     is when an RPC with `RPC_SCHEDULE_FLAG_NOSYSRESTART' was used\n";
	fp << " * Interaction with `SA_RESTART':\n";
	fp << " *  - auto + ~SA_RESTART:      No\n";
	fp << " *  - auto + SA_RESTART:       Yes\n";
	fp << " *  - dont + ~SA_RESTART:      No\n";
	fp << " *  - dont + SA_RESTART:       No\n";
	fp << " *  - must + ~SA_RESTART:      Yes\n";
	fp << " *  - must + SA_RESTART:       Yes\n";
	fp << " * Interaction with RPC flags:\n";
	fp << " *  - auto + <no flags>:                     Yes\n";
	fp << " *  - auto + RPC_SCHEDULE_FLAG_SYSRESTART:   Yes\n";
	fp << " *  - auto + RPC_SCHEDULE_FLAG_NOSYSRESTART: No\n";
	fp << " *  - dont + <no flags>:                     No\n";
	fp << " *  - dont + RPC_SCHEDULE_FLAG_SYSRESTART:   Yes\n";
	fp << " *  - dont + RPC_SCHEDULE_FLAG_NOSYSRESTART: No\n";
	fp << " *  - must + <no flags>:                     Yes\n";
	fp << " *  - must + RPC_SCHEDULE_FLAG_SYSRESTART:   Yes\n";
	fp << " *  - must + RPC_SCHEDULE_FLAG_NOSYSRESTART: No\n";
	fp << " */\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		fp << "#define " << prefix << "RM_" << f.name << " " * (longestNameLen - #f.name);
		fp << " " << f.restartMode << "\n";
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_RESTART_MODES */\n";
	fp << "#endif /* __WANT_SYSCALL_RESTART_MODES */\n";
	fp << "\n\n";

	printMessageBox(fp, "SYSCALL CANCELLATION POINTS");
	fp << "#ifdef __WANT_SYSCALL_CANCELLATION_POINTS\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_CANCELLATION_POINTS\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_CANCELLATION_POINTS 1\n";
	local isFirst = true;
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		if (f.isCp) {
			if (isFirst) {
				fp << "#define " << prefix << "FEAT_HAVE_CANCELLATION_POINTS 1\n";
				isFirst = false;
			}
			fp << "#define " << prefix << "CP_" << f.name << " " * (longestNameLen - #f.name);
			fp << " 1\n";
		}
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_CANCELLATION_POINTS */\n";
	fp << "#endif /* __WANT_SYSCALL_CANCELLATION_POINTS */\n";
	fp << "\n\n";

	printMessageBox(fp, "SYSCALL REGISTER COUNT");
	fp << "#ifdef __WANT_SYSCALL_REGISTER_COUNT\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_REGISTER_COUNT\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_REGISTER_COUNT 1\n";
	fp << "#define " << prefix << "FEAT_SYSCALL_REGISTER_MAX_COUNT " << arch.platformSyscallRegisterCount << "\n";
	fp << "#define " << prefix << "FEAT_SYSCALL_REGISTER_BITS " << arch.platformGpRegisterSizeInBits << "\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		fp << "#define " << prefix << "RC_" << f.name << " " * (longestNameLen - #f.name);
		local rc = f.getArgumentRegisterCount(arch.platformGpRegisterSizeInBits);
		fp << " " << rc;
		if (rc != #f.args) {
			fp << " /* " << prefix << "AC_"
				<< f.name << " + " << (rc - #f.args) << " */";
		}
		fp << "\n";
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_REGISTER_COUNT */\n";
	fp << "#endif /* __WANT_SYSCALL_REGISTER_COUNT */\n";
	fp << "\n\n";

	printMessageBox(fp, "SYSCALL DOUBLE WIDE RETURN VALUE");
	fp << "#ifdef __WANT_SYSCALL_DOUBLE_WIDE_RETURN\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_DOUBLE_WIDE_RETURN\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_DOUBLE_WIDE_RETURN 1\n";
	local isFirst = true;
	if (arch.platformGpRegisterSizeInBits != 0) {
		for (local sysno: ids) {
			local f: Function = context.functions[context.sysidMappings[sysno][2]];
			if ((f.returnType.isReg128 && arch.platformGpRegisterSizeInBits < 128) ||
			    (f.returnType.isReg64 && arch.platformGpRegisterSizeInBits < 64)) {
				if (isFirst) {
					fp << "#define " << prefix << "FEAT_HAVE_DOUBLE_WIDE 1\n";
					isFirst = false;
				}
				fp << "#define " << prefix << "DW_" << f.name << " " * (longestNameLen - #f.name);
				fp << " 1\n";
			}
		}
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_DOUBLE_WIDE_RETURN */\n";
	fp << "#endif /* __WANT_SYSCALL_DOUBLE_WIDE_RETURN */\n";
	fp << "\n\n";
}

@@Generate include/asm/syscalls-proto.h
function generateAsmSyscallsProtoHeader(
		fp: File, context: ParserContext,
		arch/*: SyscallArch*/, prefix: string = "__NR") {
	local ids = context.sysidMappings.keys.sorted();
	if (!ids)
		return;
	local longestNameLen = 0;
	for (local sysno: ids) {
		local temp = #context.sysidMappings[sysno][2];
		if (longestNameLen < temp)
			longestNameLen = temp;
	}
	fp << copyright << "\n\n";
	printMessageBox(fp, "SYSCALL NORETURN ATTRIBUTE");
	fp << "#ifdef __WANT_SYSCALL_ATTR_NORETURN\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_ATTR_NORETURN\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_ATTR_NORETURN 1\n";
	local isFirst = true;
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		if (f.isNoReturn) {
			if (isFirst) {
				fp << "#define " << prefix << "FEAT_HAVE_ATTR_NORETURN 1\n";
				isFirst = false;
			}
			fp << "#define " << prefix << "NT_" << f.name << " " * (longestNameLen - #f.name);
			fp << " 1\n";
		}
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_ATTR_NORETURN */\n";
	fp << "#endif /* __WANT_SYSCALL_ATTR_NORETURN */\n";
	fp << "\n\n";

	printMessageBox(fp, "SYSCALL ARGUMENT COUNT");
	fp << "#ifdef __WANT_SYSCALL_ARGUMENT_COUNT\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_COUNT\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_COUNT 1\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		fp << "#define " << prefix << "AC_" << f.name << " " * (longestNameLen - #f.name);
		fp << " " << #f.args << "\n";
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_COUNT */\n";
	fp << "#endif /* __WANT_SYSCALL_ARGUMENT_COUNT */\n";
	fp << "\n\n";

	printMessageBox(fp, "SYSCALL RETURN TYPES");
	fp << "#ifdef __WANT_SYSCALL_RETURN_TYPES\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_RETURN_TYPES\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_RETURN_TYPES 1\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		fp << "#define " << prefix << "RT_" << f.name << " " * (longestNameLen - #f.name);
		fp << " (" << f.returnType.typenameBase << ", " << f.returnType.escapedTypenameBase << ")\n";
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_RETURN_TYPES */\n";
	fp << "#endif /* __WANT_SYSCALL_RETURN_TYPES */\n";
	fp << "\n\n";

	printMessageBox(fp, "SYSCALL ARGUMENT TYPES");
	fp << "#ifdef __WANT_SYSCALL_ARGUMENT_TYPES\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_TYPES\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_TYPES 1\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		for (local i, a: util.enumerate(f.args)) {
			local t, n = a...;
			fp << "#define " << prefix << "AT" << i << "_" << f.name << " " * (longestNameLen - #f.name);
			fp << " (" << t.typenameBase << ", " << t.escapedTypenameBase << ")\n";
		}
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_TYPES */\n";
	fp << "#endif /* __WANT_SYSCALL_ARGUMENT_TYPES */\n";
	fp << "\n\n";

	printMessageBox(fp, "SYSCALL ARGUMENT LIST MAKING");
	fp << "#ifdef __WANT_SYSCALL_ARGUMENT_LIST_MAKER\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_LIST_MAKER\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_LIST_MAKER 1\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		local args = [ABC[:arch.platformSyscallRegisterCount]...];
		fp << "#define " << prefix << "AM_"
			<< f.name
			<< "(" << ", ".join(args) << ")"
			<< (" " * (longestNameLen - #f.name))
			<< " ";
		local is_first = true;
		for (local t, none: f.args) {
			if (!is_first)
				fp << ", ";
			is_first = false;
			fp << "(" << t.escapedTypenameBase << ")";
			if (t.isReg128 && arch.platformGpRegisterSizeInBits && arch.platformGpRegisterSizeInBits < 128) {
				if (arch.platformGpRegisterSizeInBits < 64) {
					local a = args.pop(0);
					local b = args.pop(0);
					local c = args.pop(0);
					local d = args.pop(0);
					if (arch.platformEndian == "be") {
						local temp = a;
						a = d;
						d = temp;
						temp = b;
						b = c;
						c = temp;
					}
					fp << "((__uint128_t)" << a << " | (__uint128_t)" << b << " << 32 | "
					       "(__uint128_t)" << c << " << 64 | (__uint128_t)" << d << " << 96)";
				} else {
					local a = args.pop(0);
					local b = args.pop(0);
					if (arch.platformEndian == "be") {
						local temp = a;
						a = b;
						b = temp;
					}
					fp << "((__uint128_t)" << a << " | (__uint128_t)" << b << " << 64)";
				}
			} else if (t.isReg64 && arch.platformGpRegisterSizeInBits &&
			           arch.platformGpRegisterSizeInBits < 64) {
				local a = args.pop(0);
				local b = args.pop(0);
				if (arch.platformEndian == "be") {
					local temp = a;
					a = b;
					b = temp;
				}
				fp << "((__uint64_t)" << a << " | (__uint64_t)" << b << " << 32)";
			} else {
				fp << args.pop(0);
			}
		}
		if (is_first)
			fp << "/* nothing */";
		fp << "\n";
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_LIST_MAKER */\n";
	fp << "#endif /* __WANT_SYSCALL_ARGUMENT_LIST_MAKER */\n";
	fp << "\n\n";


	printMessageBox(fp, "SYSCALL ARGUMENT LIST PACKING");
	fp << "#ifdef __WANT_SYSCALL_ARGUMENT_LIST_PACKER\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_LIST_PACKER\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_LIST_PACKER 1\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		local args = [ABC[:arch.platformSyscallRegisterCount]...];
		fp << "#define " << prefix << "AP_"
			<< f.name
			<< "(" << ", ".join(args[:#f.args]) << ")"
			<< (" " * (longestNameLen - #f.name))
			<< " ";

		fp << (f.args ? ("   " * (#args - #f.args)) : ("   " * (#args - #f.args))[2:]);
		local is_first = true;
		for (local t, none: f.args) {
			if (!is_first)
				fp << ", ";
			is_first = false;
			if (t.isReg128 && arch.platformGpRegisterSizeInBits && arch.platformGpRegisterSizeInBits < 128) {
				local arg = args.pop(0);
				if (arch.platformEndian == "be") {
					fp << "(__syscall_ulong_t)((__uint128_t)" << arg << " >> 64), ";
					fp << "(__syscall_ulong_t)" << arg;
				} else {
					fp << "(__syscall_ulong_t)" << arg << ", ";
					fp << "(__syscall_ulong_t)((__uint128_t)" << arg << " >> 64)";
				}
			} else if (t.isReg64 && arch.platformGpRegisterSizeInBits && arch.platformGpRegisterSizeInBits < 64) {
				local arg = args.pop(0);
				if (arch.platformEndian == "be") {
					fp << "(__syscall_ulong_t)((__uint64_t)" << arg << " >> 32), ";
					fp << "(__syscall_ulong_t)" << arg;
				} else {
					fp << "(__syscall_ulong_t)" << arg << ", ";
					fp << "(__syscall_ulong_t)((__uint64_t)" << arg << " >> 32)";
				}
			} else {
				fp << "(__syscall_ulong_t)" << args.pop(0);
			}
		}
		if (is_first)
			fp << "/* nothing */";
		fp << "\n";
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_LIST_PACKER */\n";
	fp << "#endif /* __WANT_SYSCALL_ARGUMENT_LIST_PACKER */\n";
	fp << "\n";
}

function unpackTrace(cType: CType): (string, string) {
	local x = cType.tostrMethod;
	if (x is none)
		x = syscallTostrExpressions.get(cType.typename);
	if (x is none) {
		if (cType.typename.endswith("*") || cType.typename.endswith("]"))
			return ("\"%p\"", ",{me}");
		print "Warning: Missing tostr() for", repr cType.typename;
		return none;
	}
	if (x.startswith("select")) {
		local basevalue = "?";
		x = x[#"select":].lstrip();
		assert x.startswith("(");
		assert x.endswith(")");
		x = x[1:-1].strip();
		if (":" in x) {
			basevalue, none, x = x.partition(":")...;
			assert "," !in basevalue;
			basevalue = basevalue.strip();
			x = x.strip();
		}
		File.Writer args_writer;
		args_writer << ",({me}),";
		for (local f: x.split(",")) {
			f = f.strip();
			local fval = f;
			if ("=" in f) {
				f, none, fval = f.partition("=")...;
				f = f.strip();
				fval = fval.strip();
			}
			args_writer
				<< "({me}) == " << fval
				<< " ? " << repr(f)
				<< " : ";
		}
		args_writer << repr(basevalue);
		return ("\"%#Ix=%s\"", args_writer.string);
	}
	if (x.startswith("flagset")) {
		local baseflag = none;
		x = x[#"flagset":].lstrip();
		assert "|" !in x, "x = " + repr(x);
		assert x.startswith("(");
		assert x.endswith(")");
		x = x[1:-1].strip();
		if (":" in x) {
			baseflag, none, x = x.partition(":")...;
			assert "," !in baseflag;
			baseflag = baseflag.strip();
			x = x.strip();
		}
		local flags = List(for (local f: x.split(",")) f.strip());
		assert flags;
		local format_string = "%s" * ((#flags * 2) - 1);
		format_string = "%#Ix=" + format_string;
		File.Writer args_writer;
		args_writer << ",(uintptr_t)({me})";
		for (local i = 0; i < #flags; ++i) {
			local f = flags[i];
			local fval = f;
			if ("=" in f) {
				f, none, fval = f.partition("=")...;
				f = f.strip();
				fval = fval.strip();
			}
			if (i) {
				args_writer
					<< ",(({me}) & " << fval << ") && (({me}) & ("
					<< "|".join(
						for (local r: flags[:i])
							"=" in r
								? r.partition("=")[2].lstrip()
								: r)
					<< ")) ? \"|\" : \"\"";
			}
			if (i == 0 && baseflag) {
				args_writer << ",({me}) & " << fval << " ? " << repr(f) << " : ({me}) ? \"\" : " << repr(baseflag) << "\n";
			} else {
				args_writer << ",({me}) & " << fval << " ? " << repr(f) << " : \"\"\n";
			}
		}
		return (optimizePrintf(format_string), args_writer.string.rstrip());
	}
	assert x.startswith("\"");
	local i = 1;
	while (i < #x && (x[i] != "\"" || x[i-1] == "\\"))
		++i;
	if (i < #x)
		++i;
	local format_string = x[:i];
	x = x[i:].lstrip();
	assert x.startswith(",");
	x = x[1:].lstrip();
	format_string = optimizePrintf(format_string.decode("c-escape"));
	return (format_string, "," + x);
}

@@Generate include/asm/syscalls-trace.h
function generateAsmSyscallsTraceHeader(
		fp: File, context: ParserContext,
		arch/*: SyscallArch*/, prefix: string = "__NR") {
	local ids = context.sysidMappings.keys.sorted();
	if (!ids)
		return;
	local longestNameLen = 0;
	for (local sysno: ids) {
		local temp = #context.sysidMappings[sysno][2];
		if (longestNameLen < temp)
			longestNameLen = temp;
	}
	fp << copyright << "\n\n";
	printMessageBox(fp, "SYSCALL ARGUMENT NAMES");
	fp << "#ifdef __WANT_SYSCALL_ARGUMENT_NAMES\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_NAMES\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_NAMES 1\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		for (local i, a: util.enumerate(f.args)) {
			local t, n = a...;
			fp << "#define " << prefix << "AN" << i << "_" << f.name << " " * (longestNameLen - #f.name);
			fp << " " << n << "\n";
		}
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_NAMES */\n";
	fp << "#endif /* __WANT_SYSCALL_ARGUMENT_NAMES */\n";
	fp << "\n\n";
	printMessageBox(fp, "SYSCALL ARGUMENT FORMAT");
	fp << "#ifdef __WANT_SYSCALL_ARGUMENT_FORMAT\n";
	fp << "#ifndef " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_FORMAT\n";
	fp << "#define " << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_FORMAT 1\n";
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		local args = ", ".join(for (local none, n: f.args) n);
		local spc = "";
		local indent = #f.name + 2 + #args;
		if (indent < longestNameLen)
			spc = " " * (longestNameLen - indent);
		local i = 0;
		for (local t, n: f.args) {
			local fmt, arg = unpackTrace(t)...;
			if (fmt is none)
				fmt = "\"?\"";
			if (arg is none)
				arg = "/* nothing */";
			fp << "#define " << prefix << "ATRF" << i << "_"
				<< f.name
				<< (" " * (longestNameLen - #f.name))
				<< " "
				<< fmt
				<< "\n";
			arg = arg.format({ "me" : n });
			if ("\n" in arg) {
				File.Writer fprefix;
				fprefix << "#define " << prefix << "ATRA" << i << "_"
					<< f.name
					<< "("
					<< args
					<< ") "
					<< spc;
				fprefix = fprefix.string;
				local lines = List(arg.splitlines(false));
				for (local i = 0; i < #lines; ++i) {
					fp << fprefix << lines[i];
					if (i != #lines - 1)
						fp << " \\";
					fp << "\n";
					fprefix = " " * #fprefix;
				}
			} else {
				fp << "#define " << prefix << "ATRA" << i << "_"
					<< f.name
					<< "("
					<< args
					<< ") "
					<< spc
					<< arg
					<< "\n";
			}
			++i;
		}
	}
	fp << "#endif /* !" << prefix << "FEAT_DEFINED_SYSCALL_ARGUMENT_FORMAT */\n";
	fp << "#endif /* __WANT_SYSCALL_ARGUMENT_FORMAT */\n";
	fp << "\n";
}

function nth(i: int): string {
	local r = {
		1 : "1st",
		2 : "2nd",
		3 : "3rd",
	}.get(i);
	if (r !is none)
		return r;
	return "{}th".format({ i });
}

@@Generate include/asm/ls-syscalls.h
function generateAsmLsSyscallsHeader(
		fp: File, context: ParserContext, arch/*: SyscallArch*/) {
	local ids = context.sysidMappings.keys.sorted();
	if (!ids)
		return;
	local ranges = calculateSyscallTableRanges(ids, arch);
	fp << copyright << "\n\n";
	fp << "/* Enumerate known system calls by name */\n";
	fp << "#ifndef __SYSCALL\n";
	fp << "#define __SYSCALL(name) /* nothing */\n";
	fp << "#endif /* !__SYSCALL */\n";
	fp << "\n";
	fp << "/* Enumerate unused system calls IDs */\n";
	fp << "#ifndef __SYSCALL_UNUSED\n";
	fp << "#define __SYSCALL_UNUSED(sysno) /* nothing */\n";
	fp << "#endif /* !__SYSCALL_UNUSED */\n";
	fp << "\n";
	fp << "/* Enumerate used system calls */\n";
	fp << "#ifndef __TSYSCALL\n";
	fp << "#define __TSYSCALL(table_id, name, table_index, table_index_without_unused_leading) __SYSCALL(name)\n";
	fp << "#endif /* !__TSYSCALL */\n";
	fp << "\n";
	fp << "/* Enumerate unused system calls */\n";
	fp << "#ifndef __TSYSCALL_UNUSED\n";
	fp << "#define __TSYSCALL_UNUSED(table_id, sysno, table_index, table_index_without_unused_leading) __SYSCALL_UNUSED(sysno)\n";
	fp << "#endif /* !__TSYSCALL_UNUSED */\n";
	fp << "\n";
	fp << "/* Enumerate unused system calls at the start of a table */\n";
	fp << "#ifndef __TSYSCALL_UNUSED_LEADING\n";
	fp << "#define __TSYSCALL_UNUSED_LEADING(table_id, sysno, table_index) __SYSCALL_UNUSED(sysno)\n";
	fp << "#endif /* !__TSYSCALL_UNUSED_LEADING */\n";
	fp << "\n";
	fp << "/* Enumerate unused system calls at the end of a table */\n";
	fp << "#ifndef __TSYSCALL_UNUSED_TRAILING\n";
	fp << "#define __TSYSCALL_UNUSED_TRAILING(table_id, sysno, table_index, table_index_without_unused_leading, index_in_unused_trailing) __SYSCALL_UNUSED(sysno)\n";
	fp << "#endif /* !__TSYSCALL_UNUSED_TRAILING */\n";
	fp << "\n";
	fp << "/* Invoked at the start of a system call table */\n";
	fp << "#ifndef __TSYSCALL_TABLE_BEGIN\n";
	fp << "#define __TSYSCALL_TABLE_BEGIN(table_id, minsysno, maxsysno, sysnocnt, minsysno_without_unused_leading, maxsysno_without_unused_trailing, sysnocnt_without_unused_surrounding) /* nothing */\n";
	fp << "#endif /* !__TSYSCALL_TABLE_BEGIN */\n";
	fp << "\n";
	fp << "/* Invoked at the end of a system call table */\n";
	fp << "#ifndef __TSYSCALL_TABLE_END\n";
	fp << "#define __TSYSCALL_TABLE_END(table_id, minsysno, maxsysno, sysnocnt, minsysno_without_unused_leading, maxsysno_without_unused_trailing, sysnocnt_without_unused_surrounding) /* nothing */\n";
	fp << "#endif /* !__TSYSCALL_TABLE_END */\n";
	fp << "\n";
	for (local i: [:#ranges]) {
		fp << "/* Enumerate used system calls in the " << nth(i + 1) << " system call */\n";
		fp << "#ifndef __TSYSCALL" << i << "\n";
		fp << "#define __TSYSCALL" << i << "(name, index, index_without_unused_leading) __TSYSCALL(" << i << ", name, index, index_without_unused_leading)\n";
		fp << "#endif /* !__TSYSCALL" << i << " */\n";
		fp << "\n";
		fp << "/* Enumerate unused system calls in the middle of the " << nth(i + 1) << " system call table*/\n";
		fp << "#ifndef __TSYSCALL" << i << "_UNUSED\n";
		fp << "#define __TSYSCALL" << i << "_UNUSED(sysno, index, index_without_unused_leading) __TSYSCALL_UNUSED(" << i << ", sysno, index, index_without_unused_leading)\n";
		fp << "#endif /* !__TSYSCALL" << i << "_UNUSED */\n";
		fp << "\n";
		fp << "/* Enumerate unused system calls at the start of the " << nth(i + 1) << " system call table */\n";
		fp << "#ifndef __TSYSCALL" << i << "_UNUSED_LEADING\n";
		fp << "#define __TSYSCALL" << i << "_UNUSED_LEADING(sysno, index) __TSYSCALL_UNUSED_LEADING(" << i << ", sysno, index)\n";
		fp << "#endif /* !__TSYSCALL" << i << "_UNUSED_LEADING */\n";
		fp << "\n";
		fp << "/* Enumerate unused system calls at the end of the " << nth(i + 1) << " system call table */\n";
		fp << "#ifndef __TSYSCALL" << i << "_UNUSED_TRAILING\n";
		fp << "#define __TSYSCALL" << i << "_UNUSED_TRAILING(sysno, index, index_without_unused_leading, index_in_unused_trailing) __TSYSCALL_UNUSED_TRAILING(" << i << ", sysno, index, index_without_unused_leading, index_in_unused_trailing)\n";
		fp << "#endif /* !__TSYSCALL" << i << "_UNUSED_TRAILING */\n";
		fp << "\n";
		fp << "/* Invoked at the start of the " << nth(i + 1) << " system call table */\n";
		fp << "#ifndef __TSYSCALL" << i << "_TABLE_BEGIN\n";
		fp << "#define __TSYSCALL" << i << "_TABLE_BEGIN(minsysno, maxsysno, sysnocnt, minsysno_without_unused_leading, maxsysno_without_unused_trailing, sysnocnt_without_unused_surrounding) \\\n";
		fp << "\t__TSYSCALL_TABLE_BEGIN(" << i << ", minsysno, maxsysno, sysnocnt, minsysno_without_unused_leading, maxsysno_without_unused_trailing, sysnocnt_without_unused_surrounding)\n";
		fp << "#endif /* !__TSYSCALL" << i << "_TABLE_BEGIN */\n";
		fp << "\n";
		fp << "/* Invoked at the end of the " << nth(i + 1) << " system call table */\n";
		fp << "#ifndef __TSYSCALL" << i << "_TABLE_END\n";
		fp << "#define __TSYSCALL" << i << "_TABLE_END(minsysno, maxsysno, sysnocnt, minsysno_without_unused_leading, maxsysno_without_unused_trailing, sysnocnt_without_unused_surrounding) \\\n";
		fp << "\t__TSYSCALL_TABLE_END(" << i << ", minsysno, maxsysno, sysnocnt, minsysno_without_unused_leading, maxsysno_without_unused_trailing, sysnocnt_without_unused_surrounding)\n";
		fp << "#endif /* !__TSYSCALL" << i << "_TABLE_END */\n";
		fp << "\n";
	}
	for (local i, data: util.enumerate(ranges)) {
		local minsysno, maxsysno = data...;
		printMessageBox(fp, "Contents of the {} table".format({ nth(i + 1) }));
		local minsysno_used = minsysno;
		local maxsysno_used = maxsysno;
		while (minsysno_used < maxsysno_used &&
		       minsysno_used !in context.sysidMappings)
			++minsysno_used;
		while (maxsysno_used > minsysno_used &&
		       maxsysno_used !in context.sysidMappings)
			--maxsysno_used;
		fp << "__TSYSCALL" << i << "_TABLE_BEGIN(";
		fp << (minsysno).hex() << ", ";
		fp << (maxsysno).hex() << ", ";
		fp << ((maxsysno - minsysno) + 1).hex() << ", ";
		fp << (minsysno_used).hex() << ", ";
		fp << (maxsysno_used).hex() << ", ";
		fp << ((maxsysno_used - minsysno_used) + 1).hex() << ")\n";
		for (local j: [minsysno: minsysno_used]) {
			fp << "__TSYSCALL" << i << "_UNUSED_LEADING("
				<< j << ", " << (j - minsysno) << ")\n";
		}
		for (local sysno: [minsysno_used: maxsysno_used+1]) {
			if (sysno in ids) {
				local name = context.sysidMappings[sysno][2];
				fp << "__TSYSCALL" << i << "(" << name;
			} else {
				fp << "__TSYSCALL" << i << "_UNUSED(" << sysno.hex();
			}
			fp << ", "
				<< (sysno - minsysno).hex() << ", "
				<< (sysno - minsysno_used).hex() << ")\n";
		}
		for (local j: [maxsysno_used+1: maxsysno+1]) {
			fp << "__TSYSCALL" << i << "_UNUSED_TRAILING("
				<< (j).hex() << ", "
				<< (j - minsysno).hex() << ", "
				<< (j - minsysno_used).hex() << ", "
				<< (j - (maxsysno_used + 1)).hex() << ")\n";
		}
		fp << "__TSYSCALL" << i << "_TABLE_END(";
		fp << (minsysno).hex() << ", ";
		fp << (maxsysno).hex() << ", ";
		fp << ((maxsysno - minsysno) + 1).hex() << ", ";
		fp << (minsysno_used).hex() << ", ";
		fp << (maxsysno_used).hex() << ", ";
		fp << ((maxsysno_used - minsysno_used) + 1).hex() << ")\n";
		fp << "\n";
	}
	for (local i: [#ranges-1:-1,-1]) {
		fp << "#undef __TSYSCALL" << i << "_TABLE_END\n";
		fp << "#undef __TSYSCALL" << i << "_TABLE_BEGIN\n";
		fp << "#undef __TSYSCALL" << i << "_UNUSED_TRAILING\n";
		fp << "#undef __TSYSCALL" << i << "_UNUSED_LEADING\n";
		fp << "#undef __TSYSCALL" << i << "_UNUSED\n";
		fp << "#undef __TSYSCALL" << i << "\n";
	}
	fp << "#undef __TSYSCALL_TABLE_END\n";
	fp << "#undef __TSYSCALL_TABLE_BEGIN\n";
	fp << "#undef __TSYSCALL_UNUSED_TRAILING\n";
	fp << "#undef __TSYSCALL_UNUSED_LEADING\n";
	fp << "#undef __TSYSCALL_UNUSED\n";
	fp << "#undef __TSYSCALL\n";
	fp << "#undef __SYSCALL_UNUSED\n";
	fp << "#undef __SYSCALL\n";
}

@@Generate include/bits/syscalls.h
function generateBitsSyscallsHeader(
		fp: File, context: ParserContext,
		arch/*: SyscallArch*/, guard: string) {
	fp << copyright << "\n\n";
	fp << "#ifndef " << guard << "\n";
	fp << "#define " << guard << " 1\n";
	fp << "\n";
	local ids = context.sysidMappings.keys.sorted();
	if (!ids)
		goto done;
	local firstName = context.sysidMappings[ids.first][2];
	fp << "#ifndef __NR_" << firstName << "\n";
	fp << "#include \"../asm/syscalls";
	if (arch !is none)
		fp << arch.platformSuffix;
	fp << ".h\"\n";
	fp << "#endif /* !__NR_" << firstName << " */\n";
	fp << "\n";
	local longestNameLen = 0;
	for (local sysno: ids) {
		local temp = #context.sysidMappings[sysno][2];
		if (longestNameLen < temp)
			longestNameLen = temp;
	}
	for (local sysno: ids) {
		local f: Function = context.functions[context.sysidMappings[sysno][2]];
		f.printDoc(fp);
		fp << "#define SYS_" << f.name << " " * (longestNameLen - #f.name);
		fp << " __NR_" << f.name << " " * (longestNameLen - #f.name);
		fp << " /* ";
		f.printPrototype(fp);
		fp << " */\n";
	}
	fp << "\n";
done:
	fp << "#endif /* !" << guard << " */\n";
}

@@Generate src/kernel/core/arch/{name}/syscall/wrappers{suffix}.S
function generateKernelCoreArchSyscallWrappersAssembly(
		fp: File, context: ParserContext, arch/*: SyscallArch*/,
		ALL_ARCH: {string: Object/*SyscallArch*/},
		archContexts: {string: ParserContext}) {
	local guard = arch
		.formatPath("GUARD_KERNEL_CORE_ARCH_{arch}_SYSCALL_WRAPPERS{suffix}_S")
		.upper();
	fp << copyright << "\n";
	fp << "#ifndef " << guard << "\n";
	fp << "#define " << guard << " 1\n";
	fp << "\n";
	fp << "#include <kernel/compiler.h>\n";
	fp << "\n";
	arch.platformKernelSyscallWrappersCommon(fp);
	fp << "\n";
	for (local generator, srcArchName: arch.platformKernelSyscallWrappers) {
		local srcArch/*: SyscallArch*/ = ALL_ARCH[srcArchName];
		fp << "\n\n\n\n\n\n\n\n\n";
		local srcContext = archContexts[srcArchName];
		local srcIds = srcContext.sysidMappings.keys.sorted();
		for (local id: srcIds) {
			local name: string = srcContext.sysidMappings[id][2];
			local f: Function = srcContext.functions[name];
			f.printDoc(fp);
			fp << "/* ";
			f.printPrototype(fp);
			fp << " */\n";
			generator(fp, f, id);
			fp << "\n";
		}
	}
	fp << "\n";
	fp << "#endif /* !" << guard << " */\n";
}

@@Generate src/libc/libc/arch/{name}/syscalls{suffix}.S
function generateLibcArchSyscallAssembly(
		fp: File, context: ParserContext, arch/*: SyscallArch*/) {
	local guard = arch
		.formatPath("GUARD_LIBC_LIBC_ARCH_{arch}_SYSCALLS{suffix}_S")
		.upper();
	fp << copyright << "\n";
	fp << "#ifndef " << guard << "\n";
	fp << "#define " << guard << " 1\n";
	fp << "\n";
	fp << "#include <hybrid/compiler.h>\n";
	fp << "\n";
	arch.platformLibcSyscallCommon(fp);
	fp << "\n";
	local ids = context.sysidMappings.keys.sorted();
	for (local sysno: ids) {
		local name: string = context.sysidMappings[sysno][2];
		local f: Function = context.functions[name];
		for (local enableExcept: { false, true }) {
			if (enableExcept && f.isNoExcept)
				continue;
			local conditionalX = enableExcept ? "X" : "";
			f.printDoc(fp);
			fp << "/* ";
			f.printPrototype(fp);
			fp << " */\n";
			fp << ".section .text.crt.syscall." << conditionalX << name << "\n";
			fp << "INTERN_FUNCTION(libc_sys_" << conditionalX << name << ")\n";
			arch.platformLibcSyscallWrapper(fp, f, sysno, enableExcept);
			fp << "END(libc_sys_" << conditionalX << name << ")\n";
			fp << "DEFINE_PUBLIC_WEAK_ALIAS(sys_" << conditionalX << name << ", libc_sys_" << conditionalX << name << ")\n";
			fp << "\n";
		}
	}
	fp << "\n";
	fp << "\n";
	fp << "/* Include the system call amendment in order to alias\n";
	fp << " * some exception-enabled functions onto system calls. */\n";
	fp << "#include \"../../syscalls-ammend.S.inl\"\n";
	fp << "\n";
	fp << "#endif /* " << guard << " */\n";
}

@@Enumerate the names of all functions that are allowed to be defined with binary
@@compatibility for the given @name (so-long as they are actually binary-compatible)
@@This function always at the very least re-yields @name itself
function enumerateCompatibilityConsiderationFunctions(name: string): {string...} {
	local group = possiblyCompatibleFunctionGroups.get(name);
	if (group !is none) {
		assert name in group;
		yield group...;
	} else {
		yield name;
	}
}

function generateSyscallCompatibilityHeader(
		fp: File, prefix: string,
		baseContext: ParserContext, baseArch/*: SyscallArch*/, baseArchName: string,
		compatContext: ParserContext, compatArch/*: SyscallArch*/, compatArchName: string) {
	local baseFunctions = Dict(
		for (local none, decl: baseContext.sysidMappings)
			(decl[2], baseContext.functions[decl[2]]));
	local compatFunctions = Dict(
		for (local none, decl: compatContext.sysidMappings)
			(decl[2], compatContext.functions[decl[2]]));
	local compatFunctionMap: {string: HashSet with string} = Dict();
	for (local name, baseFunc: baseFunctions) {
		local compatNames = enumerateCompatibilityConsiderationFunctions(name);
		if (baseFunc.name != name) {
			compatNames = HashSet(compatNames);
			compatNames.update(enumerateCompatibilityConsiderationFunctions(baseFunc.name));
		}
		for (local compatName: compatNames) {
			local compatFunc = compatFunctions.get(compatName);
			if (compatFunc is none)
				continue;
			if (areFunctionsBinaryCompatible(baseFunc, baseContext, baseArch, baseArchName,
			                                 compatFunc, compatContext, compatArch, compatArchName)) {
				local set = compatFunctionMap.get(name);
				if (set is none)
					compatFunctionMap[name] = set = HashSet();
				set.insert(compatName);
			}
		}
	}
	local compatFunctionNames: {string...} = compatFunctionMap.keys.sorted();
	local longestNameLen = compatFunctionNames.each.length > ...;
	fp << copyright << "\n";
	if (compatFunctionNames) {
		local firstName = compatFunctionNames.first;
		fp << "#ifndef " << prefix << firstName << "\n";
		for (local n: compatFunctionNames) {
			fp << "#define " << prefix << n
				<< " " * (longestNameLen - #n);
			local compatNames: {string...} = compatFunctionMap[n].sorted();
			assert compatNames;
			fp << " " << #compatNames << "(";
			fp << ",".join(compatNames);
			fp << ")\n";
		}
		fp << "#endif /* !" << prefix << firstName << " */\n";
	}
}


@@Generate include/kos/kernel/syscalls.h
function generateKosKernelSyscallsRequestHeader(fp: File,
		baseContext: ParserContext, baseArch/*: SyscallArch*/, baseArchName: string,
		compatContext: ParserContext = none, compatArch/*: SyscallArch*/ = none,
		compatArchName: string = none) {
	local baseFunctions = Dict(
		for (local none, decl: baseContext.sysidMappings)
			(decl[2], baseContext.functions[decl[2]]));
	local compatFunctions = Dict(
		for (local none, decl: compatContext.sysidMappings)
			(decl[2], compatContext.functions[decl[2]]));
	local implicitlyDefinedCompatFunctions: HashSet with string = HashSet();
	if (compatFunctions) {
		for (local name, baseFunc: baseFunctions) {
			local compatNames = enumerateCompatibilityConsiderationFunctions(name);
			if (baseFunc.name != name) {
				compatNames = HashSet(compatNames);
				compatNames.update(enumerateCompatibilityConsiderationFunctions(baseFunc.name));
			}
			for (local compatName: compatNames) {
				local compatFunc = compatFunctions.get(compatName);
				if (compatFunc is none)
					continue;
				if (areFunctionsBinaryCompatible(baseFunc, baseContext, baseArch, baseArchName,
				                                 compatFunc, compatContext, compatArch, compatArchName))
					implicitlyDefinedCompatFunctions.insert(compatName);
			}
		}
	}
	fp << copyright << "\n";
	local requestedBaseFunctionNames = baseFunctions.keys.sorted();
	local requestedCompatFunctionNames = HashSet();
	for (local name, func: compatFunctions) {
		if (name !in implicitlyDefinedCompatFunctions)
			requestedCompatFunctionNames.insert(name);
	}
	requestedCompatFunctionNames = requestedCompatFunctionNames.sorted();
	local longestNameLen = requestedBaseFunctionNames.each.length > ...;
	if (requestedCompatFunctionNames) {
		local temp = requestedCompatFunctionNames.each.length > ...;
		if (longestNameLen < temp)
			longestNameLen = temp;
	}
	fp << "#ifndef __ARCH_WANT_SYSCALL_" << requestedBaseFunctionNames.first.upper() << "\n";
	for (local n: requestedBaseFunctionNames) {
		fp << "#define __ARCH_WANT_SYSCALL_" << n.upper();
		if (requestedCompatFunctionNames)
			fp << "       ";
		fp << " " * (longestNameLen - #n) << " 1\n";
	}
	for (local n: requestedCompatFunctionNames) {
		fp << "#define __ARCH_WANT_COMPAT_SYSCALL_" << n.upper();
		fp << " " * (longestNameLen - #n) << " 1\n";
	}
	fp << "#endif /* !__ARCH_WANT_SYSCALL_" << requestedBaseFunctionNames.first.upper() << " */\n";
}



function main(archNames: {string...}) {
	local baseContext: ParserContext = ParserContext();
	local final ALL_ARCH = import(".generate_syscalls_arch").ARCH;
	local ARCH = ALL_ARCH;
	if (archNames) {
		print "[generate_syscalls] Generating system calls for:", repr archNames;
		ARCH = Dict(for (local name, a: ALL_ARCH) if (name in archNames) (name, a));
	} else {
		print "[generate_syscalls] Generating system calls for all architectures";
	}
	parseSyscallDefsFile(baseContext, "include/asm/syscalls.def");
	local archContexts: {string: ParserContext} = Dict();
	archContexts[""] = baseContext;
	for (local name, a: ARCH) {
		local c = copy baseContext;
		parseSyscallDefsFile(c, a.formatPath(
			"include/{name}/asm/syscalls{suffix}.def"));
		archContexts[name] = c;
	}
	/* Make sure that system call names are actually defined */
	for (local name, c: archContexts) {
		for (local x, data: c.nameMappings) {
			if (x !in c.functions)
				c.errSysID(data, "Undefined function {!r}".format({ x }));
		}
	}
	for (local name, a: ARCH) {
		local c = archContexts[name];
		writeHashedFile(a.formatPath(
			"include/{name}/kos/syscalls{suffix}.h"
		), [](fp){
			generateKosSyscallHeader(
				fp,
				for (local name, none: c.nameMappings)
					c.functions[name],
				sanitizeIncludeGuard(a.formatPath(
					"_{name}_KOS_SYSCALLS{suffix}_H")),
				false);
		});
	}
	writeHashedFile("include/kos/syscalls.h", [](fp){
		generateKosSyscallHeader(
			fp,
			for (local name, none: baseContext.nameMappings)
				baseContext.functions[name],
			sanitizeIncludeGuard("_KOS_SYSCALL_H"),
			false);
	});

	/* include/{}/crt-features/crt-kos-syscalls{}.h
	 * >> #define __CRT_HAVE_sys_exit 1
	 * >> #define __CRT_HAVE_sys_Xexit 1 */
	for (local name, a: ARCH) {
		local c = archContexts[name];
		writeHashedFile(a.formatPath(
			"include/{name}/crt-features/crt-kos-syscalls{suffix}.h"
		), [](fp){
			generateCrtFeaturesCrtKosSyscallsHeader(fp,
				for (local none, decl: c.sysidMappings)
					c.functions[decl[2]]);
		});
	}
	writeHashedFile("include/crt-features/crt-kos-syscalls.h", [](fp){
		generateCrtFeaturesCrtKosSyscallsHeader(fp,
			for (local none, decl: baseContext.sysidMappings)
				baseContext.functions[decl[2]]);
	});

	/* include/{}/asm/syscalls{}.h
	 * >> #define __NR_exit 123
	 * >> #define __NRAC_exit 1
	 * >> #define __NR..._exit ... */
	for (local name, a: ARCH) {
		local c = archContexts[name];
		writeHashedFile(a.formatPath(
			"include/{name}/asm/syscalls{suffix}.h"
		), [](fp){
			generateAsmSyscallsHeaders(fp, c, a);
		});
		writeHashedFile(a.formatPath(
			"include/{name}/asm/syscalls-proto{suffix}.h"
		), [](fp){
			generateAsmSyscallsProtoHeader(fp, c, a);
		});
		writeHashedFile(a.formatPath(
			"include/{name}/asm/syscalls-trace{suffix}.h"
		), [](fp){
			generateAsmSyscallsTraceHeader(fp, c, a);
		});
		if (a.platformSuffix) {
			writeHashedFile(a.formatPath(
				"include/{name}/asm/syscalls{suffix}_d.h"
			), [](fp){
				generateAsmSyscallsHeaders(fp, c, a, "__NR" + a.platformSuffix);
			});
			writeHashedFile(a.formatPath(
				"include/{name}/asm/syscalls-proto{suffix}_d.h"
			), [](fp){
				generateAsmSyscallsProtoHeader(fp, c, a, "__NR" + a.platformSuffix);
			});
			writeHashedFile(a.formatPath(
				"include/{name}/asm/syscalls-trace{suffix}_d.h"
			), [](fp){
				generateAsmSyscallsTraceHeader(fp, c, a, "__NR" + a.platformSuffix);
			});
		}
	}
	writeHashedFile("include/asm/syscalls.h", [](fp){
		generateAsmSyscallsHeaders(fp, baseContext, none);
	});
	writeHashedFile("include/asm/syscalls-proto.h", [](fp){
		generateAsmSyscallsProtoHeader(fp, baseContext, none);
	});
	writeHashedFile("include/asm/syscalls-trace.h", [](fp){
		generateAsmSyscallsTraceHeader(fp, baseContext, none);
	});

	for (local name, a: ARCH) {
		local c = archContexts[name];
		writeHashedFile(a.formatPath(
			"include/{name}/asm/ls-syscalls{suffix}.h"
		), [](fp){
			generateAsmLsSyscallsHeader(fp, c, a);
		});
	}
	writeHashedFile("include/asm/ls-syscalls.h", [](fp){
		generateAsmLsSyscallsHeader(fp, baseContext, none);
	});
	writeHashedFile("include/kos/kernel/syscalls.h", [](fp){
		generateKosKernelSyscallsRequestHeader(fp, baseContext, none, none);
	});

	for (local name, a: ARCH) {
		local archContext = archContexts[name];
		writeHashedFile(a.formatPath(
			"include/{name}/kos/kernel/syscalls{suffix}.h"
		), [](fp){
			local compatArchName = a.platformSyscallCompatRequest;
			if (compatArchName is none) {
				generateKosKernelSyscallsRequestHeader(fp, archContext, a, name);
			} else {
				local compatArch = ALL_ARCH[compatArchName];
				if (compatArchName !in archContexts) {
					/* Lazily load definitions for compatibility-mode architectures */
					local a = ALL_ARCH[compatArchName];
					local c = copy baseContext;
					parseSyscallDefsFile(c, a.formatPath(
						"include/{name}/asm/syscalls{suffix}.def"));
					archContexts[compatArchName] = c;
				}
				local compatContext = archContexts[compatArchName];
				generateKosKernelSyscallsRequestHeader(fp,
					archContext, a, name,
					compatContext, compatArch, compatArchName);
			}
		});
	}

	for (local name, a: ARCH) {
		if (!a.platformSyscallCompatArch)
			continue;
		local archContext = archContexts[name];
		for (local headerName, prefix, compatArchName:
				a.platformSyscallCompatArch) {
			local compatArch = ALL_ARCH[compatArchName];
			if (compatArchName !in archContexts) {
				/* Lazily load definitions for compatibility-mode architectures */
				local a = ALL_ARCH[compatArchName];
				local c = copy baseContext;
				parseSyscallDefsFile(c, a.formatPath(
					"include/{name}/asm/syscalls{suffix}.def"));
				archContexts[compatArchName] = c;
			}
			local compatContext = archContexts[compatArchName];
			writeHashedFile(headerName, [](fp){
				generateSyscallCompatibilityHeader(
					fp, prefix,
					archContext, a, name,
					compatContext, compatArch, compatArchName);
			});
		}
	}

	for (local name, a: ARCH) {
		local c = archContexts[name];
		writeHashedFile(a.formatPath(
			"include/{name}/bits/syscalls{suffix}.h"
		), [](fp){
			generateBitsSyscallsHeader(fp, c, a,
				sanitizeIncludeGuard("_{}_BITS_SYSCALLS{}_H"
					.format({ a.platformName, a.platformSuffix })));
		});
	}
	writeHashedFile("include/bits/syscalls.h", [](fp){
		generateBitsSyscallsHeader(fp, baseContext, none, "_BITS_SYSCALLS_H");
	});

	for (local name, a: ARCH) {
		local c = archContexts[name];
		writeHashedFile(a.formatPath(
			"src/kernel/core/arch/{arch}/syscall/wrappers{suffix}.S"
		), [](fp){
			generateKernelCoreArchSyscallWrappersAssembly(
				fp, c, a, ALL_ARCH, archContexts);
		});
	}

	for (local name, a: ARCH) {
		local c = archContexts[name];
		writeHashedFile(a.formatPath(
			"src/libc/libc/arch/{arch}/syscalls{suffix}.S"
		), [](fp){
			generateLibcArchSyscallAssembly(fp, c, a);
		});
	}
}








#ifdef __MAIN__
fs.chdir(fs.joinpath(fs.headof(__FILE__), "../.."));
main(archNames: [...][1:]);
#endif /* __MAIN__ */

