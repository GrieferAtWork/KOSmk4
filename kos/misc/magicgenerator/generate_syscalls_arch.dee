/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .generate_syscalls;

class SyscallArch {
	this = default;

	@@name of the platform (e.g. `i386-kos')
	member platformName: string;

	@@Architecture of the platform (e.g. `i386')
	member platformArch: string;

	@@Optional suffix for platform files (for use with multi-arch platforms)
	member platformSuffix: string = "";

	@@Set of (name, prefix, arch) for other architectures for which
	@@syscall compatibility meta-data should be generated in the
	@@form of a system header @"/kos/{name}" that contains a set of
	@@definitions @"{prefix}{syscall-name} 1" for all system calls
	@@defined by both architectures that share both the same name,
	@@as well as binary compatibility.
	@@On multi-arch targets such as x86_64, this is used to determine if an
	@@invocation of `DEFINE_SYSCALLn()` should also define the compatibility-
	@@mode variant of another system call with the same name.
	member platformSyscallCompatArch: {(string, string, string)...} = none;

	@@Size of general-purpose registers used for passing system call arguments (in bits)
	member platformGpRegisterSizeInBits: int;

	@@The number of registers used to pass system call arguments
	member platformSyscallRegisterCount: int;

	@@Endian of the platform (either "le" or "be")
	member platformEndian: string;

	@@Number of system call tables used by this platform
	member platformSyscallTableCount: int;

	@@The max possibly system call number (usually `(1 << platformGpRegisterSizeInBits) - 1')
	member platformMaxPossibleSysno: int;

	@@Print common code which may be used by @platformLibcSyscallWrapper
	@@This is a @function(fp: File)
	member platformLibcSyscallCommon: Callable = none;

	@@Print assembly for invoking
	@@This is a @function(fp: File, f: Function, sysno: int, enableExcept: bool)
	member platformLibcSyscallWrapper: Callable;

	@@Print common code which may be used by @platformKernelSyscallWrappers
	@@This is a @function(fp: File)
	member platformKernelSyscallWrappersCommon: Callable = none;

	@@Mapping of known system call wrappers.
	@@@key:   The prefix to be pre-pended before the wrappers's name
	@@        e.g. when `__fooasm_', one symbol might be `__fooasm_exit'
	@@@value: A tuple @(function(fp: File, f: Function, sysno: int),
	@@                  arch_origin_name)
	@@        This function should print the assembly body for servicing
	@@        the system call in the context in which this wrapper might
	@@        be called. The given `f' is the function that is being defined.
	@@        @arch_origin_name is the name of the ARCH who's system calls
	@@        should be wrapped. Normally this is the same name as the
	@@        current arch, however in order to allow for multi-arch
	@@        compatibility mode (such as x86_64's IA32-mode), one is
	@@        allowed to specify a different arch who's system calls
	@@        are then going to be wrapped.
	member platformKernelSyscallWrappers: {string: (Callable, string)};

	formatPath(f: string): string {
		return f.format({
			.name   = platformName,
			.arch   = platformArch,
			.suffix = platformSuffix,
		});
	}
}

/************************************************************************/
/* I386                                                                 */
/************************************************************************/
final global i386SyscallArgumentRegisters = { "%ebx", "%ecx", "%edx", "%esi", "%edi", "%ebp" };
function i386_printLibcSyscallSysenterCdeclInvocation(
		fp: File, registerCount: int, enableExcept: bool) {
	local preservedRegisters = ["%edi", "%ebp"];
	if (registerCount > 0)
		preservedRegisters.append("%ebx");
	if (registerCount > 3)
		preservedRegisters.append("%esi");
	local spOffset = 4 * (1 + #preservedRegisters);
	for (local x: preservedRegisters)
		fp << "	" << "pushl_cfi_r " << x << "\n";
	if (registerCount > 0) fp << "	" << "movl   " << (spOffset + 0) << "(%esp), %ebx\n";
	if (registerCount > 1) fp << "	" << "movl   " << (spOffset + 4) << "(%esp), %ecx\n";
	if (registerCount > 2) fp << "	" << "movl   " << (spOffset + 8) << "(%esp), %edx\n";
	if (registerCount > 3) fp << "	" << "movl   " << (spOffset + 12) << "(%esp), %esi\n";
	if (registerCount > 5) {
		fp << "	" << "pushl_cfi " << (spOffset + 20) << "(%esp)\n";
		fp << "	" << "pushl_cfi " << (spOffset + 20) << "(%esp)\n";
	} else if (registerCount > 4) {
		fp << "	" << "pushl_cfi " << (spOffset + 16) << "(%esp)\n";
	}
	fp << "	call   libc_x86_sysenter_";
	if (enableExcept) fp << "X";
	fp << "common\n";
	if (registerCount > 4) {
		local off = 4 * (registerCount - 4);
		fp << "	" << "addl   $(" << off << "), %esp\n";
		fp << "	.cfi_adjust_cfa_offset -" << off << "\n";
	}
	for (local x: preservedRegisters.reversed())
		fp << "	" << "popl_cfi_r " << x << "\n";
}

function i386_printLibcSyscallInt80CdeclInvocation(
		fp: File, registerCount: int, enableExcept: bool) {
	local preservedRegisters = [];
	if (registerCount > 0)
		preservedRegisters.append("%ebx");
	if (registerCount > 3)
		preservedRegisters.append("%esi");
	if (registerCount > 4)
		preservedRegisters.append("%edi");
	if (registerCount > 5)
		preservedRegisters.append("%ebp");
	local sp_offset = 4 * (1 + #preservedRegisters);
	for (local x: preservedRegisters)
		fp << "	" << "pushl_cfi_r " << x << "\n";
	for (local i: [:registerCount])
		fp << "	" << "movl   " << (sp_offset + i * 4) << "(%esp), " << i386SyscallArgumentRegisters[i] << "\n";
	fp << (enableExcept ? "	stc\n" : "	clc\n");
	fp << "	int    $(0x80)\n";
	for (local x: preservedRegisters.reversed())
		fp << "	" << "popl_cfi_r " << x << "\n";
}

function i386_printLibcSyscallWrapperCommon(fp: File) {
	fp << "#include <asm/cfi.h>\n";
	fp << "\n";
	fp << "EXTERN(libc_x86_sysenter_common)\n";
	fp << "EXTERN(libc_x86_sysenter_Xcommon)\n";
	fp << "EXTERN(libc_x86_syscall_check_sysenter)\n";
	fp << "\n";
	for (local enableExcept: { false, true }) {
		local conditionalX = enableExcept ? "X" : "";
		for (local registerCount: [1:6+1]) {
			local name = "x86_exec_{}syscall{}".format({ conditionalX, registerCount });
			fp << "#ifdef __OPTIMIZE_SIZE__\n";
			fp << ".section .text.crt.syscall." << name << ", \"ax\"\n";
			fp << "#else /* __OPTIMIZE_SIZE__ */\n";
			fp << ".section .xdata.crt.syscall." << name << ", \"awx\"\n";
			fp << "#endif /* !__OPTIMIZE_SIZE__ */\n";
			fp << "INTERN_FUNCTION(libc_" << name << ")\n";
			fp << "	.cfi_startproc\n";
			fp << "#ifndef __OPTIMIZE_SIZE__\n";
			fp << "	call   libc_x86_syscall_check_sysenter\n";
			fp << "	.byte  0x74\n";
			fp << "	.reloc ., R_386_PC8, 1f\n";
			fp << "	.byte  0xff /* jz 1f */\n";
			i386_printLibcSyscallSysenterCdeclInvocation(fp, registerCount, enableExcept);
			fp << "	ret\n";
			fp << "1:\n";
			fp << "#endif /* !__OPTIMIZE_SIZE__ */\n";
			i386_printLibcSyscallInt80CdeclInvocation(fp, registerCount, enableExcept);
			fp << "	ret\n";
			fp << "	.cfi_endproc\n";
			fp << "END(libc_" << name << ")\n";
		}
	}
}

function i386_printLibcSyscallWrapper(fp: File, f: Function, sysno: int, enableExcept: bool) {
	local registerCount = f.getArgumentRegisterCount(32);
	local conditionalX = enableExcept ? "X" : "";
	if (sysno == 0) {
		fp << "	xorl   %eax, %eax\n";
	} else {
		fp << "	movl   $(" << sysno.hex() << "), %eax\n";
	}
	fp << "	jmp    ";
	if (registerCount == 0) {
		fp << "libc___i386_" << conditionalX << "syscall\n";
	} else {
		fp << "libc_x86_exec_" << conditionalX << "syscall" << registerCount << "\n";
	}
}

function i386_printKernelSyscallWrapperCommon(fp: File) {
	fp << "#include <asm/cfi.h>\n";
	fp << "#include <kos/kernel/gdt.h>\n";
	fp << "#include <kos/kernel/paging.h>\n";
	fp << "#include <kernel/arch/syscall.h>\n";
	fp << "\n";
	fp << "EXTERN(__asm32_bad_sysenter_extension)\n";
}

function i386_restoreSyscallRegisters(fp: File, restoreRegisters: {string...}) {
	function isNoneRegister(x) {
		return x is none || x.startswith("!");
	}
	while (restoreRegisters) {
		local reg = restoreRegisters.pop();
		if (reg.startswith("!")) {
			if (restoreRegisters && isNoneRegister(restoreRegisters[#restoreRegisters - 1]))
				reg = none;
			else {
				reg = reg[1:];
			}
		}
		if (reg is none) {
			local count = 1;
			while (restoreRegisters && isNoneRegister(restoreRegisters[#restoreRegisters - 1])) {
				restoreRegisters.pop();
				++count;
			}
			if (count == 1 && restoreRegisters) {
				local reg = restoreRegisters.first;
				fp << "	popl_cfi " << reg << " /* addl $(4), %esp */\n";
			} else {
				fp << "	addl   $(" << (count * 4) << "), %esp\n";
				fp << "	.cfi_adjust_cfa_offset -" << (count * 4) << "\n";
			}
		} else {
			fp << "	popl_cfi_r " << reg << "\n";
		}
	}
}

function i386_printKernelSyscallWrapper_int80(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm32_syscall_int80." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_int80_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_int80\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %esp, 0\n";
	fp << "	pushl_cfi %ds\n";
	fp << "	.cfi_restore_iret_ds_or_offset -4\n";
	fp << "	pushl_cfi %es\n";
	fp << "	.cfi_restore_iret_es_or_offset -8\n";
	fp << "	pushl_cfi %fs\n";
	fp << "	.cfi_restore_iret_fs_or_offset -12\n";
	fp << "	movw   $(SEGMENT_USER_DATA_RPL), %ax\n";
	fp << "	movw   %ax, %ds\n";
	fp << "	movw   %ax, %es\n";
	fp << "	movw   $(SEGMENT_KERNEL_FSBASE), %ax\n";
	fp << "	movw   %ax, %fs\n";
	local registerCount = f.getArgumentRegisterCount(32);
	local restoreRegisters = [];
	switch (registerCount) {
	case 0:
	case 1:
		if (!f.isNoReturn) {
			fp << "	pushl_cfi_r %ecx\n";
			restoreRegisters.append("%ecx");
			if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
				fp << "	pushl_cfi_r %edx\n";
				restoreRegisters.append("%edx");
			}
		}
		if (registerCount == 1) {
			fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
			restoreRegisters.append("!%ebx");
		}
		break;
	case 2:
		if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
			fp << "	pushl_cfi_r %edx\n";
			restoreRegisters.append("%edx");
		}
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	case 6:
		fp << "	pushl_cfi_r %ebp  /* Arg #5 */\n";
		restoreRegisters.append("!%ebp");
		/* FALLTHRU */
	case 5:
		fp << "	pushl_cfi_r %edi  /* Arg #4 */\n";
		restoreRegisters.append("!%edi");
		/* FALLTHRU */
	case 4:
		fp << "	pushl_cfi_r %esi  /* Arg #3 */\n";
		restoreRegisters.append("!%esi");
		/* FALLTHRU */
	case 3:
		fp << "	pushl_cfi_r %edx  /* Arg #2 */\n";
		restoreRegisters.append((
			f.returnType.isReg64 ||
			f.returnType.isReg128)
			? none
			: "%edx");
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	default:
		break;
	}
	fp << "	EXTERN(sys_" << f.name << ")\n";
	fp << "	call   sys_" << f.name << "\n";
	if (!f.isNoReturn) {
		i386_restoreSyscallRegisters(fp, restoreRegisters);
		fp << "	popl_cfi %fs\n";
		fp << "	.cfi_restore_iret_fs\n";
		fp << "	popl_cfi %es\n";
		fp << "	.cfi_restore_iret_es\n";
		fp << "	popl_cfi %ds\n";
		fp << "	.cfi_restore_iret_ds\n";
		fp << "	iret\n";
	}
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_int80_" << f.name << ")\n";
}

function i386_printKernelSyscallWrapper_sysenter(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm32_syscall_sysenter." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_sysenter_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_sysenter\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %esp, 0\n";
	fp << "	pushl_cfi %ds\n";
	fp << "	.cfi_restore_iret_ds_or_offset -4\n";
	fp << "	pushl_cfi %es\n";
	fp << "	.cfi_restore_iret_es_or_offset -8\n";
	fp << "	pushl_cfi %fs\n";
	fp << "	.cfi_restore_iret_fs_or_offset -12\n";
	fp << "	movw   $(SEGMENT_USER_DATA_RPL), %ax\n";
	fp << "	movw   %ax, %ds\n";
	fp << "	movw   %ax, %es\n";
	fp << "	movw   $(SEGMENT_KERNEL_FSBASE), %ax\n";
	fp << "	movw   %ax, %fs\n";
	local registerCount = f.getArgumentRegisterCount(32);
	local restoreRegisters = [];
	switch (registerCount) {
	case 0:
	case 1:
		if (!f.isNoReturn) {
			fp << "	pushl_cfi_r %ecx\n";
			restoreRegisters.append("%ecx");
			if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
				fp << "	pushl_cfi_r %edx\n";
				restoreRegisters.append("%edx");
			}
		}
		if (registerCount == 1) {
			fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
			restoreRegisters.append("!%ebx");
		}
		break;
	case 2:
		if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
			fp << "	pushl_cfi_r %edx\n";
			restoreRegisters.append("%edx");
		}
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	case 6:
	case 5:
		fp << "	cmpl   $(KERNELSPACE_BASE), %ebp\n";
		fp << "	jae    __asm32_bad_sysenter_extension\n";
		if (registerCount == 6) {
			fp << "	pushl_cfi   4(%ebp)  /* Arg #5 (WARNING: SEGFAULT!) */\n";
			restoreRegisters.append(none);
		}
		/* FALLTHRU */
		fp << "	pushl_cfi   0(%ebp)  /* Arg #4 (WARNING: SEGFAULT!) */\n";
		restoreRegisters.append(none);
		/* FALLTHRU */
	case 4:
		fp << "	pushl_cfi_r %esi  /* Arg #3 */\n";
		restoreRegisters.append("!%esi");
		/* FALLTHRU */
	case 3:
		fp << "	pushl_cfi_r %edx  /* Arg #2 */\n";
		restoreRegisters.append((
			f.returnType.isReg64 ||
			f.returnType.isReg128)
			? none
			: "%edx");
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	default:
		break;
	}
	fp << "	EXTERN(sys_" << f.name << ")\n";
	fp << "	call   sys_" << f.name << "\n";
	if (!f.isNoReturn) {
		i386_restoreSyscallRegisters(fp, restoreRegisters);
		fp << "	popl_cfi %fs\n";
		fp << "	.cfi_restore_iret_fs\n";
		fp << "	popl_cfi %es\n";
		fp << "	.cfi_restore_iret_es\n";
		fp << "	popl_cfi %ds\n";
		fp << "	.cfi_restore_iret_ds\n";
		/* Can only use sysexit if not double-wide!
		 * Double-wide system calls return via EDX,
		 * which gets clobbered if we use sysexit. */
		if (!((f.returnType.isReg64 || f.returnType.isReg128))) {
			fp << "	X86_IRET_BUT_PREFER_SYSEXIT\n";
		} else {
			fp << "	iret\n";
		}
	}
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_sysenter_" << f.name << ")\n";
}



/************************************************************************/
/* X86_64                                                               */
/************************************************************************/
final global x86_64SyscallArgumentRegisters = { "%rdi", "%rsi", "%rdx", "%r10", "%r8", "%r9" };
final global x86_64SysvABIRegisters = { "%rdi", "%rsi", "%rdx", "%rcx", "%r8", "%r9" };
function x86_64_printLibcSyscallWrapperCommon(fp: File) {
}

function x86_64_printLibcSyscallWrapper(fp: File, f: Function, sysno: int, enableExcept: bool) {
	fp << "	.cfi_startproc\n";
	if (sysno == 0) {
		fp << "	xorq   %rax, %rax\n";
	} else {
		fp << "	movq   $(" << sysno.hex() << "), %rax\n";
	}
	if (f.getArgumentRegisterCount(64) >= 4)
		fp << "	movq   %rcx, %r10\n";
	fp << (enableExcept ? "	stc\n" : "	clc\n");
	fp << "	syscall\n";
	fp << "	ret\n";
	fp << "	.cfi_endproc\n";
}

function x86_64_printKernelSyscallWrapperCommon(fp: File) {
	fp << "#include <asm/cfi.h>\n";
	fp << "#include <asm/instr/movzxq.h>\n";
	fp << "#include <asm/instr/interrupt.h>\n";
	fp << "#include <kos/kernel/paging.h>\n";
	fp << "#include <kernel/arch/syscall.h>\n";
}

function x86_64_printKernelSyscallWrapper_asm64_syscall(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm64_syscall." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm64_syscall_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm64_syscall\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %rsp, 0\n";
	fp << "	pushq_cfi_r %rcx\n";
	fp << "	pushq_cfi_r %rdx\n";
	fp << "	pushq_cfi_r %rsi\n";
	fp << "	pushq_cfi_r %rdi\n";
	fp << "	pushq_cfi_r %r8\n";
	fp << "	pushq_cfi_r %r9\n";
	fp << "	pushq_cfi_r %r10\n";
	fp << "	pushq_cfi_r %r11\n";
	if (f.getArgumentRegisterCount(64) >= 4)
		fp << "	movq   %r10, %rcx\n";
	fp << "	EXTERN(sys_" << f.name << ")\n";
	fp << "	call   sys_" << f.name << "\n";
	fp << "	popq_cfi_r %r11\n";
	fp << "	popq_cfi_r %r10\n";
	fp << "	popq_cfi_r %r9\n";
	fp << "	popq_cfi_r %r8\n";
	fp << "	popq_cfi_r %rdi\n";
	fp << "	popq_cfi_r %rsi\n";
	if (f.returnType.isReg128) {
		fp << "	popq_cfi %rcx\n /* %rdx */";
	} else {
		fp << "	popq_cfi_r %rdx\n";
	}
	fp << "	popq_cfi_r %rcx\n";
	fp << "	intr_exit_sysret\n";
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm64_syscall_" << f.name << ")\n";
}


function x86_64_getRegisterName32(reg: string): string {
	local i = i386SyscallArgumentRegisters.find(reg);
	if (i >= 0)
		return "REG" + i;
	if (reg == "0(%rbp)")
		return "REG4";
	if (reg == "4(%rbp)")
		return "REG5";
	return reg;
}

function x86_64_getRegisterName64(reg: string): string {
	local i = x86_64SysvABIRegisters.find(reg);
	if (i >= 0)
		return "ARG" + i;
	return reg;
}

function x86_64_formDoubleWideArgument64Ex(
		fp: File, dst64: string, losrc32: string,
		hisrc32: string, clobber: string) {
	final local TEXTALIGN = 17;
	fp << "	movzlq " << hisrc32 << ", " << dst64
		<< (" " * (TEXTALIGN - (#hisrc32 + #dst64)))
		<< " /* "
		<< x86_64_getRegisterName64(dst64)
		<< " = " << x86_64_getRegisterName32(losrc32)
		<< ":" << x86_64_getRegisterName32(hisrc32)
		<< " */\n";
	fp << "	movzlq " << losrc32 << ", " << clobber
		<< (" " * (TEXTALIGN - (#losrc32 + #clobber)))
		<< " /* ... */\n";
	fp << "	shlq   $(32), " << dst64
		<< (" " * (TEXTALIGN - (3 + #dst64)))
		<< "  /* ... */\n";
	fp << "	orq    " << clobber << ", " << dst64
		<< (" " * (TEXTALIGN - (#clobber + #dst64)))
		<< " /* ... */\n";
}

function x86_64_assignRegister64(
		fp: File, sysenter: bool, format: string,
		clobber: string = none) {
	if (sysenter) {
		format = format
			.replace("%ebp", "4(%ebp)")
			.replace("%edi", "0(%ebp)");
	}
	local a, none, b = format.partition("=")...;
	if (":" in b) {
		local c;
		b, none, c = b.partition(":")...;
		assert clobber !is none;
		x86_64_formDoubleWideArgument64Ex(fp, a, b, c, clobber);
	} else if (b.startswith("%r")) {
		fp << "	movq   " << b << ", " << a << " /* "
			<< x86_64_getRegisterName64(a)
			<< " = "
			<< x86_64_getRegisterName64(b)
			<< " */\n";
	} else {
		fp << "	movzlq " << b << ", " << a << " /* "
			<< x86_64_getRegisterName64(a)
			<< " = "
			<< x86_64_getRegisterName32(b)
			<< " */\n";
	}
}

function x86_64_printKernelSyscallWrapper_transformArguments(
		fp: File, f: Function, sysenter: bool) {
	/* Re-arrange and zero-extend registers:
	 *   - ARG0: %ebx -> %rdi
	 *   - ARG1: %ecx -> %rsi
	 *   - ARG2: %edx -> %rdx
	 *   - ARG3: %esi -> %rcx
	 *   - ARG4: %edi -> %r8     ARG4: 0(%ebp) -> %r8
	 *   - ARG5: %ebp -> %r9     ARG5: 4(%ebp) -> %r9 */
	local argumentCount = #f.args;
	local registerCount = f.getArgumentRegisterCount(32);
	local doubleWideArguments = Tuple(
		for (local i: [:argumentCount])
			if (f.args[i][0].isReg64)
				i);
	if (sysenter && registerCount > 4) {
		fp << "	movzlq %ebp, %rbp\n"; /*  */
		/* NOTE: By zero-extending the user-space EBP, we already
		 *       ensured that %rbp doesn't point into kernel-space,
		 *       as kernelspace on x86_64 only begins after the end
		 *       of the 32-bit user-code address-space. */
		/*fp << "	cmpq   $(0), %rbp\n";
		fp << "	jl     __asm32_bad_sysenter_extension\n";*/
	}
#define R(...) x86_64_assignRegister64(fp, sysenter, __VA_ARGS__)
	switch (registerCount) {
	case 0:
		assert argumentCount == 0;
		break;
	case 1:
		assert argumentCount == 1;
		/* ARG0: %rdi=%ebx */
		R("%rdi=%ebx");
		break;
	case 2:
		if (0 in doubleWideArguments) {
			assert argumentCount == 1;
			/* ARG0: %rdi=%ebx:%ecx */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
		} else {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx
			 * ARG1: %rsi=%ecx */
			R("%rdi=%ebx");
			R("%rsi=%ecx");
		}
		break;
	case 3:
		if (0 in doubleWideArguments) {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx:%ecx
			 * ARG1: %rsi=%edx */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rsi=%edx");
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx
			 * ARG1: %rsi=%ecx:%edx */
			R("%rdi=%ebx");
			R("%rsi=%ecx:%edx", clobber: "%rax");
		} else {
			assert argumentCount == 3;
			/* ARG0: %rdi=%ebx
			 * ARG1: %rsi=%ecx
			 * ARG2: %rdx=%edx */
			R("%rdi=%ebx");
			R("%rsi=%ecx");
			R("%rdx=%edx");
		}
		break;
	case 4:
		if (0 in doubleWideArguments && 1 in doubleWideArguments) {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx:%ecx
			 * ARG1: %rsi=%edx:%esi */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rsi=%edx:%esi", clobber: "%rax");
		} else if (0 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi */
			R("%rdi=%ebx");
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
		} else if (2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi */
			R("%rdi=%ebx");
			R("%rax=%ecx");
			R("%rdx=%edx:%esi", clobber: "%r8");
			R("%rsi=%rax");
		} else {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi */
			R("%rdi=%ebx");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
		}
		break;
	case 5:
		if (0 in doubleWideArguments && 1 in doubleWideArguments) {
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx:%esi
			 * ARG2: %rdx = %edi */
			assert argumentCount == 3;
			R("%rax=%edi");
			R("%rdi=%ebx:%ecx", clobber: "%r8");
			R("%rsi=%edx:%esi", clobber: "%r8");
			R("%rdx=%rax");
		} else if (1 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi:%edi */
			R("%rsi=%ecx:%edx", clobber: "%rax");
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rdi=%ebx");
			R("%rdx=%rax");
		} else if (0 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi:%edi */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%edx");
			R("%rdi=%ebx:%ecx", clobber: "%r8");
			R("%rdx=%rax");
		} else if (0 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi */
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
			R("%rax=%ebx:%ecx", clobber: "%r8");
			R("%rcx=%edi");
			R("%rdi=%rax");
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
			R("%rcx=%edi");
			R("%rdi=%ebx");
		} else if (2 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi
			 * ARG3: %rcx = %edi */
			R("%rdx=%edx:%esi", clobber: "%rax");
			R("%rsi=%ecx");
			R("%rcx=%edi");
			R("%rdi=%ebx");
		} else if (3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi:%edi */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%ecx");
			R("%rcx=%rax");
			R("%rdx=%edx");
			R("%rdi=%ebx");
		} else {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi
			 * ARG4: %r8  = %edi */
			R("%r8=%edi");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
			R("%rdi=%ebx");
		}
		break;
	case 6:
		if (0 in doubleWideArguments && 1 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx:%esi
			 * ARG2: %rdx = %edi:%ebp */
			R("%rax=%edi:%ebp", clobber: "%r8");
			R("%rsi=%edx:%esi", clobber: "%r8");
			R("%rdx=%rax");
			R("%rdi=%ebx:%ecx", clobber: "%rax");
		} else if (0 in doubleWideArguments && 1 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx:%esi
			 * ARG2: %rdx = %edi
			 * ARG3: %rcx = %ebp */
			R("%rsi=%edx:%esi", clobber: "%rax");
			R("%rax=%ebx:%ecx", clobber: "%r8");
			R("%rdx=%edi");
			R("%rdi=%rax");
			R("%rcx=%ebp");
		} else if (0 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi:%edi
			 * ARG3: %rcx = %ebp */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%edx");
			R("%rdx=%rax");
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rcx=%ebp");
		} else if (0 in doubleWideArguments && 3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi:%ebp */
			R("%rax=%ebx:%ecx", clobber: "%r8");
			R("%rcx=%edi:%ebp", clobber: "%r8");
			R("%rdi=%rax");
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
		} else if (1 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi:%edi
			 * ARG3: %rcx = %ebp */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi:%edi", clobber: "%r8");
			R("%rsi=%rax");
			R("%rdi=%ebx");
			R("%rcx=%ebp");
		} else if (1 in doubleWideArguments && 3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi:%ebp */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
			R("%rcx=%edi:%ebp", clobber: "%rax");
			R("%rdi=%ebx");
		} else if (2 in doubleWideArguments && 3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi
			 * ARG3: %rcx = %edi:%ebp */
			R("%rdx=%edx:%esi", clobber: "%rax");
			R("%rax=%edi:%ebp", clobber: "%r8");
			R("%rsi=%ecx");
			R("%rcx=%rax");
			R("%rdi=%ebx");
		} else if (0 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi
			 * ARG4: %r8  = %ebp */
			R("%rax=%ebx:ecx", clobber: "%r8");
			R("%rcx=%edi");
			R("%rdi=%rax");
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
			R("%r8=%ebp");
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi
			 * ARG4: %r8  = %ebp */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
			R("%rcx=%edi");
			R("%rdi=%ebx");
			R("%r8=%ebp");
		} else if (2 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi
			 * ARG3: %rcx = %edi
			 * ARG4: %r8  = %ebp */
			R("%rdx=%edx:%esi", clobber: "%rax");
			R("%rsi=%ecx");
			R("%rcx=%edi");
			R("%rdi=%ebx");
			R("%r8=%ebp");
		} else if (3 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi:%edi
			 * ARG4: %r8  = %ebp */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%ecx");
			R("%rcx=%rax");
			R("%rdx=%edx");
			R("%rdi=%ebx");
			R("%r8=%ebp");
		} else if (4 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi
			 * ARG4: %r8  = %edi:%ebp */
			R("%r8=%edi:%ebp", clobber: "%rax");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
			R("%rdi=%ebx");
		} else {
			assert argumentCount == 6;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi
			 * ARG4: %r8  = %edi
			 * ARG5: %r9  = %ebp */
			R("%r8=%edi");
			R("%r9=%ebp");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
			R("%rdi=%ebx");
		}
		break;
#undef R
	default:
		assert 0, "registerCount = " + registerCount;
	}
}

function x86_64_printKernelSyscallWrapper_asm32_int80(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm32_syscall_int80." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_int80_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_int80\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %rsp, 0\n";
	/* Preserve callee-clobber registers to prevent
	 * kernel data from leaking into user-space. */
	fp << "	pushq_cfi_r %rcx\n";
	fp << "	pushq_cfi_r %rdx\n";
	fp << "	pushq_cfi_r %rsi\n";
	fp << "	pushq_cfi_r %rdi\n";
	fp << "	pushq_cfi_r %r8\n";
	fp << "	pushq_cfi_r %r9\n";
	fp << "	pushq_cfi_r %r10\n";
	fp << "	pushq_cfi_r %r11\n";
	x86_64_printKernelSyscallWrapper_transformArguments(fp, f, sysenter: false);
	fp << "	EXTERN(sys32_" << f.name << ")\n";
	fp << "	call   sys32_" << f.name << "\n";
	fp << "	popq_cfi_r %r11\n";
	fp << "	popq_cfi_r %r10\n";
	fp << "	popq_cfi_r %r9\n";
	fp << "	popq_cfi_r %r8\n";
	fp << "	popq_cfi_r %rdi\n";
	fp << "	popq_cfi_r %rsi\n";
	if (f.returnType.isReg64) {
		fp << "	popq_cfi %rcx\n /* %rdx */";
		/* Split the 64-bit return value into %eax:%edx */
		fp << "	movq   %rax, %rdx\n";
		fp << "	shrq   $(32), %rdx\n";
	} else {
		fp << "	popq_cfi_r %rdx\n";
	}
	fp << "	popq_cfi_r %rcx\n";
	fp << "	intr_exit_sysret\n";
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_int80_" << f.name << ")\n";
}

function x86_64_printKernelSyscallWrapper_asm32_sysenter(fp: File, f: Function, sysno: int) {
	if (f.getArgumentRegisterCount(32) <= 4) {
		fp << "DEFINE_INTERN_WEAK_ALIAS("
			"__x86_asm32_sysenter_" << f.name << ", "
			"__x86_asm32_int80_" << f.name << ")\n";
		return;
	}
	fp << ".section .text.x86.asm32_syscall_sysenter." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_sysenter_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_sysenter\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %rsp, 0\n";
	/* Preserve callee-clobber registers to prevent
	 * kernel data from leaking into user-space. */
	fp << "	pushq_cfi_r %rcx\n";
	fp << "	pushq_cfi_r %rdx\n";
	fp << "	pushq_cfi_r %rsi\n";
	fp << "	pushq_cfi_r %rdi\n";
	fp << "	pushq_cfi_r %r8\n";
	fp << "	pushq_cfi_r %r9\n";
	fp << "	pushq_cfi_r %r10\n";
	fp << "	pushq_cfi_r %r11\n";
	x86_64_printKernelSyscallWrapper_transformArguments(fp, f, sysenter: true);
	fp << "	EXTERN(sys32_" << f.name << ")\n";
	fp << "	call   sys32_" << f.name << "\n";
	fp << "	popq_cfi_r %r11\n";
	fp << "	popq_cfi_r %r10\n";
	fp << "	popq_cfi_r %r9\n";
	fp << "	popq_cfi_r %r8\n";
	fp << "	popq_cfi_r %rdi\n";
	fp << "	popq_cfi_r %rsi\n";
	if (f.returnType.isReg64) {
		fp << "	popq_cfi %rcx\n /* %rdx */";
		/* Split the 64-bit return value into %eax:%edx */
		fp << "	movq   %rax, %rdx\n";
		fp << "	shrq   $(32), %rdx\n";
	} else {
		fp << "	popq_cfi_r %rdx\n";
	}
	fp << "	popq_cfi_r %rcx\n";
	fp << "	intr_exit_sysret\n";
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_sysenter_" << f.name << ")\n";
}

@@Listing of supported system call architectures, as well
@@as arch-specific configuration options, and code generators.
global ARCH: {string: SyscallArch} = {

	"i386" : SyscallArch(
		platformName: "i386-kos",
		platformArch: "i386",
		platformSuffix: "32",
		platformGpRegisterSizeInBits: 32,
		platformSyscallRegisterCount: 6,
		platformEndian: "le",
		platformSyscallTableCount: 2,
		platformMaxPossibleSysno: 0xffffffff,
		platformLibcSyscallCommon: i386_printLibcSyscallWrapperCommon,
		platformLibcSyscallWrapper: i386_printLibcSyscallWrapper,
		platformKernelSyscallWrappersCommon: i386_printKernelSyscallWrapperCommon,
		platformKernelSyscallWrappers: {
			(i386_printKernelSyscallWrapper_int80, "i386"),
			(i386_printKernelSyscallWrapper_sysenter, "i386"),
		},
	),

	"x86_64" : SyscallArch(
		platformName: "i386-kos",
		platformArch: "i386",
		platformSuffix: "64",
		platformSyscallCompatArch: {
			("include/i386-kos/asm/syscall3264-compat.h", "__NR3264COMPAT_", "i386"),
		},
		platformGpRegisterSizeInBits: 64,
		platformSyscallRegisterCount: 6,
		platformEndian: "le",
		platformSyscallTableCount: 2,
		platformMaxPossibleSysno: 0xffffffffffffffff,
		platformLibcSyscallCommon: x86_64_printLibcSyscallWrapperCommon,
		platformLibcSyscallWrapper: x86_64_printLibcSyscallWrapper,
		platformKernelSyscallWrappersCommon: x86_64_printKernelSyscallWrapperCommon,
		platformKernelSyscallWrappers: {
			(x86_64_printKernelSyscallWrapper_asm64_syscall, "x86_64"),
			(x86_64_printKernelSyscallWrapper_asm32_int80, "i386"),
			(x86_64_printKernelSyscallWrapper_asm32_sysenter, "i386"),
		},
	),

//	"arm" : SyscallArch(
//		platformName: "arm-kos",
//		platformArch: "arm",
//		platformGpRegisterSizeInBits: 32,
//		platformSyscallRegisterCount: 6,
//		platformEndian: "le",
//		platformSyscallTableCount: 2,
//		platformMaxPossibleSysno: 0xffffffff,
//		platformLibcSyscallCommon: arm_printLibcSyscallWrapperCommon,
//		platformLibcSyscallWrapper: arm_printLibcSyscallWrapper,
//		platformKernelSyscallWrappersCommon: arm_printKernelSyscallWrapperCommon,
//		platformKernelSyscallWrappers: {
//			"__arm_syscall_" : ("INTERN", "arm", arm_printKernelSyscallWrapper),
//		},
//	),
};


