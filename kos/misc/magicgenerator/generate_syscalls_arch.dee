/* Copyright (c) 2019-2022 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2022 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .generate_syscalls;

class SyscallArch {
	this = default;

	@@name of the platform (e.g. `i386-kos`)
	member platformName: string;

	@@Architecture of the platform (e.g. `i386`)
	member platformArch: string;

	@@Optional suffix for platform files (for use with multi-arch platforms)
	member platformSuffix: string = "";

	@@Set of (name, prefix, arch) for other architectures for which
	@@syscall compatibility meta-data  should be  generated in  the
	@@form of a system header @"/kos/{name}" that contains a set of
	@@definitions @"{prefix}{syscall-name} 1" for all system  calls
	@@defined by both architectures that share both the same  name,
	@@as well as binary compatibility.
	@@On  multi-arch targets such as x86_64, this  is used to determine if an
	@@invocation of `DEFINE_SYSCALLn()` should also define the compatibility-
	@@mode variant of another system call with the same name.
	member platformSyscallCompatArch: {(string, string, string)...} = none;

	@@Set of (name, arch) for hybridized syscalls-types.h headers
	member platformSyscallCompatTypes: {(string, string)...} = none;

	@@Name of  the architecture  that is  targeted by  `__ARCH_HAVE_COMPAT`,  and
	@@for which  compatibility-mode implementation  requests  are issued  to  the
	@@kernel. (when  defined,  emit  `#define  __ARCH_WANT_COMPAT_SYSCALL_XXX  1`
	@@alongside `#define __ARCH_WANT_SYSCALL_YYY 1` in `<kos/kernel/syscalls.h>`)
	@@NOTE: Compatibility-mode system calls that are already share binary
	@@      compatibility with other, regular system calls will not cause
	@@      an implementation request to be issued.
	member platformSyscallCompatRequest: string = none;

	@@Size of general-purpose registers used for passing system call arguments (in bits)
	member platformGpRegisterSizeInBits: int;

	@@Size of `sizeof(void *)`
	member platformPointerSizeInBytes: int;

	@@The number of registers used to pass system call arguments
	member platformSyscallRegisterCount: int;

	@@Endian of the platform (either "le" or "be")
	member platformEndian: string;

	@@Number of system call tables used by this platform
	member platformSyscallTableCount: int;

	@@The max possibly system call number (usually `(1 << platformGpRegisterSizeInBits) - 1`)
	member platformMaxPossibleSysno: int;

	@@Print common code which may be used by @platformLibcSyscallWrapper
	@@This is a @function(fp: File)
	member platformLibcSyscallPrefix: Callable = none;
	member platformLibcSyscallSuffix: Callable = none;

	/* Prefix/Suffix for noexcept/except system call wrappers. */
	member platformLibcSyscallNoexceptPrefix: Callable = none;
	member platformLibcSyscallNoexceptSuffix: Callable = none;
	member platformLibcSyscallExceptPrefix: Callable = none;
	member platformLibcSyscallExceptSuffix: Callable = none;

	@@Print assembly for invoking
	@@This is a @function(fp: File, f: Function, sysno: int, enableExcept: bool)
	member platformLibcSyscallWrapper: Callable;

	@@Print common code which may be used by @platformKernelSyscallWrappers
	@@This is a @function(fp: File)
	member platformKernelSyscallWrappersCommon: Callable = none;

	@@Mapping of known system call wrappers.
	@@@key:   The prefix  to be  pre-pended before  the wrappers´s  name
	@@        e.g. when `__fooasm_`, one symbol might be `__fooasm_exit`
	@@@value: A tuple @(function(fp: File, f: Function, sysno: int),
	@@                  arch_origin_name)
	@@        This function  should print  the  assembly body  for  servicing
	@@        the system  call in  the context  in which  this wrapper  might
	@@        be called. The given `f` is the function that is being defined.
	@@        @arch_origin_name is the name of the ARCH who´s system calls
	@@        should be wrapped. Normally this is the same name as the
	@@        current arch, however in  order to allow for  multi-arch
	@@        compatibility  mode (such as x86_64´s IA32-mode), one is
	@@        allowed to specify a  different arch who´s system  calls
	@@        are then going to be wrapped.
	member platformKernelSyscallWrappers: {string: (Callable, string)};

	function formatPath(f: string): string {
		return f.format({
			.name   = platformName,
			.arch   = platformArch,
			.suffix = platformSuffix,
		});
	}
}

/************************************************************************/
/* I386                                                                 */
/************************************************************************/
/* Print instructions to set/restore EFLAGS.DF before/after a system call.
 * NOTE: The sysv i386 specs require that EFLAGS.DF=0 during normal user-space
 *       operations, so we  the user  wants to  invoke a  system call  without
 *       exceptions, additional set-up is required. */

/* CFI code to inject in order to clear EFLAGS.DF upon return */
/*[[[deemon
print("final global i386CfiClearDF = ", repr(",".join(
(assemble from ..libgen.cfi.comp)('i386', '%eflags', r'
	push %eflags
	and  ~$EFLAGS_DF
'))), ";");
]]]*/
final global i386CfiClearDF = "22,9,6,121,0,11,255,251,26";
/*[[[end]]]*/
#define I386_SETDF_BEGIN(fp, enableExcept) if (enableExcept) fp << "\tstd /* Enable exceptions */\n";
#define I386_SETDF_END(fp, enableExcept)   if (enableExcept) fp << "\tcld /* Disable exceptions */\n";
final global i386SyscallArgumentRegisters = { "%ebx", "%ecx", "%edx", "%esi", "%edi", "%ebp" };
function i386_printLibcSyscall386CdeclInvocation(
		fp: File, registerCount: int, enableExcept: bool) {
	local conditionalX = enableExcept ? "X" : "";
	local preservedRegisters = [];
	if (registerCount > 0)
		preservedRegisters.append("%ebx");
	if (registerCount > 3)
		preservedRegisters.append("%esi");
	if (registerCount > 4)
		preservedRegisters.append("%edi");
	if (registerCount > 5)
		preservedRegisters.append("%ebp");
	local sp_offset = 4 * (1 + #preservedRegisters);
	for (local x: preservedRegisters)
		fp << "	" << "pushl_cfi_r " << x << "\n";
	for (local i: [:registerCount])
		fp << "	" << "movl   " << (sp_offset + i * 4) << "(%esp), " << i386SyscallArgumentRegisters[i] << "\n";
	fp << "	call   libc___i386_" << conditionalX << "syscall\n";
	for (local x: preservedRegisters.reversed())
		fp << "	" << "popl_cfi_r " << x << "\n";
}

function i386_printLibcSyscallWrapperPrefix(fp: File) {
	fp << "#include <asm/cfi.h>\n";
	fp << "\n";
	fp << "EXTERN(libc_x86_sysenter_common)\n";
	fp << "EXTERN(libc_x86_syscall_check_sysenter)\n";
	fp << "\n";
	for (local enableExcept: { false, true }) {
		local conditionalX = enableExcept ? "X" : "";
		for (local registerCount: [1:6+1]) {
			local name = f"x86_exec_{conditionalX}syscall{registerCount}";
			fp << ".section .text.crt.syscalls\n";
			fp << "INTERN_FUNCTION(libc_" << name << ")\n";
			fp << "	.cfi_startproc\n";
			i386_printLibcSyscall386CdeclInvocation(fp, registerCount, enableExcept);
			fp << "	ret\n";
			fp << "	.cfi_endproc\n";
			fp << "END(libc_" << name << ")\n";
		}
	}
	fp << "\n";
	fp << ".section .text.crt.syscalls\n";
	fp << ".cfi_startproc /* Unwinding for syscall wrappers */\n";
}

function i386_printLibcSyscallWrapperSuffix(fp: File) {
	fp << ".cfi_endproc /* Unwinding for syscall wrappers */\n";
}

function i386_printLibcSyscallWrapper(fp: File, f: Function, sysno: int, enableExcept: bool) {
	local registerCount = f.getArgumentRegisterCount(32);
	local conditionalX = enableExcept ? "X" : "";
	if (sysno == 0) {
		fp << "	xorl   %eax, %eax\n";
	} else {
		fp << "	movl   $(" << sysno.hex() << "), %eax\n";
	}
	fp << "	jmp    ";
	if (registerCount == 0) {
		fp << "libc___i386_" << conditionalX << "syscall\n";
	} else {
		fp << "libc_x86_exec_" << conditionalX << "syscall" << registerCount << "\n";
	}
}

function i386_printKernelSyscallWrapperCommon(fp: File) {
	fp << "#include <asm/cfi.h>\n";
	fp << "#include <kos/kernel/gdt.h>\n";
	fp << "#include <kos/kernel/paging.h>\n";
	fp << "#include <kernel/arch/syscall.h>\n";
	fp << "\n";
	fp << "EXTERN(__asm32_bad_sysenter_extension)\n";
}

function i386_restoreSyscallRegisters(fp: File, restoreRegisters: {string...}) {
	function isNoneRegister(x) {
		return x is none || x.startswith("!");
	}
	while (restoreRegisters) {
		local reg = restoreRegisters.pop();
		if (reg.startswith("!")) {
			if (restoreRegisters && isNoneRegister(restoreRegisters[#restoreRegisters - 1])) {
				reg = none;
			} else {
				reg = reg[1:];
			}
		}
		if (reg is none) {
			local count = 1;
			while (restoreRegisters && isNoneRegister(restoreRegisters[#restoreRegisters - 1])) {
				restoreRegisters.pop();
				++count;
			}
			if (count == 1 && restoreRegisters) {
				local reg = restoreRegisters.first;
				fp << "	popl_cfi " << reg << " /* addl $(4), %esp */\n";
			} else {
				fp << "	addl   $(" << (count * 4) << "), %esp\n";
				fp << "	.cfi_adjust_cfa_offset -" << (count * 4) << "\n";
			}
		} else {
			fp << "	popl_cfi_r " << reg << "\n";
		}
	}
}

function i386_printKernelSyscallWrapper_int80(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm32_syscall_int80." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_int80_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_int80\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %esp, 0\n";
	fp << "	pushl_cfi %ds\n";
	fp << "	.cfi_restore_iret_ds_or_offset -4\n";
	fp << "	pushl_cfi %es\n";
	fp << "	.cfi_restore_iret_es_or_offset -8\n";
	fp << "	pushl_cfi %fs\n";
	fp << "	.cfi_restore_iret_fs_or_offset -12\n";
	fp << "	movw   $(SEGMENT_USER_DATA_RPL), %ax\n";
	fp << "	movw   %ax, %ds\n";
	fp << "	movw   %ax, %es\n";
	fp << "	movw   $(SEGMENT_KERNEL_FSBASE), %ax\n";
	fp << "	movw   %ax, %fs\n";
	local registerCount = f.getArgumentRegisterCount(32);
	local restoreRegisters = [];
	switch (registerCount) {
	case 0:
	case 1:
		if (!f.isNoReturn) {
			fp << "	pushl_cfi_r %ecx\n";
			restoreRegisters.append("%ecx");
			if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
				fp << "	pushl_cfi_r %edx\n";
				restoreRegisters.append("%edx");
			}
		}
		if (registerCount == 1) {
			fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
			restoreRegisters.append("!%ebx");
		}
		break;
	case 2:
		if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
			fp << "	pushl_cfi_r %edx\n";
			restoreRegisters.append("%edx");
		}
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	case 6:
		fp << "	pushl_cfi_r %ebp  /* Arg #5 */\n";
		restoreRegisters.append("!%ebp");
		/* FALLTHRU */
	case 5:
		fp << "	pushl_cfi_r %edi  /* Arg #4 */\n";
		restoreRegisters.append("!%edi");
		/* FALLTHRU */
	case 4:
		fp << "	pushl_cfi_r %esi  /* Arg #3 */\n";
		restoreRegisters.append("!%esi");
		/* FALLTHRU */
	case 3:
		fp << "	pushl_cfi_r %edx  /* Arg #2 */\n";
		restoreRegisters.append((
			f.returnType.isReg64 ||
			f.returnType.isReg128)
			? none
			: "%edx");
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	default:
		break;
	}
	fp << "	EXTERN(sys_" << f.name << ")\n";
	fp << "	call   sys_" << f.name << "\n";
	if (!f.isNoReturn) {
		i386_restoreSyscallRegisters(fp, restoreRegisters);
		fp << "	popl_cfi %fs\n";
		fp << "	.cfi_restore_iret_fs\n";
		fp << "	popl_cfi %es\n";
		fp << "	.cfi_restore_iret_es\n";
		fp << "	popl_cfi %ds\n";
		fp << "	.cfi_restore_iret_ds\n";
		fp << "	iret\n";
	}
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_int80_" << f.name << ")\n";
}

function i386_printKernelSyscallWrapper_sysenter(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm32_syscall_sysenter." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_sysenter_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_sysenter\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %esp, 0\n";
	fp << "	pushl_cfi %ds\n";
	fp << "	.cfi_restore_iret_ds_or_offset -4\n";
	fp << "	pushl_cfi %es\n";
	fp << "	.cfi_restore_iret_es_or_offset -8\n";
	fp << "	pushl_cfi %fs\n";
	fp << "	.cfi_restore_iret_fs_or_offset -12\n";
	fp << "	movw   $(SEGMENT_USER_DATA_RPL), %ax\n";
	fp << "	movw   %ax, %ds\n";
	fp << "	movw   %ax, %es\n";
	fp << "	movw   $(SEGMENT_KERNEL_FSBASE), %ax\n";
	fp << "	movw   %ax, %fs\n";
	local registerCount = f.getArgumentRegisterCount(32);
	local restoreRegisters = [];
	switch (registerCount) {
	case 0:
	case 1:
		if (!f.isNoReturn) {
			fp << "	pushl_cfi_r %ecx\n";
			restoreRegisters.append("%ecx");
			if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
				fp << "	pushl_cfi_r %edx\n";
				restoreRegisters.append("%edx");
			}
		}
		if (registerCount == 1) {
			fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
			restoreRegisters.append("!%ebx");
		}
		break;
	case 2:
		if (!(f.returnType.isReg64 || f.returnType.isReg128)) {
			fp << "	pushl_cfi_r %edx\n";
			restoreRegisters.append("%edx");
		}
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	case 6:
	case 5:
		fp << "	cmpl   $(KERNELSPACE_BASE), %ebp\n";
		fp << "	jae    __asm32_bad_sysenter_extension\n";
		if (registerCount == 6) {
			fp << "	pushl_cfi   4(%ebp)  /* Arg #5 (WARNING: SEGFAULT!) */\n";
			restoreRegisters.append(none);
		}
		/* FALLTHRU */
		fp << "	pushl_cfi   0(%ebp)  /* Arg #4 (WARNING: SEGFAULT!) */\n";
		restoreRegisters.append(none);
		/* FALLTHRU */
	case 4:
		fp << "	pushl_cfi_r %esi  /* Arg #3 */\n";
		restoreRegisters.append("!%esi");
		/* FALLTHRU */
	case 3:
		fp << "	pushl_cfi_r %edx  /* Arg #2 */\n";
		restoreRegisters.append((
			f.returnType.isReg64 ||
			f.returnType.isReg128)
			? none
			: "%edx");
		fp << "	pushl_cfi_r %ecx  /* Arg #1 */\n";
		restoreRegisters.append("%ecx");
		fp << "	pushl_cfi_r %ebx  /* Arg #0 */\n";
		restoreRegisters.append("!%ebx");
		break;
	default:
		break;
	}
	fp << "	EXTERN(sys_" << f.name << ")\n";
	fp << "	call   sys_" << f.name << "\n";
	if (!f.isNoReturn) {
		i386_restoreSyscallRegisters(fp, restoreRegisters);
		fp << "	popl_cfi %fs\n";
		fp << "	.cfi_restore_iret_fs\n";
		fp << "	popl_cfi %es\n";
		fp << "	.cfi_restore_iret_es\n";
		fp << "	popl_cfi %ds\n";
		fp << "	.cfi_restore_iret_ds\n";
		/* Can only use sysexit if not double-wide!
		 * Double-wide system calls return via EDX,
		 * which gets clobbered if we use sysexit. */
		if (!((f.returnType.isReg64 || f.returnType.isReg128))) {
			fp << "	X86_IRET_BUT_PREFER_SYSEXIT\n";
		} else {
			fp << "	iret\n";
		}
	}
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_sysenter_" << f.name << ")\n";
}



/************************************************************************/
/* X86_64                                                               */
/************************************************************************/
/* CFI code to inject in order to clear EFLAGS.DF upon return */
/*[[[deemon
print("final global x86_64CfiClearDF = ", repr(",".join(
(assemble from ..libgen.cfi.comp)('x86_64', '%rflags', r'
	push %rflags
	and  ~$EFLAGS_DF
'))), ";");
]]]*/
final global x86_64CfiClearDF = "22,49,7,146,49,0,11,255,251,26";
/*[[[end]]]*/
final global x86_64SyscallArgumentRegisters = { "%rdi", "%rsi", "%rdx", "%r10", "%r8", "%r9" };
final global x86_64SysvABIRegisters = { "%rdi", "%rsi", "%rdx", "%rcx", "%r8", "%r9" };
final global x86_64Reg8NamesOfReg32 = {
	"%eax" : "%al", "%ecx" : "%cl",
	"%edx" : "%dl", "%ebx" : "%bl",
	"%esp" : "%spl", "%ebp" : "%bpl",
	"%esi" : "%sil", "%edi" : "%dil",
};
final global x86_64Reg16NamesOfReg32 = {
	"%eax" : "%ax", "%ecx" : "%cx",
	"%edx" : "%dx", "%ebx" : "%bx",
	"%esp" : "%sp", "%ebp" : "%bp",
	"%esi" : "%si", "%edi" : "%di",
};
function x86_64_printLibcSyscallWrapperPrefix(fp: File) {
	fp << ".cfi_startproc\n";
	fp << ".cfi_escape " << x86_64CfiClearDF << " /* Clear EFLAGS.DF on exit */\n";
}
function x86_64_printLibcSyscallWrapperSuffix(fp: File) {
	fp << ".cfi_endproc\n";
}

function x86_64_printLibcSyscallWrapper(fp: File, f: Function, sysno: int, enableExcept: bool) {
	if (sysno == 0) {
		fp << "	xorq   %rax, %rax\n";
	} else {
		fp << "	movq   $(" << sysno.hex() << "), %rax\n";
	}
	if (f.getArgumentRegisterCount(64) >= 4)
		fp << "	movq   %rcx, %r10\n";
	I386_SETDF_BEGIN(fp, enableExcept)
	fp << "	syscall\n";
	I386_SETDF_END(fp, enableExcept)
	fp << "	ret\n";
}

function x86_64_printKernelSyscallWrapperCommon(fp: File) {
	fp << "#include <asm/cfi.h>\n";
	fp << "#include <asm/instr/movzxq.h>\n";
	fp << "#include <asm/instr/interrupt.h>\n";
	fp << "#include <kos/kernel/paging.h>\n";
	fp << "#include <kernel/arch/syscall.h>\n";
}

function x86_64_printKernelSyscallWrapper_asm64_syscall(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm64_syscall." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm64_syscall_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm64_syscall\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %rsp, 0\n";
	fp << "	pushq_cfi_r %rcx\n";
	fp << "	pushq_cfi_r %rdx\n";
	fp << "	pushq_cfi_r %rsi\n";
	fp << "	pushq_cfi_r %rdi\n";
	fp << "	pushq_cfi_r %r8\n";
	fp << "	pushq_cfi_r %r9\n";
	fp << "	pushq_cfi_r %r10\n";
	fp << "	pushq_cfi_r %r11\n";
	if (f.getArgumentRegisterCount(64) >= 4)
		fp << "	movq   %r10, %rcx\n";
	fp << "	EXTERN(sys_" << f.name << ")\n";
	fp << "	call   sys_" << f.name << "\n";
	fp << "	popq_cfi_r %r11\n";
	fp << "	popq_cfi_r %r10\n";
	fp << "	popq_cfi_r %r9\n";
	fp << "	popq_cfi_r %r8\n";
	fp << "	popq_cfi_r %rdi\n";
	fp << "	popq_cfi_r %rsi\n";
	if (f.returnType.isReg128) {
		fp << "	popq_cfi %rcx\n /* %rdx */";
	} else {
		fp << "	popq_cfi_r %rdx\n";
	}
	fp << "	popq_cfi_r %rcx\n";
	/* NOTE: On x86_64, 64-bit system calls can be invoked in 1 of 2 ways:
	 *       - int 80h
	 *       - syscall
	 * Documentation throughout the kernel states that both of these methods
	 * yield identical results, though one  minor detail that is  documented
	 * nowhere else is left to use to decide upon:
	 *       `int 80h' on x86_64 is allowed to clobber %rcx and %r11
	 * By allowing for  this, we  can use identical  return-paths for  both
	 * invocation methods, by trying to make use of `sysret' in both cases. */
	fp << "	X86_IRET_BUT_PREFER_SYSRET64\n";
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm64_syscall_" << f.name << ")\n";
}


function x86_64_getRegisterIndex32(reg: string): int {
	local i = i386SyscallArgumentRegisters.find(reg);
	if (i >= 0)
		return i;
	if (reg == "0(%rbp)")
		return 4;
	if (reg == "4(%rbp)")
		return 5;
	return none;
}

function x86_64_getRegisterName32(reg: string): string {
	local i = i386SyscallArgumentRegisters.find(reg);
	if (i >= 0)
		return "REG" + i;
	if (reg == "0(%rbp)")
		return "REG4";
	if (reg == "4(%rbp)")
		return "REG5";
	return reg;
}

function x86_64_getRegisterName64(reg: string): string {
	local i = x86_64SysvABIRegisters.find(reg);
	if (i >= 0)
		return "ARG" + i;
	return reg;
}

function x86_64_formDoubleWideArgument64Ex(
		fp: File, dst64: string, losrc32: string,
		hisrc32: string, clobber: string) {
	final local TEXTALIGN = 17;
	fp << "	movzlq " << hisrc32 << ", " << dst64
		<< (" " * (TEXTALIGN - (#hisrc32 + #dst64)))
		<< " /* "
		<< x86_64_getRegisterName64(dst64)
		<< " = " << x86_64_getRegisterName32(losrc32)
		<< ":" << x86_64_getRegisterName32(hisrc32)
		<< " */\n";
	fp << "	movzlq " << losrc32 << ", " << clobber
		<< (" " * (TEXTALIGN - (#losrc32 + #clobber)))
		<< " /* ... */\n";
	fp << "	shlq   $(32), " << dst64
		<< (" " * (TEXTALIGN - (3 + #dst64)))
		<< "  /* ... */\n";
	fp << "	orq    " << clobber << ", " << dst64
		<< (" " * (TEXTALIGN - (#clobber + #dst64)))
		<< " /* ... */\n";
}

function x86_64_assignRegister64(
		fp: File, sysenter: bool,
		registerSizeValues: {int...},
		signedRegisters: {bool...},
		format: string,
		clobber: string = none) {
	if (sysenter) {
		format = format
			.replace("%ebp", "4(%ebp)")
			.replace("%edi", "0(%ebp)");
	}
	local a, none, b = format.partition("=")...;
	if (":" in b) {
		local c;
		b, none, c = b.partition(":")...;
		assert clobber !is none;
		x86_64_formDoubleWideArgument64Ex(fp, a, b, c, clobber);
	} else if (b.startswith("%r")) {
		fp << "	movq   " << b << ", " << a << " /* "
			<< x86_64_getRegisterName64(a)
			<< " = "
			<< x86_64_getRegisterName64(b)
			<< " */\n";
	} else {
		local regSize = 4;
		local regSigned = "z";
		local regI = x86_64_getRegisterIndex32(b);
		if (regI !is none) {
			assert regI <= #registerSizeValues;
			regSize = registerSizeValues[regI];
			if (signedRegisters[regI])
				regSigned = "s";
		}
		switch (regSize) {
		case 1:
			fp << "	mov" << regSigned << "bq " << x86_64Reg8NamesOfReg32.get(b, b) << ", " << a;
			break;
		case 2:
			fp << "	mov" << regSigned << "wq " << x86_64Reg16NamesOfReg32.get(b, b) << ", " << a;
			break;
		default:
			fp << "	mov" << regSigned << "lq " << b << ", " << a;
			break;
		}
		fp << " /* "
			<< x86_64_getRegisterName64(a)
			<< " = "
			<< x86_64_getRegisterName32(b);
		if (regSize != 4)
			fp << " (" << (regSize * 8) << "-bit)";
		fp << " */\n";
	}
}

function x86_64_printKernelSyscallWrapper_transformArguments(
		fp: File, f: Function, sysenter: bool) {
	/* Re-arrange and zero-extend registers:
	 *   - ARG0: %ebx -> %rdi
	 *   - ARG1: %ecx -> %rsi
	 *   - ARG2: %edx -> %rdx
	 *   - ARG3: %esi -> %rcx
	 *   - ARG4: %edi -> %r8     ARG4: 0(%ebp) -> %r8
	 *   - ARG5: %ebp -> %r9     ARG5: 4(%ebp) -> %r9 */
	local argumentCount = #f.args;
	local registerCount = f.getArgumentRegisterCount(32);
	local doubleWideArguments = Tuple(
		for (local i: [:argumentCount])
			if (f.args[i][0].isReg64)
				i);
	local signedRegisters = Tuple(() -> {
		for (local i: [:argumentCount]) {
			if (i in doubleWideArguments) {
				yield false;
				yield false;
				continue;
			}
			yield f.args[i][0].isSigned;
		}
	}());
	local registerSizeValues = Tuple(() -> {
		for (local i: [:argumentCount]) {
			if (i in doubleWideArguments) {
				yield 4;
				yield 4;
				continue;
			}
			local temp = getSizeofCType(f.args[i][0], "i386", 4);
			if (temp is none)
				temp = 4;
			if (temp !in [1, 2, 4])
				temp = 4;
			yield temp;
		}
	}());
	assert #registerSizeValues == registerCount;
#if 0 /* Not needed, because we can use 0(%ebp) during addressing, thus forcing
       * the  CPU to  dereference a 32-bit  pointer, rather than  a 64-bit one! */
	if (sysenter && registerCount > 4) {
		fp << "	movzlq %ebp, %rbp\n";
		/* NOTE: By zero-extending the  user-space EBP, we  already
		 *       ensured that %rbp doesn't point into kernel-space,
		 *       as kernelspace on x86_64 only begins after the end
		 *       of the 32-bit user-code address-space. */
		/*fp << "	cmpq   $(0), %rbp\n";
		fp << "	jl     __asm32_bad_sysenter_extension\n";*/
	}
#endif
#define R(...) x86_64_assignRegister64(fp, sysenter, registerSizeValues, signedRegisters, __VA_ARGS__)
	switch (registerCount) {
	case 0:
		assert argumentCount == 0;
		break;
	case 1:
		assert argumentCount == 1;
		/* ARG0: %rdi=%ebx */
		R("%rdi=%ebx");
		break;
	case 2:
		if (0 in doubleWideArguments) {
			assert argumentCount == 1;
			/* ARG0: %rdi=%ebx:%ecx */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
		} else {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx
			 * ARG1: %rsi=%ecx */
			R("%rdi=%ebx");
			R("%rsi=%ecx");
		}
		break;
	case 3:
		if (0 in doubleWideArguments) {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx:%ecx
			 * ARG1: %rsi=%edx */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rsi=%edx");
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx
			 * ARG1: %rsi=%ecx:%edx */
			R("%rdi=%ebx");
			R("%rsi=%ecx:%edx", clobber: "%rax");
		} else {
			assert argumentCount == 3;
			/* ARG0: %rdi=%ebx
			 * ARG1: %rsi=%ecx
			 * ARG2: %rdx=%edx */
			R("%rdi=%ebx");
			R("%rsi=%ecx");
			R("%rdx=%edx");
		}
		break;
	case 4:
		if (0 in doubleWideArguments && 1 in doubleWideArguments) {
			assert argumentCount == 2;
			/* ARG0: %rdi=%ebx:%ecx
			 * ARG1: %rsi=%edx:%esi */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rsi=%edx:%esi", clobber: "%rax");
		} else if (0 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi */
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi */
			R("%rdi=%ebx");
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
		} else if (2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi */
			R("%rdi=%ebx");
			R("%rax=%ecx");
			R("%rdx=%edx:%esi", clobber: "%r8");
			R("%rsi=%rax");
		} else {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi */
			R("%rdi=%ebx");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
		}
		break;
	case 5:
		if (0 in doubleWideArguments && 1 in doubleWideArguments) {
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx:%esi
			 * ARG2: %rdx = %edi */
			assert argumentCount == 3;
			R("%rax=%edi");
			R("%rdi=%ebx:%ecx", clobber: "%r8");
			R("%rsi=%edx:%esi", clobber: "%r8");
			R("%rdx=%rax");
		} else if (1 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi:%edi */
			R("%rsi=%ecx:%edx", clobber: "%rax");
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rdi=%ebx");
			R("%rdx=%rax");
		} else if (0 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi:%edi */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%edx");
			R("%rdi=%ebx:%ecx", clobber: "%r8");
			R("%rdx=%rax");
		} else if (0 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi */
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
			R("%rax=%ebx:%ecx", clobber: "%r8");
			R("%rcx=%edi");
			R("%rdi=%rax");
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
			R("%rcx=%edi");
			R("%rdi=%ebx");
		} else if (2 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi
			 * ARG3: %rcx = %edi */
			R("%rdx=%edx:%esi", clobber: "%rax");
			R("%rsi=%ecx");
			R("%rcx=%edi");
			R("%rdi=%ebx");
		} else if (3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi:%edi */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%ecx");
			R("%rcx=%rax");
			R("%rdx=%edx");
			R("%rdi=%ebx");
		} else {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi
			 * ARG4: %r8  = %edi */
			R("%r8=%edi");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
			R("%rdi=%ebx");
		}
		break;
	case 6:
		if (0 in doubleWideArguments && 1 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 3;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx:%esi
			 * ARG2: %rdx = %edi:%ebp */
			R("%rax=%edi:%ebp", clobber: "%r8");
			R("%rsi=%edx:%esi", clobber: "%r8");
			R("%rdx=%rax");
			R("%rdi=%ebx:%ecx", clobber: "%rax");
		} else if (0 in doubleWideArguments && 1 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx:%esi
			 * ARG2: %rdx = %edi
			 * ARG3: %rcx = %ebp */
			R("%rsi=%edx:%esi", clobber: "%rax");
			R("%rax=%ebx:%ecx", clobber: "%r8");
			R("%rdx=%edi");
			R("%rdi=%rax");
			R("%rcx=%ebp");
		} else if (0 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi:%edi
			 * ARG3: %rcx = %ebp */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%edx");
			R("%rdx=%rax");
			R("%rdi=%ebx:%ecx", clobber: "%rax");
			R("%rcx=%ebp");
		} else if (0 in doubleWideArguments && 3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi:%ebp */
			R("%rax=%ebx:%ecx", clobber: "%r8");
			R("%rcx=%edi:%ebp", clobber: "%r8");
			R("%rdi=%rax");
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
		} else if (1 in doubleWideArguments && 2 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi:%edi
			 * ARG3: %rcx = %ebp */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi:%edi", clobber: "%r8");
			R("%rsi=%rax");
			R("%rdi=%ebx");
			R("%rcx=%ebp");
		} else if (1 in doubleWideArguments && 3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi:%ebp */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
			R("%rcx=%edi:%ebp", clobber: "%rax");
			R("%rdi=%ebx");
		} else if (2 in doubleWideArguments && 3 in doubleWideArguments) {
			assert argumentCount == 4;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi
			 * ARG3: %rcx = %edi:%ebp */
			R("%rdx=%edx:%esi", clobber: "%rax");
			R("%rax=%edi:%ebp", clobber: "%r8");
			R("%rsi=%ecx");
			R("%rcx=%rax");
			R("%rdi=%ebx");
		} else if (0 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx:%ecx
			 * ARG1: %rsi = %edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi
			 * ARG4: %r8  = %ebp */
			R("%rax=%ebx:ecx", clobber: "%r8");
			R("%rcx=%edi");
			R("%rdi=%rax");
			R("%rsi=%esi");
			R("%rdx=%edx");
			fp << "	xchgq  %rdx, %rsi /* ARG1 = ARG2, ARG2 = ARG1 */\n";
			R("%r8=%ebp");
		} else if (1 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx:%edx
			 * ARG2: %rdx = %esi
			 * ARG3: %rcx = %edi
			 * ARG4: %r8  = %ebp */
			R("%rax=%ecx:%edx", clobber: "%r8");
			R("%rdx=%esi");
			R("%rsi=%rax");
			R("%rcx=%edi");
			R("%rdi=%ebx");
			R("%r8=%ebp");
		} else if (2 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx:%esi
			 * ARG3: %rcx = %edi
			 * ARG4: %r8  = %ebp */
			R("%rdx=%edx:%esi", clobber: "%rax");
			R("%rsi=%ecx");
			R("%rcx=%edi");
			R("%rdi=%ebx");
			R("%r8=%ebp");
		} else if (3 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi:%edi
			 * ARG4: %r8  = %ebp */
			R("%rax=%esi:%edi", clobber: "%r8");
			R("%rsi=%ecx");
			R("%rcx=%rax");
			R("%rdx=%edx");
			R("%rdi=%ebx");
			R("%r8=%ebp");
		} else if (4 in doubleWideArguments) {
			assert argumentCount == 5;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi
			 * ARG4: %r8  = %edi:%ebp */
			R("%r8=%edi:%ebp", clobber: "%rax");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
			R("%rdi=%ebx");
		} else {
			assert argumentCount == 6;
			/* ARG0: %rdi = %ebx
			 * ARG1: %rsi = %ecx
			 * ARG2: %rdx = %edx
			 * ARG3: %rcx = %esi
			 * ARG4: %r8  = %edi
			 * ARG5: %r9  = %ebp */
			R("%r8=%edi");
			R("%r9=%ebp");
			R("%rdx=%edx");
			R("%rsi=%esi");
			R("%rcx=%ecx");
			fp << "	xchgq  %rcx, %rsi /* ARG1 = ARG3, ARG3 = ARG1 */\n";
			R("%rdi=%ebx");
		}
		break;
#undef R
	default:
		assert 0, "registerCount = " + registerCount;
	}
}

function x86_64_printKernelSyscallWrapper_asm32_int80(fp: File, f: Function, sysno: int) {
	fp << ".section .text.x86.asm32_syscall_int80." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_int80_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_int80\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %rsp, 0\n";
	/* Preserve callee-clobber registers to prevent
	 * kernel  data  from leaking  into user-space. */
	fp << "	pushq_cfi_r %rcx\n";
	fp << "	pushq_cfi_r %rdx\n";
	fp << "	pushq_cfi_r %rsi\n";
	fp << "	pushq_cfi_r %rdi\n";
#if 0
	fp << "	pushq_cfi_r %r8\n";
	fp << "	pushq_cfi_r %r9\n";
	fp << "	pushq_cfi_r %r10\n";
	fp << "	pushq_cfi_r %r11\n";
#endif
	x86_64_printKernelSyscallWrapper_transformArguments(fp, f, sysenter: false);
	fp << "	EXTERN(sys32_" << f.name << ")\n";
	fp << "	call   sys32_" << f.name << "\n";
#if 0
	fp << "	popq_cfi_r %r11\n";
	fp << "	popq_cfi_r %r10\n";
	fp << "	popq_cfi_r %r9\n";
	fp << "	popq_cfi_r %r8\n";
#elif 0 /* I don't *think* this right here is necessary.
         * After all: 32-bit  user-space shouldn't  have
         * any way of accessing this from the get-go! */
	fp << "	xorq %r11, %r11\n";
	fp << "	xorq %r10, %r10\n";
	fp << "	xorq %r9, %r9\n";
	fp << "	xorq %r8, %r8\n";
#endif
	fp << "	popq_cfi_r %rdi\n";
	fp << "	popq_cfi_r %rsi\n";
	if (f.returnType.isReg64) {
		fp << "	popq_cfi %rcx /* %rdx */\n";
		fp << "	.cfi_restore %rdx\n";
		/* Split the 64-bit return value into %eax:%edx */
		fp << "	movq   %rax, %rdx\n";
		fp << "	shrq   $(32), %rdx\n";
	} else {
		fp << "	popq_cfi_r %rdx\n";
	}
	fp << "	popq_cfi_r %rcx\n";
	/* _Must_ use `intr_exit' here, so-as to ensure that %ecx is preserved! */
	fp << "	intr_exit\n";
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_int80_" << f.name << ")\n";
}

function x86_64_printKernelSyscallWrapper_asm32_sysenter(fp: File, f: Function, sysno: int) {
	if (f.getArgumentRegisterCount(32) <= 4) {
		fp << "DEFINE_INTERN_WEAK_ALIAS("
			"__x86_asm32_sysenter_" << f.name << ", "
			"__x86_asm32_int80_" << f.name << ")\n";
		return;
	}
	fp << ".section .text.x86.asm32_syscall_sysenter." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_sysenter_" << f.name << ")\n";
	fp << "	.cfi_startproc simple\n";
	fp << "	.cfi_personality 0, x86_syscall_personality_asm32_sysenter\n";
	fp << "	.cfi_lsda 0, " << sysno.hex() << "\n";
	fp << "	.cfi_iret_signal_frame\n";
	fp << "	.cfi_def_cfa %rsp, 0\n";
	/* Preserve callee-clobber registers to prevent
	 * kernel  data  from leaking  into user-space. */
	fp << "	pushq_cfi_r %rcx\n";
	fp << "	pushq_cfi_r %rdx\n";
	fp << "	pushq_cfi_r %rsi\n";
	fp << "	pushq_cfi_r %rdi\n";
	fp << "	pushq_cfi_r %r8\n";
	fp << "	pushq_cfi_r %r9\n";
	fp << "	pushq_cfi_r %r10\n";
	fp << "	pushq_cfi_r %r11\n";
	x86_64_printKernelSyscallWrapper_transformArguments(fp, f, sysenter: true);
	fp << "	EXTERN(sys32_" << f.name << ")\n";
	fp << "	call   sys32_" << f.name << "\n";
	fp << "	popq_cfi_r %r11\n";
	fp << "	popq_cfi_r %r10\n";
	fp << "	popq_cfi_r %r9\n";
	fp << "	popq_cfi_r %r8\n";
	fp << "	popq_cfi_r %rdi\n";
	fp << "	popq_cfi_r %rsi\n";
	if (f.returnType.isReg64) {
		fp << "	popq_cfi %rcx\n /* %rdx */";
		/* Split the 64-bit return value into %eax:%edx */
		fp << "	movq   %rax, %rdx\n";
		fp << "	shrq   $(32), %rdx\n";
	} else {
		fp << "	popq_cfi_r %rdx\n";
	}
	fp << "	popq_cfi_r %rcx\n";
	/* We can just use `sysret' as a drop-in replacement for `sysexit', since
	 * `sysret' doesn't clobber any  32-bit registers that `sysexit'  doesn't
	 * also clobber! */
	fp << "	X86_IRET_BUT_PREFER_SYSRET32\n";
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_sysenter_" << f.name << ")\n";
}

function x86_64_printKernelSyscallWrapper_asm32_sysrun32(fp: File, f: Function, sysno: int) {
	local argumentCount = #f.args;
	local registerCount = f.getArgumentRegisterCount(32);
	if (registerCount == 0) {
		fp << "/* DEFINE_INTERN_ALIAS(__x86_asm32_sysrun32_" << f.name << ", sys32_" << f.name << "); */\n";
		return;
	}
	local doubleWideArguments = Tuple(
		for (local i: [:argumentCount])
			if (f.args[i][0].isReg64)
				i);
	local registerSizeValues = Tuple(() -> {
		for (local i: [:argumentCount]) {
			if (i in doubleWideArguments) {
				yield 4;
				yield 4;
				continue;
			}
			local temp = getSizeofCType(f.args[i][0], "i386", 4);
			if (temp is none)
				temp = 4;
			if (temp !in [1, 2, 4])
				temp = 4;
			yield temp;
		}
	}());
	assert #registerSizeValues == registerCount;
	function loadArg32(argi, regi) {
		local sz = registerSizeValues[regi];
		fp << "	movz" << { 1: "b", 2: "w", 4: "l" }[sz] << "q ";
		fp << (regi*8) << "(%rdi), " << x86_64SysvABIRegisters[argi] << "\n";
	}
	function loadArg64(argi, regi_lo, regi_hi) {
		local destreg = x86_64SysvABIRegisters[argi];
		fp << "	movzlq " << (regi_hi*8) << "(%rdi), %rax\n";
		fp << "	movzlq " << (regi_lo*8) << "(%rdi), " << destreg << "\n";
		fp << "	shlq   $32, %rax\n";
		fp << "	orq    %rax, " << destreg << "\n";
	}
	fp << ".section .text.x86.asm32_syscall_sysrun32." << f.name << "\n";
	fp << "INTERN_WEAK_FUNCTION(__x86_asm32_sysrun32_" << f.name << ")\n";
	fp << "	.cfi_startproc\n";
	/* Load (and zero-extend) arguments */
	if (registerCount == argumentCount) {
		/* Simple case */
		local i = registerCount;
		while (i) {
			--i;
			loadArg32(i, i);
		}
	} else {
		/* Must handle all of the double-wide register cases. */
		assert doubleWideArguments;
		switch (registerCount) {
		case 2:
			assert argumentCount == 1;
			loadArg64(0, 0, 1);
			break;
		case 3:
			assert argumentCount == 2;
			if (0 in doubleWideArguments) {
				loadArg32(1, 2);
				loadArg64(0, 0, 1);
			} else {
				assert 1 in doubleWideArguments;
				loadArg64(1, 1, 2);
				loadArg32(0, 0);
			}
			break;
		case 4:
			if (argumentCount == 2) {
				loadArg64(1, 2, 3);
				loadArg64(0, 0, 1);
			} else if (0 in doubleWideArguments) {
				assert argumentCount == 3;
				loadArg32(2, 3);
				loadArg32(1, 2);
				loadArg64(0, 0, 1);
			} else if (1 in doubleWideArguments) {
				loadArg32(2, 3);
				loadArg64(1, 1, 2);
				loadArg32(0, 0);
			} else {
				assert 2 in doubleWideArguments;
				loadArg64(2, 2, 3);
				loadArg32(1, 1);
				loadArg32(0, 0);
			}
			break;
		case 5:
			if (0 in doubleWideArguments && 1 in doubleWideArguments) {
				assert argumentCount == 3;
				loadArg32(2, 4);
				loadArg64(1, 2, 3);
				loadArg64(0, 0, 1);
			} else if (0 in doubleWideArguments && 2 in doubleWideArguments) {
				assert argumentCount == 3;
				loadArg64(2, 3, 4);
				loadArg32(1, 2);
				loadArg64(0, 0, 1);
			} else if (0 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg32(3, 4);
				loadArg32(2, 3);
				loadArg32(1, 2);
				loadArg64(0, 0, 1);
			} else if (1 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg32(3, 4);
				loadArg32(2, 3);
				loadArg64(1, 1, 2);
				loadArg32(0, 0);
			} else if (2 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg32(3, 4);
				loadArg64(2, 2, 3);
				loadArg32(1, 1);
				loadArg32(0, 0);
			} else {
				assert 3 in doubleWideArguments;
				assert argumentCount == 4;
				loadArg64(3, 3, 4);
				loadArg32(2, 2);
				loadArg32(1, 1);
				loadArg32(0, 0);
			}
			break;
		case 6:
			if (0 in doubleWideArguments && 1 in doubleWideArguments && 2 in doubleWideArguments) {
				assert argumentCount == 3;
				loadArg64(2, 4, 5);
				loadArg64(1, 2, 3);
				loadArg64(0, 0, 1);
			} else if (0 in doubleWideArguments && 1 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg32(3, 5);
				loadArg32(2, 4);
				loadArg64(1, 2, 3);
				loadArg64(0, 0, 1);
			} else if (0 in doubleWideArguments && 2 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg32(3, 5);
				loadArg64(2, 3, 4);
				loadArg32(1, 2);
				loadArg64(0, 0, 1);
			} else if (0 in doubleWideArguments && 3 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg64(3, 4, 5);
				loadArg32(2, 3);
				loadArg32(1, 2);
				loadArg64(0, 0, 1);
			} else if (1 in doubleWideArguments && 2 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg32(3, 5);
				loadArg64(2, 3, 4);
				loadArg64(1, 1, 2);
				loadArg32(0, 0);
			} else if (1 in doubleWideArguments && 3 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg64(3, 4, 5);
				loadArg32(2, 3);
				loadArg64(1, 1, 2);
				loadArg32(0, 0);
			} else if (2 in doubleWideArguments && 3 in doubleWideArguments) {
				assert argumentCount == 4;
				loadArg64(3, 4, 5);
				loadArg64(2, 2, 3);
				loadArg32(1, 1);
				loadArg32(0, 0);
			} else if (0 in doubleWideArguments) {
				assert argumentCount == 5;
				loadArg32(4, 5);
				loadArg32(3, 4);
				loadArg32(2, 3);
				loadArg32(1, 2);
				loadArg64(0, 0, 1);
			} else if (1 in doubleWideArguments) {
				assert argumentCount == 5;
				loadArg32(4, 5);
				loadArg32(3, 4);
				loadArg32(2, 3);
				loadArg64(1, 1, 2);
				loadArg32(0, 0);
			} else if (2 in doubleWideArguments) {
				assert argumentCount == 5;
				loadArg32(4, 5);
				loadArg32(3, 4);
				loadArg64(2, 2, 3);
				loadArg32(1, 1);
				loadArg32(0, 0);
			} else if (3 in doubleWideArguments) {
				assert argumentCount == 5;
				loadArg32(4, 5);
				loadArg64(3, 3, 4);
				loadArg32(2, 2);
				loadArg32(1, 1);
				loadArg32(0, 0);
			} else {
				assert 4 in doubleWideArguments;
				assert argumentCount == 5;
				loadArg64(4, 4, 5);
				loadArg32(3, 3);
				loadArg32(2, 2);
				loadArg32(1, 1);
				loadArg32(0, 0);
			}
			break;
		}
	}
	fp << "	EXTERN(sys32_" << f.name << ")\n";
	fp << "	jmp    sys32_" << f.name << "\n";
	fp << "	.cfi_endproc\n";
	fp << "END(__x86_asm32_sysrun32_" << f.name << ")\n";
}

@@Listing  of  supported  system call  architectures,  as well
@@as arch-specific configuration options, and code generators.
global ARCH: {string: SyscallArch} = {

	"i386" : SyscallArch(
		platformName: "i386-kos",
		platformArch: "i386",
		platformSuffix: "32",
		platformGpRegisterSizeInBits: 32,
		platformPointerSizeInBytes: 4,
		platformSyscallRegisterCount: 6,
		platformEndian: "le",
		platformSyscallTableCount: 2,
		platformMaxPossibleSysno: 0xffffffff,
		platformLibcSyscallPrefix: i386_printLibcSyscallWrapperPrefix,
		platformLibcSyscallSuffix: i386_printLibcSyscallWrapperSuffix,
		platformLibcSyscallWrapper: i386_printLibcSyscallWrapper,
		platformKernelSyscallWrappersCommon: i386_printKernelSyscallWrapperCommon,
		platformKernelSyscallWrappers: {
			(i386_printKernelSyscallWrapper_int80, "i386"),
			(i386_printKernelSyscallWrapper_sysenter, "i386"),
		},
	),

	"x86_64" : SyscallArch(
		platformName: "i386-kos",
		platformArch: "i386",
		platformSuffix: "64",
		platformSyscallCompatArch: {
			/* Define  a header containing  a listing of all  64-bit system calls that
			 * should also be implemented as aliases for specific 32-bit system calls.
			 * e.g.: The declaration `DEFINE_SYSCALL0(uid_t, getuid) { ... }' should is
			 *       expanded at compile-time to also contain the following on  x86_64:
			 *       >> DEFINE_PUBLIC_ALIAS(sys32_setuid32, sys_setuid);
			 *       >> DEFINE_PUBLIC_ALIAS(sys32_setuid, sys_setuid);
			 * As such, `syscall3264-compat.h' contains the following definition:
			 * >> #define __NR3264COMPAT_setuid   2(setuid32,setuid)
			 * Or in more general terms (with 2 being the number of aliases):
			 * >> #define __NR3264COMPAT_<sys_mysyscall>   2(<sys32_firstalias>,<sys32_secondalias>)
			 * NOTE: In the case  of functions  such as  `sys32_setuid` (which  take a  16-bit
			 *       argument), the underlying system call wrapper will (usually) have already
			 *       truncated the argument (s.a. `__x86_asm32_int80_setuid', which contains a
			 *       line `movzwq %bx, %rdi`).
			 */
			("include/i386-kos/asm/syscall3264-compat.h", "__NR3264COMPAT_", "i386"),
		},
		platformSyscallCompatTypes: {
			("include/i386-kos/asm/syscall3264-types.h", "i386"),
		},
		platformSyscallCompatRequest: "i386",
		platformGpRegisterSizeInBits: 64,
		platformPointerSizeInBytes: 8,
		platformSyscallRegisterCount: 6,
		platformEndian: "le",
		platformSyscallTableCount: 2,
		platformMaxPossibleSysno: 0xffffffffffffffff,
		platformLibcSyscallPrefix: x86_64_printLibcSyscallWrapperPrefix,
		platformLibcSyscallSuffix: x86_64_printLibcSyscallWrapperSuffix,
		platformLibcSyscallWrapper: x86_64_printLibcSyscallWrapper,
		platformKernelSyscallWrappersCommon: x86_64_printKernelSyscallWrapperCommon,
		platformKernelSyscallWrappers: {
			(x86_64_printKernelSyscallWrapper_asm64_syscall, "x86_64"),
			(x86_64_printKernelSyscallWrapper_asm32_int80, "i386"),
			(x86_64_printKernelSyscallWrapper_asm32_sysenter, "i386"),
			/* sysrun forwarding wrappers (given a `u64 *%rdi' (argument vector of up
			 * to 6 arguments), call forward to the underlying `sys32_*' system call) */
			(x86_64_printKernelSyscallWrapper_asm32_sysrun32, "i386"),
		},
	),

//	"arm" : SyscallArch(
//		platformName: "arm-kos",
//		platformArch: "arm",
//		platformGpRegisterSizeInBits: 32,
//		platformPointerSizeInBytes: 4,
//		platformSyscallRegisterCount: 6,
//		platformEndian: "le",
//		platformSyscallTableCount: 2,
//		platformMaxPossibleSysno: 0xffffffff,
//		platformLibcSyscallPrefix: arm_printLibcSyscallWrapperCommon,
//		platformLibcSyscallWrapper: arm_printLibcSyscallWrapper,
//		platformKernelSyscallWrappersCommon: arm_printKernelSyscallWrapperCommon,
//		platformKernelSyscallWrappers: {
//			"__arm_syscall_" : ("INTERN", "arm", arm_printKernelSyscallWrapper),
//		},
//	),
};
