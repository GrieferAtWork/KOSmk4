/* Copyright (c) 2019-2022 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2022 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

#include "../../../include/libunwind/cfi.h" /* For opcode constants */

/* ============= CFI assembly compiler =============
 *
 * CFI is a an instrumentation system for the purpose of specifying how
 * the kernel or userspace (libunwind) should unwind function calls for
 * the purpose of exception unwinding (<kos/except.h>: THROW()) or  for
 * the purpose of generating tracebacks (<execinfo.h>: backtrace(3)).
 *
 * For this purpose,  alongside some generic  register restore  location
 * descriptors, CFI also includes a turing-complete bytecode interpreter
 * that can be  used to calculate  arbitrarily complex register  restore
 * values.
 *
 * While the bytecode read by such an interpreter (/kos/src/libunwind/cfi.c)
 * is standardized, there doesn't exist  a portable representation to  which
 * this bytecode could be disassembled or assembled from.
 *
 * This deemon module includes an assembler which can be used to generate
 * register  unwind instrumentation from  human-readable input, making it
 * much easier to write CFI expressions.
 *
 * Syntax:
 *   - '#' Marks the rest of the line as a comment
 *   - ';' and '\n' act as a separators between instructions
 *   - Empty instructions are ignored
 *   - Mnemonics are separated from operands by whitespace
 *   - Operands are separated from each other by ','
 *   - GAS-style forward/backward labels are recognized (1: 1b, 1f)
 *   - Labels are declared as mnemonics followed by ':' (e.g. 'foo:')
 *
 * Integer operands:
 *   - '$1234':      Integer constant
 *   - '$CONSTANT':  Named constant (appears as #define in arch-specific headers)
 *   - '\variable':  Assembler  macro  variable  (the  compiler  automatically
 *                   generates optimized code for every supported value range)
 *   All of these can be combined within  the same operand by having them  be
 *   combined  with '+' or '-'. Each such set of operand parts may contain at
 *   most 1 \variable element, which must not appear after a '-', though  any
 *   number of $1234 or $CONSTANT addends are allowed. Additionally, $1234 or
 *   $CONSTANT addends may also be prefixed by '~' which will result in the
 *   bit-wise inverse to be used instead.  (Very useful when wishing to  mask
 *   specific bits, e.g.: 'and ~$EFLAGS_DF' to clear the DF flag on x86)
 *
 * Special operands:
 *   - '<symbol>':   Symbol operands are just the raw symbol name
 *   - '%<regname>': Register-value operand
 *   - '&<regname>': Register-address operands
 *   - '@<value>':   Raw carry-though
 *
 * Recognized instructions:
 *
 * ```
 *     push   top           alias for `dup'
 *     push   $<value>      DW_OP_lit*,
 *                          DW_OP_const1s, DW_OP_const1u,
 *                          DW_OP_const2s, DW_OP_const2u,
 *                          DW_OP_const4s, DW_OP_const4u,
 *                          DW_OP_const8s, DW_OP_const8u,
 *                          DW_OP_consts, DW_OP_constu
 *     push   @foo          DW_OP_const1u foo
 *     push   &reg          DW_OP_reg*, DW_OP_regx
 *     push   %reg          DW_OP_breg*+0, DW_OP_bregx+0
 *     push   %reg+X        DW_OP_breg*+X, DW_OP_bregx+X
 *
 *     push[8|16|32|64] ... Like  `push', but don't exceed given address width
 *                          without explicit width suffix, use `arch.addrsize'
 *
 *     addr   $<value>      DW_OP_addr, <value>
 *
 *     const1u $<value>     DW_OP_const1u, $<value>
 *     const1u @foo         DW_OP_const1u, foo
 *     const1s $<value>     DW_OP_const1s, $<value>
 *     const1s @foo         DW_OP_const1s, foo
 *     const2u $<value>     DW_OP_const2u, $<value>
 *     const2s $<value>     DW_OP_const2s, $<value>
 *     const4u $<value>     DW_OP_const4u, $<value>
 *     const4s $<value>     DW_OP_const4s, $<value>
 *     const8u $<value>     DW_OP_const8u, $<value>
 *     const8s $<value>     DW_OP_const8s, $<value>
 *     constu $<value>      DW_OP_constu, $<value>
 *     consts $<value>      DW_OP_consts, $<value>
 *
 *     and                  DW_OP_and
 *     div                  DW_OP_div
 *     minus                DW_OP_minus
 *     mod                  DW_OP_mod
 *     mul                  DW_OP_mul
 *     or                   DW_OP_or
 *     shl                  DW_OP_shl
 *     shr                  DW_OP_shr
 *     shra                 DW_OP_shra
 *     xor                  DW_OP_xor
 *     eq                   DW_OP_eq
 *     ge                   DW_OP_ge
 *     gt                   DW_OP_gt
 *     le                   DW_OP_le
 *     lt                   DW_OP_lt
 *     ne                   DW_OP_ne
 *
 *     and    <value>       alias for 'push <value>; and;'
 *     div    <value>       alias for 'push <value>; div;'
 *     minus  <value>       alias for 'push <value>; minus;'
 *     mod    <value>       alias for 'push <value>; mod;'
 *     mul    <value>       alias for 'push <value>; mul;'
 *     or     <value>       alias for 'push <value>; or;'
 *     shl    <value>       alias for 'push <value>; shl;'
 *     shr    <value>       alias for 'push <value>; shr;'
 *     shra   <value>       alias for 'push <value>; shra;'
 *     xor    <value>       alias for 'push <value>; xor;'
 *     eq     <value>       alias for 'push <value>; eq;'
 *     ge     <value>       alias for 'push <value>; ge;'
 *     gt     <value>       alias for 'push <value>; gt;'
 *     le     <value>       alias for 'push <value>; le;'
 *     lt     <value>       alias for 'push <value>; lt;'
 *     ne     <value>       alias for 'push <value>; ne;'
 *     *[8|16|32|64] ...    Use the given max address width in the emulated 'push'
 *
 *     plus                 DW_OP_plus
 *     plus   <value>       DW_OP_plus_uconst  (or 'push <value>; plus;')
 *     plus[8|16|32|64] ... Use the given max address width in the emulated 'push'
 *
 *     deref                DW_OP_deref
 *     derefb               DW_OP_deref_size, 1
 *     derefw               DW_OP_deref_size, 2
 *     derefl               DW_OP_deref_size, 4
 *     derefq               DW_OP_deref_size, 8
 *     deref_size $<n>      DW_OP_deref_size, <n>
 *
 *     xderef               DW_OP_xderef
 *     xderefb              DW_OP_xderef_size, 1
 *     xderefw              DW_OP_xderef_size, 2
 *     xderefl              DW_OP_xderef_size, 4
 *     xderefq              DW_OP_xderef_size, 8
 *     xderef_size $<n>     DW_OP_xderef_size, <n>
 *
 *     pick   $<n>          DW_OP_pick, <n>
 *
 *     bra    <symbol>      DW_OP_bra, <symbol>
 *     skip   <symbol>      DW_OP_skip, <symbol>
 *
 *     reg    &reg          DW_OP_reg*, DW_OP_regx
 *     reg    $<regno>      DW_OP_reg*, DW_OP_regx
 *
 *     fbreg  @<offset>     DW_OP_fbreg, <offset>
 *     fbreg  $<offset>     DW_OP_fbreg, <offset>
 *
 *     breg   %reg, $<offset>     DW_OP_breg*, DW_OP_bregx
 *     breg   $<regno>, $<offset> DW_OP_breg*, DW_OP_bregx
 *
 *     piece  $<nbytes>     DW_OP_piece, <nbytes>
 *     bit_piece $<nbits>   DW_OP_bit_piece, <nbits>
 *
 *     dup                  DW_OP_dup
 *     drop                 DW_OP_drop
 *     over                 DW_OP_over
 *     swap                 DW_OP_swap
 *     rot                  DW_OP_rot
 *     abs                  DW_OP_abs
 *     neg                  DW_OP_neg
 *     not                  DW_OP_not
 *     nop                  DW_OP_nop
 *     push_object_address  DW_OP_push_object_address
 *     form_tls_address     DW_OP_form_tls_address
 *     call_frame_cfa       DW_OP_call_frame_cfa
 *     stack_value          DW_OP_stack_value
 *     GNU_push_tls_address DW_OP_GNU_push_tls_address    # WARNING: Doesn't actually "push" anything; same as 'form_tls_address'
 *     GNU_uninit           DW_OP_GNU_uninit
 *
 *     implicit_value "ABCD"   DW_OP_implicit_value, 4, 'A', 'B', 'C', 'D'
 * ```
 *
 *
 *
 * Advanced instructions:
 *
 * ```
 *     ret                  Convenience instruction to perform a jump to the very end
 *
 *     .cfi_escape "foo"    Raw output bytes: 'f', 'o', 'o'
 *     .cfi_escape $<x>     Raw output byte: <x>
 *     .cfi_escape $<x>, $<y>, $<z>  Raw output bytes: <x>, <y>, <z>
 *
 *     ifnotimpl "IMPL", <symbol>  Alias for: >>     skip 1f
 *                                            >> .cfi_escape "IMPL"
 *                                            >> 1:  skip <symbol>
 *                          When "IMPL" is "KOS", the kos-specific implementation will
 *                          not jump to <symbol>, but  will instead execute immediately
 *                          after this instruction. Use this to encode program code
 *                          only understood on KOS (but not by GDB)
 * ```
 *
 *
 *
 * Aliases:
 *
 * ```
 *     add    [...]         Alias for `plus'
 *     sub    [...]         Alias for `minus'
 *     pop                  Alias for `drop'
 *     push_tls_address     Alias for `GNU_push_tls_address'
 *     uninit               Alias for `GNU_uninit'
 *     jf     pop, <symbol> Alias for `not; bra <symbol>;'
 *     jf     top, <symbol> Alias for `dup; not; bra <symbol>;'
 *     jt     pop, <symbol> Alias for `bra <symbol>;'
 *     jt     top, <symbol> Alias for `dup; bra <symbol>;'
 *     jz     ...           Alias for `jf ...'
 *     jnz    ...           Alias for `jt ...'
 *     jmp    <symbol>      Alias for `skip <symbol>;'
 *     regx   ...           Alias for `reg ...'
 *     bregx  ...           Alias for `breg ...'
 * ```
 *
 */

import * from deemon;
import * from errors;
import enumerateIntegerMacrosFromFile from ..strendN;
import fs;

class Architecture {
	this = default;

	@@Architecture name
	public member name: string;

	@@Mapping of name->id for CFI registers
	public member registers: {string: int};

	@@Files to scan for system macro definitions
	public member sysmacroFiles: {string...};

	@@Address size (for DW_OP_addr)
	public member addrsize: int;

	@@True if this is a big endian architecture
	public member bigEndian: bool = false;

	@@Set of pre-defined arch macros
	public member archMacros: {string: int} = none;

	@@True if 64-bit offsets should be supported
	public property support64: bool = {
		get(): bool {
			return addrsize >= 8;
		}
	}

	public property byteorder: string = {
		get(): string {
			return bigEndian ? "big" : "little";
		}
	}

	private member _sysmacroValueCache: {string: int} = Dict();
	private member _sysmacroLoadedFiles: {string...} = HashSet();
	private function _loadSysmacroFile(filename: string) {
		for (local name, value: enumerateIntegerMacrosFromFile(filename))
			this._sysmacroValueCache.setdefault(name, value);
	}

	@@Return the name of the given register id, or re-return @id
	function getRegisterByID(id: int): string | int {
		for (local name, regno: this.registers) {
			if (regno == id)
				return name;
		}
		return id;
	}

	@@Return the value of a system macro, given its @name (or @none if unknown)
	function getSysMacro(name: string): int | none {
		local r = _sysmacroValueCache.get(name);
		if (r !is none)
			return r;
		for (local file: this.sysmacroFiles) {
			if (file in _sysmacroLoadedFiles)
				continue;
			this._loadSysmacroFile(fs.expand(fs.joinpath(
				fs.headof(__FILE__), "../../../../" + file), "pac"));
			_sysmacroLoadedFiles.insert(file);
			r = _sysmacroValueCache.get(name);
			if (r !is none)
				return r;
		}
		r = archMacros.get(name);
		if (r !is none)
			return r;
		if (name in { "P", "SIZEOF_POINTER", "__SIZEOF_POINTER__" })
			return addrsize;
		return none;
	}
}


class Symbol {
	this = default;
	@@Symbol name
	public member name: string;
	@@Symbol address
	public member addr: int;
}

class Instruction {
	this = default;
	public member mnemonic: string;
	@@Instruction operands. Each of these is one of:
	@@  - Symbol        (Reference to another code location)
	@@  - int           (Integer constant)
	@@  - (string, int) (Argument with addend: \foo+42)
	@@  - string        (something else: \foo argument, @blablabla, %foo register, etc...)
	public member operands: {Symbol | int | (string, int) | string...};
}


global final PAREN_MATCH: {string: string} = { "(" : ")", "[" : "]", "{" : "}" };

function removeSurroundingParenthesis(s: string): string {
	while (s && s.first == "(" && s.last == PAREN_MATCH[s.first] &&
	       s.findmatch(s.first, s.last, 1) == #s - 1)
		s = s[1:-1].strip();
	return s;
}

function parseInstructions(arch: Architecture, text: string, optPrefix: string = "DW_OP_"): {Symbol | Instruction...} {
	text = text.unifylines().replace("\\\n", "");
	local i = 0, len = #text;
	local uniqueSymbolId = 0;
	local namedSymbols: {string: Symbol} = Dict();
	local forwardSymbols: {string: Symbol} = Dict();
	local backwardSymbols: {string: Symbol} = Dict();
	local returnSymbol: Symbol | none = none;
	function parseOperand(content: string): Object {
		if (content.startswith("@"))
			return content;
		content = removeSurroundingParenthesis(content);
		if ((content.endswith("f") || content.endswith("b")) &&
		    (content.isnumeric(0, #content - 1))) {
			local id = content[:-1];
			local sym;
			if (content.endswith("f")) {
				sym = forwardSymbols.get(id);
				if (sym is none) {
					sym = Symbol(name: id);
					forwardSymbols[id] = sym;
				}
			} else {
				sym = backwardSymbols[id];
			}
			return sym;
		}
		local addend = none;
		local base = none;
		local i = 0, len = #content;
		local partStart = 0;
		for (;;) {
			local ch;
			if (i >= len) {
flush_part:
				local isNegative = false;
				local isInverse = false;
				local partEnd = i;
again_skip_leading_space:
				while (partStart < partEnd && content.isspace(partStart))
					++partStart;
				if (partStart < partEnd) {
					local ch = content[partStart];
					if (ch == "-") {
						isNegative = !isNegative;
						++partStart;
						goto again_skip_leading_space;
					}
					if (ch == "~") {
						isInverse = !isInverse;
						++partStart;
						goto again_skip_leading_space;
					}
				}
				while (partEnd > partStart && content.isspace(partEnd - 1))
					--partEnd;
				local part = content[partStart:partEnd];
				if (part.startswith("\\")) {
					if (base !is none)
						throw Error("Multiple bases in " + repr content);
					if (isNegative || isInverse)
						throw Error("Negative or inverse base in " + repr content);
					base = part[1:];
				} else if (part.startswith("$")) {
					local val = part[1:];
					local val = try int(val) catch (...) arch.getSysMacro(val);
					if (val is none)
						throw Error("Unknown system macro " + repr part[1:]);
					if (addend is none)
						addend = 0;
					if (isNegative)
						val = -val;
					if (isInverse)
						val = ~val;
					addend += val;
				} else {
					return content;
				}
				if (i >= len)
					break;
				if (content[i] == "+")
					++i;
				partStart = i;
				if (content[i] != "+")
					++i;
				continue;
			}
			local ch = content[i];
			if (ch in "+-")
				goto flush_part;
			if (ch in "([{") {
				i = content.indexmatch(ch, PAREN_MATCH[ch], i + 1) + 1;
				continue;
			}
			++i;
		}
		if (base !is none || addend !is none) {
			if (base is none)
				return addend;
			if (addend is none)
				addend = 0;
			return (base, addend);
		}
		return content;
	}
	while (i < len) {
		if (text.isspace(i)) {
			++i;
			continue;
		}
		local ch = text[i];
		if (ch == "#") {
			i = text.find("\n", i);
			if (i < 0)
				break;
			++i;
			continue;
		}
		local instrEnd = text.find("\n", i);
		if (instrEnd < 0)
			instrEnd = len;
		local temp = text.find("#", i, instrEnd);
		if (temp >= 0)
			instrEnd = temp;
		local temp = text.find(";", i, instrEnd);
		if (temp >= 0)
			instrEnd = temp;
		while (instrEnd > i && text.isspace(instrEnd - 1))
			--instrEnd;
		if (instrEnd <= i) { /* Should never be `<' */
			++i;
			continue;
		}
		local instrStart = i;
		++i;
		while (i < instrEnd && !text.isspace(i) && text[i] !in ":=")
			++i;
		local mnemonic = text[instrStart:i];
		while (i < instrEnd && text.isspace(i))
			++i;
		if (i < instrEnd && text[i] == ":") {
			/* Label definition */
			local symbol: Symbol;
			if (mnemonic.isnumeric()) {
				symbol = forwardSymbols.get(mnemonic);
				if (symbol !is none) {
					del forwardSymbols[mnemonic];
				} else {
					symbol = Symbol(name: mnemonic);
				}
				backwardSymbols[mnemonic] = symbol;
			} else if (mnemonic.issymbol()) {
				symbol = namedSymbols.get(mnemonic);
				if (symbol is none) {
					symbol = Symbol(name: mnemonic);
					namedSymbols[mnemonic] = symbol;
				}
			} else {
				throw Error("Invalid symbol name:" + repr mnemonic);
			}
			yield symbol;
			++i;
			continue;
		}
		if (mnemonic.startswith(optPrefix))
			mnemonic = mnemonic[#optPrefix:];
		local instr = Instruction(mnemonic: mnemonic, operands: []);
		local flushStart = i;
		while (i < instrEnd) {
			local ch = text[i];
			if (ch in "([{") {
				i = text.findmatch(ch, PAREN_MATCH[ch], i + 1, instrEnd);
				if (i < 0)
					throw Error(f"Unmatched {repr ch} in {repr text[instrStart:instrEnd]}");
				++i;
				continue;
			}
			if (ch == ",") {
				while (flushStart < i && text.isspace(flushStart))
					++flushStart;
				local opEnd = i;
				while (opEnd > flushStart && text.isspace(opEnd - 1))
					--opEnd;
				instr.operands.append(parseOperand(text[flushStart:opEnd]));
				flushStart = i + 1;
				++i;
				continue;
			}
			++i;
		}
		while (flushStart < instrEnd && text.isspace(flushStart))
			++flushStart;
		if (instr.operands || flushStart < instrEnd)
			instr.operands.append(parseOperand(text[flushStart:instrEnd]));
		if (instr.mnemonic == "ret" && !instr.operands && optPrefix == "DW_OP_") {
			/* There is no `ret' instruction, but we can emulate it
			 * by perform a jump to the end of generated  bytecode. */
			if (returnSymbol is none)
				returnSymbol = Symbol(name: "<return>");
			instr.mnemonic = "skip";
			instr.operands = { returnSymbol };
		}
		yield instr;
		i = instrEnd + 1;
	}
	if (returnSymbol !is none)
		yield returnSymbol;
}


/* Relocation IDs */
#define R_CFI_REL16_A 0
#define R_CFI_REL16_B 1

class Relocation {
	this = default;
	@@One of `R_CFI_*'
	public member kind: int;
	public member symbol: Symbol;
	public member addr: int;

	public function resolve(): int {
		local symaddr = symbol.addr;
		switch (kind) {
		case R_CFI_REL16_A:
			return (symaddr - (this.addr + 2)) & 0xff;
		case R_CFI_REL16_B:
			return ((symaddr - (this.addr + 1)) >> 8) & 0xff;
		}
	}
}

@@Error class for when code generation constraints are impossible
class ImpossibleConstraints {
	public member varName: string; /* Variable with impossible constraints */
	this(arg) {
		varName = arg is Sequence ? arg.first : none;
	}
}

@@Error class to indicate that operands are invalid for a given instruction
class InvalidOperands {}

@@Instructions  that  may be  written as  `<instr> <operand>;`,
@@which is compiled as an alias for `push <operand>;  <instr>;`
@@Note that `plus` (aka. `add`) isn't in this list because that
@@instruction  has special handling due to `DW_OP_plus_uconst`!
global final BINARY_AS_PUSH_INSTR_OPCODES: {int...} = {
	DW_OP_and, DW_OP_div, DW_OP_minus, DW_OP_mod, DW_OP_mul,
	DW_OP_or, DW_OP_shl, DW_OP_shr, DW_OP_shra, DW_OP_xor,
	DW_OP_eq, DW_OP_ge, DW_OP_gt, DW_OP_le, DW_OP_lt, DW_OP_ne
};

@@Instructions with variants that don't take any arguments
global final NOARG_INSTRUCTIONS: {string: int} = {
	"deref"                : DW_OP_deref,
	"dup"                  : DW_OP_dup,
	"drop"                 : DW_OP_drop,
	"pop"                  : DW_OP_drop, /* ALIAS! */
	"over"                 : DW_OP_over,
	"swap"                 : DW_OP_swap,
	"rot"                  : DW_OP_rot,
	"xderef"               : DW_OP_xderef,
	"abs"                  : DW_OP_abs,
	"and"                  : DW_OP_and,
	"div"                  : DW_OP_div,
	"minus"                : DW_OP_minus,
	"sub"                  : DW_OP_minus, /* ALIAS! */
	"mod"                  : DW_OP_mod,
	"mul"                  : DW_OP_mul,
	"neg"                  : DW_OP_neg,
	"not"                  : DW_OP_not,
	"or"                   : DW_OP_or,
	"plus"                 : DW_OP_plus,
	"shl"                  : DW_OP_shl,
	"shr"                  : DW_OP_shr,
	"shra"                 : DW_OP_shra,
	"xor"                  : DW_OP_xor,
	"eq"                   : DW_OP_eq,
	"ge"                   : DW_OP_ge,
	"gt"                   : DW_OP_gt,
	"le"                   : DW_OP_le,
	"lt"                   : DW_OP_lt,
	"ne"                   : DW_OP_ne,
	"nop"                  : DW_OP_nop,
	"push_object_address"  : DW_OP_push_object_address,
	"form_tls_address"     : DW_OP_form_tls_address,
	"call_frame_cfa"       : DW_OP_call_frame_cfa,
	"stack_value"          : DW_OP_stack_value,
	"GNU_push_tls_address" : DW_OP_GNU_push_tls_address,
	"push_tls_address"     : DW_OP_GNU_push_tls_address,
	"GNU_uninit"           : DW_OP_GNU_uninit,
	"uninit"               : DW_OP_GNU_uninit,
};

#define ULEB128_3BYTE_MAX  2097151  /* Max value encodable as a 3-byte ULEB128 */
#define SLEB128_3BYTE_MIN  -1048576 /* Min value encodable as a 3-byte SLEB128 */

@@Generate bytes to encode @value as a ULEB128
function encodeULeb128(value: int): {int...} {
	for (;;) {
		if (value <= 0x7f) {
			yield value;
			break;
		}
		yield 0x80 | (value & 0x7f);
		value = value >> 7;
	}
}

@@Generate bytes to encode @value as a SLEB128
function encodeSLeb128(value: int): {int...} {
	for (;;) {
		local byte = value & 0x7f;
		if (value >= 0) {
			value = value / 128;
		} else {
			value = ~(~value / 128);
		}
		if ((value == 0 && (byte & 0x40) == 0) ||
		    (value == -1 && (byte & 0x40) != 0)) {
			yield byte;
			break;
		}
		yield 0x80 | byte;
	}
}


class Assembler {
	@@Guaranties on value ranges never used by variables.
	@@Variables not  in  this  list may  take  any  value
	public member inLimits: {string: (int, int)};

	@@Min/Max allowed values for variables in generated code
	public member outLimits: {string: (int, int)};

	@@Symbols
	public member symbols: {string: Symbol} = Dict();

	@@Instructions
	public member instructions: {Symbol | Instruction...};

	@@Should the stack-top value be dereferenced in the end
	public member isDerefAfter: bool;

	@@The used architecture
	public member arch: Architecture;

	public member asmArgPrefix: string = "__ASM_ARG(";
	public member asmArgSuffix: string = ")";

	this(arch: string | Architecture, code: string) {
		this.arch = arch is Architecture ? arch
			: import(".arch." + arch).ARCH;
		this.instructions = List(parseInstructions(this.arch, code));

		this.isDerefAfter = false;
		/* If the last stream element is an instruction (iow:  there
		 * is no trailing label definition), and that instruction is
		 * the deref instruction, then compile w/ isDerefAfter=true */
		if (this.instructions) {
			local lastInstr = this.instructions.last;
			if (lastInstr is Instruction && !lastInstr.operands &&
			    lastInstr.mnemonic == "deref") {
				this.instructions.popback();
				isDerefAfter = true;
			}
		}

		/* Load named symbols */
		for (local part: this.instructions) {
			if (part is Symbol && !part.name.isnumeric())
				this.symbols[part.name] = part;
		}

		/* Resolve named symbol operands */
		for (local part: this.instructions) {
			if (part is Instruction) {
				for (local i: [:#part.operands]) {
					local op = part.operands[i];
					if (op is string) {
						local sym = this.symbols.get(op);
						if (sym !is none)
							part.operands[i] = sym;
					}
				}
			}
		}
	}

	@@Use this function to select how to encode variables
	@@>> if (testVariableMaxval("foo", 0, 42)) {
	@@>>     // Code that only works while "foo >= 0 && foo <= 42"
	@@>> } else if (testVariableMaxval("foo", 0, 127)) {
	@@>>     // Code that only works while "foo >= 0 && foo <= 127"
	@@>> } else {
	@@>>     throw ImpossibleConstraints(arg);
	@@>> }
	function testVariableMaxval(name: string, minval: int, maxval: int): bool {
		local neverMin, neverMax = inLimits.get(name, (0, -1))...;
		if (minval >= neverMin && maxval <= neverMax)
			return false; /* These values never appear */
		/* Update the max supported value in outLimits */
		local activeMinVal, activeMaxVal = outLimits.get(name)...;
		if (activeMinVal is none || activeMinVal < minval)
			activeMinVal = minval;
		if (activeMaxVal is none || activeMaxVal > maxval)
			activeMaxVal = maxval;
		if (activeMinVal >= neverMin && activeMaxVal <= neverMax)
			return false;
		outLimits[name] = (activeMinVal, activeMaxVal);
		return true;
	}

	function testEncodeMinMax(arg: {int | (string, int)...}, min: int, max: int): bool {
		if (arg is int)
			return arg >= min && arg <= max;
		if (arg !is Sequence)
			return false;
		local base, addend = arg...;
		return testVariableMaxval(base, min - addend, max - addend);
	}

	function testEncodeS1(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, -128, 127);
	function testEncodeS2(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, -32768, 32767);
	function testEncodeS4(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, -2147483648, 2147483647);
	function testEncodeS8(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, -9223372036854775808, 9223372036854775807);
	function testEncodeU5bit(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, 0, 0x1f);
	function testEncodeU6bit(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, 0, 0x3f);
	function testEncodeU7bit(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, 0, 0x7f);
	function testEncodeU1(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, 0, 0xff);
	function testEncodeU2(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, 0, 0xffff);
	function testEncodeU4(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, 0, 0xffffffff);
	function testEncodeU8(arg: {int | (string, int)...}): bool -> testEncodeMinMax(arg, 0, 0xffffffffffffffff);

	function encodeU5Bit(arg: int | (string, int), base: int): int | string {
		if (arg is int)
			return base + arg;
		local totalAddend = base + arg.last;
		if (totalAddend == 0)
			return f"{asmArgPrefix}\\{arg.first}{asmArgSuffix}";
		return f"{asmArgPrefix}\\{arg.first}{asmArgSuffix}+{totalAddend}";
	}
	function encodeX1(arg: int | (string, int), signed: bool): int | string {
		if (arg is int)
			return arg.tobytes(1, byteorder: arch.byteorder, signed: signed)[0];
		if (arg.last == 0)
			return f"{asmArgPrefix}\\{arg.first}{asmArgSuffix}";
		return f"{asmArgPrefix}\\{arg.first}{asmArgSuffix}+{arg.last}";
	}
	function encodeX2(arg: int | (string, int), signed: bool): {int | string...} {
		if (arg is int)
			return arg.tobytes(2, byteorder: arch.byteorder, signed: signed);
		local minVal, maxVal = this.outLimits.get(arg.first, (0, 0xffff))...;
		local formatArgs = { asmArgPrefix, arg.first, asmArgSuffix, arg.last };
		local b0 = minVal >= 0 && maxVal <= 0x00ff ? 0 : "(({}\\{}{}+{})&0xff00)>>8".format(formatArgs);
		local b1 =                                       "({}\\{}{}+{})&0xff".format(formatArgs);
		return arch.bigEndian ? { b0, b1 }
		                      : { b1, b0 };
	}
	function encodeX4(arg: int | (string, int), signed: bool): {int | string...} {
		if (arg is int)
			return arg.tobytes(4, byteorder: arch.byteorder, signed: signed);
		local minVal, maxVal = this.outLimits.get(arg.first, (0, 0xffffffff))...;
		local formatArgs = { asmArgPrefix, arg.first, asmArgSuffix, arg.last };
		local b0 = minVal >= 0 && maxVal <= 0x00ffffff ? 0 : "(({}\\{}{}+{})&0xff000000)>>24".format(formatArgs);
		local b1 = minVal >= 0 && maxVal <= 0x0000ffff ? 0 : "(({}\\{}{}+{})&0xff0000)>>16".format(formatArgs);
		local b2 = minVal >= 0 && maxVal <= 0x000000ff ? 0 : "(({}\\{}{}+{})&0xff00)>>8".format(formatArgs);
		local b3 =                                           "({}\\{}{}+{})&0xff".format(formatArgs);
		return arch.bigEndian ? { b0, b1, b2, b3 }
		                      : { b3, b2, b1, b0 };
	}
	function encodeX8(arg: int | (string, int), signed: bool): {int | string...} {
		if (arg is int)
			return arg.tobytes(4, byteorder: arch.byteorder, signed: signed);
		local minVal, maxVal = this.outLimits.get(arg.first, (0, 0xffffffffffffffff))...;
		local formatArgs = { asmArgPrefix, arg.first, asmArgSuffix, arg.last };
		local b0 = minVal >= 0 && maxVal <= 0x00ffffffffffffff ? 0 : "(({}\\{}{}+{})&0xff00000000000000)>>56".format(formatArgs);
		local b1 = minVal >= 0 && maxVal <= 0x0000ffffffffffff ? 0 : "(({}\\{}{}+{})&0xff000000000000)>>48".format(formatArgs);
		local b2 = minVal >= 0 && maxVal <= 0x000000ffffffffff ? 0 : "(({}\\{}{}+{})&0xff0000000000)>>40".format(formatArgs);
		local b3 = minVal >= 0 && maxVal <= 0x00000000ffffffff ? 0 : "(({}\\{}{}+{})&0xff00000000)>>32".format(formatArgs);
		local b4 = minVal >= 0 && maxVal <= 0x0000000000ffffff ? 0 : "(({}\\{}{}+{})&0xff000000)>>24".format(formatArgs);
		local b5 = minVal >= 0 && maxVal <= 0x000000000000ffff ? 0 : "(({}\\{}{}+{})&0xff0000)>>16".format(formatArgs);
		local b6 = minVal >= 0 && maxVal <= 0x00000000000000ff ? 0 : "(({}\\{}{}+{})&0xff00)>>8".format(formatArgs);
		local b7 =                                                   "({}\\{}{}+{})&0xff".format(formatArgs);
		return arch.bigEndian ? { b0, b1, b2, b3, b4, b5, b6, b7 }
		                      : { b7, b6, b5, b4, b3, b2, b1, b0 };
	}

	function encodeS1(arg: {int | (string, int)...}): int | string -> encodeX1(arg, true);
	function encodeU1(arg: {int | (string, int)...}): int | string -> encodeX1(arg, false);
	function encodeS2(arg: {int | (string, int)...}): {int | string...} -> encodeX2(arg, true);
	function encodeU2(arg: {int | (string, int)...}): {int | string...} -> encodeX2(arg, false);
	function encodeS4(arg: {int | (string, int)...}): {int | string...} -> encodeX4(arg, true);
	function encodeU4(arg: {int | (string, int)...}): {int | string...} -> encodeX4(arg, false);
	function encodeS8(arg: {int | (string, int)...}): {int | string...} -> encodeX8(arg, true);
	function encodeU8(arg: {int | (string, int)...}): {int | string...} -> encodeX8(arg, false);

/***********************************************************************************************/
/* Instruction assemblers                                                                      */
/***********************************************************************************************/
	function assemble_push(arg) -> _assemble_push(arg, arch.addrsize);
	function assemble_push8(arg) -> _assemble_push(arg, 1);
	function assemble_push16(arg) -> _assemble_push(arg, 2);
	function assemble_push32(arg) -> _assemble_push(arg, 4);
	function assemble_push64(arg) -> _assemble_push(arg, 8);
	function _assemble_push(arg, maxsize: int) {
		if (arg is string) {
			/* push @xxx         -- DW_OP_const1u xxx */
			/* push top          -- DW_OP_dup */
			/* push &reg         -- Push register address  (DW_OP_regx) */
			/* push %reg         -- Push register value    (DW_OP_bregx) */
			/* push %reg+ADDEND  -- Push register value    (DW_OP_bregx) */
			if (arg == "top") {
				yield DW_OP_dup;
			} else if (arg.startswith("@")) {
				yield DW_OP_const1u;
				yield removeSurroundingParenthesis(arg[1:]);
			} else if (arg.startswith("&")) {
				local regno = arch.registers[arg[1:]];
				if (regno <= 31) {
					yield DW_OP_reg0 + regno;
					yield encodeULeb128(regno)...;
				} else {
					yield DW_OP_regx;
					yield encodeULeb128(regno)...;
				}
			} else {
				local registerId = none;
				local variableName = none;
				local addend = 0;
				for (local part: arg.split("+")) {
					part = part.strip();
					if (part.startswith("%")) {
						if (registerId !is none)
							throw InvalidOperands();
						registerId = arch.registers[part[1:]];
					} else if (part.startswith("\\")) {
						if (variableName !is none)
							throw InvalidOperands();
						variableName = part[1:];
					} else {
						addend += int(part);
					}
				}
				if (registerId !is none) {
					local addendArg = variableName is none
						? addend : (variableName, addend);
					if (registerId <= 31) {
						yield DW_OP_breg0 + registerId;
					} else {
						yield DW_OP_bregx;
						yield encodeULeb128(registerId)...;
					}
					if (addendArg is int || testEncodeU6bit(addendArg)) {
						if (addendArg) {
							yield encodeSLeb128(addendArg)...;
						} else {
							yield encodeU1(addendArg);
						}
					} else {
						yield encodeSLeb128(addend)...;
						/* Encode the variable addend in a second instruction */
						yield assemble_plus((variableName, 0))...;
					}
				} else {
					throw InvalidOperands();
				}
			}
		} else if (testEncodeU5bit(arg)) {
			yield encodeU5Bit(arg, DW_OP_lit0);
		} else if (testEncodeS1(arg)) {
			yield DW_OP_const1s;
			yield encodeS1(arg);
		} else if (testEncodeU1(arg)) {
			yield DW_OP_const1u;
			yield encodeU1(arg);
		} else if (testEncodeS2(arg) && maxsize >= 2) {
			yield DW_OP_const2s;
			yield encodeS2(arg)...;
		} else if (testEncodeU2(arg) && maxsize >= 2) {
			yield DW_OP_const2u;
			yield encodeU2(arg)...;
		} else if (arg is int && arg >= SLEB128_3BYTE_MIN && arg <= ULEB128_3BYTE_MAX) {
			/* In this range, we can encode the value more efficiently as (U|S)LEB */
			goto encode_suleb;
		} else if (testEncodeS4(arg) && maxsize >= 4) {
			yield DW_OP_const4s;
			yield encodeS4(arg)...;
		} else if (testEncodeU4(arg) && maxsize >= 4) {
			yield DW_OP_const4u;
			yield encodeU4(arg)...;
		} else if (arch.support64 && testEncodeS8(arg) && maxsize >= 8) {
			yield DW_OP_const8s;
			yield encodeS8(arg)...;
		} else if (arch.support64 && testEncodeU8(arg) && maxsize >= 8) {
			yield DW_OP_const8u;
			yield encodeU8(arg)...;
		} else if (arg is int) {
encode_suleb:
			if (arg >= 0) {
				yield DW_OP_constu;
				yield encodeULeb128(arg)...;
			} else {
				yield DW_OP_consts;
				yield encodeSLeb128(arg)...;
			}
		} else {
			throw ImpossibleConstraints(arg);
		}
	}

	function assemble_addr(arg) {
		local testEncodeUn = "testEncodeU" + arch.addrsize;
		local encodeUn = "encodeU" + arch.addrsize;
		if (!this.operator . (testEncodeUn)(arg))
			throw ImpossibleConstraints(arg);
		yield DW_OP_addr;
		yield this.operator . (encodeUn)(arg)...;
	}

	function assemble_const1u(arg) {
		if (arg is string && arg.startswith("@")) {
			yield DW_OP_const1u;
			yield removeSurroundingParenthesis(arg[1:]);
		} else {
			if (!testEncodeU1(arg))
				throw ImpossibleConstraints(arg);
			yield DW_OP_const1u;
			yield encodeU1(arg);
		}
	}
	function assemble_const1s(arg) {
		if (arg is string && arg.startswith("@")) {
			yield DW_OP_const1s;
			yield removeSurroundingParenthesis(arg[1:]);
		} else {
			if (!testEncodeS1(arg))
				throw ImpossibleConstraints(arg);
			yield DW_OP_const1s;
			yield encodeS1(arg);
		}
	}
	function assemble_const2u(arg) { if (!testEncodeU2(arg)) throw ImpossibleConstraints(arg); yield DW_OP_const2u; yield encodeU2(arg)...; }
	function assemble_const2s(arg) { if (!testEncodeS2(arg)) throw ImpossibleConstraints(arg); yield DW_OP_const2s; yield encodeS2(arg)...; }
	function assemble_const4u(arg) { if (!testEncodeU4(arg)) throw ImpossibleConstraints(arg); yield DW_OP_const4u; yield encodeU4(arg)...; }
	function assemble_const4s(arg) { if (!testEncodeS4(arg)) throw ImpossibleConstraints(arg); yield DW_OP_const4s; yield encodeS4(arg)...; }
	function assemble_const8u(arg) { if (!testEncodeU8(arg)) throw ImpossibleConstraints(arg); yield DW_OP_const8u; yield encodeU8(arg)...; }
	function assemble_const8s(arg) { if (!testEncodeS8(arg)) throw ImpossibleConstraints(arg); yield DW_OP_const8s; yield encodeS8(arg)...; }

	function assemble_consts(arg) {
		yield DW_OP_consts;
		if (testEncodeU6bit(arg)) {
			yield encodeU1(arg);
		} else if (arg is int) {
			yield encodeSLeb128(arg)...;
		} else {
			throw ImpossibleConstraints(arg);
		}
	}

	function assemble_constu(arg) {
		yield DW_OP_constu;
		if (testEncodeU7bit(arg)) {
			yield encodeU1(arg);
		} else if (arg is int && arg >= 0) {
			yield encodeULeb128(arg)...;
		} else {
			throw ImpossibleConstraints(arg);
		}
	}

	function assemble_pick(arg) {
		if (arg is int && arg == 0) {
			yield DW_OP_dup;
		} else if (arg is string && arg.startswith("@")) {
			yield DW_OP_pick;
			yield removeSurroundingParenthesis(arg[1:]);
		} else if (testEncodeU1(arg)) {
			yield DW_OP_pick;
			yield encodeU1(arg);
		} else {
			throw ImpossibleConstraints(arg);
		}
	}

	function assemble_plus_uconst(arg) -> assemble_plus(arg);
	function assemble_plus(arg) -> _assemble_plus(arg, arch.addrsize);
	function assemble_plus8(arg) -> _assemble_plus(arg, 1);
	function assemble_plus16(arg) -> _assemble_plus(arg, 2);
	function assemble_plus32(arg) -> _assemble_plus(arg, 4);
	function assemble_plus64(arg) -> _assemble_plus(arg, 8);
	function assemble_add(arg) -> assemble_plus(arg);
	function assemble_add8(arg) -> assemble_plus8(arg);
	function assemble_add16(arg) -> assemble_plus16(arg);
	function assemble_add32(arg) -> assemble_plus32(arg);
	function assemble_add64(arg) -> assemble_plus64(arg);
	function _assemble_plus(arg, maxsize: int) {
		if (arg is int && arg == 0) {
			/* No-op */
		} else if (arg is string && arg.startswith("@")) {
			yield DW_OP_plus_uconst;
			yield removeSurroundingParenthesis(arg[1:]);
		} else if (testEncodeU7bit(arg)) {
			yield DW_OP_plus_uconst;
			yield encodeU1(arg);
		} else if (arg is int && arg >= 0) {
			/* Encode via ULEB */
			yield DW_OP_plus_uconst;
			yield encodeULeb128(arg)...;
		} else {
			/* Encode as 2 instructions */
			yield _assemble_push(arg, maxsize)...;
			yield DW_OP_plus;
		}
	}

	function assemble_jnz(x, arg) -> assemble_jt(x, arg); /* Jump-if-true */
	function assemble_jt(x, arg) {
		if (x is string && x == "pop") {
			yield _asm_jmp(DW_OP_bra, arg)...;
		} else if (x is string && x == "top") {
			yield DW_OP_dup;
			yield _asm_jmp(DW_OP_bra, arg)...;
		} else {
			throw InvalidOperands();
		}
	}

	function assemble_jz(x, arg) -> assemble_jf(x, arg); /* Jump-if-false */
	function assemble_jf(x, arg) {
		if (x is string && x == "pop") {
			yield DW_OP_not;
			yield _asm_jmp(DW_OP_bra, arg)...;
		} else if (x is string && x == "top") {
			yield DW_OP_dup;
			yield DW_OP_not;
			yield _asm_jmp(DW_OP_bra, arg)...;
		} else {
			throw InvalidOperands();
		}
	}

	function assemble_bra(arg)  -> _asm_jmp(DW_OP_bra, arg);
	function assemble_skip(arg) -> _asm_jmp(DW_OP_skip, arg);
	function assemble_jmp(arg)  -> _asm_jmp(DW_OP_skip, arg);
	function _asm_jmp(op, arg) {
		if (arg !is Symbol)
			throw InvalidOperands();
		yield op;
		if (arch.bigEndian) {
			yield Relocation(R_CFI_REL16_B, arg);
			yield Relocation(R_CFI_REL16_A, arg);
		} else {
			yield Relocation(R_CFI_REL16_A, arg);
			yield Relocation(R_CFI_REL16_B, arg);
		}
	}

	function assemble_regx(arg) -> assemble_reg(arg);
	function assemble_reg(arg) {
		if (arg is string) {
			if (!arg.startswith("&"))
				throw InvalidOperands();
			arg = arch.registers[arg[1:]];
		}
		if (testEncodeU5bit(arg)) {
			yield encodeU5Bit(arg, DW_OP_reg0);
		} else if (arg is string && arg.startswith("@")) {
			yield DW_OP_regx;
			yield removeSurroundingParenthesis(arg[1:]);
		} else if (testEncodeU7bit(arg)) {
			yield DW_OP_regx;
			yield encodeU1(arg);
		} else if (arg is int && arg >= 0) {
			yield DW_OP_regx;
			yield encodeULeb128(arg)...;
		} else {
			throw ImpossibleConstraints(arg);
		}
	}

	function assemble_fbreg(arg) {
		if (arg is string && arg.startswith("@")) {
			yield DW_OP_fbreg;
			yield removeSurroundingParenthesis(arg[1:]);
		} else if (testEncodeU6bit(arg)) {
			yield DW_OP_fbreg;
			yield encodeU1(arg);
		} else if (arg is int) {
			yield DW_OP_fbreg;
			yield encodeSLeb128(arg)...;
		} else {
			throw ImpossibleConstraints(arg);
		}
	}

	function assemble_bregx(regno, offset) -> assemble_breg(regno, offset);
	function assemble_breg(regno, offset) {
		if (regno is string) {
			if (!regno.startswith("%"))
				throw InvalidOperands();
			regno = arch.registers[regno[1:]];
		}
		if (testEncodeU5bit(regno)) {
			yield encodeU5Bit(regno, DW_OP_breg0);
		} else if (testEncodeU7bit(regno)) {
			yield DW_OP_bregx;
			yield encodeU1(regno);
		} else {
			if (regno !is int || regno < 0)
				throw ImpossibleConstraints();
			yield DW_OP_bregx;
			yield encodeULeb128(regno)...;
		}
		if (offset is string && offset.startswith("@")) {
			yield removeSurroundingParenthesis(offset[1:]);
		} else if (testEncodeU6bit(offset)) {
			yield encodeU1(offset);
		} else {
			if (offset !is int)
				throw ImpossibleConstraints();
			yield encodeSLeb128(offset)...;
		}
	}

	function assemble_piece(numBytes) {
		yield DW_OP_piece;
		if (numBytes is string && numBytes.startswith("@")) {
			yield removeSurroundingParenthesis(numBytes[1:]);
		} else if (testEncodeU7bit(numBytes)) {
			yield encodeU1(numBytes);
		} else {
			if (numBytes !is int)
				throw ImpossibleConstraints();
			yield encodeULeb128(numBytes)...;
		}
	}

	function assemble_derefb() -> assemble_deref_size(1);
	function assemble_derefw() -> assemble_deref_size(2);
	function assemble_derefl() -> assemble_deref_size(4);
	function assemble_derefq() -> assemble_deref_size(8);
	function assemble_deref_size(n) {
		if (n is int && n == arch.addrsize) {
			yield DW_OP_deref;
		} else if (n is string && n.startswith("@")) {
			yield DW_OP_deref_size;
			yield removeSurroundingParenthesis(n[1:]);
		} else {
			yield DW_OP_deref_size;
			if (testEncodeU1(n)) {
				yield encodeU1(n);
			} else {
				throw ImpossibleConstraints();
			}
		}
	}

	function assemble_xderefb() -> assemble_xderef_size(1);
	function assemble_xderefw() -> assemble_xderef_size(2);
	function assemble_xderefl() -> assemble_xderef_size(4);
	function assemble_xderefq() -> assemble_xderef_size(8);
	function assemble_xderef_size(n) {
		if (n is int && n == arch.addrsize) {
			yield DW_OP_xderef;
		} else if (n is string && n.startswith("@")) {
			yield DW_OP_xderef_size;
			yield removeSurroundingParenthesis(n[1:]);
		} else {
			yield DW_OP_xderef_size;
			if (testEncodeU1(n)) {
				yield encodeU1(n);
			} else {
				throw ImpossibleConstraints();
			}
		}
	}

	function assemble_bit_piece(numBits) {
		yield DW_OP_bit_piece;
		if (testEncodeU7bit(numBits)) {
			yield encodeU1(numBits);
		} else if (numBits is string && numBits.startswith("@")) {
			yield removeSurroundingParenthesis(numBits[1:]);
		} else {
			if (numBits !is int)
				throw ImpossibleConstraints();
			yield encodeULeb128(numBits)...;
		}
	}

	function assemble_implicit_value(value) {
		if (value !is string || !value.startswith("\"") || !value.endswith("\""))
			throw InvalidOperands();
		try {
			value = value[1:-1].decode("c-escape");
		} catch (...) {
			throw InvalidOperands();
		}
		value = value.encode("utf-8").bytes();
		yield DW_OP_implicit_value;
		yield encodeULeb128(#value)...;
		yield value...;
	}

	function assemble__cfi_escape(bytes...) {
		for (local b: bytes) {
			if (b.startswith("\"") && b.endswith("\"")) {
				try {
					b = b[1:-1].decode("c-escape");
				} catch (...) {
					throw InvalidOperands();
				}
				yield b.encode("utf-8").bytes()...;
			} else if (testEncodeU1(b)) {
				yield encodeU1(b);
			} else {
				throw ImpossibleConstraints();
			}
		}
	}

	/* Special instruction: ifnotimpl
	 * >> ifnotimpl "KOS", .Ltarget
	 *
	 * If the hosting implementation isn't KOS's, jump to `.Ltarget'
	 * NOTE: This is implemented via a double-jump:
	 * >>     skip 1f
	 * >>     .byte 'K','O','S'
	 * >> 1:  skip .Ltarget */
	function assemble_ifnotimpl(implName /*: string*/, target /*: Symbol*/) {
		if (implName !is string || !implName.startswith("\"") ||
		    !implName.endswith("\"") || target !is Symbol)
			throw InvalidOperands();
		try {
			implName = implName[1:-1].decode("c-escape");
		} catch (...) {
			throw InvalidOperands();
		}
		implName = implName.encode("utf-8").bytes();
		yield DW_OP_skip; /* Skip over the impl indicator string */
		yield (#implName).tobytes(2, byteorder: arch.byteorder, signed: false)...;
		yield implName...;
		yield DW_OP_skip;
		if (arch.bigEndian) {
			yield Relocation(R_CFI_REL16_B, target);
			yield Relocation(R_CFI_REL16_A, target);
		} else {
			yield Relocation(R_CFI_REL16_A, target);
			yield Relocation(R_CFI_REL16_B, target);
		}
	}

/***********************************************************************************************/

	function assembleInstruction(i: Instruction): {string | int | Relocation | Symbol...} {
		local mnemonic = i.mnemonic;
		local opcode = NOARG_INSTRUCTIONS.get(mnemonic);
		local maxOperandSize;
		if (opcode !is none) {
			if (!i.operands)
				return { opcode };
			maxOperandSize = arch.addrsize;
handle_fixed_operand_size:
			if (#i.operands == 1 && opcode in BINARY_AS_PUSH_INSTR_OPCODES) {
				/* Compile as `push <i.operands.first>; <opcode>;' */
				return { _assemble_push(i.operands.first, maxOperandSize)..., opcode };
			}
		} else if (mnemonic.endswith("8")) {
			opcode = NOARG_INSTRUCTIONS.get(mnemonic[:-1]);
			if (opcode !is none) {
				maxOperandSize = 1;
				goto handle_fixed_operand_size;
			}
		} else if (mnemonic.endswith("16") || mnemonic.endswith("32") || mnemonic.endswith("64")) {
			opcode = NOARG_INSTRUCTIONS.get(mnemonic[:-2]);
			if (opcode !is none) {
				maxOperandSize = { "6" : 2, "2" : 4, "4" : 8 }[mnemonic[-1:]];
				goto handle_fixed_operand_size;
			}
		}
		local attrName = "assemble_" + mnemonic.replace(".", "_");
		try {
			return this.operator . (attrName)(i.operands...);
		} catch (AttributeError) {
			if (opcode is none)
				throw;
		} catch (InvalidOperands) {
		}
		throw Error(f"Invalid operands for {repr mnemonic}: {
			', '.join(for (local o: i.operands) repr o)
		}");
	}

	function assembleOnceWithRelocations(): {string | int | Relocation | Symbol...} {
		for (local i: this.instructions) {
			if (i is Instruction) {
				yield this.assembleInstruction(i)...;
			} else {
				yield i;
			}
		}
	}

	function assembleOnce(): {string | int...} {
		local result = [];
		for (local part: assembleOnceWithRelocations()) {
			if (part is Symbol) {
				part.addr = #result;
				continue;
			}
			if (part is Relocation)
				part.addr = #result;
			result.append(part);
		}
		/* Resolve relocations */
		for (local i: [:#result]) {
			local part = result[i];
			if (part is Relocation)
				result[i] = part.resolve();
		}
		return result;
	}

	function assembleOnceWithHeaders(outputRegister: string | int): {string | int...} {
		local data = assembleOnce();
		if (outputRegister !is int) {
			if (outputRegister.startswith("%"))
				outputRegister = outputRegister[1:];
			if (outputRegister == "cfa") {
				/* Special case to define the %cfa register itself! */
				yield DW_CFA_def_cfa_expression;
				if (isDerefAfter) {
					yield encodeULeb128(#data + 1)...;
					yield data...;
					yield DW_OP_deref;
				} else {
					yield encodeULeb128(#data)...;
					yield data...;
				}
				return;
			}
			outputRegister = this.arch.registers[outputRegister];
		}
		yield isDerefAfter ? DW_CFA_expression : DW_CFA_val_expression;
		yield encodeULeb128(outputRegister)...;
		yield encodeULeb128(#data)...;
		yield data...;
	}

	private function doAssemble(outputRegister: string | int,
	                            fullyLimited: HashSet with string)
			: {(string, {string | int...})...} {
		this.outLimits = Dict();
		/* Assemble twice so code can be optimized via outLimits assumptions */
		this.assembleOnceWithHeaders(outputRegister)...;
		local bytes = Tuple(this.assembleOnceWithHeaders(outputRegister));
		if (!this.outLimits) {
			yield ("1", bytes);
		} else {
			local condition = " && ".join(for (local name: this.outLimits.keys.sorted())
				"{0}\\{1}{2} >= {3} && {0}\\{1}{2} <= {4}"
					.format({ asmArgPrefix, name, asmArgSuffix, this.outLimits[name]... }));
			yield (condition, bytes);
			/* Update input constraints */
			local changed = false;
			local oldInLimits = this.inLimits;
			local newInLimits = Dict();
			for (local name, newMinMax: this.outLimits) {
				local oldMinMax = oldInLimits.get(name);
				if (oldMinMax is none) {
					newInLimits[name] = newMinMax;
					changed = true;
				} else if (name in fullyLimited) {
					newInLimits[name] = oldMinMax;
				} else {
					local oldMin, oldMax = oldMinMax...;
					local newMin, newMax = newMinMax...;
					if (oldMin > newMin) {
						oldMin = newMin;
						changed = true;
					}
					if (oldMax < newMax) {
						oldMax = newMax;
						changed = true;
					}
					newInLimits[name] = (oldMin, oldMax);
				}
			}
			if (changed) {
				local more;
again_with_less_limits:
				this.inLimits = newInLimits;
				try {
					more = Tuple(this.doAssemble(outputRegister, fullyLimited));
				} catch (ImpossibleConstraints as e) {
					local name = e.varName;
					if (name !is none && newInLimits.get(name) !== oldInLimits.get(name)) {
						if (fullyLimited.insert(name)) {
							/* Remove constraints from `e.varName' */
							newInLimits[name] = oldInLimits[name];
							goto again_with_less_limits;
						}
					}
					throw;
				} catch (...) {
					this.inLimits = oldInLimits;
					throw;
				}
				yield more...;
			}
		}
	}

	@@Assemble all code variables, including requirements
	function assemble(outputRegister: string | int): {(string, {string | int...})...} {
		this.inLimits = Dict();
		local fullyLimited = HashSet();
		local all = List(this.doAssemble(outputRegister, fullyLimited));
		all.sort(key: x -> { #x.last, x });
		local result = [];
		local usedConditions = HashSet();
		for (local cond, bytes: all) {
			if (usedConditions.insert(cond))
				result.append((cond, bytes));
		}
		return result;
	}
}

function assemble(arch: string, outputRegister: string, code: string): {int | string...} {
	local asm = Assembler(arch, code);
	local dat = asm.assemble(outputRegister);
	assert #dat == 1;
	dat = dat.first;
	assert dat.first == "1";
	return dat.last;
}

function outputBytesForAssembly(bytes: {int | string...},
                                linePrefix: string = "__ASM_L(",
                                lineSuffix: string = ")",
                                outputFile: File = none,
                                bytesPerLine: int = 16) {
	if (outputFile is none)
		outputFile = File.stdout;
#if 0
	import(".disasm").disassemble(asm.arch, bytes);
	for (local line: bytes.segments(bytesPerLine))
		print outputFile: (linePrefix, "\t.cfi_escape ", ",".join(
			for (local b: line) b !is int ? b : "0x" + b.hex()[2:].zfill(2)), lineSuffix);
#else
	for (local line: bytes.segments(bytesPerLine))
		print outputFile: (linePrefix, "\t.cfi_escape ", ",".join(line), lineSuffix);
#endif
}

function outputForAssembly(arch: string, outputRegister: string, code: string,
                           linePrefix: string = "__ASM_L(", lineSuffix: string = ")",
                           outputFile: File = none,
                           asmArgPrefix: string | none = none,
                           asmArgSuffix: string | none = none,
                           bytesPerLine: int = 16) {
	if (outputFile is none)
		outputFile = File.stdout;
	local asm = Assembler(arch, code);
	if (asmArgPrefix !is none)
		asm.asmArgPrefix = asmArgPrefix;
	if (asmArgSuffix !is none)
		asm.asmArgSuffix = asmArgSuffix;
	local isFirst = true;
	local hasUncondition = false;
	for (local cond, bytes: asm.assemble(outputRegister)) {
		if (cond == "1") {
			hasUncondition = true;
			if (!isFirst)
				print outputFile: (linePrefix, ".else", lineSuffix);
		} else {
			print outputFile: (linePrefix, isFirst ? ".if " : ".elseif ", cond, lineSuffix);
			isFirst = false;
		}
		outputBytesForAssembly(bytes, linePrefix, lineSuffix, outputFile, bytesPerLine);
		if (cond == "1")
			break;
	}
	if (hasUncondition) {
		if (!isFirst)
			print outputFile: (linePrefix, ".endif", lineSuffix);
	} else {
		if (!isFirst)
			print outputFile: (linePrefix, ".else", lineSuffix);
		print outputFile: (linePrefix, "\t.error \"Input arguments too large\"", lineSuffix);
		if (!isFirst)
			print outputFile: (linePrefix, ".endif", lineSuffix);
	}
}

/* Assert that the constants for 3-vs-4 byte LEB encoding are correct. */
assert #encodeULeb128(ULEB128_3BYTE_MAX) == 3;
assert #encodeULeb128(ULEB128_3BYTE_MAX + 1) == 4;
assert #encodeSLeb128(SLEB128_3BYTE_MIN) == 3;
assert #encodeSLeb128(SLEB128_3BYTE_MIN - 1) == 4;

Error.AppExit.atexit(() -> Error.AppExit.exit(0));
