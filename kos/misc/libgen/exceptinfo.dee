/* Copyright (c) 2019-2021 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2021 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import fs;
import util;
import functools;
import * from deemon;
import parititionIds from .strendN;
import .c.ppexpr as ppexpr;

function printPreprocessorExpressionIf(fp: File, cond: string): File {
	cond = cond.strip();
again:
	if (cond.startswith("!")) {
		local negCond = cond[1:].lstrip();
		if (negCond.startswith("!")) {
			cond = negCond[1:].lstrip();
			goto again;
		}
		if (negCond.startswith("defined(") && negCond.endswith(")") &&
		    negCond.findmatch("(", ")", 8) == #negCond - 1) {
			return fp << "#ifndef " << cond[8:-1].strip() << "\n";
		}
	} else {
		if (cond.startswith("defined(") && cond.endswith(")") &&
		    cond.findmatch("(", ")", 8) == #cond - 1) {
			return fp << "#ifdef " << cond[8:-1].strip() << "\n";
		}
	}
	return fp << "#if " << cond << "\n";
}

function printPreprocessorExpressionEndif(fp: File, cond: string): File {
	for (;;) {
		final local PREFIX = "defined(";
		final local SUFFIX = ")";
		local i = cond.find(PREFIX);
		if (i < 0)
			break;
		local end = cond.find(SUFFIX, i + #PREFIX);
		if (end < 0)
			break;
		cond = cond[:i] + cond[i+#PREFIX:end] + cond[end+#SUFFIX:];
	}
	return fp << "#endif /* " << cond << " */\n";
}



class ExceptClass: WeakRefAble {
	this = default;
	public operator str(): string -> name;

	@@Exception name (e.g. `E_BADALLOC')
	public member name: string;

	@@Exception message
	public member message: string = "";

	@@Default exception  code (either  `ERROR_CLASS()`
	@@when @baseClass is @none, or `ERROR_SUBCLASS()`)
	public member code: int;

	@@Set to @true if the code of this @ExceptClass can be overwritten
	public member allowExceptionCodeOverrides: bool = false;

	@@Additional overrides for @code, as a mapping `ppCond: overrideCode'
	public member codeOverrides: {string: int} = none;

	@@Exception errno expression
	public member errnoExpr: string = none;

	@@Exception base class (or @none if this one's a normal class)
	public member baseClass: ExceptClass | none = none;

	@@A preprocessor expression that must hold true for this class to be defined
	public member ppCond: string = "1";

	@@Enumerate all known exception codes as (ppCond, code) pairs
	public property allCodes: {(string, int)...} = {
		get(): {(string, int)...} {
			yield ("1", code);
			yield codeOverrides...;
		}
	}

	public function getCodeForPPCond(cond: string): int {
		for (local ppCond, codeOverride: codeOverrides) {
			if (cond == ppCond)
				return codeOverride;
		}
		return code;
	}

	@@Sub-classes of this @ExceptClass
	public member _subClasses: {WeakRef with ExceptClass...} = [];
	public property subClasses: {ExceptClass...} = {
		get(): {ExceptClass...} {
			for (local c: _subClasses)
				yield c.value;
		}
	}

	@@Exception pointer bindings (name, typ, doc)
	public member fields: {(string, string, string)...} = [];

	@@Short-hand field-prefix for this exception (e.g. `ba_' for `E_BADALLOC')
	public member _prefix: string;
	public property prefix: string = {
		get(): string {
			if (_prefix !is bound) {
				local usedPrefix = "";
				local usedName = name;
				if (baseClass !is none) {
					local baseName = baseClass.name;
					local commonTextLength = 0;
					while (commonTextLength < #baseName &&
						   commonTextLength < #usedName &&
						   baseName[commonTextLength] == usedName[commonTextLength])
						++commonTextLength;
					usedName = usedName[commonTextLength:];
				}
				if (#usedName >= 2) {
					for (local i: [:#usedName - 1]) {
						if (usedName[i] == "_") {
							usedPrefix += usedName[i + 1];
						}
					}
				}
				_prefix = usedPrefix.lower() + "_";
			}
			return _prefix;
		}
	}

	@@The name for the containing exception data struct
	@@e.g.  E_BADALLOC  uses  `exception_badalloc_data`
	public member _exceptionDataStructName: string;
	public property exceptionDataStructName: string = {
		get(): string {
			if (_exceptionDataStructName !is bound) {
				_exceptionDataStructName = baseClass !is none
					? baseClass.exceptionDataStructName
					: "exception_{}_data"
						.format({ name.lower().lsstrip("e_") });
			}
			return _exceptionDataStructName;
		}
	}

	private member _hasExceptionDataStruct: bool;
	@@Returns @true if @this @ExceptClass has an exception-data-struct
	public property hasExceptionDataStruct: bool = {
		get(): bool {
			if (_hasExceptionDataStruct !is bound) {
				if (baseClass is none) {
					if (fields)
						goto yes;
					for (local c: subClasses) {
						if (c.fields)
							goto yes;
					}
				}
				_hasExceptionDataStruct = false;
			}
			return _hasExceptionDataStruct;
yes:
			_hasExceptionDataStruct = true;
			return true;
		}
	}


	@@Return the short exception info member name of @this @ExceptClass
	@@e.g.     E_BADALLOC_INSUFFICIENT_HEAP_MEMORY.getClassMemberName()
	@@     returns: "insufficient_heap_memory"
	public function getClassMemberShortName(): string {
		if (baseClass is none)
			return name.lower();
		local baseName = baseClass.name;
		local thisName = name;
		local commonTextLength = 0;
		while (commonTextLength < #baseName &&
		       commonTextLength < #thisName &&
		       baseName[commonTextLength] == thisName[commonTextLength])
			++commonTextLength;
		return thisName[commonTextLength:]
			.lstrip("_").lower();
	}

	@@Return the exception info  member name of @this  @ExceptClass
	@@e.g. E_BADALLOC_INSUFFICIENT_HEAP_MEMORY.getClassMemberName()
	@@     returns: "ba_insufficient_heap_memory"
	public function getClassMemberName(): string {
		if (baseClass is none)
			return name.lower();
		return baseClass.prefix + getClassMemberShortName();
	}

	@@Return the prefix for fields of this exception
	@@e.g. E_BADALLOC_INSUFFICIENT_HEAP_MEMORY.getFieldPrefix()
	@@     returns: "e_badalloc.ba_insufficient_heap_memory.ihm_"
	public function getFieldPrefix(): string {
		if (baseClass is none)
			return "{}.{}".format({ name.lower(), prefix });
		return "{}{}.{}".format({
			baseClass.getFieldPrefix(),
			getClassMemberShortName(),
			prefix });
	}


	@@Find  a  field  and  exception-pointer-index,  given  its  raw  @name
	@@e.g. E_BADALLOC_INSUFFICIENT_HEAP_MEMORY.findFieldByName("num_bytes")
	@@     returns: ("e_badalloc.ba_insufficient_heap_memory.ihm_num_bytes", 0)
	public function findFieldByName(name: string): (string, int) {
		/* Search the base classes fields. */
		local index = 0;
		if (baseClass !is none) {
			for (local baseFieldName, none, none: baseClass.fields) {
				if (baseFieldName == name)
					return (baseClass.getFieldPrefix() + name, index);
				++index;
			}
		}
		/* Search my own fields. */
		for (local fieldName, none, none: fields) {
			if (fieldName == name)
				return (getFieldPrefix() + name, index);
			++index;
		}
		throw Error("Error class {} does not have a field {!r}"
			.format({ this, name }));
	}

	@@Print  the  errno  expression.   The  given  @cbField  is   called
	@@to print $fieldName references, where the argument is @"fieldName"
	public function printErrnoExpr(
			fp: File, cbField: Callable with string = none)
			: File {
		if (cbField is none) {
			cbField = [](name: string): string {
				fp << "error_data()->e_args." << findFieldByName(name)[0];
			};
		}
		local expr = errnoExpr;
		local flushStart = 0;
		local len = #expr;
		local i = 0;
		while (i < len - 1) {
			if (expr[i] != "$") {
				++i;
				continue;
			}
			local nameStart = i + 1;
			if (!expr.issymstrt(nameStart)) {
				++i;
				continue;
			}
			local nameEnd = nameStart + 1;
			while (nameEnd < len && expr.issymcont(nameEnd))
				++nameEnd;
			fp << expr[flushStart:i];
			cbField(expr[nameStart:nameEnd]);
			flushStart = nameEnd;
			i = nameEnd;
		}
		return fp << expr[flushStart:];
	}

	@@Print the exception-data struct for @this @ExceptClass
	@@@param: escapeTypename: Called to escape type names.
	@@                        Should return the escaped type name.
	@@E.g. for E_INVALID_ARGUMENT:
	@@>> struct exception_invalid_argument_data {
	@@>>     syscall_ulong_t ia_context; /* Argument context (One of `E_INVALID_ARGUMENT_CONTEXT_*') */
	@@>>     union {
	@@>>         struct {
	@@>>             uintptr_t uf_value;  /* The value that was given */
	@@>>             uintptr_t uf_mask;   /* The mask of illegal & fixed bits */
	@@>>             uintptr_t uf_result; /* The mask of fixed bits */
	@@>>         }           ia_unknown_flag;
	@@>>         ...
	@@>>     }
	@@>> #ifndef __COMPILER_HAVE_TRANSPARENT_UNION
	@@>>     ...
	@@>> #endif /* !__COMPILER_HAVE_TRANSPARENT_UNION */
	@@>>     ;
	@@>> };
	public function printExceptionDataStruct(
			fp: File = none,
			escapeTypename: Callable with string = none,
			structName: string = none): File {
		if (fp is none)
			fp = File.stdout;
		if (escapeTypename is none)
			escapeTypename = functools.identity;
		assert baseClass is none;
		assert hasExceptionDataStruct;
		if (ppCond != "1")
			printPreprocessorExpressionIf(fp, ppCond);
		if (structName is none)
			structName = exceptionDataStructName;
		fp << "struct " << structName << " {\n";
		printExceptionDataStructFields(fp, escapeTypename, "\t");
		local subClassesWithFields = [];
		for (local c: subClasses) {
			if (c.fields)
				subClassesWithFields.append(c);
		}
		if (subClassesWithFields) {
			fp << "\tunion {\n";
			local classNames = List(
				for (local c: subClassesWithFields)
					c.getClassMemberName());
			for (local name: classNames)
				fp << "#undef " << name << "\n";
			local hasUnconditionalSubClass = false;
			for (local c: subClassesWithFields) {
				fp << "\n";
				if (c.ppCond == "1" || c.ppCond == ppCond) {
					hasUnconditionalSubClass = true;
				} else {
					printPreprocessorExpressionIf(fp, c.ppCond);
				}
				fp << "\t\tstruct {\n";
				c.printExceptionDataStructFields(fp, escapeTypename, "\t\t\t");
				fp << "\t\t} " << c.getClassMemberName()
					<< "; /* " << c.name << " */\n";
				if (c.ppCond != "1" && c.ppCond != ppCond)
					printPreprocessorExpressionEndif(fp, c.ppCond);
			}
			if (!hasUnconditionalSubClass) {
				fp << "\n";
				fp << "int _" << prefix << "placeholder;\n";
			}
			fp << "\n"
				"\t}\n"
				"#ifndef __COMPILER_HAVE_TRANSPARENT_UNION\n";
			local subClassUnionName = "_" + prefix + "classes";
			fp << "\t" << subClassUnionName << "\n";
			local longestClassName = classNames.each.length > ...;
			for (local name: classNames) {
				fp << "#define " << name << (" " * (longestClassName - #name))
					<< " " << subClassUnionName << "." << name << "\n";
			}
			fp << "#endif /* !__COMPILER_HAVE_TRANSPARENT_UNION */\n"
				"\t;\n";
		}
		fp << "};\n";
		if (ppCond != "1")
			printPreprocessorExpressionEndif(fp, ppCond);
		return fp;
	}

	public function printExceptionDataStructFields(
			fp: File, escapeTypename: Callable with string,
			linePrefix: string): File {
		local effectiveFields = [];
		local myFieldPrefix = prefix;
		for (local name, typ, doc: fields) {
			effectiveFields.append((
				myFieldPrefix + name,
				escapeTypename(typ),
				doc));
		}
		local longestFieldName = effectiveFields.each[0].length > ...;
		local longestFieldType = effectiveFields.each[1].length > ...;
		for (local name, typ, doc: effectiveFields) {
			fp << linePrefix << typ
				<< (" " * (longestFieldType - #typ))
				<< " " << name << ";";
			doc = doc.rstrip();
			if (doc) {
				fp << (" " * (longestFieldName - #name))
					<< " /* ";
				local docPrefix = "\n{}{}    * ".format({
					linePrefix,
					" " * (longestFieldType + longestFieldName)
				});
				fp << docPrefix.join(
					for (local l: doc.splitlines(false))
						l.rstrip());

				fp << " */";
			}
			fp << "\n";
		}
		return fp;
	}
}


function skipWhitespaceAndComments(text: string, i: int, end: int): int {
again:
	while (i < end && text.isspace(i))
		++i;
	if (i + 1 < end) {
		local ch = text[i];
		if (ch == "/") {
			ch = text[i + 1];
			if (ch == "/") {
				i = text.find("\n", i, end);
				if (i < 0)
					i = end;
				else {
					++i;
				}
				goto again;
			} else if (ch == "*") {
				i = text.find("*/", i, end);
				if (i < 0)
					i = end;
				else {
					i += 2;
				}
				goto again;
			}
		}
	}
	return i;
}

function skipWhitespaceAndCommentsNoLf(text: string, i: int, end: int): int {
again:
	while (i < end && text.isspace(i) && !text.islf(i))
		++i;
	if (i + 1 < end) {
		local ch = text[i];
		if (ch == "/") {
			ch = text[i + 1];
			if (ch == "/") {
				i = text.find("\n", i, end);
				if (i < 0)
					i = end;
				else {
					++i;
				}
				goto again;
			} else if (ch == "*") {
				i = text.find("*/", i, end);
				if (i < 0)
					i = end;
				else {
					i += 2;
				}
				goto again;
			}
		}
	}
	return i;
}

function decodeMultiPartCString(s: string): string {
	File.Writer result;
	local partStart = 0;
	local len = #s;
	for (;;) {
		while (partStart < len && s.isspace(partStart))
			++partStart;
		if (partStart >= len)
			break;
		local ch = s[partStart];
		if (ch !in "\"\'")
			throw Error.ValueError("Bad string character {!r}"
				.format({ ch }));
		++partStart;
		local partEnd = s.find(ch, partStart);
		if (partEnd < 0)
			throw Error.ValueError("Unmatched {!r} in {!r}"
				.format({ ch, s[partStart:] }));
		result << s[partStart:partEnd].decode("c-escape");
		partStart = partEnd + 1;
	}
	return result.string;
}


global _cachedExceptionClasses = Dict();


@@Parse  all  exception  classes  described  by  `fp'  and
@@return them as  a mapping for  name->ppCond->ExceptClass
@@e.g. parseExceptionClasses("include/kos/except/codes.h")
function parseExceptionClasses(
		fp: File | string = none, filename: string = none)
		: {string: {string: ExceptClass}} {
	if (fp is none) {
		fp = fs.joinpath(fs.headof(__FILE__),
			"../../include/kos/except/codes.h");
	}
	local result: {string: {string: ExceptClass}} = Dict();
	if (fp is string) {
		local newResult = _cachedExceptionClasses.get(fp);
		if (newResult !is none)
			return newResult;
		filename = fp;
		_cachedExceptionClasses[filename] = result;
		fp = File.open(filename);
	}
	if (filename is none)
		filename = fp.filename;
	local text = fp.read().unifylines().decode("utf-8");
	local textEnd = #text;
	local i = 0;
	function lcAt(index: int): (int, int) {
		local lineStart = text.rfind("\n", 0, index) + 1;
		return (
			1 + text.count("\n", 0, lineStart),
			1 + (index - lineStart));
	}
	function errAt(index: int, message: string) {
		local line, col = lcAt(index)...;
		print File.stderr: (filename, "(", line, ",", col, ") : Error : ", message);
		throw Error(message);
	}
	@@Stack of expressions that must hold true
	local ppExpressionStack = [];
	for (;;) {
		final local BEGIN = "/*[[[begin]]]*/";
		final local END   = "/*[[[end]]]*/";
		i = text.find(BEGIN, i);
		if (i < 0)
			break;
		local end = text.find(END, i);
		if (end < 0)
			errAt(i, "Tag not closed");
		i += #BEGIN;
		for (;;) {
			i = skipWhitespaceAndComments(text, i, end);
			if (i >= end)
				break;
			local ch = text[i];
			if (ch != "#") {
				errAt(i, "Unexpected character {!r} in exception-code region"
					.format({ ch }));
			}
			i = skipWhitespaceAndCommentsNoLf(text, i + 1, end);
			if (i >= end)
				break;
			if (text.islf(i))
				continue;
			if (!text.issymstrt(i))
				errAt(i, "Unexpected character {!r} after '#'"
					.format({ text[i] }));
			local directiveStart = i;
			++i;
			while (i < end && text.issymcont(i))
				++i;
			local directive = text[directiveStart:i];
			i = skipWhitespaceAndCommentsNoLf(text, i, end);
			switch (directive) {

			case "if":
			case "ifdef":
			case "ifndef":
			case "else":
			case "elif":
			case "endif": {
				local lineEnd = text.find("\n", i, end);
				if (lineEnd < 0)
					errAt(directiveStart, "Unterminated directive");
				local expr = text[i:lineEnd].strip();
				switch (directive) {
				case "if":
do_pp_if:
					ppExpressionStack.append(expr);
					break;
				case "ifdef":
					expr = "defined({})".format({ expr });
					goto do_pp_if;
				case "ifndef":
					expr = "!defined({})".format({ expr });
					goto do_pp_if;
				case "elif":
					if (!ppExpressionStack)
						errAt(directiveStart, "Empty pp-stack");
					expr = "!({}) && ({})".format({
						ppExpressionStack.popback(),
						expr });
					goto do_pp_if;
				case "else":
					if (!ppExpressionStack)
						errAt(directiveStart, "Empty pp-stack");
					expr = "!({})".format({ ppExpressionStack.popback() });
					goto do_pp_if;
				case "endif":
					if (!ppExpressionStack)
						errAt(directiveStart, "Empty pp-stack");
					ppExpressionStack.popback();
					break;
				}
				i = lineEnd + 1;
			}	break;

			case "define": {
				local macroNameStart = i;
				if (i >= end || !text.issymstrt(i))
					errAt(i, "Unexpected character {!r} after #define"
						.format({ text.substr(i, i + 1) }));
				++i;
				while (i < end && text.issymcont(i))
					++i;
				local macroNameEnd = i;
				local macroName = text[macroNameStart:macroNameEnd];
				local ifNdefMacroName = "!defined({})".format({ macroName });
				local ppCond = "&&".join(
					for (local e: ppExpressionStack)
						if (e != ifNdefMacroName)
							"({})".format({ e }));
				if (!ppCond)
					ppCond = "1";
				if (ppCond != "1") {
					try {
						ppCond = ppexpr.optimize(ppCond);
					} catch (Error as e) {
						errAt(macroNameStart, "Error while parsing pp expression {!r}: {}"
							.format({ ppCond, e.message }));
					}
				}
				local map = result.get(macroName);
				if (map is none)
					result[macroName] = map = Dict();
				else {
					if (ppCond in map)
						errAt(macroNameStart, "Duplicate exception class: {!r} with {!r}"
							.format({ macroName, ppCond }));
				}
				local e_class: ExceptClass = ExceptClass(
					name:   macroName,
					ppCond: ppCond);
				/* Check if the code for  this exception can be  overwritten.
				 * This is the case if we're surrounded by `#ifndef E_MYNAME' */
				for (local e: ppExpressionStack) {
					if (e == ifNdefMacroName) {
						e_class.allowExceptionCodeOverrides = true;
						break;
					}
				}
				map[ppCond] = e_class;
				i = skipWhitespaceAndCommentsNoLf(text, i, end);
				if (i >= end || text[i] != "(")
					errAt(i, "Expected '(' after '#define {}', but got {!r}"
						.format({ macroName, text.substr(i, i + 1) }));
				++i;
				local rParenIndex = text.findmatch("(", ")", i, end);
				if (rParenIndex < 0)
					errAt(i, "Missing ')' after '#define {} ('"
						.format({ macroName }));
				local baseAndCode = text[i:rParenIndex].strip();
				if ("," in baseAndCode) {
					local baseName, none, resultCode = baseAndCode.partition(",")...;
					baseName = baseName.strip();
					e_class.code = resultCode.strip();
					e_class.baseClass = result.get(baseName).get(ppCond);
					if (e_class.baseClass is none)
						e_class.baseClass = result.get(baseName).get("1");
					if (e_class.baseClass is none)
						errAt(i, "Unknown base class name: {!r}"
							.format({ baseName }));
					e_class.baseClass._subClasses.append(WeakRef(e_class));
				} else {
					e_class.code = baseAndCode.strip();
				}
				try {
					e_class.code = int(e_class.code);
				} catch (Error as e) {
					errAt(i, "Bad exception code {!r}: {}"
						.format({ e_class.code, e.message }));
				}
				i = rParenIndex + 1;
				while (i < end && text.isspace(i) && !text.islf(i))
					++i;
				if (i + 1 < end && text[i] == "/" && text[i + 1] in "/*") {
					@@Triples of (textStart, textEnd)
					local commentLines: (int, int) = [];
					local commentLineStart = i + 2;
					if (text[i + 1] == "*") {
						local commentEnd = text.find("*/", commentLineStart, end);
						if (commentEnd < 0)
							errAt(i, "Comment not terminated");
						while (commentLineStart < commentEnd) {
							local lineEnd = text.find("\n", commentLineStart, commentEnd);
							if (lineEnd < 0)
								lineEnd = commentEnd;
							commentLines.append((commentLineStart, lineEnd));
							commentLineStart = lineEnd;
							while (commentLineStart < commentEnd && text.isspace(commentLineStart))
								++commentLineStart;
							if (commentLineStart < commentEnd && text[commentLineStart] == "*")
								++commentLineStart;
						}
						i = commentEnd + 2;
					} else {
						for (;;) {
							i = text.find("\n", commentLineStart, end);
							if (i < 0)
								i = end;
							commentLines.append((commentLineStart, i));
							if (i >= end)
								break;
							++i;
							while (i < end && text.isspace(i))
								++i;
							if (i + 2 >= end)
								break;
							if (text.substr(i, i + 2) != "//")
								break;
							i += 2;
							commentLineStart = i;
						}
					}
					local commentText = File.Writer();
					local isFirst = true;
					for (local start, end: commentLines) {
						if (!isFirst)
							commentText << "\n";
						commentText << text[start:end];
						isFirst = false;
					}
					commentText = commentText.string;
					function errAtComment(index: int, message: string) {
						for (local start, end: commentLines) {
							local len = end - start;
							if (index < len)
								return errAt(start + index, message);
							index -= len;
						}
						return errAt(i, message);
					}
					local commentIndex = 0;
					local commentLen = #commentText;
					while (commentIndex < commentLen) {
						if (commentText[commentIndex] != "[") {
							++commentIndex;
							continue;
						}
						local tagStart = commentIndex + 1;
						local tagEnd = commentText.findmatch("[", "]", tagStart);
						if (tagEnd < 0)
							errAtComment(commentIndex, "Unmatched '['");
						while (tagEnd > tagStart && commentText.isspace(tagEnd - 1))
							--tagEnd;
again_parse_tag_directive:
						while (tagStart < tagEnd && commentText.isspace(tagStart))
							++tagStart;
						if (tagStart < tagEnd) {
							if (!commentText.issymstrt(tagStart))
								errAtComment(tagStart, "Unexpected character {!r} after '['"
									.format({ commentText[tagStart] }));
							local tagDirectiveEnd = tagStart + 1;
							while (tagDirectiveEnd < tagEnd && commentText.issymcont(tagDirectiveEnd))
								++tagDirectiveEnd;
							local tagDirective = commentText[tagStart:tagDirectiveEnd];
							while (tagDirectiveEnd < tagEnd && commentText.isspace(tagDirectiveEnd))
								++tagDirectiveEnd;
							local tagArgsStart = tagDirectiveEnd;
							local tagArgsEnd   = tagDirectiveEnd;
							if (tagDirectiveEnd < tagEnd && commentText[tagDirectiveEnd] == "(") {
								tagArgsStart = tagDirectiveEnd + 1;
								tagArgsEnd   = commentText.findmatch(
									"(", ")", tagArgsStart, tagEnd);
								if (tagArgsEnd < 0)
									errAtComment(tagDirectiveEnd, "Unmatched '('");
							}
							commentIndex = tagArgsEnd + 1;
							while (commentIndex < tagEnd && commentText.isspace(commentIndex))
								++commentIndex;
							while (tagArgsStart < tagArgsEnd && commentText.isspace(tagArgsStart))
								++tagArgsStart;
							while (tagArgsEnd > tagArgsStart && commentText.isspace(tagArgsEnd - 1))
								--tagArgsEnd;
							local tagArgs = commentText[tagArgsStart:tagArgsEnd];
							try {
								switch (tagDirective) {

								case "errno":
									/* Errno expression */
									e_class.errnoExpr = tagArgs;
									break;

								case "msg":
								case "message":
									/* Exception message */
									e_class.message = decodeMultiPartCString(tagArgs);
									break;

								case "prefix":
									e_class._prefix = decodeMultiPartCString(tagArgs);
									break;

								case "fld":
								case "field": {
									/* [fld(num_bytes: size_t, "The number of bytes that could not be allocated")] */
									local fieldNameEnd = tagArgs.find(":");
									if (fieldNameEnd < 0)
										errAtComment(tagArgsStart, "Missing ':' in argument {!r}"
											.format({ tagArgs }));
									local fieldTypeEnd = tagArgs.find(",", fieldNameEnd);
									local fieldCommentStart = #tagArgs;
									if (fieldTypeEnd < 0)
										fieldTypeEnd = fieldCommentStart;
									else {
										fieldCommentStart = fieldTypeEnd + 1;
									}
									local fieldName = tagArgs[:fieldNameEnd].strip();
									local fieldType = tagArgs[fieldNameEnd+1:fieldTypeEnd].strip();
									local fieldDoc  = decodeMultiPartCString(tagArgs[fieldCommentStart:]).strip();
									e_class.fields.append((fieldName, fieldType, fieldDoc));
								}	break;

								default:
									errAtComment(tagStart, "Unrecognized tag directive {}({})"
										.format({ tagDirective, tagArgs }));
								}
							} catch (Error as e) {
								if (e is Error && type(e) !== Error)
									errAtComment(tagStart, "Error during {}-directive: {}"
										.format({ tagDirective, e.message }));
								throw;
							}
							if (commentIndex < tagEnd && commentText[commentIndex] == ",") {
								tagStart = commentIndex + 1;
								goto again_parse_tag_directive;
							}
						}
						commentIndex = tagEnd + 1;
					}
				}
			}	break;

			default:
				errAt(directiveStart, "Unexpected directive {!r}"
					.format({ directive }));
			}
		}
		i = end + #END;
	}
	return result;
}


@@Print all exception data structures, as well as the
@@combinatory         `union exception_data_pointers'
@@@param: keyStructName: A key function which may be used to skew struct names
function printExceptionDataStructs(
		fp: File = none,
		classes: {string: {string: ExceptClass}} = none,
		escapeTypename: Callable with string = none,
		keyStructName: Callable with string = none,
		exceptionDataPointerType: string = "__UINTPTR_TYPE__",
		exceptionDataPointerCount: string = "EXCEPTION_DATA_POINTERS") {
	if (fp is none)
		fp = File.stdout;
	if (classes is none)
		classes = parseExceptionClasses();
	if (keyStructName is none)
		keyStructName = functools.identity;
	if (escapeTypename is none)
		escapeTypename = functools.identity;
	local isFirst = true;
	@@List of (ppCond, structName, e_name) for all defined exception data struct names
	local exceptionDataStructNames: {(string, string, string)...} = [];
	for (local name: classes.keys.sorted()) {
		local ppCondToCls = classes[name];
		for (local ppCond: ppCondToCls.keys.sorted()) {
			local cls = ppCondToCls[ppCond];
			if (!cls.hasExceptionDataStruct)
				continue;
			if (!isFirst)
				fp << "\n";
			isFirst = false;
			fp << "/* " << cls.name << " */\n";
			local usedStructName = keyStructName(cls.exceptionDataStructName);
			assert cls.ppCond === ppCond;
			cls.printExceptionDataStruct(
				fp:             fp,
				escapeTypename: escapeTypename,
				structName:     usedStructName);
			exceptionDataStructNames.append((
				ppCond, "struct " + usedStructName, cls.name));
		}
	}
	if (!isFirst)
		fp << "\n";
	/* Print the combinatory `union exception_data_pointers' */
	fp << "union " << keyStructName("exception_data_pointers") << " {\n";
	local longestDataStructName = exceptionDataStructNames.each[1].length > ...;
	local longestErrorClassName = exceptionDataStructNames.each[2].length > ...;
	if (longestDataStructName < #exceptionDataPointerType)
		longestDataStructName = #exceptionDataPointerType;
	fp << "\t" << exceptionDataPointerType
		<< (" " * (longestDataStructName - #exceptionDataPointerType))
		<< " e_pointers[" << exceptionDataPointerCount << "];\n";
	for (local ppCond, name, e_name: exceptionDataStructNames) {
		if (ppCond != "1")
			printPreprocessorExpressionIf(fp, ppCond);
		fp << "\t" << name
			<< (" " * (longestDataStructName - #name))
			<< " " << e_name.lower() << ";"
			<< (" " * (longestErrorClassName - #e_name))
			<< " /* " << e_name << " */\n";
		if (ppCond != "1")
			printPreprocessorExpressionEndif(fp, ppCond);
	}
	fp << "};\n";
}


@@Parse additional overrides for exception codes
@@@param: classes: The class mappings that should be updated to include overrides
@@@param: files:   The set of files to scan for overrides, given as pairs of (ppCond, filename)
function parseExceptionCodeOverrides(
		classes: {string: {string: ExceptClass}} = none,
		files: {(string, string)...} = none)
		: {string: {string: ExceptClass}} {
	if (classes is none)
		classes = parseExceptionClasses();
	local filesCwd;
	if (files is none) {
		filesCwd = fs.headof(__FILE__);
		files = {
			("defined(__i386__) || defined(__x86_64__)", "../../include/i386-kos/kos/except/asm/codes.h"),
			/* NOTE: exception  code overrides for  other architectures (if applicable)
			 *       should be added here, alongside preprocessor-expressions which may
			 *       be used to detect these architectures in portable code. */
		};
	} else {
		filesCwd = fs.getcwd();
	}
	for (local ppCond, filename: files) {
		/* Make  sure  to only  work with  optimized pp-expression,
		 * so-as to ensure that we can safely compare the resulting
		 * strings  for equality, where the optimization phase will
		 * have ensure that the expressions are canonical with each
		 * other. */
		ppCond = ppexpr.optimize(ppCond);
		filename = fs.abspath(filename, filesCwd);
		local knownMacros: {string: string} = Dict();
		with (local fp = File.open(filename)) {
			for (local l: fp) {
				local macroName, macroValue;
				try {
					macroName, macroValue = l.scanf(" # define %[^ ] %[^]")...;
				} catch (...) {
					continue;
				}
				for (;;) {
					local i = macroValue.find("/*");
					if (i < 0)
						break;
					local j = macroValue.find("*/", i);
					if (j < 0)
						j = #macroValue;
					else {
						j += 2;
					}
					macroValue = macroValue[:i] + macroValue[j:];
				}
				local i = macroValue.find("//");
				if (i >= 0)
					macroValue = macroValue[:i];
				macroValue = macroValue.strip();
				local oldval = knownMacros.get(macroName);
				if (oldval !is none) {
					if (oldval === false)
						continue;
					if (oldval == macroValue)
						continue;
					knownMacros[macroValue] = false;
					continue;
				}
				knownMacros[macroName] = macroValue;
			}
		}
		function resolveMacroValue(value: string): int {
again:
			while (value.startswith("(") && value.endswith(")") &&
			       value.findmatch("(", ")", 1) == #value - 1)
				value = value[1:-1].strip();
			if ("," in value) {
				/* XXX: Assert that the base class didn't change? */
				value = value.rpartition(",")[2].lstrip();
				goto again;
			}
			try {
				return int(value);
			} catch (...) {
				value = knownMacros.get(value);
				if (value !is none)
					goto again;
				throw;
			}
		}
		/* Now search for macros that share names with ExceptClass-es */
		for (local name, ppCondToCls: classes) {
			if (name !in knownMacros)
				continue; /* Not overwritten */
			local newOverride = resolveMacroValue(knownMacros[name]);
			/* Found an override! */
			for (local none, cls: ppCondToCls) {
				if (cls.codeOverrides is none)
					cls.codeOverrides = Dict();
				if (ppCond in cls.codeOverrides) {
					if (cls.codeOverrides[ppCond] != newOverride)
						throw Error("Incompatible error code overrides for {!r} (old: {}, new: {})"
							.format({ name, cls.codeOverrides[ppCond].hex(), newOverride.hex() }));
					continue;
				}
				cls.codeOverrides[ppCond] = newOverride;
			}
		}
	}
	return classes;
}


@@Return a mapping for {ppCond:{errorClass:{errorSubClass:{ExceptClass}}}}
function getExceptionCodeMappings(
		classes: {string: {string: ExceptClass}} = none)
		: {string: {int: {int: ExceptClass}}} {
	if (classes is none)
		classes = parseExceptionCodeOverrides();
	@@Mapping for ppCond->ErrorClass->ErrorSubClass->ExceptClass
	@@NOTE: An exception base-class has the sub-class code `0'!
	local nameMappings: {string: {int: {int: ExceptClass}}} = Dict();
	local alreadyDefinedNames: {string: HashSet with string} = Dict();
	function addClass(
			fullPpCond: string, cls: ExceptClass, code: int,
			skipIfAlreadyExists: bool = false) {
		local map = nameMappings.get(fullPpCond);
		if (map is none)
			nameMappings[fullPpCond] = map = Dict();
		if (cls.allowExceptionCodeOverrides) {
			local alreadyDefinedSet = alreadyDefinedNames.get(fullPpCond);
			if (alreadyDefinedSet is none)
				alreadyDefinedNames[fullPpCond] = alreadyDefinedSet = HashSet();
			if (cls.name in alreadyDefinedSet)
				return; /* Already defined */
			alreadyDefinedSet.insert(cls.name);
		}
		local errorClass, errorSubClass;
		if (cls.baseClass is none) {
			errorClass    = code;
			errorSubClass = 0x0000;
		} else {
			/* Lookup   the   proper    code   for   our    namespace.
			 * This is  required to  ensure that  we use  the  correct
			 * base-class code for our current pp-condition namespace,
			 * in   situations  where  an  arch-specific  header  only
			 * overrides  the code of a base-class, without overriding
			 * sub-class codes. */
			errorClass    = cls.baseClass.getCodeForPPCond(fullPpCond);
			errorSubClass = code;
		}
		local errorSubClassToName = map.get(errorClass);
		if (errorSubClassToName is none)
			map[errorClass] = errorSubClassToName = Dict();
		local existingEntry = errorSubClassToName.get(errorSubClass);
		if (existingEntry !is none) {
			if (!skipIfAlreadyExists && existingEntry.name != cls.name) {
				throw Error("Inconsistent mapping with {!r} for "
				            "0x{}:0x{} (is both {!r} and {!r})"
				.format({
					fullPpCond,
					errorClass.hex()[2:].zfill(4),
					errorSubClass.hex()[2:].zfill(4),
					existingEntry.name,
					cls.name
				}));
			}
			return;
		}
		errorSubClassToName[errorSubClass] = cls;
	}
	/* Step #1: Load a codes for which arch-specific overrides exist */
	for (local name, ppCondToCls: classes) {
		for (local classPpCond, cls: ppCondToCls) {
			for (local codePpCond, code: cls.allCodes) {
				if (codePpCond == "1")
					continue;
				local fullPpCond = ppexpr.optimize("({}) && ({})"
					.format({ classPpCond, codePpCond }));
				if (fullPpCond == "0")
					continue;
				addClass(fullPpCond, cls, code);
			}
		}
	}
	/* Step #2: Fill in default codes whereever arch-specific
	 *          overrides   didn't   define   them    already */
	for (local name, ppCondToCls: classes) {
		for (local classPpCond, cls: ppCondToCls) {
			assert classPpCond != "0";
			for (local codePpCond, code: cls.allCodes) {
				if (codePpCond != "1")
					continue;
				addClass(classPpCond, cls, code, true);
				if (classPpCond == "1" && cls.baseClass !is none) {
					/* Also add the class for all of the pp-conditions */
					for (local ppCond2, none: nameMappings) {
						if (ppCond2 != "1")
							addClass(ppCond2, cls, code, true);
					}
				}
			}
		}
	}
	/* Step #3: Automatically complete missing codes from the `#if 1'-namespace. */
	local universalMappings: {int: {int: string}} = nameMappings.get("1");
	if (universalMappings !is none) {
		for (local mappingsPpCond, mappings: nameMappings) {
			if (mappings === universalMappings)
				continue;
			for (local errorClass, errorSubClassToName: universalMappings) {
				for (local errorSubClass, cls: errorSubClassToName)
					addClass(mappingsPpCond, cls, cls.code, true);
			}
		}
	}
	/* Merge duplicate ppCond->xxx mappings */
again_merge_dups:
	for (local ppCond, mappings: nameMappings) {
		for (local ppCond2, mappings2: nameMappings) {
			if (ppCond === ppCond2)
				continue;
			if (mappings != mappings2)
				continue;
			// Merge ppCond and ppCond2
			ppCond = ppexpr.optimize("({}) || ({})".format({ ppCond, ppCond2 }));
			del nameMappings[ppCond];
			del nameMappings[ppCond2];
			if (ppCond == "0")
				goto again_merge_dups;
			if (ppCond in nameMappings)
				goto again_merge_dups;
			nameMappings[ppCond] = mappings;
		}
	}
	/* Check  if we can get rid of nameMappings["1"]
	 * We can do this if the ||-sum of all the other
	 * mappings also equals "1" */
	if ("1" in nameMappings) {
		local allConditions = [];
		for (local ppCond, none: nameMappings) {
			if (ppCond != "1")
				allConditions.append(ppCond);
		}
		allConditions = ppexpr.optimize("||".join(
			for (local cond: allConditions)
				"({})".format({ cond })));
		if (allConditions == "1") {
			/* All right! we don't need nameMappings["1"] */
			del nameMappings["1"];
		}
	}
	return nameMappings;
}


function printStrendExpr(fp: File, arg: string, marker: string): File {
	if (marker == "\0") {
		fp	<< "strend(" << arg << ")";
	} else {
		fp	<< "rawmemchr(" << arg << ", '"
			<< marker.encode("c-escape")
			<< "')";
	}
	return fp;
}


function printExceptNameFunctionBodyForMappings(
		fp: File, mappings: {int: {int: ExceptClass}},
		classVariableName: string, subClassVariableName: string,
		linePrefix: string,
		keyExceptClassName: Callable with ExceptClass,
		exceptClassEndMarker: string = "\1",
		exceptSubClassEndMarker: string = "\0") {

	function hex4(v: int): string {
		return v.hex()[2:].zfill(4);
	}

	@@Min/max bounds for continuous error sub-class ranges
	local subClassPartitions: {int: {(int, int)...}} = Dict();

	@@Mappings for @ERROR_CLASS(...) where @(#subClassPartitions[ERROR_CLASS(...)] >= 2)
	local nonLinearMappings: {int: {int: ExceptClass}} = Dict();

	@@Same as @mappings, but doesn't contain class
	local linearMappings: {int: {int: ExceptClass}} = Dict();

	for (local errorClass, subClassMappings: mappings) {
		local partitions = parititionIds(subClassMappings.keys);
		subClassPartitions[errorClass] = partitions;
		if (#partitions >= 2 || partitions.first.first != 0) {
			nonLinearMappings[errorClass] = subClassMappings;
		} else {
			linearMappings[errorClass] = subClassMappings;
		}
	}

	@@Min/max bound partitions for @linearMappings
	local classParitions: {(int, int)...} = parititionIds(linearMappings.keys);

	/* Generate the string table(s) for linear partitions.
	 * This table is designed as:
	 * >> "[1234:0000]\0[1234:0001]\0\0[1234:0003]\1"
	 * >> "\1"
	 * >> "[1236:0000]\0\1"
	 * >> "[1237:0000]\0\1"
	 * Meaning that '\1'-characters indicate the end of an error-sub-class, as
	 * well as introduce the start of the next error-class. */
	for (local min, max: classParitions) {
		File.Writer text;
		for (local errorClass: [min:max+1]) {
			local subClasses = linearMappings.get(errorClass);
			if (subClasses !is none) {
				local mySubClassPartitions = subClassPartitions[errorClass];
				assert #mySubClassPartitions == 1;
				assert mySubClassPartitions.first.first == 0;
				local maxSubClass = mySubClassPartitions.first.last;
				for (local errorSubClass: [0:maxSubClass+1]) {
					local name = subClasses.get(errorSubClass);
					if (name !is none)
						name = keyExceptClassName(name);
					if (name is none)
						name = "";
					text << name << exceptSubClassEndMarker;
				}
			}
			text << exceptClassEndMarker;
		}
		fp << linePrefix << "static char const e_linear_"
			<< hex4(min) << "h_" << hex4(max) << "h[] =\n"
			<< linePrefix;
		local isFirst = true;
		for (local l: text.string.segments(64)) {
			if (!isFirst)
				fp << "\n" << linePrefix;
			isFirst = false;
			fp << repr(l);
		}
		if (isFirst)
			fp << "\"\"";
		fp << ";\n";
	}
	/* Generate code to select the correct range from `classParitions' */
	fp	<< linePrefix << "char const *result;\n"
		<< linePrefix << "error_class_t class_offset;\n"
		<< linePrefix << "error_subclass_t subclass_offset;\n"
		<< linePrefix;
	local isFirst = true;
	for (local min, max: classParitions) {
		isFirst = false;
		fp << "if (";
		if (min != 0)
			fp << classVariableName << " >= 0x" << hex4(min) << " && ";
		fp << classVariableName << " <= 0x" << hex4(max) << ") {\n"
			<< linePrefix << "	result = e_linear_" << hex4(min) << "h_" << hex4(max) << "h;\n"
			<< linePrefix << "	class_offset = " << classVariableName;
		if (min != 0)
			fp << " - 0x" << hex4(min);
		fp << ";\n"
			<< linePrefix << "} else ";
	}
	if (!isFirst) {
		fp	<< "{\n"
			<< linePrefix << "	goto non_linear_prefix;\n"
			<< linePrefix << "}\n"
			<< linePrefix << "while (class_offset) {\n"
			<< linePrefix << "	--class_offset;\n"
			<< linePrefix << "	result = (char *)";
		printStrendExpr(fp, "result", exceptClassEndMarker);
		fp	<< " + 1;\n"
			<< linePrefix << "}\n"
			<< linePrefix << "subclass_offset = " << subClassVariableName << ";\n"
			<< linePrefix << "for (;;) {\n"
			<< linePrefix << "	if (*result == '\\1')\n"
			<< linePrefix << "		break; /* End-of-class */\n"
			<< linePrefix << "	if (!subclass_offset) {\n"
			<< linePrefix << "		if (!*result)\n"
			<< linePrefix << "			result = NULL;\n"
			<< linePrefix << "		return result;\n"
			<< linePrefix << "	}\n"
			<< linePrefix << "	--subclass_offset;\n"
			<< linePrefix << "	result = ";
		printStrendExpr(fp, "result", exceptSubClassEndMarker);
		fp	<< " + 1;\n"
			<< linePrefix << "}\n"
			<< "non_linear_prefix:\n";
	}
	if (nonLinearMappings) {
		fp << linePrefix << "switch(" << classVariableName << ") {\n";
		for (local classId: nonLinearMappings.keys.sorted()) {
			fp << "\n" << linePrefix << "case 0x" << hex4(classId) << ": {\n";
			/* Deal with `nonLinearMappings' by generating a conventional STREND^N table. */
			local mySubClassPartitions = subClassPartitions[classId];
			assert #mySubClassPartitions >= 2 || mySubClassPartitions.first.first != 0;
			for (local min, max: mySubClassPartitions) {
				File.Writer text;
				local isFirst = true;
				for (local subClassId: [min:max+1]) {
					local subClassName = mappings[classId].get(subClassId);
					if (subClassName !is none)
						subClassName = keyExceptClassName(subClassName);
					if (subClassName is none)
						subClassName = "";
					if (!isFirst)
						text << exceptSubClassEndMarker;
					isFirst = false;
					text << subClassName;
				}
				if (exceptSubClassEndMarker != "\0" && !isFirst)
					text << exceptSubClassEndMarker;
				fp << linePrefix << "\tstatic char const e_" << hex4(classId) << "h_linear_"
					<< hex4(min) << "h_" << hex4(max) << "h[] =\n"
					<< linePrefix << "\t";
				local isFirst = true;
				for (local l: text.string.segments(64)) {
					if (!isFirst)
						fp << "\n" << linePrefix << "\t";
					isFirst = false;
					fp << repr(l);
				}
				if (isFirst)
					fp << "\"\"";
				fp << ";\n";
			}
			/* Generate code to select the correct string table. */
			local isFirst = true;
			fp << linePrefix << "\t";
			for (local min, max: mySubClassPartitions) {
				isFirst = false;
				fp << "if (";
				if (min != 0)
					fp << subClassVariableName << " >= 0x" << hex4(min) << " && ";
				fp << subClassVariableName << " <= 0x" << hex4(max) << ") {\n"
					<< linePrefix << "		result = e_" << hex4(classId)
						<< "h_linear_" << hex4(min) << "h_" << hex4(max) << "h;\n"
					<< linePrefix << "		subclass_offset = "
						<< subClassVariableName;
				if (min != 0)
					fp << " - 0x" << hex4(min);
				fp	<< ";\n"
					<< linePrefix << "	} else ";
			}
			if (!isFirst) {
				fp << "{\n"
					<< linePrefix << "		return NULL;\n"
					<< linePrefix << "	}\n";
			}
			fp << linePrefix << "}	break;\n";
		}
		fp	<< "\n" << linePrefix << "default:\n"
			<< linePrefix << "	return NULL;\n"
			<< linePrefix << "}\n";
	}
	fp	<< linePrefix << "while (subclass_offset) {\n"
		<< linePrefix << "	--subclass_offset;\n"
		<< linePrefix << "	result = ";
	printStrendExpr(fp, "result", exceptSubClassEndMarker);
	fp	<< " + 1;\n"
		<< linePrefix << "}\n"
		<< linePrefix << "if (!*result)\n"
		<< linePrefix << "	result = NULL;\n"
		<< linePrefix << "return result;\n"
	;
}


function printExceptNameFunctionBody(
		fp: File = none,
		ppCondMappings: {string: {int: {int: ExceptClass}}} = none,
		classVariableName: string = "err_class",
		subClassVariableName: string = "err_subclass",
		linePrefix: string = "\t",
		keyExceptClassName: Callable with ExceptClass = none) {
	if (fp is none)
		fp = File.stdout;
	if (ppCondMappings is none)
		ppCondMappings = getExceptionCodeMappings();
	if (keyExceptClassName is none)
		keyExceptClassName = [](x: ExceptClass) -> x.name;
	/* Use ppexpr optimizations to turn a sequence of:
	 * >> #if FOO
	 * >> a
	 * >> #endif
	 * >> #if !FOO
	 * >> b
	 * >> #endif
	 *
	 * into:
	 * >> #if FOO
	 * >> a
	 * >> #else
	 * >> b
	 * >> #endif */
	local assumptions: ppexpr.PPAssume = none;
	local didEncounter1: bool = false;
	for (local ppCond, mappings: ppCondMappings) {
		if (didEncounter1) {
			print File.stderr: ("Warning: Impossible mappings for:", repr ppCond);
			continue;
		}
		ppCond = ppexpr.ppParse(ppCond).optimize(assume: assumptions);
		local strCond = ppCond.tostr();
		if (strCond == "1") {
			didEncounter1 = true;
			if (assumptions !is none) {
				fp << "#else /* ... */\n";
				assumptions = none;
			}
			printExceptNameFunctionBodyForMappings(
				fp, mappings, classVariableName,
				subClassVariableName, linePrefix,
				keyExceptClassName);
			continue;
		}
		if (assumptions !is none) {
			fp << "#elif " << strCond << "\n";
		} else {
			printPreprocessorExpressionIf(File.stdout, strCond);
			assumptions = ppexpr.createPPAssume();
		}
		ppCond = ppexpr.PPBranch(ppexpr.BRT_NOT, ppCond).optimize(assume: assumptions);
		assumptions.addAssumption(ppCond);
		printExceptNameFunctionBodyForMappings(
			fp, mappings, classVariableName,
			subClassVariableName, linePrefix,
			keyExceptClassName);
	}
	if (assumptions !is none) {
		fp << "#endif /* ... */\n";
	} else if (didEncounter1) {
		fp << "#endif /* !... */\n";
	}
}







#ifdef __MAIN__
for (local name, ppCondToCls: parseExceptionClasses()) {
	for (local none, cls: ppCondToCls) {
		if (cls.hasExceptionDataStruct) {
			print(cls.name, ":[msg(", repr cls.message, ")]");
			cls.printExceptionDataStruct();
		}
	}
}
#endif /* __MAIN__ */
