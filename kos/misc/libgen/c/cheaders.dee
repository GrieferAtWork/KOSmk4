global COPYRIGHT =
"/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */";



/* Definitions for data structures used to represent pre-parsed C headers
 * definition files, as well as helper functions used to construct system
 * headers, as well as automatic/user implementations */

import * from deemon;
import * from .parser;
import * from .writer;
import * from .escape;
import * from .globals;
import * from .namespace;
import * from .namespace;

global Function;
global SystemHeader;

global final LIBC_LINKAGE_DECLS = { "__LIBC", "LIBC" };
global final NAMESPACE_IMPORT_DECL = "__FORCELOCAL";
global final DEFAULT_DECL = "__LIBC";

global final function keyLocalDep(symbolName: string): string {
	return "__localdep_" + symbolName;
}

function isLibcLinkage(
		decl: string | UserString, cc: string | UserString,
		asmname: string | UserString): bool {
	if (decl !in LIBC_LINKAGE_DECLS)
		return false;
	switch (cc) {

	case "LIBCCALL":
	case "__LIBCCALL":
		return !asmname.startswith("DOS$") &&
		       !asmname.startswith("KOS$");

	case "LIBKCALL":
	case "__LIBKCALL":
		return asmname.startswith("KOS$");

	case "LIBDCALL":
	case "__LIBDCALL":
		return asmname.startswith("DOS$");

	default:
		break;
	}
	return false;
}

class CType {
	this = default;

	@@A string to insert before the name of the associated variable (e.g. @"fd_t")
	@@NOTE: This string will have already been stripped of leading/trailing spaces
	public member beforeName: string | UserString;

	@@A string to insert after the name of the associated variable (e.g. @"[2]")
	@@NOTE: This string will have already been stripped of leading/trailing spaces
	public member afterName: string | UserString = "";

	@@Returns @true if @this @CType is implicitly convertible to @other
	function implicitlyConvertibleTo(other: CType): bool {
		/* TODO: This can be done better! */
		return beforeName == other.beforeName &&
		       afterName == other.afterName;
	}

	@@Returns @true if @this @CType is @"void"
	public property isVoid: bool = {
		get(): bool {
			return beforeName == "void" && !afterName;
		}
	}

	@@Returns @true if @this @CType is a pointer
	public property isPointer: bool = {
		get(): bool {
			return str(beforeName).endswith("*");
		}
	}


	@@Prints the c-cast prefix (e.g. @"(int)") for @this
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintCCastPrefix(fp: CWriter, escapeMode: int) {
		fp << "(";
		/* TODO: This doesn't work for array types! */
		/* TODO: This doesn't work for things like __restrict */
		cprint(fp, escapeMode);
		fp << ")";
	}

	@@Output @this @CType to a @CWriter
	@@Returns @true if the type string must be followed by whitespace if
	@@immediatly succeeded by a keyword. Returns @false otherwise.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprint(fp: CWriter, escapeMode: int, name: string | UserString = ""): bool {
		local beforeNameStr = str beforeName;
		local afterNameStr = str afterName;
		escapeTextIntoFile(fp, beforeName, escapeMode);
		if (name) {
			if (!beforeNameStr.endswith("*"))
				fp << " ";
			escapeTextIntoFile(fp, name, escapeMode);
		}
		if (afterNameStr) {
			if (!afterNameStr.startswith(")"))
				fp << " ";
			escapeTextIntoFile(fp, afterName, escapeMode);
		}
		if (afterNameStr)
			return true;
		if (name)
			return true;
		if (beforeNameStr)
			return !beforeNameStr.endswith("*");
		return false;
	}

}


class Argument {
	this = default;

	@@Argument name (fully escaped; empty string if the argument is unnamed)
	@@NOTE: Ellipsis arguments have this field set to @""
	public member name: string | UserString;

	@@The argument name that should be combined with @ctype in the prototype
	@@Usually this is the same as @name, but in the case of functions such
	@@as @"execv", this would be an empty string to accout for the fact that
	@@the set @ctype is actually the name of a macro that already includes
	@@the name of the argument (meaning that the name mustn't be written twice)
	public member protoTypeName: string | UserString;

	@@C Typing of this argument.
	@@NOTE: Ellipsis arguments have this field set to @CType("...")
	public member ctype: CType;

	@@Output @this @Argument to a @CWriter
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprint(fp: CWriter, escapeMode: int) {
		ctype.cprint(fp, escapeMode, protoTypeName);
	}

	public operator hash(): int -> Object.id(this);
	public operator == (other: Argument): bool -> this === other;
	public operator != (other: Argument): bool -> this !== other;
}

class FunctionPrototype {
	this = default;

	@@List of attributes that should be applied to this function (e.g. @{ "ATTR_NORETURN" })
	public member attributes: {(string | UserString)...} = ();

	@@The nothrow behavior of this function. Should be one of:
	@@  - @"":                   Unspecified (assume THROWING, but don't warn if used from NOTHROW)
	@@  - @"NOTHROW":            Function doesn't throw
	@@  - @"NOTHROW_NCX":        Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS)
	@@  - @"NOTHROW_RPC":        Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS)
	@@  - @"NOTHROW_RPC_KOS":    Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS) && defined(__KOS__)
	@@  - @"NOTHROW_RPC_NOKOS":  Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS) && !defined(__KOS__)
	@@  - @"NOTHROW_RPC_PURE":   Function is nothrow when: #if defined(__NO_RPC_EXCEPTIONS)
	@@  - @"THROWS(...)":        Function can throw and should be warned about if used from NOTHROW.
	@@                           The given @"..." is a comma-seperated list of `E_*' codes from <kos/except.h>
	public member nothrow: string | UserString = "";

	@@Calling convention of this function prototype (e.g. @"ATTR_CDECL")
	@@Set to an empty string to use the default calling convention.
	public member cc: string | UserString = "";

	@@The type that is returned by this function prototype
	public member returnType: CType;

	@@The actual List of arguments
	public member argv: {Argument...} = ();

	@@When set to non-@none, these are the types of the arguments passed through ellipsis
	@@This information can be helpful when trying to construct an argument list
	public member ellipsisArgumentTypes: {CType...} = none;

	@@Pieces of code that must be written before @this @FunctionPrototype can be printed
	@@NOTE: These prefixes are only printed in local function implementations, as well as
	@@      their dependencies, as well as the dependencies of inline functions
	public member declPrefix: {(string | UserString)...} = ();

	@@Returns @true if this prototype contains a @"ATTR_NORETURN" attribute
	public property isNoreturn: bool = {
		get(): bool {
			for (local at: attributes) {
				if (at in ["ATTR_NORETURN", "__ATTR_NORETURN"])
					return true;
			}
			return false;
		}
	}

	@@Returns @true if @nothrow describes @"THROWS(...)"
	public property isNothrowThrowing: bool = {
		get(): bool {
			if (m_isNothrowThrowing !is bound) {
				local nts = str nothrow;
				m_isNothrowThrowing =
					nts.startswith("THROWS(") ||
					nts.startswith("__THROWS(");
			}
			return m_isNothrowThrowing;
		}
	}
	private member m_isNothrowThrowing: bool;

	@@Returns @"__THROWING" or @"THROWING" based on the escape-state of @nothrow
	@@The caller must ensure that @isNothrowThrowing is @true
	public property nothrowThrowingSpec: string = {
		get(): bool {
			local nts = str nothrow;
			if (nts.startswith("THROWS("))
				return "THROWING";
			return "__THROWING";
		}
	}


	public property argsByName: {string: Argument} = {
		get(): {string: Argument} {
			if (m_argsByName !is bound) {
				m_argsByName = Dict();
				for (local a: argv) {
					local usedName = str a.name;
					if (usedName)
						m_argsByName[usedName] = a;
				}
			}
			return m_argsByName;
		}
	}
	private member m_argsByName: {string: Argument};

	public operator # (): string -> #argv;
	public operator [] (i: int): Argument -> argv[i];

	@@Evaluate to @true if @this @FunctionPrototype ends with an ellipsis argument (i.e. @"...")
	public property hasEllipsis: bool = {
		get(): bool {
			return argv && argv.last.ctype.beforeName == "...";
		}
	}

	@@Print the attribute list (returns @false if
	@@nothing was printed, and @true otherwise)
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintAttributeList(fp: CWriter, escapeMode: int): bool {
		local isFirst = true;
		for (local attr: attributes) {
			if (!isFirst)
				fp << " ";
			escapeTextIntoFile(fp, attr, escapeMode);
			isFirst = false;
		}
		return !isFirst;
	}

	@@Output the argument list including types to @fp
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintArgumentListWithTypes(fp: CWriter, escapeMode: int) {
		local isFirst = true;
		fp << "(";
		if (!argv)
			fp << "void";
		else {
			for (local arg: argv) {
				if (!isFirst)
					fp << ", ";
				arg.cprint(fp, escapeMode);
				isFirst = false;
			}
		}
		fp << ")";
	}

	@@Output the argument list excluding types to @fp
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintArgumentListWithoutTypes(fp: CWriter, escapeMode: int) {
		local isFirst = true;
		fp << "(";
		for (local arg: argv) {
			if (!isFirst)
				fp << ",";
			escapeTextIntoFile(fp, arg.protoTypeName, escapeMode);
			isFirst = false;
		}
		fp << ")";
	}

	@@Print a declaration akin to:
	@@> __LIBC __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t __NOTHROW_NCX(__LIBCCALL strlen)(char const *__restrict __str) __CASMNAME_SAME("open");
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintDeclarationWithOptionalAsmname(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string) {
		local isLcl = isLibcLinkage(decl, cc, assemblyName);
		local isSameAsname = exposedName == assemblyName && fp.externLinkage in ["", "C"];
		if (isLcl) {
			if (isSameAsname)
				return cprintDeclarationCDECLARE(fp, escapeMode, decl, exposedName);
			return cprintRedirectDeclaration(fp, escapeMode, decl, exposedName, assemblyName);
		}
		/* Same symbol name -> declare normally (or with `__ASMNAME()' suffix) */
		cprintDeclarationWithoutTerminator(fp, escapeMode, decl, exposedName);
		if (isLcl) {
			fp << " __CASMNAME";
			local suffix = "";
			if (assemblyName.startswith("DOS$")) {
				suffix       = "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				suffix       = "_KOS";
				assemblyName = assemblyName[4:];
			}
			if (isSameAsname)
				fp << "_SAME";
			fp << suffix << "(" << repr(assemblyName) << ")";
		} else if (!isSameAsname) {
			fp << " __ASMNAME(" << repr(assemblyName) << ")";
		}
		fp << ";\n";
	}

	@@Print a declaration akin to:
	@@> __CDECLARE(__ATTR_WUNUSED __ATTR_NONNULL((1)),__SIZE_TYPE__,__NOTHROW_NCX,wcslen,(__WCHAR_TYPE__ const *__restrict __str),(__str))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintDeclarationCDECLARE(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string) {
		/* Special case: Make use of __CDECLARE */
		local isVoidReturn = returnType.isVoid;
		fp << "__CDECLARE";
		if (isVoidReturn)
			fp << "_VOID";
		fp << "(";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		fp << ",";
		/* Return type */
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		/* Exposed name */
		fp << "," << exposedName << ",";
		cprintArgumentListWithTypes(fp, escapeMode);
		fp << ",";
		cprintArgumentListWithoutTypes(fp, escapeMode);
		fp << ")\n";
	}

	@@Print a declaration akin to:
	@@> __LIBC __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t
	@@> __NOTHROW_NCX(__LIBCCALL strlen)(char const *__restrict __str)
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintDeclarationWithoutTerminator(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string) {
		/* Same symbol name -> declare normally */
		escapeTextIntoFile(fp, decl, escapeMode);
		if (decl)
			fp << " ";
		if (cprintAttributeList(fp, escapeMode))
			fp << " ";
		if (returnType.cprint(fp, escapeMode))
			fp << " ";
		if (!isNothrowThrowing)
			escapeTextIntoFile(fp, nothrow, escapeMode);
		fp << "(";
		escapeTextIntoFile(fp, cc, escapeMode);
		if (cc)
			fp << " ";
		fp << exposedName << ")";
		cprintArgumentListWithTypes(fp, escapeMode);
		if (isNothrowThrowing)
			escapeTextIntoFile(fp, nothrowThrowingSpec, escapeMode);
	}

	@@Print a declaration akin to:
	@@> FORCELOCAL __ATTR_PURE __ATTR_WUNUSED __ATTR_NONNULL((1)) __SIZE_TYPE__
	@@> __NOTHROW_NCX(__LIBCCALL wcslen)(wchar_t const *__restrict __string) {
	@@> return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))(__string); }
	@@If the types from @callToPrototype different from those in @this prototype,
	@@insert casts where- and as necessary.
	@@NOTE: This function will not print a trailing line-feed after the declaration!
	@@@param: escapeMode:      One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:            In the above example: @"FORCELOCAL"
	@@@param: exposedName:     In the above example: @"wcslen"
	@@@param: callToName:      In the above example: @"(__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))"
	@@@param: callToPrototype: In the above example: @(allLocalFunctionsByName["wcslen"].prototype)
	public function cprintCallToAliasDeclaration(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			callToName: string, callToPrototype: FunctionPrototype) {
		cprintDeclarationWithoutTerminator(fp, escapeMode, decl, exposedName);
		fp << " { return ";
		if (!callToPrototype.returnType.implicitlyConvertibleTo(returnType))
			returnType.cprintCCastPrefix(fp, escapeMode);
		fp << callToName << "(";
		local argc = #callToPrototype.argv;
		local isFirst = true;
		for (local argi: [:argc]) {
			if (!isFirst)
				fp << ", ";
			isFirst = false;
			local arg = callToPrototype.argv[argi];
			if (argi >= #argv) {
				/* Shouldn't happen... */
				arg.ctype.cprintCCastPrefix(fp, escapeMode);
				fp << "0";
				continue;
			}
			local myArg = this.argv[argi];
			if (!myArg.ctype.implicitlyConvertibleTo(arg.ctype))
				arg.ctype.cprintCCastPrefix(fp, escapeMode);
			escapeTextIntoFile(fp, myArg.name, escapeMode);
		}
		fp << "); }";
	}

	@@Print a declaration akin to:
	@@> __REDIRECT(__LIBC,__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,__NOTHROW_NCX,
	@@>            __LIBCCALL,strlen,(char const *__str),strlen_alias,(__str))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintRedirectDeclaration(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string) {
		local isLcl = isLibcLinkage(decl, cc, assemblyName);
		fp << (isLcl ? "__CREDIRECT" : "__REDIRECT");
		local isVoidReturn = returnType.isVoid;
		if (isVoidReturn)
			fp << "_VOID";
		if (isLcl) {
			if (assemblyName.startswith("DOS$")) {
				fp << "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				fp << "_KOS";
				assemblyName = assemblyName[4:];
			}
		}
		fp << "(";
		/* Linkage */
		if (!isLcl)
			fp << decl << ",";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		/* Return type */
		fp << ",";
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		fp << ",";
		/* Calling convention */
		if (!isLcl) {
			escapeTextIntoFile(fp, cc, escapeMode);
			fp << ",";
		}
		/* Exposed symbol name */
		fp << exposedName << ",";
		/* Argument list */
		cprintArgumentListWithTypes(fp, escapeMode);
		/* Assembly import symbol name */
		fp << "," << assemblyName << ",";
		/* Argument names */
		cprintArgumentListWithoutTypes(fp, escapeMode);
		fp << ")\n";
	}

	@@Print a redirection- or declaration-binding, based on
	@@the exposed- and assembly name being the same
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintRedirectionBinding(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string) {
		if (exposedName != assemblyName || fp.externLinkage !in ["", "C"]) {
			cprintRedirectDeclaration(
				fp, escapeMode, decl, exposedName, assemblyName);
			return;
		}
		cprintDeclarationWithOptionalAsmname(
			fp, escapeMode, decl, exposedName, assemblyName);
	}

}


class FunctionImplementation {
	this = default;

	@@The actual local implementation body of this function
	@@NOTE: This string has already been fully escaped!
	public member body: string | UserString;

	@@Name of the function itself within the implementation
	public member name: string | UserString;

	@@Pieces of code that must be written before @impl can be generated
	@@This code is inserted at the global namespace scope!
	public member implPrefix: {(string | UserString)...} = ();

	@@Other functions for which prototypes (though not necessarily c++ overloads) must
	@@be provided in order to use this implementation. Functions that appear in this
	@@list will be linked locally by their specified names.
	@@This mapping usually takes the form @("__localdep_strlen" : "strlen")
	@@NOTE: When this points to a Callable object, then that function is
	@@      invoked and should then return one of the other accepted types.
	@@NOTE: Additionally, this member may also be assigned a Callable object,
	@@      in which case that object's return value is used as the dependencies
	@@      @Mapping
	public member dependencies
		: {string: (string | UserString | Function | Callable)} | Callable = none;

	@@Same as @dependencies, but enumerate the actual Function objects
	public property dependencyFunctions: {string: Function} = {
		get(): {Function...} {
			if (m_dependencyFunctions !is bound) {
				m_dependencyFunctions = Dict();
				local usedDeps = dependencies;
				if (usedDeps is Callable)
					usedDeps = usedDeps();
				for (local name, elem: usedDeps) {
					if (elem !is Function) {
						if (elem is Callable)
							elem = elem();
						elem = findFunctionByName(elem);
					}
					m_dependencyFunctions[name] = elem;
				}
			}
			return m_dependencyFunctions;
		}
	}
	private member m_dependencyFunctions: {string: Function};

	@@Truncate @body for use in a truncated inline function binding
	public function truncateBodyForInline(): FunctionImplementation {
		local result = copy this;
		local newBody = result.body;
		/* Simple: Unescape escaped line-feeds */
		newBody = newBody.replace("\\\n", "");
		/* TODO:
		 *  - Delete all C/C++-style comments from @result.body
		 *  - Replace all new-line characters from @result.body with " ",
		 *    except for those that was followed by an arbitrary amount
		 *    of whitespace, followed by a "#"-character. However, also
		 *    make
		 *  - Replace all instances of multiple consecutive space characters
		 *    with only a single space character, except for those that appear
		 *    in string-/character-literals
		 */
		/* TODO: This is hacky, and imperfect! (See the above comment) */
		newBody = newBody.replace("\n", " ").replace("\t", " ");
		for (;;) {
			local temp = newBody.replace("  ", " ");
			if (temp == newBody)
				break;
			newBody = temp;
		}
		result.body = newBody;
		return result;
	}

	@@Print everything necessary for this implmentation
	@@@param: dependencyDecl: Declaration prefix for dependencies (usually @"__LIBC")
	@@@param: escapeMode:     One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: keyDependency:  Transformation key for the names of dependent functions
	public function cprintLocalFunctionImplementation(
			fp: CWriter, escapeMode: int, name: string,
			prototype: FunctionPrototype, dependencyDecl: string,
			doc: string, namespace: Namespace,
			keyDependency: Callable with string) {
		fp.forceStartOfLine();
		local oldNs = fp.namespace;
		fp.namespace = namespace;
		local oldExternLinkage = fp.externLinkage;
		if (oldExternLinkage !in ["", "C"])
			fp.externLinkage = "";
		/* Bind dependent functions. */
		local deps = dependencyFunctions;
		for (local depName, depFun: deps) {
			fp << "/* Dependency: "
				<< depFun.name << " from "
				<< depFun.originalSystemHeaderName << " */\n";
			depName = keyDependency(depName);
			depFun.cprintHeaderDeclaration(
				fp, escapeMode, dependencyDecl,
				exposedName: depName,
				guardName:   namespace.keyDefaultGuard(depName),
				preferBindingMacros:      true,
				printDeclarationPrefixes: true);
		}
		if (implPrefix) {
			fp.namespace = GLOBAL_NAMESPACE;
			for (local x: implPrefix)
				escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
			fp.namespace = namespace;
		}
		if (doc)
			fp.printComment(doc);
		fp << "__LOCAL_LIBC(" << name << ") ";
		if (prototype.cprintAttributeList(fp, escapeMode))
			fp << " ";
		prototype.returnType.cprint(fp, escapeMode);
		fp << "\n";
		if (!prototype.isNothrowThrowing)
			escapeTextIntoFile(fp, prototype.nothrow, escapeMode);
		fp << "(";
		escapeTextIntoFile(fp, prototype.cc, escapeMode);
		if (prototype.cc)
			fp << " ";
		local csymbolName = namespace.keyCSymbolName(name);
		fp << csymbolName << ")";
		prototype.cprintArgumentListWithTypes(fp, escapeMode);
		if (prototype.isNothrowThrowing) {
			fp << " ";
			escapeTextIntoFile(fp, prototype.nothrow, escapeMode);
		}
		fp << " ";
		local selfName = this.name;
		escapeTextIntoFile(fp, body, escapeMode,
			keyEscape: [](keyword: string): string {
				if (keyword == selfName)
					return csymbolName;
				if (keyword in deps)
					return keyDependency(keyword);
				return none;
			},
			forceKeyEscape: true
		);
		fp << "\n";
		fp.externLinkage = oldExternLinkage;
		fp.namespace = oldNs;
	}
}


@@Only used by the @(import .loader)
class LoaderFunctionImplementation {
	this = default;
	public member impl: FunctionImplementation;
	public member ppCond: string | UserString = "1";
	public member ppCondPrefix: {(string | UserString)...} = ();
}



class LocalFunction {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of this local function (e.g. "strlen")
	public member name: string | UserString;

	@@Name of this declaring system header (e.g. "string" for <string.h>)
	public member originalSystemHeaderName: string | UserString;

	@@The prototype adhered to by all local implementation variants
	public member prototype: FunctionPrototype | Callable;

	@@Preprocessor conditions that must be met in order
	@@for this local function implementation to be chosed.
	public member ppCond: string | UserString = "1";

	@@Pieces of code that must be written before @ppCond can be evaluated
	@@This code is inserted at the global namespace scope!
	public member ppCondPrefix: {(string | UserString)...} = ();

	@@The bound implementation for the local function
	public member impl: FunctionImplementation | Callable;

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Helper wrapper for @prototype that will automatically unwind @Callable objects
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				prototype = result = result();
			return result;
		}
	}

	@@Wrapper for @impl that will automatically unwind @Callable bindings
	public property functionImpl: FunctionImplementation = {
		get(): FunctionImplementation {
			local result = impl;
			if (result is Callable)
				result = impl = result();
			return result;
		}
	}

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				documentation = result = result();
			return result;
		}
	}

	@@@param: dependencyDecl: Declaration prefix for dependencies (usually @"__LIBC")
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintLocalFunctionHeader(
			fp: CWriter, escapeMode: int, dependencyDecl: string,
			keyDependency: Callable with string = none, printCopyright: bool = true) {
		if (keyDependency is none)
			keyDependency = keyLocalDep;
		if (printCopyright)
			fp << COPYRIGHT << "\n";
		local usedPrototype = functionPrototype;
		local localGuardName = LOCAL_NAMESPACE.keyDefaultGuard(name);
		fp.ppIfndef(localGuardName);
		fp.ppDefine(localGuardName, "1");
		fp.ppInclude("<__crt.h>");
		/* Include the preprocessor-condition prefix texts. */
		for (local x: ppCondPrefix)
			escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
		fp.ppIf(expandPreprocessorConditionString(ppCond));
		/* Print out the declaration prefix. */
		for (local x: usedPrototype.declPrefix)
			escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
		fp.forceStartOfLine();
		/* Print the binding */
		functionImpl.cprintLocalFunctionImplementation(
			fp, escapeMode, name, usedPrototype,
			dependencyDecl, documentationString,
			LOCAL_NAMESPACE, keyDependency);
		fp.ppElse();
		fp.ppUndef(localGuardName);
		fp.ppEndif();
		fp.ppEndif();
	}

	@@Print a binding for this function
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintFunctionBinding(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			prototypes: {FunctionPrototype...}, doc: string, preferBindingMacros: bool) {
		local usedPrototype = functionPrototype;
		local oldNs = fp.namespace;
		fp.namespace = GLOBAL_NAMESPACE;
		local oldExternLinkage = fp.externLinkage;
		if (oldExternLinkage !in ["", "C"])
			fp.externLinkage = "";
		/* Include the local-header for this function */
		fp.ppInclude("<local/{}/{}.h>".format({ originalSystemHeaderName, name }));
		/* Remember that we'll be needing the local implementation of this function */
		neededLocalFunction.insert(this);
		fp.namespace = oldNs;
		fp.externLinkage = oldExternLinkage;
		local callToLocalName = LOCAL_NAMESPACE.keyCSymbolName(name);
		if (oldNs === GLOBAL_NAMESPACE) {
			if (LOCAL_NAMESPACE.prefix)
				callToLocalName = "{} {}".format({ LOCAL_NAMESPACE.prefix, callToLocalName });
			callToLocalName = "({})".format({ callToLocalName });
		}
		if (preferBindingMacros) {
			/* TODO: Need to cast arguments if prototypes don't match up */
			if (doc)
				fp.printComment(doc);
			fp << "#define " << exposedName << " " << callToLocalName;
			return;
		}
		for (local ptype: prototypes) {
			if (doc)
				fp.printComment(doc);
			if (exposedName == name) {
				/* TODO: Can only be done if the prototypes match up! */
				LOCAL_NAMESPACE.keyUsingOrImpl(fp, exposedName, []{
					ptype.cprintCallToAliasDeclaration(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, callToLocalName, usedPrototype);
				});
			} else {
				ptype.cprintCallToAliasDeclaration(
					fp, escapeMode, NAMESPACE_IMPORT_DECL,
					exposedName, callToLocalName, usedPrototype);
				fp << "\n";
			}
		}
	}

}

class InlineFunction {
	this = default;

	@@Inline mode. One of:
	@@  - @"LOCAL"
	@@  - @"FORCELOCAL"
	@@  - @"__EXTERNINLINE"
	public member mode: string = "LOCAL";

	@@The different, possible methods by which this function can be implemented.
	@@During compile-time, the first variant is chosen for which
	@@the @ppCond evaluates to a true-expression
	public member impl: FunctionImplementation | Callable = ();

	@@Name of the assembly symbol against which
	@@to link in case @(mode == "__EXTERNINLINE")
	public member externInlineAsmname: string | UserString;

	@@Returns @impl, but will unwind @Callable wrappers
	public property functionImpl: FunctionImplementation = {
		get(): FunctionImplementation {
			local result = impl;
			if (result is Callable)
				result = impl = result();
			return result;
		}
	}

	@@Bind the inline function's body.
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintFunctionBinding(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			prototypes: {FunctionPrototype...}, doc: string,
			preferBindingMacros: bool, keyDependency: Callable with string = none,
			dependenciesNamespace: Namespace = none, dependencyDecl: string = "__LIBC") {
		local impl: FunctionImplementation = functionImpl;
		local implName = impl.name;
		if (impl.implPrefix) {
			local oldNs = fp.namespace;
			fp.namespace = GLOBAL_NAMESPACE;
			local oldExternLinkage = fp.externLinkage;
			if (oldExternLinkage !in ["", "C"])
				fp.externLinkage = "";
			for (local x: impl.implPrefix)
				escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
			fp.externLinkage = oldExternLinkage;
			fp.namespace = oldNs;
		}
		/* Bind dependent functions. */
		local deps = impl.dependencyFunctions;
		local depKey = none;
		if (deps) {
			if (dependenciesNamespace is none)
				dependenciesNamespace = NAMESPACES["local"];
			if (keyDependency is none)
				keyDependency = keyLocalDep;
			depKey = [](keyword: string): string {
				if (keyword == implName)
					return exposedName;
				if (keyword in deps) {
					local res = keyDependency(keyword);
					if (fp.namespace === dependenciesNamespace)
						return res;
					return "({} {})".format({
						dependenciesNamespace.prefix,
						res
					});
				}
				return none;
			};
			local oldNs = fp.namespace;
			fp.namespace = dependenciesNamespace;
			local oldExternLinkage = fp.externLinkage;
			if (oldExternLinkage !in ["", "C"])
				fp.externLinkage = "";
			for (local depName, depFun: deps) {
				depName = keyDependency(depName);
				depFun.cprintHeaderDeclaration(fp, escapeMode, dependencyDecl,
					exposedName:              depName,
					guardName:                dependenciesNamespace.keyDefaultGuard(depName),
					preferBindingMacros:      true,
					printDeclarationPrefixes: true);
			}
			fp.externLinkage = oldExternLinkage;
			fp.namespace = oldNs;
		} else {
			depKey = [](keyword: string): string {
				if (keyword == implName)
					return exposedName;
				return none;
			};
		}
		for (local prototype: prototypes) {
			if (doc)
				fp.printComment(doc);
			if (mode == "__EXTERNINLINE") {
				local assemblyName = str externInlineAsmname;
				local isLcl = isLibcLinkage(decl, prototype.cc, assemblyName);
				local isRedirect = exposedName != assemblyName;
				fp << (isLcl
					   ? isRedirect ? "__CEIREDIRECT" : "__CEIDECLARE"
					   : isRedirect ? "__EIREDIRECT" : "__EIDECLARE");
				if (isRedirect && isLcl) {
					if (assemblyName.startswith("DOS$")) {
						fp << "_DOS";
						assemblyName = assemblyName[4:];
					} else if (assemblyName.startswith("KOS$")) {
						fp << "_KOS";
						assemblyName = assemblyName[4:];
					}
				}
				fp << "(";
				if (!isLcl)
					fp << decl << ","; /* Declaration linkage */
				/* Attribute list */
				prototype.cprintAttributeList(fp, escapeMode);
				fp << ",";
				/* Return type */
				prototype.returnType.cprint(fp, escapeMode);
				fp << ",";
				/* NOTHROW behavior */
				escapeTextIntoFile(fp, prototype.isNothrowThrowing
					? prototype.nothrowThrowingSpec
					: prototype.nothrow, escapeMode);
				if (!isLcl)
					fp << prototype.cc << ","; /* Calling convention */
				/* Exposed name */
				fp << "," << exposedName << ",";
				prototype.cprintArgumentListWithTypes(fp, escapeMode);
				fp << ",";
				if (isRedirect)
					fp << assemblyName << ",";
				/* Inline implementation */
				escapeTextIntoFile(
					fp, impl.body, escapeMode,
					keyEscape: depKey,
					forceKeyEscape: true);
				fp << ")\n";
			} else {
				/* Generic inlining (use the inlining mode as declaration prefix) */
				prototype.cprintDeclarationWithoutTerminator(
					fp, escapeMode, this.mode, exposedName);
				fp << " ";
				escapeTextIntoFile(
					fp, impl.body, escapeMode,
					keyEscape: depKey,
					forceKeyEscape: true);
				fp << "\n";
			}
		}
	}
}




class FunctionBinding {
	this = default;

	@@Preprocessor condition that must be evaluate to true at compile-time
	@@in order for this binding to be considered usable by the hosting compiler.
	public member ppCond: string | UserString = "1";

	@@Pieces of code that must be written before @ppCond can be evaluated
	@@This code is inserted at the global namespace scope!
	public member ppCondPrefix: {(string | UserString)...} = ();

	@@Prototype selectors (usually simply @({ "1", { <primaryPrototype> } }))
	@@This is a list of pairs (ppCond, prototypes) to select which prototypes
	@@should be used to bind the function.
	@@Different prototypes can be provided with a dependency on some preprocessor
	@@expression in order to support CORRECT_ISO_CXX_OVERLOADS declarations.
	@@NOTE: In practice, the preprocessor conditions for prototype selection
	@@      should always be done such that a prototype will exist in all
	@@      conditions. However, this is not a requirement.
	public member prototypes: {(string | UserString, {FunctionPrototype...})...} | Callable = ();

	@@The actual binding provided by this function:
	@@  - @LocalFunction:  Provide a local function implementation, via inclusion of
	@@                     <local/@(binding.originalSystemHeaderName)/@(binding.name).h>
	@@  - @InlineFunction: Provide an in-line function implementation, possibly alongside
	@@                     support for @"__EXTERNINLINE"
	@@  - @string:         External assembly symbol (bind the function against
	@@                     an assembly symbol by the name of @binding)
	@@  - @UserString:     Same as @string
	@@  - @Namespace:      Import an existing declaration from some other namespace
	@@  - @Callable:       A callback that takes no arguments, and returns one of the above
	public member binding: LocalFunction | InlineFunction | string | UserString | Namespace | Callable;

	public property functionPrototypes: {(string | UserString, {FunctionPrototype...})...} = {
		get(): {(string | UserString, {FunctionPrototype...})...} {
			local result = prototypes;
			if (result is Callable)
				result = prototypes = result();
			return result;
		}
	}

	@@Return @binding, but unwind @Callable wrappers
	public property functionBinding: LocalFunction | InlineFunction | string | UserString | Namespace = {
		get(): LocalFunction | InlineFunction | string | UserString | Namespace {
			local result = binding;
			if (result is Callable)
				result = binding = result();
			return result;
		}
	}

	@@Simple helper to peek if the ppCond part of @this binding is known already
	@@Note that it may become known at a later point in time, and that this function
	@@may not necessary detect it as being known. Only note that a return value
	@@other than @none indicates a guarantied, known value
	public function getRequiresConstant(): bool | none {
		local usedProtos = functionPrototypes;
		if (!usedProtos || ppCond == "0")
			return false;
		local hasBindablePrototype = false;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "1") {
				/* Universal prototype */
				if (ppCond == "1")
					return true;
				return none;
			} else if (protoCond != "0") {
				hasBindablePrototype = true;
			}
		}
		if (!hasBindablePrototype)
			return false;
		return none;
	}

	@@Print requires-conditions for this function (has used by @"$has_function(...)")
	public function cprintRequires(fp: CWriter | File) {
		local usedProtos = functionPrototypes;
		if (!usedProtos || ppCond == "0") {
			fp << "0";
			return;
		}
		local hasUniversalPrototype = false;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "1") {
				hasUniversalPrototype = true;
				break;
			}
		}
		if (hasUniversalPrototype) {
			printPreprocessorConditionString(fp, ppCond);
			return;
		}
		if (ppCond != "1") {
			fp << "((";
			printPreprocessorConditionString(fp, ppCond);
			fp << ")&&";
		}
		local hasMultiplePrototypes = 0;
		for (local protoCond, none: usedProtos) {
			if (protoCond != "0")
				++hasMultiplePrototypes;
		}
		if (hasMultiplePrototypes > 1)
			fp << "(";
		local isFirst = true;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "0")
				continue;
			if (!isFirst)
				fp << "||";
			fp << "(";
			printPreprocessorConditionString(fp, protoCond);
			fp << ")";
			isFirst = false;
		}
		if (hasMultiplePrototypes > 1)
			fp << ")";
		if (ppCond != "1")
			fp << ")";
	}

	@@Print a normal binding, as may be found in `<string.h>`
	@@NOTE: The caller is responsible to ensure that @ppCond evaluates to non-zero at compile-time
	@@@param: escapeMode:          One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:                Declaration prefix (e.g. @"__LIBC")
	@@@param: exposedName:         The name by which to expose this binding (e.g. @"strlen")
	@@@param: doc:                 A human-readable description of the associated function
	@@@param: guardName:           The name of a macro that must be #undef'd if no prototype
	@@                             has been exposed at compile-time. Set to @none if no such macro exists
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	public function cprintBindFunction(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			guardName: string | none = none, doc: string = "",
			preferBindingMacros: bool = false,
			printDeclarationPrefixes: bool = false) {
		local usedBinding = functionBinding;
		if (usedBinding is Namespace) {
			assert usedBinding !== fp.namespace, "The caller must check this!";
			local nsCName = usedBinding.keyCSymbolName(exposedName);
			if (nsCName == exposedName) {
				/* Simple case: C doesn't perform any name mangling.
				 * This is the case for functions imported from  */
				usedBinding.keyUsing(fp, nsCName);
			} else {
				usedBinding.keyUsingOrImpl(fp, nsCName, []{
					fp << "/* TODO: IMPORT-MANGLED-C-FUNCTION-FROM-NAMESPACE */";
				});
			}
			return;
		}
		local isFirst = true;
		if (printDeclarationPrefixes) {
			/* TODO: Print declaration prefixes common to all of @functionPrototypes,
			 *       so-long as at least one of @functionPrototypes has a ppCond that
			 *       always evaluates to true */
		}
		for (local ppCond, associatedPrototypes: functionPrototypes) {
			ppCond = expandPreprocessorConditionString(ppCond);
			if (isFirst)
				fp.ppIf(ppCond);
			else {
				fp.ppElif(ppCond);
			}
			isFirst = false;
			if (printDeclarationPrefixes) {
				/* Print declaration prefixes */
				for (local proto: associatedPrototypes) {
					for (local x: proto.declPrefix)
						escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
				}
			}
			if (usedBinding !is string && usedBinding !is UserString) {
				usedBinding.cprintFunctionBinding(
					fp, escapeMode, decl, exposedName, associatedPrototypes,
					doc, preferBindingMacros);
			} else {
				usedBinding = str usedBinding;
				for (local ptype: associatedPrototypes) {
					if (doc)
						fp.printComment(doc);
					ptype.cprintRedirectionBinding(
						fp, escapeMode, decl,
						exposedName, usedBinding);
				}
			}
		}
		if (guardName !is none) {
			if (!isFirst)
				fp.ppElse();
			fp.ppUndef(guardName);
		}
		if (!isFirst)
			fp.ppEndif();
	}
}




class Function {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of the function in public headers (e.g. @"strlen")
	public member name: string | UserString;

	@@Name of the original defining system header (may differ from the containing
	@@header in case @"%[insert:extern(...)]" was used to inject a foreign function)
	public member originalSystemHeaderName: string | UserString;

	@@Ordered list of bindings with which this function is exposed in system headers
	@@This list is enumerated, and the first binding who's @FunctionBinding.ppCond
	@@field evaluates to @true will then be used as the binding exposed.
	public member bindings: {(FunctionBinding | Callable)...} | Callable = [];

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				documentation = result = result();
			return result;
		}
	}

	@@Same as @bindings, however Callable objects will have been flattened
	public property functionBindings: {FunctionBinding...} = {
		get(): {FunctionBinding...} {
			if (m_functionBindings !is bound) {
				local usedBindings = bindings;
				if (usedBindings is Callable)
					usedBindings = usedBindings();
				local newBindings = List();
				for (local bind: usedBindings) {
					if (bind is Callable) {
						bind = bind();
						if (bind is Sequence)
							newBindings.extend(bind);
						else if (bind !is none) {
							newBindings.append(bind);
						}
					} else {
						newBindings.append(bind);
					}
				}
				m_functionBindings = newBindings;
				return newBindings;
			}
			return m_functionBindings;
		}
	}
	private member m_functionBindings: {FunctionBinding...};

//TODO:	@@Find identical bindings, and merge them into a single one
//TODO:	public function resolveDuplicateBindings() {
//TODO:		if (#functionBindings <= 1)
//TODO:			return;
//TODO:		//public member binding: LocalFunction | InlineFunction | string | UserString | Namespace | Callable;
//TODO:	}

	@@Print requires-conditions for this function (has used by @"$has_function(...)")
	public function cprintRequires(fp: CWriter | File) {
		local usedBindings = functionBindings;
		if (!usedBindings) {
no_usable_bindings:
			fp << "0";
			return;
		}
		local hasUsableBindings = 0;
		local hasUnusableBindings = false;
		for (local bind: usedBindings) {
			local c = bind.getRequiresConstant();
			if (c === true) {
				fp << "1";
				return;
			}
			if (c === false)
				hasUnusableBindings = true;
			if (c is none)
				++hasUsableBindings;
		}
		if (!hasUsableBindings)
			goto no_usable_bindings;
		if (hasUsableBindings == 1) {
			local bind;
			for (bind: usedBindings) {
				if (bind.getRequiresConstant() is none)
					break;
			}
			bind.cprintRequires(fp);
		} else {
			fp << "(";
			local isFirst = true;
			for (local bind: usedBindings) {
				if (hasUnusableBindings) {
					if (bind.getRequiresConstant() === false)
						continue;
				}
				if (!isFirst)
					fp << "||";
				bind.cprintRequires(fp);
				isFirst = false;
			}
			fp << ")";
		}
	}

	@@Print this function's normal declaration, as might be found in `<string.h>`
	@@@param: escapeMode:          One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:                The declaration prefix (e.g. @"__LIBC") with which to link
	@@@param: exposedName:         The name under which functions should be exposed (or @none
	@@                             if @this.name should be used instead)
	@@@param: guardName:           The name of a guard that should be used to wrap the declaration
	@@                             When set to @true, use fp.namespace.keyDefaultGuard(exposedName)
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	public function cprintHeaderDeclaration(
			fp: CWriter, escapeMode: int, decl: string = "__LIBC",
			exposedName: string = none, guardName: string | bool = none,
			preferBindingMacros: bool = false,
			printDeclarationPrefixes: bool = false) {
		local usedBindings = functionBindings;
		if (!usedBindings)
			return; /* No bindings -> Noop */
		if (exposedName is none)
			exposedName = this.name;
		if (guardName is bool) {
			guardName = guardName
				? fp.namespace.keyDefaultGuard(exposedName)
				: none;
		}
		if (printDeclarationPrefixes) {
			/* TODO: Print declaration prefixes common to all bindings,
			 *       when at least one one binding exists that can get
			 *       bound unconditionally. */
		}
		if (guardName !is none) {
			if (#usedBindings == 1) {
				/* Try to optimize special case: Only 1 binding
				 * Instead of writing something like this:
				 * >> #ifndef __wcslen_defined
				 * >> #define __wcslen_defined 1
				 * >> #if $has_function(wcslen) || defined(__std_wcslen_defined)
				 * >> __NAMESPACE_STD_USING(wcslen)
				 * >> #else // <$has_function(wcslen)> || __std_wcslen_defined
				 * >> #undef __wcslen_defined
				 * >> #endif // !<$has_function(wcslen)> && !__std_wcslen_defined
				 * >> #endif // !__wcslen_defined
				 *
				 * Write the following instead:
				 * >> #if !defined(__wcslen_defined) && (defined(__std_wcslen_defined) || $has_function(wcslen))
				 * >> #define __wcslen_defined 1
				 * >> __NAMESPACE_STD_USING(wcslen)
				 * >> #endif // !__wcslen_defined && (__std_wcslen_defined || $has_function(wcslen)) */
				local bind = usedBindings.first;
				/* Special case: Can't bind against a declaration from the current namespace! */
				if (bind.binding is Callable)
					bind.binding = bind.binding();
				if (bind.binding is Namespace && bind.binding === fp.namespace)
					return;
				for (local x: bind.ppCondPrefix) {
					if (!fp.wasPrefixPrinted(escapeText(x, escapeMode)))
						goto normal_guardName_binding;
				}
				fp.ppIf("!defined({}) && ({})".format({
					guardName,
					expandPreprocessorConditionString(bind.ppCond)
				}));
				fp.ppDefine(guardName, "1");
				bind.cprintBindFunction(
					fp, escapeMode, decl, exposedName, guardName,
					documentationString, preferBindingMacros,
					printDeclarationPrefixes);
				fp.ppEndif();
				return;
			}
normal_guardName_binding:
			fp.ppIfndef(guardName);
			fp.ppDefine(guardName, "1");
		}
		local isFirst = true;
		local numNeededEndif = [];
		for (local bind: usedBindings) {
			/* Special case: Can't bind against a declaration from the current namespace! */
			if (bind.binding is Namespace && bind.binding === fp.namespace)
				continue;
			local usedPpCond = expandPreprocessorConditionString(bind.ppCond);
			local oldNs: Namespace | none = none;
			local oldExternLinkage;
			for (local x: bind.ppCondPrefix) {
				local newText = escapeText(x, escapeMode);
				if (fp.wasPrefixPrinted(newText))
					continue;
				if (oldNs is none) {
					if (!isFirst) {
						fp.ppElse();
						numNeededEndif.last = false;
					}
					/* Include the preprocessor-condition prefix texts. */
					oldNs = fp.namespace;
					fp.namespace = GLOBAL_NAMESPACE;
					oldExternLinkage = fp.externLinkage;
					if (oldExternLinkage !in ["", "C"])
						fp.externLinkage = "";
				}
				fp.forceStartOfLine() << newText;
			}
			if (oldNs !is none) {
				fp.externLinkage = oldExternLinkage;
				fp.namespace = oldNs;
				fp.ppIf(usedPpCond);
				numNeededEndif.pushback(true);
			} else if (isFirst) {
				fp.ppIf(usedPpCond);
				numNeededEndif.pushback(true);
			} else {
				fp.ppElif(usedPpCond);
			}
			bind.cprintBindFunction(
				fp, escapeMode, decl, exposedName, guardName,
				documentationString, preferBindingMacros,
				printDeclarationPrefixes);
			isFirst = false;
		}
		while (numNeededEndif) {
			local l = numNeededEndif.popback();
			if (l && guardName !is none) {
				fp.ppElse();
				fp.ppUndef(guardName);
			}
			fp.ppEndif();
		}
		if (guardName !is none)
			fp.ppEndif();
	}

}


@@An optional wrapper for exposing a @Function within headers
class ExposedFunction {
	this = default;

	@@The associated function
	public member func: Function | Callable;

	@@Declaration prefix for this function exposure
	public member decl: string = "__LIBC";

	@@The actual, exposed name of the function (or @none to use @func.name instead)
	public member exposedName: string = none;

	@@The name of a guard that should be used to wrap
	@@the declaration. Set to @false to not provide a guard
	@@NOTE: When set to @true, use fp.namespace.keyDefaultGuard(exposedName)
	public member guardName: string | bool = false;

	@@Prefer function bindings to be done with macros,
	@@rather than through use of inline functions.
	public member preferBindingMacros: bool = false;

	@@Print @FunctionPrototype.declPrefix
	public member printDeclarationPrefixes: bool = false;

	@@An override for the active namespace during function declaration
	public member namespaceOverride: Namespace | UserString | string | none = none;

	@@An override for the active `extern "<externLinkage>"` during function declaration
	public member externLinkageOverride: string | none = none;

	@@Print this function's normal declaration, as might be found in `<string.h>`
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintHeaderDeclaration(fp: CWriter, escapeMode: int) {
		local oldNs = fp.namespace;
		if (namespaceOverride !is none)
			fp.namespace = namespaceOverride;
		local oldExternLinkage = fp.externLinkage;
		if (externLinkageOverride !is none)
			fp.externLinkage = externLinkageOverride;
		if (func is Callable)
			func = func();
		func.cprintHeaderDeclaration(
			fp, escapeMode, decl, exposedName,
			guardName, preferBindingMacros,
			printDeclarationPrefixes);
		fp.externLinkage = oldExternLinkage;
		fp.namespace = oldNs;
	}

}




class LibraryFunctionBinding {
	this = default;

	@@Preprocessor condition that must be evaluate to true at compile-time in
	@@order for this implementation to be considered usable by the hosting compiler.
	public member ppCond: string | UserString = "1";

	@@Binding, which is either a @FunctionImplementation,
	@@specifying how the function should actually be implemented,
	@@or is the symbol name of some other function for which this
	@@one should be defined as an INTERN-ALIAS
	public member binding: FunctionImplementation | string | UserString | Callable;

	@@Name of the section in which this function's body should be
	@@placed in order to provide the libc auto- or user-implementations
	@@NOTE: Ignored when binding isn't a @FunctionImplementation
	public member implSection: string | UserString | none = none;

	@@Returns @binding, but unwind @Callable wrappers
	public property functionBinding: FunctionImplementation | string | UserString = {
		get(): FunctionImplementation | string | UserString {
			local result = binding;
			if (result is Callable)
				result = binding = result();
			return result;
		}
	}
}

class LibraryFunction {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of the function in public headers (e.g. @"strlen")
	public member name: string | UserString;

	@@Preprocessor condition that must be evaluate to true at compile-time
	@@in order for this library function to actually be implemented.
	public member ppCond: string | UserString = "1";

	@@Name of the original defining system header (may differ from the containing
	@@header in case @"%[insert:extern(...)]" was used to inject a foreign function)
	public member originalSystemHeaderName: string | UserString;

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Prototype used for the library implementation
	public member prototype: FunctionPrototype | Callable;

	@@The different ways by which this library function can be implemented.
	public member bindings: {(LibraryFunctionBinding | Callable)...} | Callable = [];

	@@Pairs of @(ppCond, symbolName) of how @this Binding should be exported from the library.
	public member exportSymbolNames: {(string | UserString, string | UserString)...} = [];

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				documentation = result = result();
			return result;
		}
	}

	@@Helper wrapper for @prototype to automatically unwind callable objects
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				result = prototype = result();
			return result;
		}
	}

	@@Helper wrapper for @bindings that automates invocation of Callable objects
	public property functionBindings: {LibraryFunctionBinding...} = {
		get(): {LibraryFunctionBinding...} {
			if (m_functionBindings !is bound) {
				local usedBindings = bindings;
				if (usedBindings is Callable)
					usedBindings = usedBindings();
				local newBindings = [];
				for (local b: usedBindings) {
					if (b is Callable)
						b = b();
					if (b is Sequence) {
						newBindings.extend(b);
					} else if (b !is none) {
						newBindings.append(b);
					}
				}
				m_functionBindings = newBindings;
				return newBindings;
			}
			return m_functionBindings;
		}
	}
	private member m_functionBindings: {LibraryFunctionBinding...};

	@@Print the in-library declaration of this function
	public function cprintInLibraryDeclaration(
			fp: CWriter, escapeMode: int, decl: string) {
		local usedBindings = functionBindings;
		if (!usedBindings)
			return;
		fp.ppIf(ppCond);
		local isFirst = true;
		local doc = documentationString;
		local proto = functionPrototype;
		for (local bind: usedBindings) {
			if (isFirst) {
				fp.ppIf(bind.ppCond);
			} else {
				fp.ppElIf(bind.ppCond);
			}
			if (doc)
				fp.printComment(doc);
			proto.cprintDeclarationWithoutTerminator(
				fp, escapeMode, decl: decl, exposedName: this.name);
			fp << ";\n";
			isFirst = false;
		}
		if (!isFirst)
			fp.ppEndif();
		fp.ppEndif();
	}

	@@Print the in-library auto-implementation of this function
	public function cprintInLibraryAutoImplementation(
			fp: CWriter, escapeMode: int, decl: string) {
		local usedBindings = functionBindings;
		if (!usedBindings)
			return;
		fp.ppIf(ppCond);
		local isFirst = true;
		local doc = documentationString;
		local proto = functionPrototype;
		for (local bind: usedBindings) {
			if (isFirst) {
				fp.ppIf(bind.ppCond);
				isFirst = false;
			} else {
				fp.ppElIf(bind.ppCond);
			}
			local impl: FunctionImplementation | string | UserString = bind.functionBinding;
			if (impl is FunctionImplementation) {
				for (local x: impl.implPrefix)
					escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
				/* TODO: Include @impl.implementationSection as @"ATTR_SECTION(...)"! */
				if (doc)
					fp.printComment(doc);
				proto.cprintDeclarationWithoutTerminator(
					fp, escapeMode, decl: decl, exposedName: this.name);
				escapeTextIntoFile(fp, impl.body, escapeMode,
					[](keyword: string): string {
						if (keyword == impl.implementationName)
							return this.name;
						local depFun = impl.dependencyFunctions.get(keyword);
						if (depFun !is none)
							return depFun.name;
						return none;
					},
				);
				fp.forceStartOfLine();
			} else {
				fp << "DEFINE_" << decl << "_ALIAS("
					<< this.name << ", "
					<< impl << ");\n";
			}
		}
		if (!isFirst)
			fp.ppEndif();
		fp.ppEndif();
	}

	@@Print the in-library export table of this function
	public function cprintInLibraryExports(
			fp: CWriter, escapeMode: int) {
		local hasUsableExport = false;
		for (local ppCond, none: exportSymbolNames) {
			if (ppCond != "0") {
				hasUsableExport = true;
				break;
			}
		}
		if (!hasUsableExport)
			return;
		local usedBindings = functionBindings;
		fp.ppIf(ppCond);
		local hasUniversalBinding = false;
		for (local bind: usedBindings) {
			if (bind.ppCond == "1") {
				hasUniversalBinding = true;
				break;
			}
		}
		if (!hasUniversalBinding) {
			File.Writer mergedCond;
			local isFirst = true;
			for (local bind: usedBindings) {
				if (!isFirst)
					mergedCond << "||";
				mergedCond << "(" << bind.ppCond << ")";
				isFirst = false;
			}
			fp.ppIf(mergedCond.string);
		}
		for (local ppCond, symbolName: exportSymbolNames) {
			fp.ppIf(ppCond);
			fp << "DEFINE_PUBLIC_ALIAS(" << symbolName << ", " << this.name << ");\n";
			fp.ppEndif();
		}
		if (!hasUniversalBinding)
			fp.ppEndif();
		fp.ppEndif();
	}
}



class SystemHeader {
	this = default;

	@@Name of @this system header (e.g. @"sys.stat" for <sys/stat.h>)
	public member name: string;

	@@Functions declared in this system header
	@@If a function is declared multiple times under the same name,
	@@it will appear as @DuplicateFunctionMarker in this mapping
	public member functionsByName: {string: (Function | _DuplicateFunctionMarker)} = Dict();

	@@Same as @functionsByName, but for local functions
	@@Duplicate entires aren't allowed
	public member localFunctionsByName: {string: LocalFunction} = Dict();

	@@Output order of <string.h> (when empty, don't generate that header)
	@@This is one of:
	@@  - @Function:            Call @Function.cprintHeaderDeclaration(fp, escapeMode) (other arguments are defaulted)
	@@  - @ExposedFunction:     Call @ExposedFunction.cprintHeaderDeclaration(fp, escapeMode)
	@@  - @string, @UserString: Insert the string as-is
	@@  - @Callable:            Invoke @Callable(fp, escapeMode)
	public member order_header: {(Function | ExposedFunction | string | UserString | Callable)...} = [];

	@@Output order of <libc/string.h> (when empty, don't generate that header)
	public member order_libcHeader: {(Function | string | UserString)...} = [];

	@@Output order of <libc/core/string.h> (when empty, don't generate that header)
	public member order_libcCoreHeader: {(Function | string | UserString)...} = [];

	@@Output order of /src/libc/auto/string.h (when empty, don't generate that header)
	public member order_libcAutoHeader: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/auto/string.c (when empty, don't generate that header)
	public member order_libcAutoSource: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/user/string.h (when empty, don't generate that header)
	public member order_libcUserHeader: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/user/string.c (when empty, don't generate that header)
	public member order_libcUserSource: {LibraryFunction...} = [];

	@@Print the contents of the exposed header (such as `<string.h>`),
	@@excluding the leading/trailing COPYRIGHT
	public function cprintHeader(fp: CWriter, escapeMode: int) {
		/* TODO: Assume that "defined(__BUILDING_LIBC)" == "0" */
		for (local part: order_header) {
			if (part is Function || part is ExposedFunction) {
				part.cprintHeaderDeclaration(fp, escapeMode);
			} else if (part is Callable) {
				part(fp, escapeMode);
			} else {
				fp << part;
			}
		}
	}

	@@Print the header /kos/src/libc/auto/string.h
	public function cprintLibraryAutoHeader(
			fp: CWriter, escapeMode: int, decl: string = "INTDEF") {
		/* TODO: Assume that "defined(__BUILDING_LIBC)" == "1" */
		/* TODO: Assume that "defined(__CRT_HAVE_*)" == "1" for all symbols exported from libc
		 *       In cases of conditional exports, "defined(__CRT_HAVE_*)" should instead be
		 *       replaced by the export-condition */
		for (local part: order_libcAutoHeader) {
			if (part is LibraryFunction) {
				part.cprintInLibraryDeclaration(fp, escapeMode, decl);
			} else {
				fp << part;
			}
		}
	}

	@@Print the implementations from /kos/src/libc/auto/string.c
	public function cprintLibraryAutoSourceImplementations(
			fp: CWriter, escapeMode: int, decl: string = "INTERN") {
		/* TODO: Assume that "defined(__BUILDING_LIBC)" == "1" */
		/* TODO: Assume that "defined(__CRT_HAVE_*)" == "1" for all symbols exported from libc
		 *       In cases of conditional exports, "defined(__CRT_HAVE_*)" should instead be
		 *       replaced by the export-condition */
		for (local part: order_libcAutoSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryAutoImplementation(fp, escapeMode, decl);
			} else {
				fp << part;
			}
		}
	}

	@@Print the export table from /kos/src/libc/auto/string.c
	public function cprintLibraryAutoSourceExports(
			fp: CWriter, escapeMode: int) {
		/* TODO: Assume that "defined(__BUILDING_LIBC)" == "1" */
		/* TODO: Assume that "defined(__CRT_HAVE_*)" == "1" for all symbols exported from libc
		 *       In cases of conditional exports, "defined(__CRT_HAVE_*)" should instead be
		 *       replaced by the export-condition */
		for (local part: order_libcAutoSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryExports(fp, escapeMode);
			} else {
				fp << part;
			}
		}
	}

	@@Print the header /kos/src/libc/user/string.h
	public function cprintLibraryUserHeader(
			fp: CWriter, escapeMode: int, decl: string = "INTDEF") {
		/* TODO: Assume that "defined(__BUILDING_LIBC)" == "1" */
		/* TODO: Assume that "defined(__CRT_HAVE_*)" == "1" for all symbols exported from libc
		 *       In cases of conditional exports, "defined(__CRT_HAVE_*)" should instead be
		 *       replaced by the export-condition */
		for (local part: order_libcUserHeader) {
			if (part is LibraryFunction) {
				part.cprintInLibraryDeclaration(fp, escapeMode, decl);
			} else {
				fp << part;
			}
		}
	}

	@@Print the source /kos/src/libc/user/string.c
	public function cprintLibraryUserSourceImplementations(
			fp: CWriter, escapeMode: int, decl: string = "INTERN") {
		/* TODO: Assume that "defined(__BUILDING_LIBC)" == "1" */
		/* TODO: Assume that "defined(__CRT_HAVE_*)" == "1" for all symbols exported from libc
		 *       In cases of conditional exports, "defined(__CRT_HAVE_*)" should instead be
		 *       replaced by the export-condition */
		/* TODO: This needs special handling! */
		for (local part: order_libcUserSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryAutoImplementation(fp, escapeMode, decl);
			} else {
				fp << part;
			}
		}
	}

	@@Print the export table from /kos/src/libc/user/string.c
	public function cprintLibraryUserSourceExports(
			fp: CWriter, escapeMode: int) {
		/* TODO: Assume that "defined(__BUILDING_LIBC)" == "1" */
		/* TODO: Assume that "defined(__CRT_HAVE_*)" == "1" for all symbols exported from libc
		 *       In cases of conditional exports, "defined(__CRT_HAVE_*)" should instead be
		 *       replaced by the export-condition */
		for (local part: order_libcUserSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryExports(fp, escapeMode);
			} else {
				fp << part;
			}
		}
	}
}







