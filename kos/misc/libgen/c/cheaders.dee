global COPYRIGHT =
"/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */";



/* Definitions for data structures used to represent pre-parsed C headers
 * definition files, as well as helper functions used to construct system
 * headers, as well as automatic/user implementations */

import * from deemon;
import * from .parser;
import * from .writer;
import * from .escape;
import * from .globals;
import * from .namespace;
import * from .namespace;
import * from .typeclass;
import GCC_NCX from .gccncx;
import util;


global Function;
global SystemHeader;

global final LIBC_LINKAGE_DECLS = { "__LIBC", "LIBC" };
global final NAMESPACE_IMPORT_DECL = "__FORCELOCAL";
global final DEFAULT_DECL = "__LIBC";
global final INJECTED_WRAPPER_FUNCTION_ATTRIBUTES = { "ATTR_ARTIFICIAL" };

global final function keyLocalDep(symbolName: string): string {
	return "__localdep_" + symbolName;
}

@@Check if `__C[EI](DECLARE|REDIRECT)` can be used for some given declaration
function isLibcLinkage(
		decl: string | UserString, cc: string | UserString,
		asmname: string | UserString, hasEllipsis: bool): bool {
	if (decl !in LIBC_LINKAGE_DECLS)
		return false;
	cc = str(cc);
	if (hasEllipsis != (cc.startswith("V") || cc.startswith("__V")))
		return false;
	switch (cc) {

	case "LIBCCALL":
	case "VLIBCCALL":
	case "__LIBCCALL":
	case "__VLIBCCALL":
		return !asmname.startswith("DOS$") &&
		       !asmname.startswith("KOS$");

	case "LIBKCALL":
	case "VLIBKCALL":
	case "__LIBKCALL":
	case "__VLIBKCALL":
		return asmname.startswith("KOS$");

	case "LIBDCALL":
	case "VLIBDCALL":
	case "__LIBDCALL":
	case "__VLIBDCALL":
		return asmname.startswith("DOS$");

	default:
		break;
	}
	return false;
}

function CWriter_ppIfEscaped(
		fp: CWriter, ppCond: string | UserString, escapeMode: int) {
	local extendedPrefixes = [];
	local usedCond = escapeText(
		ppCond, escapeMode, extendedPrefixes: extendedPrefixes);
	if (usedCond !in ["0", "1"]) {
again:
		local newExtendedPrefixes = [];
		for (local x: extendedPrefixes) {
			escapeNonRepeatingTextIntoFile(fp, x, escapeMode,
				extendedPrefixes: newExtendedPrefixes);
		}
		if (newExtendedPrefixes) {
			extendedPrefixes = newExtendedPrefixes;
			goto again;
		}
	}
	fp.ppIf(usedCond);
}

@@@return: true:  #elif was used
@@@return: false: #else; #if was used
function CWriter_ppElifEscaped(
		fp: CWriter, ppCond: string | UserString, escapeMode: int): bool {
	local extendedPrefixes = [];
	local usedCond = escapeText(
		ppCond, escapeMode, extendedPrefixes: extendedPrefixes);
	local useElseIf = false;
	if (usedCond !in ["0", "1"]) {
again:
		local newExtendedPrefixes = [];
		for (local x: extendedPrefixes) {
			local newText = escapeText(x, escapeMode, extendedPrefixes: newExtendedPrefixes);
			if (newText && !fp.wasPrefixPrinted(newText)) {
				if (!useElseIf) {
					fp.ppElse();
					useElseIf = true;
				}
				fp.forceStartOfLine();
				fp.printPrefix(str newText);
			}
		}
		if (newExtendedPrefixes) {
			extendedPrefixes = newExtendedPrefixes;
			goto again;
		}
	}
	if (useElseIf) {
		fp.ppIf(usedCond);
		return false;
	}
	fp.ppElif(usedCond);
	return true;
}

class CType {
	this = default;

	public operator str(): string {
		return beforeName + afterName;
	}

	@@A string to insert before the name of the associated variable (e.g. @"fd_t")
	@@NOTE: This string will have already been stripped of leading/trailing spaces
	public member beforeName: string | UserString;

	@@A string to insert after the name of the associated variable (e.g. @"[2]")
	@@NOTE: This string will have already been stripped of leading/trailing spaces
	public member afterName: string | UserString = "";

	/* TODO: public member commentBefore: string; */
	/* TODO: public member commentAfter: string; */

	public function equals(other: CType): bool {
		if (this === other)
			return true;
		if (beforeName != str(other.beforeName))
			return false;
		if (afterName != str(other.afterName))
			return false;
		return true;
	}

	@@Same as @typeClass, but throw an @Error if the class cannot be deduced
	public property requireTypeClass: string = {
		get(): string {
			local result = typeClass;
			if (result !is none)
				return result;
			throw Error("Unable to deduce typeclass of {!r}".format({ this }));
		}
	}

	@@Returns the type classification for @this @CType
	@@Note that this class only applies when @this type is used in an argument list
	@@For more information, see @(import .typeclass)
	@@If the type class cannot be deduced, this property returns @none instead
	public property typeClass: string | none = {
		get(): string {
			if (afterName) {
				/* An after-string only exists for the following cases, all
				 * of which are pointers when they appear in argument lists:
				 * >> int x[];         // Flexible array (C convention passes this as a pointer)
				 * >> int x[42];       // Fixed-length array (Passed like its flexible counterpart)
				 * >> int (*x)(int a); // Function pointer */
				return "TP";
			}
			local typename = str(beforeName).strip();
			if (typename.endswith("__restrict"))
				return "TP"; /* Only pointer can be marked as __restrict */
			if (typename.endswith("*") || typename.endswith("&"))
				return "TP"; /* Pointer type */
again:
			typename = typename.replace("$", "");
			for (;;) {
				if (typename.startswith("unsigned ")) {
					typename = typename[9:].lstrip();
					continue;
				}
				if (typename.startswith("signed ")) {
					typename = typename[7:].lstrip();
					continue;
				}
				if (typename.startswith("int ")) {
					typename = typename[4:].lstrip();
					continue;
				}
				if (typename.endswith(" unsigned")) {
					typename = typename[:-9].rstrip();
					continue;
				}
				if (typename.endswith(" signed")) {
					typename = typename[:-7].rstrip();
					continue;
				}
				if (typename.endswith(" int")) {
					typename = typename[:-4].rstrip();
					continue;
				}
				break;
			}
			if (typename.startswith("struct ")) {
				typename = typename[7:];
do_handle_struct_type:
				return "TS(__SIZEOF_{})".format({ typename.lstrip().lstrip("_").upper() });
			}
			if (typename.startswith("union ")) {
				typename = typename[6:];
				goto do_handle_struct_type;
			}
			if (typename.startswith("enum "))
				return "TD"; /* Enums always get passed like `int` */
			local result = knownTypeClasses.get(typename);
			if (result !is none)
				return result;
			/* Also check if the escaped variant may be known */
			for (local map: { keywordEscapes, partialKeywordEscapes }) {
				local escaped = map.get(typename);
				if (escaped is none)
					continue;
				result = knownTypeClasses.get(escaped);
				if (result !is none)
					return result;
				if (escaped.endswith("__restrict"))
					return "TP";
				if (escaped.endswith("*") || escaped.endswith("&"))
					return "TP"; /* Pointer type */
				if (escaped.startswith("struct ") || escaped.startswith("union ") ||
				    escaped.startswith("enum ") || escaped.startswith("unsigned ") ||
				    escaped.startswith("signed ") || escaped.startswith("int ") ||
				    escaped.endswith(" unsigned") || escaped.endswith(" signed") ||
				    escaped.endswith(" int")) {
					typename = escaped;
					goto again;
				}
			}
			return none;
		}
	}

	@@Returns @true if @this @CType is implicitly convertible to @other
	public function implicitlyConvertibleTo(other: CType): bool {
		if (equals(other))
			return true;
		local typename = str(beforeName).strip();
		if (typename.endswith("__restrict"))
			typename = typename[:-10].rstrip();
		local an = str(afterName);
		if (an.startswith("[") && an.endswith("]"))
			an = "*";
		typename = typename + an;
		local otTypename = str(other.beforeName).strip();
		if (otTypename.endswith("__restrict"))
			otTypename = otTypename[:-10].rstrip();
		local an = str(other.afterName);
		if (an.startswith("[") && an.endswith("]"))
			an = "*";
		otTypename = otTypename + an;
again_compare_typenames:
		if (typename == otTypename)
			return true;
		typename = typename.replace("\t", " ");
		otTypename = otTypename.replace("\t", " ");
		while ("  " in typename)
			typename = typename.replace("  ", " ");
		while ("  " in otTypename)
			otTypename = otTypename.replace("  ", " ");
		if (typename == otTypename)
			return true;
		if ("const" in otTypename) {
			if ((otTypename.count("*") + otTypename.count("&")) < 2) {
				otTypename = otTypename.replace("const", "");
				goto again_compare_typenames;
			}
			/* Only replace "const" up until the second-to-last "*" or "&":
			 *  - "char const *"          -> "char *"
			 *  - "char *const *"         -> "char **"
			 *  - "char const *const *"   -> "char const **" */
			local replStart = #otTypename;
			while (otTypename[replStart - 1] !in "*&")
				--replStart;
			--replStart;
			while (otTypename[replStart - 1] !in "*&")
				--replStart;
			/* `replStart` now points after the second-to-last "*" or "&" */
			local after = otTypename[replStart:];
			if ("const" in after) {
				otTypename = otTypename[:replStart] + after.replace("const", "");
				goto again_compare_typenames;
			}
		}
		return false;
	}

	@@Returns @true if @this @CType is @"void"
	public property isVoid: bool = {
		get(): bool {
			return beforeName == "void" && !afterName;
		}
	}

	@@Returns @true if @this @CType is a pointer
	public property isPointer: bool = {
		get(): bool {
			return str(beforeName).endswith("*");
		}
	}


	@@Prints the c-cast prefix (e.g. @"(int)") for @this
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintCCastPrefix(fp: CWriter, escapeMode: int) {
		fp << "(";
		local typename = str(beforeName).strip();
		if (typename.endswith("__restrict"))
			typename = typename[:-10].rstrip();
		local an = str(afterName);
		escapeTextIntoFile(fp, typename, escapeMode);
		if (an.startswith("[") && an.endswith("]"))
			fp << " *";
		fp << ")";
	}

	@@Same @cprintCCastPrefix, but meant to be used by generators
	public function cprintCCastPrefixForGenerator(fp: CWriter) {
		fp << "(";
		local typename = str(beforeName).strip();
		if (typename.endswith("__restrict"))
			typename = typename[:-10].rstrip();
		local an = str(afterName);
		fp << typename;
		if (an.startswith("[") && an.endswith("]"))
			fp << " *";
		fp << ")";
	}

	@@Print a stub-value for @this type (e.g. @"(char const *)0")
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintStubValue(fp: CWriter | File, escapeMode: int) {
		cprintCCastPrefix(fp, escapeMode);
		fp << "0";
	}

	@@Same @cprintStubValue, but meant to be used by generators
	public function cprintStubValueForGenerator(fp: CWriter | File) {
		cprintCCastPrefixForGenerator(fp);
		fp << "0";
	}

	@@Output @this @CType to a @CWriter
	@@Returns @true if the type string must be followed by whitespace if
	@@immediately succeeded by a keyword. Returns @false otherwise.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprint(fp: CWriter, escapeMode: int, name: string | UserString = ""): bool {
		local beforeNameStr = str beforeName;
		local afterNameStr = str afterName;
		escapeTextIntoFile(fp, beforeName, escapeMode);
		if (name) {
			if (!beforeNameStr.endswith("*"))
				fp << " ";
			escapeTextIntoFile(fp, name, escapeMode);
		}
		if (afterNameStr) {
			if (afterNameStr.first !in ")[")
				fp << " ";
			escapeTextIntoFile(fp, afterName, escapeMode);
		}
		if (afterNameStr)
			return true;
		if (name)
			return true;
		if (beforeNameStr)
			return !beforeNameStr.endswith("*");
		return false;
	}

	@@Same @cprint, but meant to be used by generators
	public function cprintForGenerator(fp: CWriter, name: string = ""): bool {
		local beforeNameStr = str beforeName;
		local afterNameStr = str afterName;
		fp << beforeNameStr;
		if (name) {
			if (!beforeNameStr.endswith("*"))
				fp << " ";
			fp << name;
		}
		if (afterNameStr) {
			if (afterNameStr.first !in ")[")
				fp << " ";
			fp << afterName;
		}
		if (afterNameStr)
			return true;
		if (name)
			return true;
		if (beforeNameStr)
			return !beforeNameStr.endswith("*");
		return false;
	}

}


class Argument {
	this = default;

	@@Argument name (fully escaped; empty string if the argument is unnamed)
	@@NOTE: Ellipsis arguments have this field set to @""
	public member name: string | UserString;

	@@The argument name that should be combined with @ctype in the prototype
	@@Usually this is the same as @name, but in the case of functions such
	@@as @"execv", this would be an empty string to accout for the fact that
	@@the set @ctype is actually the name of a macro that already includes
	@@the name of the argument (meaning that the name mustn't be written twice)
	public member protoTypeName: string | UserString;

	@@C Typing of this argument.
	@@NOTE: Ellipsis arguments have this field set to @CType("...")
	public member ctype: CType;

	@@Output @this @Argument to a @CWriter
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprint(fp: CWriter, escapeMode: int) {
		ctype.cprint(fp, escapeMode, protoTypeName);
	}

	public operator hash(): int -> Object.id(this);
	public operator == (other: Argument): bool -> this === other;
	public operator != (other: Argument): bool -> this !== other;
}

class FunctionPrototype {
	this = default;

	@@List of attributes that should be applied to this function (e.g. @{ "ATTR_NORETURN" })
	public member attributes: {(string | UserString | Callable)...} = ();

	@@The nothrow behavior of this function. Should be one of:
	@@  - @"":                   Unspecified (assume THROWING, but don't warn if used from NOTHROW)
	@@  - @"NOTHROW":            Function doesn't throw
	@@  - @"NOTHROW_NCX":        Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS)
	@@  - @"NOTHROW_RPC":        Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS)
	@@  - @"NOTHROW_RPC_KOS":    Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS) && defined(__KOS__)
	@@  - @"NOTHROW_RPC_NOKOS":  Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS) && !defined(__KOS__)
	@@  - @"NOTHROW_RPC_PURE":   Function is nothrow when: #if defined(__NO_RPC_EXCEPTIONS)
	@@  - @"THROWS(...)":        Function can throw and should be warned about if used from NOTHROW.
	@@                           The given @"..." is a comma-seperated list of `E_*' codes from <kos/except.h>
	public member nothrow: string | UserString = "";

	@@Calling convention of this function prototype (e.g. @"ATTR_CDECL")
	@@Set to an empty string to use the default calling convention.
	public member cc: string | UserString;

	@@The type that is returned by this function prototype
	public member returnType: CType;

	@@The actual List of arguments
	public member argv: {Argument...} = ();

	@@When set to non-@none, these are the types of the arguments passed through ellipsis
	@@This information can be helpful when trying to construct an argument list
	public member ellipsisArgumentTypes: {CType...} = none;

	@@Pieces of code that must be written before @this @FunctionPrototype can be printed
	@@NOTE: These prefixes are only printed in local function implementations, as well as
	@@      their dependencies, as well as the dependencies of inline functions
	public member declPrefix: {(string | UserString)...} = ();

	@@Wrapper around @attributes that will automatically sort and unwind attributes
	public property prototypeAttributes: {(string | UserString)...} = {
		get(): {(string | UserString)...} {
			local result = attributes;
			if (!m_attributesSorted) {
				local wip = []; /* WIthParen */
				local wop = []; /* WithOutParen */
#define APPEND_ATTRIBUTE(a)            \
				a = str(a);            \
				if ("(" in a) {        \
					if (a !in wip)     \
						wip.append(a); \
				} else {               \
					if (a !in wop)     \
						wop.append(a); \
				}
				for (local a: result) {
					if (a is Callable) {
						a = a();
						if (a is Sequence) {
							for (local e: a) {
								APPEND_ATTRIBUTE(e)
							}
							continue;
						}
						if (a is none)
							continue;
					}
					APPEND_ATTRIBUTE(a)
					continue;
				}
#undef APPEND_ATTRIBUTE
				wip.sort();
				wop.sort();
				wop.extend(wip);
				result = wop;
				attributes = result;
				m_attributesSorted = true;
			}
			return result;
		}
	}
	private member m_attributesSorted: bool = false;


	@@Returns @true if this prototype contains a @"ATTR_NORETURN" attribute
	public property isNoreturn: bool = {
		get(): bool {
			for (local at: attributes) {
				if (at in ["ATTR_NORETURN", "__ATTR_NORETURN"])
					return true;
			}
			return false;
		}
	}

	@@Returns @true if @nothrow describes @"THROWS(...)"
	public property isNothrowThrowing: bool = {
		get(): bool {
			if (m_isNothrowThrowing !is bound) {
				local nts = str nothrow;
				m_isNothrowThrowing =
					nts.startswith("THROWS(") ||
					nts.startswith("__THROWS(");
			}
			return m_isNothrowThrowing;
		}
	}
	private member m_isNothrowThrowing: bool;

	@@Returns @true if @nothrow describes @"NOTHROW_NCX" or something
	@@else that needs the `__COMPILER_HAVE_GCCNCX_BUILTIN_BUG'-workaround
	public property isNothrowGCCNCX: bool = {
		get(): bool {
			if (m_isNothrowGCCNCX !is bound) {
				local nts = str nothrow;
				m_isNothrowGCCNCX = nts !in ["NOTHROW", "__NOTHROW"];
			}
			return m_isNothrowGCCNCX;
		}
	}
	private member m_isNothrowGCCNCX: bool;

	@@Returns @"__THROWING" or @"THROWING" based on the escape-state of @nothrow
	@@The caller must ensure that @isNothrowThrowing is @true
	public property nothrowThrowingSpec: string = {
		get(): bool {
			local nts = str nothrow;
			if (nts.startswith("THROWS("))
				return "THROWING";
			return "__THROWING";
		}
	}


	public property argsByName: {string: Argument} = {
		get(): {string: Argument} {
			if (m_argsByName !is bound) {
				local result = Dict();
				for (local a: argv) {
					local usedName = str(a.name);
					if (usedName)
						result[usedName] = a;
				}
				m_argsByName = result;
				return result;
			}
			return m_argsByName;
		}
	}
	private member m_argsByName: {string: Argument};

	public operator # (): string -> #argv;
	public operator [] (i: int): Argument -> argv[i];

	@@Evaluate to @true if @this @FunctionPrototype ends with an ellipsis argument (i.e. @"...")
	public property hasEllipsis: bool = {
		get(): bool {
			return argv && argv.last.ctype.beforeName == "...";
		}
	}

	public operator str(): string {
		File.Writer fp;
		for (local a: prototypeAttributes)
			fp << a << " ";
		fp << returnType.beforeName << returnType.afterName
			<< " " << cc << " ...(";
		local isFirst = true;
		for (local a: argv) {
			if (!isFirst)
				fp << ", ";
			isFirst = false;
			fp << a.ctype.beforeName << a.protoTypeName << a.ctype.afterName;
		}
		fp << ")";
		return fp.string;
	}

	@@Check if @this FunctionPrototype is compatible with @other
	@@i.e.: uses identical items, attributes, and calling convention.
	@@Note however that argument names are not checked here!
	public function compatibleWith(other: FunctionPrototype): bool {
		if (this === other)
			return true;
		if (!returnType.equals(other.returnType))
			return false;
		local n = #argv;
		if (n != #other.argv)
			return false;
		for (local i = 0; i < n; ++i) {
			local my = argv[i];
			local ot = other.argv[i];
			if (!my.ctype.equals(ot.ctype))
				return false;
		}
		if (nothrow != other.nothrow)
			return false;
		if (cc != other.cc)
			return false;
		if (ellipsisArgumentTypes is none) {
			if (other.ellipsisArgumentTypes !is none)
				return false;
		} else {
			if (other.ellipsisArgumentTypes is none)
				return false;
			if (ellipsisArgumentTypes != other.ellipsisArgumentTypes)
				return false;
		}
		if (declPrefix != other.declPrefix)
			return false;
		if (prototypeAttributes != other.prototypeAttributes)
			return false;
		return true;
	}

	@@Print the attribute list (returns @false if
	@@nothing was printed, and @true otherwise)
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintAttributeList(fp: CWriter, escapeMode: int): bool {
		local isFirst = true;
		for (local attr: prototypeAttributes) {
			if (!isFirst)
				fp << " ";
			escapeTextIntoFile(fp, attr, escapeMode);
			isFirst = false;
		}
		return !isFirst;
	}

	@@Output the argument list including types to @fp
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintArgumentListWithTypes(fp: CWriter, escapeMode: int) {
		local isFirst = true;
		fp << "(";
		if (!argv)
			fp << "void";
		else {
			for (local arg: argv) {
				if (!isFirst)
					fp << ", ";
				arg.cprint(fp, escapeMode);
				isFirst = false;
			}
		}
		fp << ")";
	}

	@@Output the argument list excluding types to @fp
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintArgumentListWithoutTypes(fp: CWriter, escapeMode: int) {
		local isFirst = true;
		fp << "(";
		for (local arg: argv) {
			if (!isFirst)
				fp << ",";
			escapeTextIntoFile(fp, arg.name, escapeMode);
			isFirst = false;
		}
		fp << ")";
	}

	@@Print a declaration akin to:
	@@> __LIBC __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t __NOTHROW_NCX(__LIBCCALL strlen)(char const *__restrict __str) __CASMNAME_SAME("open");
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintDeclarationWithOptionalAsmname(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string,
			isSameAsname: bool) {
		local hasGccNCX = decl in LIBC_LINKAGE_DECLS && fp.externLinkage in ["", "C"] &&
		                  exposedName in GCC_NCX && isNothrowGCCNCX;
		if (hasGccNCX) {
			fp << "#ifdef __COMPILER_HAVE_GCCNCX_BUILTIN_BUG\n";
			fp << "extern \"C++\" {\n";
			fp << "#endif /* __COMPILER_HAVE_GCCNCX_BUILTIN_BUG */\n";
		}
		/* Same symbol name -> declare normally (or with `__ASMNAME()' suffix) */
		cprintDeclarationWithoutTerminator(fp, escapeMode, decl, exposedName);
		if (decl in LIBC_LINKAGE_DECLS) {
			/* Always use __CASMNAME for anything declared in the context of libc.
			 * This is required to ensure proper assembly linkage, as well as
			 * symbol visibility when libc.so is including its own headers. */
			fp << " __CASMNAME";
			local suffix = "";
			if (assemblyName.startswith("DOS$")) {
				suffix       = "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				suffix       = "_KOS";
				assemblyName = assemblyName[4:];
			}
			if (isSameAsname)
				fp << "_SAME";
			if (hasGccNCX)
				fp << "_GCCNCX";
			fp << suffix << "(" << repr(assemblyName) << ")";
		} else if (!isSameAsname) {
			fp << " __ASMNAME(" << repr(assemblyName) << ")";
		}
		fp << ";\n";
		if (hasGccNCX) {
			fp << "#ifdef __COMPILER_HAVE_GCCNCX_BUILTIN_BUG\n";
			fp << "} /* extern \"C++\" */\n";
			fp << "#endif /* __COMPILER_HAVE_GCCNCX_BUILTIN_BUG */\n";
		}
	}

	@@Print a declaration akin to:
	@@> __CDECLARE(__ATTR_WUNUSED __ATTR_NONNULL((1)),__SIZE_TYPE__,__NOTHROW_NCX,wcslen,(__WCHAR_TYPE__ const *__restrict __str),(__str))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintCDECLARE(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, optSuffix: bool = false) {
		/* Special case: Make use of __CDECLARE */
		local isVoidReturn = this.returnType.isVoid;
		fp << "__CDECLARE";
		if (isVoidReturn)
			fp << "_VOID";
		if (fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
			fp << "_GCCNCX";
		if (optSuffix)
			fp << "_OPT";
		fp << "(";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		fp << ",";
		/* Return type */
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		/* Exposed name */
		fp << "," << exposedName << ",";
		cprintArgumentListWithTypes(fp, escapeMode);
		fp << ",";
		cprintArgumentListWithoutTypes(fp, escapeMode);
		fp << ")\n";
	}

	@@Print a declaration akin to:
	@@> __LIBC __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t
	@@> __NOTHROW_NCX(__LIBCCALL strlen)(char const *__restrict __str)
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintDeclarationWithoutTerminator(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			injectedAttributes: {string...} = none,
			breakAfterReturnType: bool = false,
			oneArgumentPerLine: bool = false) {
		/* Same symbol name -> declare normally */
		escapeTextIntoFile(fp, decl, escapeMode);
		if (decl)
			fp << " ";
		if (injectedAttributes) {
			local isFirst = true;
			for (local a: injectedAttributes) {
				if (!isFirst)
					fp << " ";
				isFirst = false;
				escapeTextIntoFile(fp, a, escapeMode);
			}
			if (!isFirst)
				fp << " ";
		}
		if (cprintAttributeList(fp, escapeMode))
			fp << " ";
		if (returnType.cprint(fp, escapeMode) && !breakAfterReturnType)
			fp << " ";
		if (breakAfterReturnType)
			fp << "\n";
		if (!isNothrowThrowing)
			escapeTextIntoFile(fp, nothrow, escapeMode);
		fp << "(";
		escapeTextIntoFile(fp, cc, escapeMode);
		if (cc)
			fp << " ";
		fp << exposedName << ")";
		if (oneArgumentPerLine && #argv >= 2) {
			local indentWidth;
			{
				local tempfp = File.Writer();
				local tempWriter = CWriter(tempfp, ppAssume: fp.ppAssume);
				if (!breakAfterReturnType) {
					escapeTextIntoFile(tempWriter, decl, escapeMode);
					if (decl)
						tempWriter << " ";
					if (injectedAttributes) {
						local isFirst = true;
						for (local a: injectedAttributes) {
							if (!isFirst)
								tempWriter << " ";
							isFirst = false;
							escapeTextIntoFile(tempWriter, a, escapeMode);
						}
						if (!isFirst)
							tempWriter << " ";
					}
					if (cprintAttributeList(tempWriter, escapeMode))
						tempWriter << " ";
					if (returnType.cprint(tempWriter, escapeMode))
						tempWriter << " ";
				}
				if (!isNothrowThrowing)
					escapeTextIntoFile(tempWriter, nothrow, escapeMode);
				tempWriter << "(";
				escapeTextIntoFile(tempWriter, cc, escapeMode);
				tempWriter.flush();
				del tempWriter;
				tempfp = tempfp.string;
				local i = tempfp.rfind("\n");
				if (i >= 0)
					tempfp = tempfp[i + 1:];
				indentWidth = #tempfp + #exposedName + 2;
				if (cc)
					++indentWidth;
			}
			fp << "(";
			local isFirst = true;
			indentWidth = " " * indentWidth;
			for (local arg: argv) {
				if (!isFirst)
					fp << ",\n" << indentWidth;
				arg.cprint(fp, escapeMode);
				isFirst = false;
			}
			fp << ")";
		} else {
			cprintArgumentListWithTypes(fp, escapeMode);
		}
		if (isNothrowThrowing) {
			fp << " ";
			escapeTextIntoFile(fp, nothrow, escapeMode);
		}
	}

	@@Print a declaration akin to:
	@@> #define wcslen (*(size_t(LIBCCALL*)(wchar_t const *__restrict))&__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))
	@@If the types from @callToPrototype different from those in @this prototype,
	@@insert casts where- and as necessary.
	@@NOTE: This function will not print a trailing line-feed after the declaration!
	@@@param: escapeMode:      One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: exposedName:     In the above example: @"wcslen"
	@@@param: callToName:      In the above example: @"(__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))"
	@@@param: callToPrototype: In the above example: @(allLocalFunctionsByName["wcslen"].prototype)
	public function cprintCallToMacro(
			fp: CWriter, escapeMode: int, exposedName: string,
			callToName: string, callToPrototype: FunctionPrototype,
			explicitCastAllTypes: bool = false) {
		fp << "#define " << exposedName;
		/* Check if the prototypes are already compatible */
		if (this.compatibleWith(callToPrototype)) {
			fp << " " << callToName << "\n";
			return;
		}
		local myArgc = #argv;
		local otArgc = #callToPrototype.argv;
		local myHaveEllipsis = hasEllipsis;
		local otHaveEllipsis = callToPrototype.hasEllipsis;
		if (myArgc != otArgc || myHaveEllipsis != otHaveEllipsis) {
			/* Different # of arguments (shouldn't happen, but can only be dealt with
			 * by generating a function-like macro, though obviously this macro cannot
			 * be used in a situation where it's address would have to be taken) */
			fp << "(";
			local isFirst = true;
			for (local a: argv) {
				if (!isFirst)
					fp << ", ";
				isFirst = false;
				fp << a.name;
			}
			if (myHaveEllipsis) {
				if (!isFirst)
					fp << ", ";
				fp << "...";
			}
			fp << ") " << callToName << "(";
			if (otHaveEllipsis)
				--otArgc;
			if (myHaveEllipsis)
				--myArgc;
			local commonArgc = otArgc;
			if (commonArgc > myArgc)
				commonArgc = myArgc;
			for (local i: [:commonArgc]) {
				if (i)
					fp << ", ";
				local myArg = argv[i];
				local otArg = callToPrototype.argv[i];
				if (!myArg.implicitlyConvertibleTo(otArg))
					otArg.cprintCCastPrefix(fp, escapeMode);
				fp << myArg.name;
			}
			if (otArgc > commonArgc) {
				if (commonArgc)
					fp << ", ";
				for (local i: [commonArgc:otArgc]) {
					if (commonArgc != commonArgc)
						fp << ", ";
					callToPrototype.argv[i].cprintStubValue(fp, escapeMode);
				}
			}
			if (myHaveEllipsis && otHaveEllipsis) {
				if (otArgc)
					fp << ", ";
				fp << "__VA_ARGS__";
			}
			fp << ")\n";
			return;
		}
		/* Same # of arguments, and same ellipsis behavior.
		 * Assume that a difference in CC is intentional and cast the
		 * other function's pointer into the intended prototype's format. */
		fp << " (*(";
		returnType.cprint(fp, escapeMode);
		fp << "(";
		if (cc) {
			escapeTextIntoFile(fp, cc, escapeMode);
			fp << " ";
		}
		fp << "*)(";
		local isFirst = true;
		for (local a: argv) {
			if (!isFirst)
				fp << ", ";
			isFirst = false;
			a.ctype.cprint(fp, escapeMode);
		}
		if (myHaveEllipsis) {
			if (!isFirst)
				fp << ", ";
			fp << "...";
		}
		fp << "))&" << callToName << ")\n";
	}

	@@Print a declaration akin to:
	@@> FORCELOCAL ATTR_PURE ATTR_WUNUSED ATTR_NONNULL((1)) size_t
	@@> NOTHROW_NCX(LIBCCALL wcslen)(wchar_t const *__restrict string) {
	@@> return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))(string); }
	@@If the types from @callToPrototype different from those in @this prototype,
	@@insert casts where- and as necessary.
	@@NOTE: This function will not print a trailing line-feed after the declaration!
	@@@param: escapeMode:      One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:            In the above example: @"FORCELOCAL"
	@@@param: exposedName:     In the above example: @"wcslen"
	@@@param: callToName:      In the above example: @"(__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))"
	@@@param: callToPrototype: In the above example: @(allLocalFunctionsByName["wcslen"].prototype)
	public function cprintCallToFunction(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			callToName: string, callToPrototype: FunctionPrototype,
			explicitCastAllTypes: bool = false, callToEscapeMode: int = none) {
		if (callToEscapeMode is none)
			callToEscapeMode = escapeMode;
		cprintDeclarationWithoutTerminator(fp, escapeMode, decl, exposedName,
			injectedAttributes: INJECTED_WRAPPER_FUNCTION_ATTRIBUTES);
		fp << " { ";
		if (!returnType.isVoid)
			fp << "return ";
		if (explicitCastAllTypes || !callToPrototype.returnType.implicitlyConvertibleTo(returnType))
			returnType.cprintCCastPrefix(fp, callToEscapeMode);
		fp << callToName << "(";
		local argc = #callToPrototype.argv;
		local isFirst = true;
		for (local argi: [:argc]) {
			if (!isFirst)
				fp << ", ";
			isFirst = false;
			local arg = callToPrototype.argv[argi];
			if (argi >= #argv) {
				/* Shouldn't happen... */
				arg.ctype.cprintCCastPrefix(fp, callToEscapeMode);
				fp << "0";
				continue;
			}
			local myArg = this.argv[argi];
			if (myArg.ctype.beforeName == "...") {
				fp << "__builtin_va_arg_pack()";
			} else {
				if (explicitCastAllTypes || !myArg.ctype.implicitlyConvertibleTo(arg.ctype))
					arg.ctype.cprintCCastPrefix(fp, callToEscapeMode);
				escapeTextIntoFile(fp, myArg.name, escapeMode);
			}
		}
		fp << "); }";
	}

	@@Print a declaration akin to:
	@@> __COMPILER_REDIRECT(__LIBC,__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,__NOTHROW_NCX,
	@@>                     __LIBCCALL,strlen,(char const *__str),strlen_alias,(__str))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintREDIRECT(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string,
			isLcl: bool) {
		fp << (isLcl ? "__CREDIRECT" : "__COMPILER_REDIRECT");
		local isVoidReturn = returnType.isVoid;
		if (isVoidReturn)
			fp << "_VOID";
		if (isLcl) {
			if (assemblyName.startswith("DOS$")) {
				fp << "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				fp << "_KOS";
				assemblyName = assemblyName[4:];
			}
		}
		if (isLcl && fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
			fp << "_GCCNCX";
		fp << "(";
		/* Linkage */
		if (!isLcl)
			fp << decl << ",";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		/* Return type */
		fp << ",";
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		fp << ",";
		/* Calling convention */
		if (!isLcl) {
			escapeTextIntoFile(fp, cc, escapeMode);
			fp << ",";
		}
		/* Exposed symbol name */
		fp << exposedName << ",";
		/* Argument list */
		cprintArgumentListWithTypes(fp, escapeMode);
		/* Assembly import symbol name */
		fp << "," << assemblyName << ",";
		/* Argument names */
		cprintArgumentListWithoutTypes(fp, escapeMode);
		fp << ")\n";
	}

	@@Print a declaration akin to:
	@@> __CVREDIRECT(__ATTR_NONNULL((1)),__pid_t,__NOTHROW_NCX,clone,
	@@>              (__clone_func_t __fn, void *__child_stack, int __flags, void *__arg),
	@@>              __clone,(__fn,__child_stack,__flags,__arg),
	@@>              __arg,3,(__pid_t,void *,__pid_t))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintVREDIRECT(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string,
			isLcl: bool) {
		fp << (isLcl ? "__CVREDIRECT" : "__COMPILER_VREDIRECT");
		local isVoidReturn = returnType.isVoid;
		if (isVoidReturn)
			fp << "_VOID";
		if (isLcl) {
			if (assemblyName.startswith("DOS$")) {
				fp << "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				fp << "_KOS";
				assemblyName = assemblyName[4:];
			}
		}
		if (isLcl && fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
			fp << "_GCCNCX";
		fp << "(";
		/* Linkage */
		if (!isLcl)
			fp << decl << ",";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		/* Return type */
		fp << ",";
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		fp << ",";
		/* Calling convention */
		if (!isLcl) {
			escapeTextIntoFile(fp, cc, escapeMode);
			fp << ",";
		}
		/* Exposed symbol name */
		fp << exposedName << ",";
		/* Argument list */
		local isFirst = true;
		fp << "(";
		for (local arg: argv[:-1]) {
			if (!isFirst)
				fp << ", ";
			arg.cprint(fp, escapeMode);
			isFirst = false;
		}
		fp << ")";
		/* Assembly import symbol name */
		fp << "," << assemblyName << ",";
		/* Argument names */
		local isFirst = true;
		fp << "(";
		for (local arg: argv[:-1]) {
			if (!isFirst)
				fp << ",";
			escapeTextIntoFile(fp, arg.protoTypeName, escapeMode);
			isFirst = false;
		}
		fp << "),";
		/* Next up: print the name of the last argument before ellipsis starts */
		escapeTextIntoFile(fp, argv[#argv - 2].name, escapeMode);
		/* Then print the # of known ellipsis argument types */
		fp << "," << #ellipsisArgumentTypes << ",(";
		/* And finally, print the actual list of ellipsis argument types */
		local isFirst = true;
		for (local typ: ellipsisArgumentTypes) {
			if (!isFirst)
				fp << ",";
			typ.cprint(fp, escapeMode);
			isFirst = false;
		}
		fp << "))\n";
	}

	@@Check if __CDECLARE will be used by @cprintRedirectionBinding,
	@@when called with the given arguments.
	public function cprintRedirectionBindingUsesCDECLARE(
			fp: CWriter, decl: string, exposedName: string,
			assemblyName: string): bool {
		if (exposedName != assemblyName)
			return false;
		if (fp.externLinkage !in ["", "C"])
			return false;
		if (this.hasEllipsis)
			return false;
		return isLibcLinkage(decl, cc, assemblyName, false);
	}

	@@Print a redirection- or declaration-binding, based on
	@@the exposed- and assembly name being the same
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintRedirectionBinding(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string) {
		local hasEllipsis = this.hasEllipsis;
		local isLcl = isLibcLinkage(decl, cc, assemblyName, hasEllipsis);
		local isSameAsname = exposedName == assemblyName && fp.externLinkage in ["", "C"];
		if (hasEllipsis) {
			if (!isSameAsname) {
				if (ellipsisArgumentTypes !is none) {
					return cprintVREDIRECT(
						fp, escapeMode, decl, exposedName, assemblyName, isLcl);
				}
				/* XXX: This is the one corner-case, where there's no real way
				 *      of implementing redirections portably... So for now,
				 *      simply fall through to use the non-portable ASMNAME()
				 *      notation... */
			}
			return cprintDeclarationWithOptionalAsmname(
				fp, escapeMode, decl, exposedName,
				assemblyName, isSameAsname);
		}
		if (isLcl) {
			if (!isSameAsname)
				return cprintREDIRECT(fp, escapeMode, decl, exposedName, assemblyName, isLcl);
			return cprintCDECLARE(fp, escapeMode, decl, exposedName);
		}
		if (!isSameAsname) {
			return cprintREDIRECT(
				fp, escapeMode, decl, exposedName, assemblyName, isLcl);
		}
		return cprintDeclarationWithOptionalAsmname(
			fp, escapeMode, decl, exposedName,
			assemblyName, isSameAsname);
	}

	@@Print the start of an EXTERN-INLINE redirection- or declaration-binding,
	@@based on the exposed- and assembly name being the same
	@@Upon return, the caller should proceed to print the inline implementation body,
	@@followed by a single @')'-terminator that will then complete the macro started
	@@by this function.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintExternInlineBindingStart(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string) {
		local hasEllipsis = this.hasEllipsis;
		local isLcl = isLibcLinkage(decl, cc, assemblyName, hasEllipsis);
		local isSameAsname = exposedName == assemblyName && fp.externLinkage in ["", "C"];
		fp << (isLcl
		       ? isSameAsname ? "__CEIDECLARE" : "__CEIREDIRECT"
		       : isSameAsname ? "__COMPILER_EIDECLARE" : "__COMPILER_EIREDIRECT");
		if (isLcl) {
			if (assemblyName.startswith("DOS$")) {
				fp << "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				fp << "_KOS";
				assemblyName = assemblyName[4:];
			}
			if (fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
				fp << "_GCCNCX";
		}
		fp << "(";
//		if (!isLcl)
//			fp << decl << ","; /* Declaration linkage */
		/* Attribute list */
		cprintAttributeList(fp, escapeMode);
		fp << ",";
		/* Return type */
		returnType.cprint(fp, escapeMode);
		fp << ",";
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		if (!isLcl)
			escapeTextIntoFile(fp << ",", cc, escapeMode); /* Calling convention */
		/* Exposed name */
		fp << "," << exposedName << ",";
		cprintArgumentListWithTypes(fp, escapeMode);
		fp << ",";
		if (!isSameAsname)
			fp << assemblyName << ",";
	}

}


class FunctionImplementation {
	this = default;

	@@The actual local implementation body of this function
	@@NOTE: This string has already been fully escaped!
	public member body: string | UserString;

	@@Name of the function itself within the implementation
	public member name: string | UserString;

	@@Pieces of code that must be written before @impl can be generated
	@@This code is inserted at the global namespace scope!
	public member implPrefix: {(string | UserString)...} = ();

	@@Other functions for which prototypes (though not necessarily c++ overloads) must
	@@be provided in order to use this implementation. Functions that appear in this
	@@list will be linked locally by their specified names.
	@@This mapping usually takes the form @("__localdep_strlen" : "strlen")
	@@NOTE: When this points to a Callable object, then that function is
	@@      invoked and should then return one of the other accepted types.
	@@NOTE: Additionally, this member may also be assigned a Callable object,
	@@      in which case that object's return value is used as the dependencies
	@@      @Mapping
	public member dependencies
		: {string: (string | UserString | Function | Callable)} | Callable = none;

	@@Same as @dependencies, but enumerate the actual Function objects
	public property dependencyFunctions: {string: Function} = {
		get(): {Function...} {
			if (m_dependencyFunctions !is bound) {
				local result = Dict();
				local usedDeps = dependencies;
				if (usedDeps is Callable)
					usedDeps = usedDeps();
				for (local name, elem: usedDeps) {
					if (elem is Callable)
						elem = elem();
					if (elem !is Function)
						elem = findFunctionByName(elem);
					result[name] = elem;
				}
				m_dependencyFunctions = result;
				dependencies          = result;
				return result;
			}
			return m_dependencyFunctions;
		}
	}
	private member m_dependencyFunctions: {string: Function};

	public function preload() {
		dependencyFunctions;
	}

	@@Truncate @body for use in a truncated inline function binding
	public function truncateBodyForInline(): FunctionImplementation {
		local result = copy this;
		local newBody = str(result.body);
		/* Simple: Unescape escaped line-feeds */
		newBody = newBody.replace("\\\n", "");
		/* TODO:
		 *  - Delete all C/C++-style comments from @result.body
		 *  - Replace all new-line characters from @result.body with " ",
		 *    except for those that was followed by an arbitrary amount
		 *    of whitespace, followed by a "#"-character. However, also
		 *    make
		 *  - Replace all instances of multiple consecutive space characters
		 *    with only a single space character, except for those that appear
		 *    in string-/character-literals
		 */
		/* TODO: This is hacky, and imperfect! (See the above comment) */
		newBody = newBody.replace("\n", " ").replace("\t", " ");
		for (;;) {
			local temp = newBody.replace("  ", " ");
			if (temp == newBody)
				break;
			newBody = temp;
		}
		result.body = newBody;
		return result;
	}

	@@Print everything necessary for this implmentation
	@@@param: dependencyDecl: Declaration prefix for dependencies (usually @"__LIBC")
	@@@param: escapeMode:     One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: keyDependency:  Transformation key for the names of dependent functions
	public function cprintLocalFunctionImplementation(
			fp: CWriter, escapeMode: int, name: string,
			prototype: FunctionPrototype, dependencyDecl: string,
			doc: string, namespace: Namespace,
			keyDependency: Callable with string) {
		fp.forceStartOfLine();
		local oldNs = fp.namespace;
		fp.namespace = namespace;
		local oldExternLinkage = fp.externLinkage;
		if (oldExternLinkage !in ["", "C"])
			fp.externLinkage = "";
		/* Bind dependent functions. */
		local deps: {string: Function} = dependencyFunctions;
		for (local depName: deps.keys.sorted()) {
			local depFun = deps[depName];
			fp << "/* Dependency: "
				<< depFun.name << " from "
				<< depFun.originalSystemHeaderName << " */\n";
			depName = keyDependency(depName);
			depFun.cprintHeaderDeclaration(
				fp, escapeMode, dependencyDecl,
				exposedName: depName,
				guardName:   namespace.keyDefaultGuard(depName),
				preferBindingMacros:       true,
				printDeclarationPrefixes:  true,
				onlyPrintPrimaryPrototype: true,
				/* FIXME: Must currently ignore fast function bindings to prevent dependency loops:
				 *
				 *     <stdlib.h>
				 *     <libc/local/wchar/wcsrtombs.h>
				 *     <optimized/string.h>      (for dependency `mempcpy()'; `__local___localdep_mempcpy_defined' was already defined)
				 *     <libc/core/string.h>
				 *     <libc/local/string/mempcpyc.h>
				 *
				 * The local implementation for `mempcpyc()' now won't pull in `mempcpy()',
				 * since `__local___localdep_mempcpy_defined' is already defined, even though
				 * the associated function hasn't been declared, yet.
				 *
				 * (Temporary) solution:
				 *     Break the dependency loop in <libc/local/wchar/wcsrtombs.h> by not including
				 *     <optimized/string.h>, which is done by ignoring fast bindings.
				 *
				 * (Better) solution:
				 *     Have one <optimized/string/xxx.h> file for every function that provides
				 *     inline optimizations (possibly auto-generate these files via a separate
				 *     generator script).
				 *     That way, `mempcpy()' wouldn't have an implicit dependency on `mempcpyc()',
				 *     as it is this loop that makes it impossible to form a proper tree of
				 *     dependencies between <libc/local/...> implementations, <libc/core/...>
				 *     bindings, and <optimized/...> wrappers.
				 */
				ignoreFastBindings:        true
				);
		}
		if (implPrefix) {
			fp.namespace = GLOBAL_NAMESPACE;
			for (local x: implPrefix) {
				escapeNonRepeatingTextIntoFile(
					fp, x, escapeMode,
					keyEscape: [](keyword: string): string {
						if (keyword in deps) {
							local res = keyDependency(keyword);
							if (fp.namespace !== LOCAL_NAMESPACE)
								res = "({} {})".format({ LOCAL_NAMESPACE.prefix, res });
							return res;
						}
						return none;
					},
					forceKeyEscape: true);
			}
			fp.namespace = namespace;
		}
		if (doc)
			fp.printComment(doc);
		fp << "__LOCAL_LIBC(" << name << ") ";
		if (prototype.cprintAttributeList(fp, escapeMode))
			fp << " ";
		prototype.returnType.cprint(fp, escapeMode);
		fp << "\n";
		if (!prototype.isNothrowThrowing)
			escapeTextIntoFile(fp, prototype.nothrow, escapeMode);
		fp << "(";
		escapeTextIntoFile(fp, prototype.cc, escapeMode);
		if (prototype.cc)
			fp << " ";
		local csymbolName = namespace.keyCSymbolName(name);
		fp << csymbolName << ")";
		prototype.cprintArgumentListWithTypes(fp, escapeMode);
		if (prototype.isNothrowThrowing) {
			fp << " ";
			escapeTextIntoFile(fp, prototype.nothrow, escapeMode);
		}
		fp << " ";
		local selfName = this.name;
		escapeTextIntoFile(fp, body, escapeMode,
			keyEscape: [](keyword: string): string {
				if (keyword == selfName)
					return csymbolName;
				if (keyword in deps)
					return keyDependency(keyword);
				return none;
			},
			forceKeyEscape: true
		);
		fp << "\n";
		fp.externLinkage = oldExternLinkage;
		fp.namespace = oldNs;
	}
}


@@Only used by the @(import .loader)
class LoaderFunctionImplementation {
	this = default;
	public member impl: FunctionImplementation;
	public member ppCond: string | UserString = "1";
	public member ppCondPrefix: {(string | UserString)...} = ();
	public function preload() {
		impl.preload();
	}
}



class LocalFunction {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of this local function (e.g. "strlen")
	public member name: string | UserString;

	@@Name of this declaring system header (e.g. "string" for <string.h>)
	public member originalSystemHeaderName: string | UserString;

	@@The prototype adhered to by all local implementation variants
	public member prototype: FunctionPrototype | Callable;

	@@Preprocessor conditions that must be met in order
	@@for this local function implementation to be chosed.
	public member ppCond: string | UserString = "1";

	@@Pieces of code that must be written before @ppCond can be evaluated
	@@This code is inserted at the global namespace scope!
	public member ppCondPrefix: {(string | UserString)...} = ();

	@@The bound implementation for the local function
	public member impl: FunctionImplementation | Callable;

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Helper wrapper for @prototype that will automatically unwind @Callable objects
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				result = prototype = result();
			return result;
		}
	}

	@@Wrapper for @impl that will automatically unwind @Callable bindings
	public property functionImpl: FunctionImplementation = {
		get(): FunctionImplementation {
			local result = impl;
			if (result is Callable)
				result = impl = result();
			return result;
		}
	}

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				result = documentation = result();
			return result;
		}
	}

	public function preload() {
		if (prototype is bound)
			functionPrototype;
		if (impl is bound)
			functionImpl.preload();
		documentationString;
	}

	@@@param: dependencyDecl: Declaration prefix for dependencies (usually @"__LIBC")
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintLocalFunctionHeader(
			fp: CWriter, escapeMode: int, dependencyDecl: string,
			keyDependency: Callable with string = none,
			printCopyright: bool = true, namespace: Namespace = none) {
		try {
			if (keyDependency is none)
				keyDependency = keyLocalDep;
			if (namespace is none)
				namespace = LOCAL_NAMESPACE;
			if (printCopyright)
				fp << COPYRIGHT << "\n";
			local usedPrototype = functionPrototype;
			local localGuardName = namespace.keyDefaultGuard(name);
			fp.ppIfndef(localGuardName);
			fp.ppDefine(localGuardName, "1");
			fp.ppInclude("<__crt.h>");
			/* Include the preprocessor-condition prefix texts. */
			for (local x: ppCondPrefix)
				escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
			CWriter_ppIfEscaped(fp, ppCond, escapeMode);
			/* Print out the declaration prefix. */
			for (local x: usedPrototype.declPrefix)
				escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
			fp.forceStartOfLine();
			/* Print the binding */
			functionImpl.cprintLocalFunctionImplementation(
				fp, escapeMode, name, usedPrototype,
				dependencyDecl, documentationString,
				namespace, keyDependency);
			local myLocalDepName = keyLocalDep(name);
			local myLocalDepGuard = namespace.keyDefaultGuard(myLocalDepName);
			fp.forceStartOfLine();
			/* Also bind ourself as a local dependency function */
			fp << "#ifndef " << myLocalDepGuard << "\n"
				"#define " << myLocalDepGuard << " 1\n"
				"#define " << myLocalDepName << " " << namespace.keyCSymbolName(name) << "\n"
				"#endif /* !" << myLocalDepGuard << " */\n";
			fp.ppElse();
			fp.ppUndef(localGuardName);
			fp.ppEndif();
			fp.ppEndif();
		} catch (...) {
			print("... while printing local-header <libc/local/",
				originalSystemHeaderName, "/", name, ".h>");
			throw;
		}
	}

	@@Print a binding for this function
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintFunctionBinding(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			prototypes: {FunctionPrototype...}, doc: string, preferBindingMacros: bool) {
		local usedPrototype = functionPrototype;
		local oldExternLinkage = fp.externLinkage;
		if (oldExternLinkage !in ["", "C"])
			fp.externLinkage = "";
		local oldNs = fp.namespace;
		fp.namespace = GLOBAL_NAMESPACE;
		/* Include the local-header for this function */
		fp.ppInclude("<libc/local/{}/{}.h>".format({
			originalSystemHeaderName, name }));
		/* Remember that we'll be needing the local implementation of this function */
		neededLocalFunction.insert(this);
		fp.namespace = oldNs;
		fp.externLinkage = oldExternLinkage;
		local callToLocalName = LOCAL_NAMESPACE.keyCSymbolName(name);
		if (oldNs !== LOCAL_NAMESPACE) {
			if (LOCAL_NAMESPACE.prefix)
				callToLocalName = "{} {}".format({ LOCAL_NAMESPACE.prefix, callToLocalName });
			callToLocalName = "({})".format({ callToLocalName });
		}
		/* When only doing partial escaping of declaration, we must still
		 * do full escaping within call-to-local expressions, since local
		 * functions may use types in their declarations (which we in turn
		 * have to cast our prototypes to), that aren't declared in the
		 * current header (meaning that their representation must be fully
		 * escaped) */
		local callToEscapeMode = escapeMode;
		if (callToEscapeMode == ESCAPE_MODE_PART)
			callToEscapeMode = ESCAPE_MODE_FULL;
		if (preferBindingMacros) {
			if (doc)
				fp.printComment(doc);
			if (#prototypes == 1) {
				prototypes.first.cprintCallToMacro(
					fp, callToEscapeMode, exposedName,
					callToLocalName, usedPrototype);
			} else {
				fp << "#define " << exposedName << " " << callToLocalName;
			}
			return;
		}
		if (prototypes.each.hasEllipsis || ...) {
			/* _Must_ (try to) use keyUsing for c++, or a macro for C */
			if (doc)
				fp.printComment(doc);
			if (exposedName == name) {
				fp.ppIfdef("__cplusplus");
				LOCAL_NAMESPACE.keyUsingOrImpl(fp, exposedName, []{
					prototypes.first.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, callToLocalName, usedPrototype,
						callToEscapeMode: callToEscapeMode);
				});
				fp.ppElse();
				fp << "#define " << exposedName << " " << callToLocalName << "\n";
				fp.ppEndif();
			} else {
				fp << "#define " << exposedName << " " << callToLocalName << "\n";
			}
			return;
		}
		for (local ptype: prototypes) {
			if (doc)
				fp.printComment(doc);
			local allowUsing = exposedName == name && #prototypes == 1 &&
			                   ptype.compatibleWith(usedPrototype);
			if (allowUsing) {
				/* Can only be done if the prototypes match up! */
				LOCAL_NAMESPACE.keyUsingOrImpl(fp, exposedName, []{
					ptype.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, callToLocalName, usedPrototype,
						callToEscapeMode: callToEscapeMode);
				});
			} else {
				ptype.cprintCallToFunction(
					fp, escapeMode, NAMESPACE_IMPORT_DECL,
					exposedName, callToLocalName, usedPrototype,
					callToEscapeMode: callToEscapeMode);
				fp << "\n";
			}
		}
	}

}

class InlineFunction {
	this = default;

	@@Inline mode. One of:
	@@  - @"LOCAL"
	@@  - @"FORCELOCAL"
	@@  - @"__EXTERN_INLINE"
	public member mode: string = "LOCAL";

	@@The different, possible methods by which this function can be implemented.
	@@During compile-time, the first variant is chosen for which
	@@the @ppCond evaluates to a true-expression
	public member impl: FunctionImplementation | Callable = ();

	@@Name of the assembly symbol against which
	@@to link in case @(mode == "__EXTERN_INLINE")
	public member externInlineAsmname: string | UserString;

	@@Set to true for so-called `fast` function bindings. Such bindings will
	@@not be linked in `<libc/core/string.h>`, through fast bindings will then
	@@still be linked everywhere else, including in `<libc/string.h>`
	public member isFastBinding: bool = false;

	@@Returns @impl, but will unwind @Callable wrappers
	public property functionImpl: FunctionImplementation = {
		get(): FunctionImplementation {
			local result = impl;
			if (result is Callable)
				result = impl = result();
			return result;
		}
	}

	public function preload() {
		functionImpl.preload();
	}

	@@Bind the inline function's body.
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintFunctionBinding(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			prototypes: {FunctionPrototype...}, doc: string,
			preferBindingMacros: bool, keyDependency: Callable with string = none,
			dependenciesNamespace: Namespace = none, dependencyDecl: string = "__LIBC") {
		local impl: FunctionImplementation = functionImpl;
		local implName = impl.name;
		/* Bind dependent functions. */
		local deps: {string: Function} = impl.dependencyFunctions;
		local depKey = none;
		if (deps) {
			if (dependenciesNamespace is none)
				dependenciesNamespace = NAMESPACES["local"];
			if (keyDependency is none)
				keyDependency = keyLocalDep;
			depKey = [](keyword: string): string {
				if (keyword == implName)
					return exposedName;
				if (keyword in deps) {
					local res = keyDependency(keyword);
					if (fp.namespace === dependenciesNamespace)
						return res;
					return "({} {})".format({
						dependenciesNamespace.prefix,
						res
					});
				}
				return none;
			};
			local oldExternLinkage = fp.externLinkage;
			if (oldExternLinkage !in ["", "C"])
				fp.externLinkage = "";
			local oldNs = fp.namespace;
			fp.namespace = dependenciesNamespace;
			for (local depName: deps.keys.sorted()) {
				local depFun = deps[depName];
				depName = keyDependency(depName);
				depFun.cprintHeaderDeclaration(fp, escapeMode, dependencyDecl,
					exposedName:              depName,
					guardName:                dependenciesNamespace.keyDefaultGuard(depName),
					preferBindingMacros:      true,
					printDeclarationPrefixes: true);
			}
			fp.namespace = oldNs;
			fp.externLinkage = oldExternLinkage;
		} else {
			depKey = [](keyword: string): string {
				if (keyword == implName)
					return exposedName;
				return none;
			};
		}
		if (impl.implPrefix) {
			local oldExternLinkage = fp.externLinkage;
			if (oldExternLinkage !in ["", "C"])
				fp.externLinkage = "";
			local oldNs = fp.namespace;
			fp.namespace = GLOBAL_NAMESPACE;
			for (local x: impl.implPrefix) {
				escapeNonRepeatingTextIntoFile(
					fp, x, escapeMode,
					keyEscape: [](keyword: string): string {
						if (keyword in deps) {
							local res = keyDependency(keyword);
							if (fp.namespace === dependenciesNamespace)
								return res;
							return "({} {})".format({
								dependenciesNamespace.prefix,
								res
							});
						}
						return none;
					},
					forceKeyEscape: true);
			}
			fp.namespace = oldNs;
			fp.externLinkage = oldExternLinkage;
		}
		for (local prototype: prototypes) {
			if (doc)
				fp.printComment(doc);
			if (mode == "__EXTERN_INLINE") {
				prototype.cprintExternInlineBindingStart(
					fp, escapeMode, decl, exposedName,
					str externInlineAsmname);
				/* Inline implementation */
				escapeTextIntoFile(
					fp, impl.body, escapeMode,
					keyEscape: depKey,
					forceKeyEscape: true);
				fp << ")\n";
			} else {
				/* Generic inlining (use the inlining mode as declaration prefix) */
				prototype.cprintDeclarationWithoutTerminator(
					fp, escapeMode, this.mode, exposedName);
				fp << " ";
				escapeTextIntoFile(
					fp, impl.body, escapeMode,
					keyEscape: depKey,
					forceKeyEscape: true);
				fp << "\n";
			}
		}
	}
}


@@Return the @FunctionPrototype.cc that is common to all of the
@@given @prototypes. If different CCs are used, return @none instead.
function getCommonCCFromPrototypes(
		prototypes: {(string | UserString, {FunctionPrototype...})...}): string | none {
	local result = none;
	for (local none, protos: prototypes) {
		for (local proto: protos) {
			local pcc = str(proto.cc);
			if (result is none)
				result = pcc;
			else if (result != pcc) {
				return none;
			}
		}
	}
	return result;
}

@@Check if the given 2 lists of function prototypes
@@and conditions are compatible with each other
function areFunctionPrototypesCompatible(
		a: {(string | UserString, {FunctionPrototype...})...},
		b: {(string | UserString, {FunctionPrototype...})...}): bool {
	if (a === b)
		return true;
	local an = #a;
	if (an != #b)
		return false;
	for (local i = 0; i < an; ++i) {
		local ea = a[i];
		local eb = b[i];
		if (ea[0] != str(eb[0]))
			return false;
		ea = ea[1];
		eb = eb[1];
		local apn = #ea;
		if (apn != #eb)
			return false;
		for (local j = 0; j < apn; ++j) {
			if (!ea[j].compatibleWith(eb[j]))
				return false;
		}
	}
	return true;
}



class NamespaceBinding {
	this = default;

	@@The namespace from which to import the function
	public member namespace: Namespace;

	@@Name of the function within @namespace
	public member importName: string | UserString;

	@@The prototype to match when doing a call-to import
	@@Ignored when @namespace doesn't do any escaping.
	@@i.e. @(namespace.keyCSymbolName(importName) == importName)
	public member prototype: FunctionPrototype | Callable;

	@@Wrapper for @prototype
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				result = prototype = result();
			return result;
		}
	}

	public function preload() {
		if (prototype is bound)
			functionPrototype;
	}

	@@Print a binding for this namespace import
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintNamespaceImportBinding(
			fp: CWriter, escapeMode: int, exposedName: string,
			conditionalPrototypes: {(string | UserString, {FunctionPrototype...})...},
			doc: string, preferBindingMacros/*unused*/: bool) {
		assert namespace !== fp.namespace;
		assert importName == exposedName;
		if (doc)
			fp.printComment(doc);
		local callToEscapeMode = escapeMode;
		if (callToEscapeMode == ESCAPE_MODE_PART)
			callToEscapeMode = ESCAPE_MODE_FULL;
		/* There are 2 ways in which we must import namespace imports:
		 * The (simple) C++ way:
		 * >> namespace.keyUsing(fp, exposedName);
		 * And the (complicated) C way:
		 * >> __NAMESPACE_FAST_USING_OR_IMPL(<exposedName>, ...) */
		local cSymbolName = namespace.keyCSymbolName(exposedName);
		if (cSymbolName == exposedName) {
			/* The namespace doesn't do any sort of name escape
			 * (this is the case for the std- and global namespaces)
			 * In this case, we can simply do a conditional namespace
			 * import in C++-mode, and don't have to do anything
			 * in C-mode (since the symbol will have already been
			 * imported in that case) */
			if (namespace === STD_NAMESPACE) {
				/* We can always simply use keyUsing() in this case! */
				namespace.keyUsing(fp, exposedName);
				return;
			}
			local nsPrefix = namespace.prefix;
			if (namespace === GLOBAL_NAMESPACE)
				nsPrefix = "::";
			if (nsPrefix)
				cSymbolName = "({} {})".format({ nsPrefix, cSymbolName });
			if (#conditionalPrototypes == 1 && conditionalPrototypes.first[0] == "1") {
				namespace.keyUsingOrImpl(fp, exposedName, []{
					local prototypes = conditionalPrototypes.first[1];
					if (#prototypes == 1) {
						local callToPrototype = prototypes.first;
						if (prototype is bound)
							callToPrototype = functionPrototype;
						prototypes.first.cprintCallToFunction(
							fp, escapeMode, NAMESPACE_IMPORT_DECL,
							exposedName, cSymbolName, callToPrototype,
							callToEscapeMode: callToEscapeMode);
					} else {
						fp.forceStartOfLine();
						local oldExternLinkage = fp.externLinkage;
						fp.externLinkage = "C++";
						for (local p: prototypes) {
							local callToPrototype = p;
							if (prototype is bound)
								callToPrototype = functionPrototype;
							p.cprintCallToFunction(
								fp, escapeMode, NAMESPACE_IMPORT_DECL,
								exposedName, cSymbolName, callToPrototype,
								callToEscapeMode: callToEscapeMode);
							fp.forceStartOfLine();
						}
						fp.externLinkage = oldExternLinkage;
					}
				});
			} else {
				local cond = "!defined(__COMPILER_HAVE_BUG_BLOATY_CXX_USING)";
				if (namespace === GLOBAL_NAMESPACE || namespace === STD_NAMESPACE)
					cond = "!defined(__COMPILER_HAVE_BUG_BLOATY_CXX_USING) || defined(__NO_NAMESPACE_STD)";
				fp.ppIf(cond);
				namespace.keyUsing(fp, exposedName);
				fp.ppElse();
				local isFirst = true;
				local numAdditionalEndifs = 0;
				for (local ppCond, prototypes: conditionalPrototypes) {
					if (!prototypes)
						continue;
					if (isFirst) {
						CWriter_ppIfEscaped(fp, ppCond, escapeMode);
						isFirst = false;
					} else {
						if (!CWriter_ppElifEscaped(fp, ppCond, escapeMode))
							++numAdditionalEndifs;
					}
					if (#prototypes == 1) {
						local callToPrototype = prototypes.first;
						if (prototype is bound)
							callToPrototype = functionPrototype;
						prototypes.first.cprintCallToFunction(
							fp, escapeMode, NAMESPACE_IMPORT_DECL,
							exposedName, cSymbolName, callToPrototype,
							callToEscapeMode: callToEscapeMode);
					} else {
						fp.forceStartOfLine();
						local oldExternLinkage = fp.externLinkage;
						fp.externLinkage = "C++";
						for (local p: prototypes) {
							local callToPrototype = p;
							if (prototype is bound)
								callToPrototype = functionPrototype;
							p.cprintCallToFunction(
								fp, escapeMode, NAMESPACE_IMPORT_DECL,
								exposedName, cSymbolName, callToPrototype,
								callToEscapeMode: callToEscapeMode);
							fp.forceStartOfLine();
						}
						fp.externLinkage = oldExternLinkage;
					}
				}
				fp.ppEndifN(numAdditionalEndifs);
				if (!isFirst)
					fp.ppEndif();
				fp.ppEndif();
			}
			return;
		}
		if (!conditionalPrototypes)
			return; /* Shouldn't happen... */
		if (namespace.prefix)
			cSymbolName = "({} {})".format({ namespace.prefix, cSymbolName });
		local isFirst = true;
		local numAdditionalEndifs = 0;
		for (local ppCond, prototypes: conditionalPrototypes) {
			if (isFirst) {
				CWriter_ppIfEscaped(fp, ppCond, escapeMode);
				isFirst = false;
			} else {
				if (!CWriter_ppElifEscaped(fp, ppCond, escapeMode))
					++numAdditionalEndifs;
			}
			if (#prototypes == 1) {
				/* The complicated case: Must use `keyUsingOrImpl' */
				namespace.keyUsingOrImpl(fp, exposedName, []{
					local callToPrototype = prototypes.first;
					if (prototype is bound)
						callToPrototype = functionPrototype;
					prototypes.first.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, cSymbolName, callToPrototype,
						callToEscapeMode: callToEscapeMode);
				});
			} else {
				/* TODO: preferBindingMacros */
				/* The even more complicated case:
				 * >> #ifdef __cplusplus
				 * >> __NAMESPACE_FAST_USING(<exposedName>)
				 * >> #else
				 * >> <CallToProto1>
				 * >> <CallToProto2>
				 * >> <CallToProto...>
				 * >> <CallToProtoN>
				 * >> #endif */
				fp.ppIf("defined(__cplusplus) && !defined(__COMPILER_HAVE_BUG_BLOATY_CXX_USING)");
				namespace.keyUsing(fp, exposedName);
				fp.ppElse();
				for (local proto: prototypes) {
					local callToPrototype = proto;
					if (prototype is bound)
						callToPrototype = functionPrototype;
					proto.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, cSymbolName, callToPrototype,
						callToEscapeMode: callToEscapeMode);
					fp << "\n";
				}
				fp.ppEndif();
			}
		}
		fp.ppEndifN(numAdditionalEndifs);
		if (!isFirst)
			fp.ppEndif();
	}
}


class FunctionBinding {
	this = default;

	@@Preprocessor condition that must be evaluate to true at compile-time
	@@in order for this binding to be considered usable by the hosting compiler.
	public member ppCond: string | UserString = "1";

	@@Pieces of code that must be written before @ppCond can be evaluated
	@@This code is inserted at the global namespace scope!
	public member ppCondPrefix: {(string | UserString)...} = ();

	@@Prototype selectors (usually simply @({ "1", { <primaryPrototype> } }))
	@@This is a list of pairs (ppCond, prototypes) to select which prototypes
	@@should be used to bind the function.
	@@Different prototypes can be provided with a dependency on some preprocessor
	@@expression in order to support CORRECT_ISO_CXX_OVERLOADS declarations.
	@@NOTE: In practice, the preprocessor conditions for prototype selection
	@@      should always be done such that a prototype will exist in all
	@@      conditions. However, this is not a requirement.
	public member prototypes: {(string | UserString, {FunctionPrototype...})...} | Callable = ();

	@@The actual binding provided by this function:
	@@  - @LocalFunction:    Provide a local function implementation, via inclusion of
	@@                       <libc/local/@(binding.originalSystemHeaderName)/@(binding.name).h>
	@@  - @InlineFunction:   Provide an in-line function implementation, possibly alongside
	@@                       support for @"__EXTERN_INLINE"
	@@  - @string:           External assembly symbol (bind the function against
	@@                       an assembly symbol by the name of @binding)
	@@  - @UserString:       Same as @string
	@@  - @NamespaceBinding: Import an existing declaration from some other namespace
	@@  - @Callable:         A callback that takes no arguments, and returns one of the above
	public member binding: LocalFunction | InlineFunction | string | UserString | NamespaceBinding | Callable;

	public property functionPrototypes: {(string | UserString, {FunctionPrototype...})...} = {
		get(): {(string | UserString, {FunctionPrototype...})...} {
			local result = prototypes;
			if (result is Callable)
				result = prototypes = result();
			return result;
		}
	}

	@@Check if this binding has a *primary* prototype (or return @none if it doesn't)
	@@A primary prototype exists if at least one @prototypes has a condition string
	@@that evaluates to @"1". The first set of prototypes that does this is then
	@@considered the set of primary prototypes. Furthermore, should this set then be
	@@made up of exactly one prototype, that prototype is then *the* primary prototype.
	@@In all other cases, no primary prototype exists, and this property returns @none
	public property primaryPrototype: FunctionPrototype | none = {
		get(): FunctionPrototype | none {
			for (local ppCond, protos: functionPrototypes) {
				if (ppCond != "1")
					continue;
				if (#protos == 1)
					return protos.first;
				break;
			}
			return none;
		}
	}

	@@Return @binding, but unwind @Callable wrappers
	public property functionBinding: LocalFunction | InlineFunction | string | UserString | NamespaceBinding = {
		get(): LocalFunction | InlineFunction | string | UserString | NamespaceBinding {
			local result = binding;
			if (result is Callable)
				result = binding = result();
			return result;
		}
	}

	public function preload() {
		functionPrototypes;
		local bind = functionBinding;
		if (hasattr(bind, "preload"))
			bind.preload();
	}

	@@Simple helper to peek if the ppCond part of @this binding is known already
	@@Note that it may become known at a later point in time, and that this function
	@@may not necessary detect it as being known. Only note that a return value
	@@other than @none indicates a guarantied, known value
	public function getRequiresConstant(): bool | none {
		if (ppCond == "0")
			return false;
		if (functionBinding is NamespaceBinding) {
			if (ppCond == "1")
				return false;
			return none;
		}
		local usedProtos = functionPrototypes;
		if (!usedProtos)
			return false;
		local hasBindablePrototype = false;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "1") {
				/* Universal prototype */
				if (ppCond == "1")
					return true;
				return none;
			} else if (protoCond != "0") {
				hasBindablePrototype = true;
			}
		}
		if (!hasBindablePrototype)
			return false;
		return none;
	}

	@@Print requires-conditions for this function (has used by @"$has_function(...)")
	public function cprintRequires(
			fp: CWriter | File,
			extendedPrefixes: List | none) {
		if (ppCond == "0") {
			fp << "0";
			return;
		}
		if (functionBinding is NamespaceBinding)
			goto do_universal_binding;
		local usedProtos = functionPrototypes;
		if (!usedProtos) {
			fp << "0";
			return;
		}
		local hasUniversalPrototype = false;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "1") {
				hasUniversalPrototype = true;
				break;
			}
		}
		if (hasUniversalPrototype) {
do_universal_binding:
			if (extendedPrefixes !is none)
				extendedPrefixes.extend(ppCondPrefix);
			fp << "(";
			escapeTextIntoFile(fp, ppCond, ESCAPE_MODE_FULL,
				extendedPrefixes: extendedPrefixes);
			fp << ")";
			return;
		}
		if (ppCond != "1") {
			if (extendedPrefixes !is none)
				extendedPrefixes.extend(ppCondPrefix);
			fp << "((";
			escapeTextIntoFile(fp, ppCond, ESCAPE_MODE_FULL,
				extendedPrefixes: extendedPrefixes);
			fp << ")&&";
		}
		local hasMultiplePrototypes = 0;
		for (local protoCond, none: usedProtos) {
			if (protoCond != "0")
				++hasMultiplePrototypes;
		}
		if (hasMultiplePrototypes > 1)
			fp << "(";
		local isFirst = true;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "0")
				continue;
			if (!isFirst)
				fp << "||";
			fp << "(";
			escapeTextIntoFile(fp, protoCond, ESCAPE_MODE_FULL,
				extendedPrefixes: extendedPrefixes);
			fp << ")";
			isFirst = false;
		}
		if (hasMultiplePrototypes > 1)
			fp << ")";
		if (ppCond != "1")
			fp << ")";
	}

	@@Print a normal binding, as may be found in `<string.h>`
	@@NOTE: The caller is responsible to ensure that @ppCond evaluates to non-zero at compile-time
	@@@param: escapeMode:                One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:                      Declaration prefix (e.g. @"__LIBC")
	@@@param: exposedName:               The name by which to expose this binding (e.g. @"strlen")
	@@@param: doc:                       A human-readable description of the associated function
	@@@param: guardName:                 The name of a macro that must be #undef'd if no prototype
	@@                                   has been exposed at compile-time. Set to @none if no such macro exists
	@@@param: preferBindingMacros:       Prefer function bindings to be done with macros, rather than
	@@                                   through use of inline functions.
	@@@param: printDeclarationPrefixes:  Print prototype declaration prefixes
	@@@param: onlyPrintPrimaryPrototype: Only bind against @primaryPrototype (but fall back to binding
	@@                                   against all prototypes if no @primaryPrototype exists)
	public function cprintBindFunction(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			guardName: string | none = none, doc: string = "",
			preferBindingMacros: bool = false,
			printDeclarationPrefixes: bool = false,
			onlyPrintPrimaryPrototype: bool = false) {
		local usedBinding = functionBinding;
		local usedPrototypes = functionPrototypes;
		if (usedBinding is NamespaceBinding) {
			local usedNs = usedBinding.namespace;
			assert usedNs !== fp.namespace, "The caller must check this!";
			assert usedBinding.importName == exposedName, "The caller must check this!";
			usedBinding.cprintNamespaceImportBinding(
				fp, escapeMode, exposedName,
				usedPrototypes, doc, preferBindingMacros);
			return;
		}
		if (onlyPrintPrimaryPrototype && #usedPrototypes > 1) {
			local prim = primaryPrototype;
			if (prim !is none)
				usedPrototypes = { ("1", { prim }) };
		}
		if (#usedPrototypes >= 2) {
			for (local ppCond, none: usedPrototypes) {
				if (ppCond != "1")
					continue;
				if (usedBinding is LocalFunction) {
					/* Include the local-implementation beforehard! */
					local oldExternLinkage = fp.externLinkage;
					if (oldExternLinkage !in ["", "C"])
						fp.externLinkage = "";
					local oldNs = fp.namespace;
					fp.namespace = GLOBAL_NAMESPACE;
					/* Include the local-header for this function */
					fp.ppInclude("<libc/local/{}/{}.h>".format({
						usedBinding.originalSystemHeaderName,
						usedBinding.name }));
					fp.namespace = oldNs;
					fp.externLinkage = oldExternLinkage;
				}
				if (printDeclarationPrefixes) {
					/* TODO: Print declaration prefixes common to all of @usedPrototypes,
					 *       so-long as at least one of @usedPrototypes has a ppCond that
					 *       always evaluates to true */
				}
				break;
			}
		}
		local isFirst = true;
		local numAdditionalEndifs = 0;
		for (local ppCond, associatedPrototypes: usedPrototypes) {
			if (isFirst) {
				CWriter_ppIfEscaped(fp, ppCond, escapeMode);
				isFirst = false;
			} else {
				if (!CWriter_ppElifEscaped(fp, ppCond, escapeMode))
					++numAdditionalEndifs;
			}
			if (printDeclarationPrefixes) {
				if (usedBinding is LocalFunction &&
				    (#usedPrototypes == 1 && #associatedPrototypes == 1) &&
				    associatedPrototypes.first.declPrefix ==
				    usedBinding.functionPrototype.declPrefix) {
					/* The same prefix will already be printed
					 * inside of the local-function header. */
				} else {
					/* Print declaration prefixes */
					local oldNs = none;
					local oldExternLinkage;
					for (local proto: associatedPrototypes) {
						for (local x: proto.declPrefix) {
							if (oldNs is none) {
								oldExternLinkage = fp.externLinkage;
								if (oldExternLinkage !in ["", "C"])
									fp.externLinkage = "";
								oldNs = fp.namespace;
								fp.namespace = GLOBAL_NAMESPACE;
							}
							escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
						}
					}
					if (oldNs !is none) {
						fp.namespace = oldNs;
						fp.externLinkage = oldExternLinkage;
					}
				}
			}
			local oldExternLinkage = fp.externLinkage;
			if (#associatedPrototypes >= 2)
				fp.externLinkage = "C++";
			if (usedBinding is string || usedBinding is UserString) {
				usedBinding = str usedBinding;
				for (local ptype: associatedPrototypes) {
					if (doc)
						fp.printComment(doc);
					ptype.cprintRedirectionBinding(
						fp, escapeMode, decl,
						exposedName, usedBinding);
				}
			} else {
				usedBinding.cprintFunctionBinding(
					fp, escapeMode, decl, exposedName, associatedPrototypes,
					doc, preferBindingMacros);
			}
			fp.externLinkage = oldExternLinkage;
		}
		fp.ppEndifN(numAdditionalEndifs);
		if (guardName !is none) {
			if (!isFirst)
				fp.ppElse();
			if (guardName == "__local___localdep__vswprintf_c_defined") {
				fp << "// !!!!HERE!!!!\n";
				fp << "// isFirst = " << repr(isFirst) << "\n";
				fp << "// usedPrototypes = " << repr(usedPrototypes) << "\n";
			}
			fp.ppUndef(guardName);
		}
		if (!isFirst)
			fp.ppEndif();
	}
}



class Function {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of the function in public headers (e.g. @"strlen")
	public member name: string | UserString;

	@@Name of the function inside of the actual library
	@@Set to @none if the function isn't actually being exported from its associated library
	public member internalName: string | UserString | none | Callable = none;

	@@Name of the original defining system header (may differ from the containing
	@@header in case @"%[insert:extern(...)]" was used to inject a foreign function)
	public member originalSystemHeaderName: string | UserString;

	@@Ordered list of bindings with which this function is exposed in system headers
	@@This list is enumerated, and the first binding who's @FunctionBinding.ppCond
	@@field evaluates to @true will then be used as the binding exposed.
	public member bindings: {(FunctionBinding | Callable)...} | Callable = [];

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Helper wrapper for @internalName to automatically unwind callable objects
	public property internalFunctionName: string | UserString | none = {
		get(): string | UserString {
			local result = internalName;
			if (result is Callable)
				result = internalName = result();
			return result;
		}
	}

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				result = documentation = result();
			return result;
		}
	}

	@@Return the only prototype in use (if only one, common prototype is
	@@defined across all @functionBinding), or @none if multiple prototypes,
	@@or no prototypes at all have been defined
	public property onlyPrototype: FunctionPrototype | none = {
		get(): FunctionPrototype | none {
			local result = none;
			for (local binding /*: FunctionBinding*/ : functionBindings) {
				for (local none, protos /*: {FunctionPrototype...}*/ : binding.functionPrototypes) {
					for (local proto /*: FunctionPrototype*/: protos) {
						if (result is none)
							result = proto;
						else if (!result.compatibleWith(proto)) {
							/* Incompatible prototypes! */
							return none;
						}
					}
				}
			}
			return result;
		}
	}

	@@Similar to @onlyPrototype, but return the set of prototypes+conditions
	@@common to all bindings, or @none if no such set exists.
	public property onlyPrototypes: {(string | UserString, {FunctionPrototype...})...} | none = {
		get(): {(string | UserString, {FunctionPrototype...})...} | none {
			local result = none;
			for (local binding /*: FunctionBinding*/ : functionBindings) {
				local conditionalProtos = binding.functionPrototypes;
				if (result is none) {
					result = conditionalProtos;
					continue;
				}
				if (areFunctionPrototypesCompatible(result, conditionalProtos))
					continue;
				return none;
			}
			return result;
		}
	}

	@@Same as @bindings, however Callable objects will have been flattened
	public property functionBindings: {FunctionBinding...} = {
		get(): {FunctionBinding...} {
			if (m_functionBindings !is bound) {
				local usedBindings = bindings;
				if (usedBindings is Callable)
					usedBindings = usedBindings();
				local newBindings = List();
				for (local bind: usedBindings) {
					if (bind is Callable) {
						bind = bind();
						if (bind is Sequence)
							newBindings.extend(bind);
						else if (bind !is none) {
							newBindings.append(bind);
						}
					} else {
						newBindings.append(bind);
					}
				}
				m_functionBindings = newBindings;
				bindings           = newBindings;
				return newBindings;
			}
			return m_functionBindings;
		}
	}
	private member m_functionBindings: {FunctionBinding...};

	@@Check if @this @Function has any @bindings for imports from the given @ns
	public function hasNamespaceImportBinding(ns: Namespace): bool {
		for (local b: functionBindings) {
			b = b.functionBinding;
			if (b is NamespaceBinding && b.namespace === ns)
				return true;
		}
		return false;
	}

	@@Check if @this @Function has any fast bindings
	public property hasFastBindings: bool = {
		get(): bool {
			for (local b: functionBindings) {
				b = b.functionBinding;
				if (b is InlineFunction && b.isFastBinding)
					return true;
			}
			if (hasNamespaceImportBinding(NAMESPACES["fast"])) /* TODO: REMOVE_ME */
				return true;
			return false;
		}
	}

	public function preload() {
		try {
			documentationString;
			for (local b: functionBindings)
				b.preload();
			internalFunctionName;
		} catch (...) {
			print "... while preloading Function", repr(name);
			throw;
		}
	}

	@@Check if this function is always, never, or only dynamically available
	@@@return: true:  Always available
	@@@return: false: Never available
	@@@return: none:  Availability must be determined at compile-time
	public function getRequiresConstant(): bool | none {
		local usedBindings = functionBindings;
		if (!usedBindings)
			return false;
		local hasDynamicBindings = false;
		for (local bind: usedBindings) {
			if (bind.functionBinding is NamespaceBinding)
				continue;
			local c = bind.getRequiresConstant();
			if (c === true)
				return true;
			if (c is none)
				hasDynamicBindings = true;
		}
		if (hasDynamicBindings)
			return none;
		return false;
	}

	@@Print requires-conditions for this function (has used by @"$has_function(...)")
	public function cprintRequires(
			fp: CWriter | File,
			extendedPrefixes: List | none) {
		local usedBindings = functionBindings;
		if (!usedBindings) {
no_usable_bindings:
			fp << "0";
			return;
		}
		local hasUsableBindings = 0;
		local hasUnusableBindings = false;
		for (local bind: usedBindings) {
			if (bind.functionBinding is NamespaceBinding)
				continue;
			local c = bind.getRequiresConstant();
			if (c === true) {
				fp << "1";
				return;
			}
			if (c === false)
				hasUnusableBindings = true;
			if (c is none)
				++hasUsableBindings;
		}
		if (!hasUsableBindings)
			goto no_usable_bindings;
		if (hasUsableBindings == 1) {
			local bind;
			for (bind: usedBindings) {
				if (bind.functionBinding is NamespaceBinding)
					continue;
				if (bind.getRequiresConstant() is none)
					break;
			}
			bind.cprintRequires(fp, extendedPrefixes);
		} else {
			fp << "(";
			local isFirst = true;
			for (local bind: usedBindings) {
				if (bind.functionBinding is NamespaceBinding)
					continue;
				if (hasUnusableBindings) {
					if (bind.getRequiresConstant() === false)
						continue;
				}
				if (!isFirst)
					fp << "||";
				bind.cprintRequires(fp, extendedPrefixes);
				isFirst = false;
			}
			fp << ")";
		}
	}

	@@Print this function's normal declaration, as might be found in `<string.h>`
	@@@param: escapeMode:                One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:                      The declaration prefix (e.g. @"__LIBC") with which to link
	@@@param: exposedName:               The name under which functions should be exposed (or @none
	@@                                   if @this.name should be used instead)
	@@@param: guardName:                 The name of a guard that should be used to wrap the declaration
	@@                                   When set to @true, use fp.namespace.keyDefaultGuard(exposedName)
	@@@param: preferBindingMacros:       Prefer function bindings to be done with macros, rather than
	@@                                   through use of inline functions.
	@@@param: printDeclarationPrefixes:  Print prototype declaration prefixes
	@@@param: onlyPrintPrimaryPrototype: Try to only bind against primary prototypes
	@@@param: ignoreNamespaceBindings:   Ignore namespace import bindings
	@@@param: ignoreFastBindings:        True if bindings with @FunctionBinding.isFastBinding should be ignored
	public function cprintHeaderDeclaration(
			fp: CWriter, escapeMode: int, decl: string = "__LIBC",
			exposedName: string = none, guardName: string | bool = none,
			preferBindingMacros: bool = false,
			printDeclarationPrefixes: bool = false,
			onlyPrintPrimaryPrototype: bool = false,
			ignoreNamespaceBindings: bool = false,
			ignoreFastBindings: bool = false) {
		try {
			local usedBindings = [];
			if (exposedName is none)
				exposedName = this.name;
			for (local b: functionBindings) {
				local bBind = b.functionBinding;
				if (bBind is InlineFunction) {
					if (ignoreFastBindings && bBind.isFastBinding)
						continue;
				} else if (bBind is NamespaceBinding) {
					if (ignoreNamespaceBindings)
						continue;
					if (bBind.namespace === fp.namespace)
						continue;
					if (bBind.importName != exposedName)
						continue;
				}
				usedBindings.append(b);
			}
			if (!usedBindings)
				return; /* No bindings -> Noop */
			local doc = documentationString;
			if (guardName is bool) {
				guardName = guardName
					? fp.namespace.keyDefaultGuard(exposedName)
					: none;
			}
			if (printDeclarationPrefixes) {
				/* TODO: Print declaration prefixes common to all bindings,
				 *       when at least one one binding exists that can get
				 *       bound unconditionally. */
			}
			if (guardName !is none) {
				if (#usedBindings == 1) {
					/* Try to optimize special case: Only 1 binding
					 * Instead of writing something like this:
					 * >> #ifndef __wcslen_defined
					 * >> #define __wcslen_defined 1
					 * >> #if $has_function(wcslen) || defined(__std_wcslen_defined)
					 * >> __NAMESPACE_STD_USING(wcslen)
					 * >> #else // <$has_function(wcslen)> || __std_wcslen_defined
					 * >> #undef __wcslen_defined
					 * >> #endif // !<$has_function(wcslen)> && !__std_wcslen_defined
					 * >> #endif // !__wcslen_defined
					 *
					 * Write the following instead:
					 * >> #if !defined(__wcslen_defined) && (defined(__std_wcslen_defined) || $has_function(wcslen))
					 * >> #define __wcslen_defined 1
					 * >> __NAMESPACE_STD_USING(wcslen)
					 * >> #endif // !__wcslen_defined && (__std_wcslen_defined || $has_function(wcslen)) */
					local bind = usedBindings.first;
					/* Special case: Can't bind against a declaration from the current namespace! */
					local bindBinding = bind.functionBinding;
					local extendedPrefixes = [];
					for (local x: bind.ppCondPrefix) {
						if (!fp.wasPrefixPrinted(escapeText(x, escapeMode,
								extendedPrefixes: extendedPrefixes)))
							goto normal_guardName_binding;
					}
again_check_extendedPrefixes:
					local newExtendedPrefixes = [];
					for (local x: extendedPrefixes) {
						if (!fp.wasPrefixPrinted(escapeText(x, escapeMode,
								extendedPrefixes: newExtendedPrefixes)))
							goto normal_guardName_binding;
					}
					if (newExtendedPrefixes) {
						extendedPrefixes = newExtendedPrefixes;
						goto again_check_extendedPrefixes;
					}
					fp.ppIf("!defined({}) && ({})".format({
						guardName,
						escapeText(bind.ppCond, escapeMode)
					}));
					fp.ppDefine(guardName, "1");
					bind.cprintBindFunction(
						fp, escapeMode, decl, exposedName, guardName,
						doc, preferBindingMacros,
						printDeclarationPrefixes,
						onlyPrintPrimaryPrototype);
					fp.ppEndif();
					return;
				}
normal_guardName_binding:
				fp.ppIfndef(guardName);
				fp.ppDefine(guardName, "1");
			} else /* if (guardName is none) */ {
				/* Check if we can use `__CDECLARE_OPT()' */
				if (#usedBindings == 1) {
					local bind: FunctionBinding = usedBindings.first;
					local bindBinding = bind.functionBinding;
					if (bindBinding is string || bindBinding is UserString) {
						bindBinding = str bindBinding;
						if (bind.ppCond == "defined(__CRT_HAVE_{})".format({ bindBinding })) {
							local bindingPrototypes: {(string | UserString, {FunctionPrototype...})...}
								= bind.functionPrototypes;
							if (#bindingPrototypes == 1) {
								local protoCond: string | UserString;
								local protos: {FunctionPrototype...};
								protoCond, protos = bindingPrototypes.first...;
								if (protoCond == "1" && #protos == 1) {
									local ptype: FunctionPrototype = protos.first;
									if (ptype.cprintRedirectionBindingUsesCDECLARE(
											fp, decl, exposedName, bindBinding)) {
										/* Use __CDECLARE_OPT() for the declaration! */
										if (doc)
											fp.printComment(doc);
										ptype.cprintCDECLARE(
											fp, escapeMode, decl, exposedName,
											optSuffix: true);
										return;
									}
								}
							}
						}
					}
				} /* if (#usedBindings == 1) */
			} /* if (guardName is none) */
			local isFirst = true;
			local numNeededEndif = [];
			for (local bind: usedBindings) {
				/* Special case: Can't bind against a declaration from the current namespace! */
				local bindBinding = bind.functionBinding;
				local extendedPrefixes = [];
				local newExtendedPrefixes = [];
				local usedPpCond = escapeText(
					bind.ppCond, escapeMode, extendedPrefixes: newExtendedPrefixes);
				local oldNs: Namespace | none = none;
				local oldExternLinkage;
				local extendedPrefixes = bind.ppCondPrefix;
handle_extendedPrefixes:
				for (local text: extendedPrefixes) {
					text = str(escapeText(text, escapeMode,
						extendedPrefixes: newExtendedPrefixes))
						.rstrip().lstrip("\n");
					if (fp._wasPrefixPrinted(text))
						continue;
					if (oldNs is none) {
						if (!isFirst) {
							fp.ppElse();
							numNeededEndif.last = false;
						}
						/* Include the preprocessor-condition prefix texts. */
						oldExternLinkage = fp.externLinkage;
						if (oldExternLinkage !in ["", "C"])
							fp.externLinkage = "";
						oldNs = fp.namespace;
						fp.namespace = GLOBAL_NAMESPACE;
					}
					fp.forceStartOfLine() << text << "\n";
					fp._rememberPrefixAlreadyPrinted(text);
				}
				if (newExtendedPrefixes) {
					extendedPrefixes = newExtendedPrefixes;
					newExtendedPrefixes = [];
					goto handle_extendedPrefixes;
				}
				if (oldNs !is none) {
					fp.namespace = oldNs;
					fp.externLinkage = oldExternLinkage;
					fp.ppIf(usedPpCond);
					numNeededEndif.pushback(true);
				} else if (isFirst) {
					fp.ppIf(usedPpCond);
					numNeededEndif.pushback(true);
				} else {
					fp.ppElif(usedPpCond);
				}
				bind.cprintBindFunction(
					fp, escapeMode, decl, exposedName, guardName,
					doc, preferBindingMacros,
					printDeclarationPrefixes,
					onlyPrintPrimaryPrototype);
				isFirst = false;
			}
			while (numNeededEndif) {
				local l = numNeededEndif.popback();
				if (l && guardName !is none) {
					fp.ppElse();
					fp.ppUndef(guardName);
				}
				fp.ppEndif();
			}
			if (guardName !is none)
				fp.ppEndif();
		} catch (...) {
			print "... while printing header declaration for",
				repr(this.name), "as", repr(exposedName);
			throw;
		}
	}

}


@@An optional wrapper for exposing a @Function within headers
class ExposedFunction {
	this = default;

	@@The associated function
	public member func: Function | Callable;

	@@Declaration prefix for this function exposure
	public member decl: string = "__LIBC";

	@@The actual, exposed name of the function (or @none to use @func.name instead)
	public member exposedName: string = none;

	@@The name of a guard that should be used to wrap
	@@the declaration. Set to @false to not provide a guard
	@@NOTE: When set to @true, use fp.namespace.keyDefaultGuard(exposedName)
	public member guardName: string | bool = false;

	@@Prefer function bindings to be done with macros,
	@@rather than through use of inline functions.
	public member preferBindingMacros: bool = false;

	@@Print @FunctionPrototype.declPrefix
	public member printDeclarationPrefixes: bool = false;

	@@Only bind against @FunctionBinding.primaryPrototype (but fall back to binding
	@@against all prototypes if no @FunctionBinding.primaryPrototype exists)
	public member onlyPrintPrimaryPrototype: bool = false;

	@@Don't bind against @NamespaceBinding
	public member ignoreNamespaceBindings: bool = false;

	@@An override for the active namespace during function declaration
	public member namespaceOverride: Namespace | UserString | string | none = none;

	@@An override for the active `extern "<externLinkage>"` during function declaration
	public member externLinkageOverride: string | none = none;

	@@Wrapper for @func
	public property exposedFunc: Function = {
		get(): Function {
			local result = func;
			if (result is Callable)
				result = func = result();
			return result;
		}
	}

	public function preload() {
		try {
			exposedFunc.preload();
		} catch (...) {
			print "... while preloading ExposedFunction",
				repr(func is Function ? func.name : none),
				"as", repr(exposedName);
			throw;
		}
	}

	@@Print this function's normal declaration, as might be found in `<string.h>`
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintHeaderDeclaration(fp: CWriter, escapeMode: int) {
		local oldNs = fp.namespace;
		local oldExternLinkage = fp.externLinkage;
		if (namespaceOverride !is none) {
			if (oldNs !== namespaceOverride) {
				if (oldExternLinkage != "")
					fp.externLinkage = "";
			}
			fp.namespace = namespaceOverride;
		}
		if (externLinkageOverride !is none)
			fp.externLinkage = externLinkageOverride;
		exposedFunc.cprintHeaderDeclaration(
			fp, escapeMode, decl, exposedName,
			guardName, preferBindingMacros,
			printDeclarationPrefixes,
			onlyPrintPrimaryPrototype,
			ignoreNamespaceBindings);
		if (fp.externLinkage != oldExternLinkage) {
			if (fp.namespace !== oldNs) {
				if (fp.externLinkage != "")
					fp.externLinkage = "";
				fp.namespace     = oldNs;
				fp.externLinkage = oldExternLinkage;
			} else {
				fp.externLinkage = oldExternLinkage;
			}
		} else {
			fp.namespace = oldNs;
		}
	}

}




class LibraryFunctionBinding {
	this = default;

	@@Preprocessor condition that must be evaluate to true at compile-time in
	@@order for this implementation to be considered usable by the hosting compiler.
	public member ppCond: string | UserString = "1";

	@@Binding, which is either a @FunctionImplementation,
	@@specifying how the function should actually be implemented,
	@@or is the symbol name of some other function for which this
	@@one should be defined as an INTERN-ALIAS
	public member binding: FunctionImplementation | string | UserString | Callable;

	@@Name of the section in which this function's body should be
	@@placed in order to provide the libc auto- or user-implementations
	@@NOTE: Ignored when binding isn't a @FunctionImplementation
	public member implSection: string | UserString | none = none;

	@@Returns @binding, but unwind @Callable wrappers
	public property functionBinding: FunctionImplementation | string | UserString = {
		get(): FunctionImplementation | string | UserString {
			local result = binding;
			if (result is Callable)
				result = binding = result();
			return result;
		}
	}

	public function preload() {
		functionBinding.preload();
	}

}

class LibraryFunction {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of the function in public headers (e.g. @"strlen")
	public member name: string | UserString;

	@@Preprocessor condition that must be evaluate to true at compile-time
	@@in order for this library function to actually be implemented.
	public member ppCond: string | UserString;

	@@Name of the original defining system header (may differ from the containing
	@@header in case @"%[insert:extern(...)]" was used to inject a foreign function)
	public member originalSystemHeaderName: string | UserString;

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Prototype used for the library implementation
	public member prototype: FunctionPrototype | Callable;

	@@The different ways by which this library function can be implemented.
	public member bindings: {(LibraryFunctionBinding | Callable)...} | Callable = [];

	@@Pairs of @(ppCond, symbolName) of how @this Binding should be exported from the library.
	public member exportSymbolNames: {(string | UserString, string | UserString)...} = [];

	@@The preprocessor-condition that must be met for @this @LibraryFunction
	@@to actually be implemented as part of its auto- or user-source
	@@This condition is essentially:
	@@    @(this.ppCond && (functionBindings.each.ppCond || ...))
	public property implementationPpCond: string = {
		get(): string {
			local ppCond = str(this.ppCond);
			if (ppCond == "0")
				return "0";
			local hasUniversalBinding = false;
			for (local b: functionBindings) {
				if (b.ppCond == "1") {
					hasUniversalBinding = true;
					break;
				}
			}
			if (hasUniversalBinding)
				return ppCond;
			local bindingConditions = [];
			for (local b: functionBindings) {
				if (b.ppCond == "0")
					continue;
				bindingConditions.append("({})".format({ b.ppCond }));
			}
			bindingConditions = "||".join(bindingConditions);
			if (!bindingConditions)
				return "0";
			if (ppCond != "1") {
				bindingConditions = "({})&&({})"
					.format({ ppCond, bindingConditions });
			}
			return bindingConditions;
		}
	}

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				result = documentation = result();
			return result;
		}
	}

	@@Helper wrapper for @prototype to automatically unwind callable objects
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				result = prototype = result();
			return result;
		}
	}

	@@Helper wrapper for @bindings that automates invocation of Callable objects
	public property functionBindings: {LibraryFunctionBinding...} = {
		get(): {LibraryFunctionBinding...} {
			if (m_functionBindings !is bound) {
				local usedBindings = bindings;
				if (usedBindings is Callable)
					usedBindings = usedBindings();
				local newBindings = [];
				for (local b: usedBindings) {
					if (b is Callable)
						b = b();
					if (b is Sequence) {
						newBindings.extend(b);
					} else if (b !is none) {
						newBindings.append(b);
					}
				}
				m_functionBindings = newBindings;
				bindings           = newBindings;
				return newBindings;
			}
			return m_functionBindings;
		}
	}
	private member m_functionBindings: {LibraryFunctionBinding...};

	public function preload() {
		documentationString;
		functionPrototype;
		for (local b: functionBindings)
			b.preload();
	}

	@@Print the in-library declaration of this function
	public function cprintInLibraryDeclaration(
			fp: CWriter, escapeMode: int, decl: string) {
		local usedBindings = functionBindings;
		if (!usedBindings)
			return;
		if (ppCond == "0")
			return;
		CWriter_ppIfEscaped(fp, ppCond, escapeMode);
		local doc = documentationString;
		if (doc)
			fp.printComment(doc);
		functionPrototype.cprintDeclarationWithoutTerminator(
			fp, escapeMode, decl: decl, exposedName: this.name);
		fp << ";\n";
		fp.ppEndif();
	}

	@@Print the in-library auto-implementation of this function
	public function cprintInLibraryAutoImplementation(
			fp: CWriter, escapeMode: int, decl: string) {
		try {
			local usedBindings = functionBindings;
			if (!usedBindings)
				return;
			CWriter_ppIfEscaped(fp, ppCond, escapeMode);
			local isFirst = true;
			local doc = documentationString;
			local proto = functionPrototype;
			local numAdditionalEndifs = 0;
			for (local bind /*: LibraryFunctionBinding*/: usedBindings) {
				if (isFirst) {
					CWriter_ppIfEscaped(fp, bind.ppCond, escapeMode);
					isFirst = false;
				} else {
					if (!CWriter_ppElifEscaped(fp, bind.ppCond, escapeMode))
						++numAdditionalEndifs;
				}
				local impl: FunctionImplementation | string | UserString = bind.functionBinding;
				if (impl is FunctionImplementation) {
					local deps: {string: Function} = impl.dependencyFunctions;
					local keyEscape = [](keyword: string): string {
						if (keyword == impl.name)
							return this.name;
						local depFun = deps.get(keyword);
						if (depFun !is none) {
							local intName = depFun.internalFunctionName;
							if (intName !is none)
								return intName;
						}
						return none;
					};
					for (local x: impl.implPrefix) {
						escapeNonRepeatingTextIntoFile(
							fp, x, escapeMode,
							keyEscape: keyEscape,
							forceKeyEscape: true);
					}
					if (doc)
						fp.printComment(doc);
					proto.cprintDeclarationWithoutTerminator(
						fp, escapeMode,
						decl:                 decl,
						exposedName:          this.name,
						injectedAttributes:   bind.implSection !is none
							? { "ATTR_SECTION({!r})".format({ bind.implSection }) }
							: none,
						breakAfterReturnType: true,
						oneArgumentPerLine:   true);
					fp << " ";
					escapeTextIntoFile(
						fp, impl.body, escapeMode,
						keyEscape: keyEscape,
						forceKeyEscape: true);
					fp << "\n";
				} else {
					fp << "DEFINE_" << decl << "_ALIAS("
						<< this.name << ", "
						<< impl << ");\n";
				}
			}
			fp.ppEndifN(numAdditionalEndifs);
			if (!isFirst)
				fp.ppEndif();
			fp.ppEndif();
		} catch (...) {
			print("... while printing in-library auto implementation for ",
				repr(this.name));
			throw;
		}
	}

	@@Print the in-library export table of this function
	public function cprintInLibraryExports(fp: CWriter, escapeMode: int) {
		local hasUsableExport = false;
		for (local ppCond, none: exportSymbolNames) {
			if (ppCond != "0") {
				hasUsableExport = true;
				break;
			}
		}
		if (!hasUsableExport)
			return;
		local usedBindings = functionBindings;
		CWriter_ppIfEscaped(fp, ppCond, escapeMode);
		local hasUniversalBinding = false;
		for (local bind: usedBindings) {
			if (bind.ppCond == "1") {
				hasUniversalBinding = true;
				break;
			}
		}
		if (!hasUniversalBinding) {
			File.Writer mergedCond;
			local isFirst = true;
			for (local bind: usedBindings) {
				if (!isFirst)
					mergedCond << "||";
				mergedCond << "(" << bind.ppCond << ")";
				isFirst = false;
			}
			CWriter_ppIfEscaped(fp, mergedCond.string, escapeMode);
		}
		for (local ppCond, symbolName: exportSymbolNames) {
			CWriter_ppIfEscaped(fp, ppCond, escapeMode);
			if (!symbolName.issymbol())
				symbolName = repr(symbolName);
			fp << "DEFINE_PUBLIC_ALIAS(" << symbolName << ", " << this.name << ");\n";
			fp.ppEndif();
		}
		if (!hasUniversalBinding)
			fp.ppEndif();
		fp.ppEndif();
	}
}



class SystemHeader {
	this = default;

	@@Name of @this system header (e.g. @"sys.stat" for <sys/stat.h>)
	public member name: string;

	@@Functions declared in this system header
	@@If a function is declared multiple times under the same name,
	@@it will appear as @DuplicateFunctionMarker in this mapping
	public member functionsByName: {string: (Function | _DuplicateFunctionMarker)} = Dict();

	@@Same as @functionsByName, but for local functions
	@@Duplicate entires aren't allowed
	public member localFunctionsByName: {string: LocalFunction} = Dict();

	public function preload() {
		for (local none, f: functionsByName) {
			if (f === DuplicateFunctionMarker)
				continue;
			f.preload();
		}
		for (local none, f: localFunctionsByName)
			f.preload();
	}

	@@Output order of <string.h> (when empty, don't generate that header)
	@@This is one of:
	@@  - @Function:            Call @Function.cprintHeaderDeclaration(fp, escapeMode) (other arguments are defaulted)
	@@  - @ExposedFunction:     Call @ExposedFunction.cprintHeaderDeclaration(fp, escapeMode)
	@@  - @string, @UserString: Insert the string as-is
	@@  - @Callable:            Invoke @Callable(fp, escapeMode)
	public member order_header: {(Function | ExposedFunction | string | UserString | Callable)...} = [];

	@@Output order of <libc/string.h> (when empty, don't generate that file)
	public member order_libcHeader: {(Function | string | UserString)...} = [];

	@@Output order of <libc/core/string.h> (when empty, don't generate that file)
	public member order_libcCoreHeader: {(Function | string | UserString)...} = [];

	@@Output order of /src/libc/auto/string.h (when empty, don't generate that file)
	public member order_libcAutoHeader: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/auto/string.c (when empty, don't generate that file)
	public member order_libcAutoSource: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/libc/dosabi-*.h (when empty, don't generate that file)
	public member order_libcDosabiSource: {LibraryFunction...} = [];

	@@Output order of /src/libc/user/string.h (when empty, don't generate that file)
	public member order_libcUserHeader: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/user/string.c (when empty, don't generate that file)
	public member order_libcUserSource: {LibraryFunction...} = [];

	@@Print the contents of the exposed header (such as `<string.h>`),
	@@excluding the leading COPYRIGHT
	public function cprintHeader(fp: CWriter, escapeMode: int) {
		for (local part: order_header) {
			if (part is Function || part is ExposedFunction) {
				part.cprintHeaderDeclaration(fp, escapeMode);
			} else if (part is Callable) {
				part(fp, escapeMode);
			} else {
				fp << part;
			}
		}
	}

	@@Print the header <libc/string.h>
	public function cprintLibcHeader(fp: CWriter) {
		local nsFast = NAMESPACES["fast"];
		local guardName = "_LIBC_{}_H"
			.format({ name.replace("-", "_").replace(".", "_").upper() });
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n"
			"\n"
			"#include <__stdinc.h>\n"
			"\n"
			"#ifdef __CC__\n"
			"#include <__crt.h>\n";
		for (local part: order_libcHeader) {
			if (part !is Function)
				continue;
			if (part.hasFastBindings) {
				fp << "#ifdef __LIBC_BIND_OPTIMIZATIONS\n"
					"#include <optimized/" << name << ".h>\n"
					"#endif /* __LIBC_BIND_OPTIMIZATIONS */\n";
				break;
			}
		}
		fp << "#include \"core/" << name << ".h\"\n"
			"\n";
		for (local part: order_libcHeader) {
			if (part !is Function) {
				fp << part;
				continue;
			}
			local rc = part.getRequiresConstant();
			if (rc === false)
				continue;
			local partName = part.name;
			local partDoc  = part.documentationString;
			local partFast = part.hasFastBindings;
			if (rc is none) {
				/* Conditionally link against some guard. */
				local coreGuardName = "____libc_core_{}_defined".format({ partName });
				local myGuardName = "____libc_{}_defined".format({ partName });
				if (partFast) {
					fp << "#ifndef " << myGuardName << "\n"
						"#ifdef __fast_" << partName << "_defined\n"
						"#define " << myGuardName << " 1\n"
						"#define __libc_" << partName << " ("
							<< nsFast.prefix << " "
							<< nsFast.keyCSymbolName(partName) << ")\n"
						"#elif defined(" << coreGuardName << ")\n"
						"#define " << myGuardName << " 1\n"
						"#define __libc_" << partName << " __libc_core_" << partName << "\n"
						"#endif /* ... */\n"
						"#endif /* !" << myGuardName << " */\n";
				} else {
					fp << "#if !defined(" << myGuardName << ") && defined(" << coreGuardName << ")\n"
						"#define " << myGuardName << " 1\n"
						"#define __libc_" << partName << " __libc_core_" << partName << "\n"
						"#endif /* !" << myGuardName << " && " << coreGuardName << " */\n";
				}
			} else {
				if (partFast) {
					fp << "#ifdef __fast_" << partName << "_defined\n";
					if (partDoc)
						fp.printComment(partDoc);
					fp << "#define __libc_" << partName << " ("
						<< nsFast.prefix << " "
						<< nsFast.keyCSymbolName(partName) << ")\n"
						<< "#else /* __fast_" << partName << "_defined */\n";
				}
				if (partDoc)
					fp.printComment(partDoc);
				fp << "#define __libc_" << partName << " __libc_core_" << partName << "\n";
				if (partFast)
					fp << "#endif /* !__fast_" << partName << "_defined */\n";
			}
		}
		fp << "\n"
			"#endif /* __CC__ */\n"
			"\n"
			"#endif /* !" << guardName << " */\n";
	}

	@@Print the header <libc/core/string.h>
	public function cprintLibcCoreHeader(fp: CWriter) {
		for (local part: order_libcHeader) {
			if (part !is Function)
				continue;
		}
		local guardName = "_LIBC_CORE_{}_H"
			.format({ name.replace("-", "_").replace(".", "_").upper() });
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n"
			"\n"
			"#include <__stdinc.h>\n"
			"\n"
			"#ifdef __CC__\n"
			"#include <__crt.h>\n"
			"#include <hybrid/typecore.h>\n"
			"\n"
			"__SYSDECL_BEGIN\n"
			"\n";
		for (local part: order_libcHeader) {
			if (part !is Function)
				continue;
			local rc = part.getRequiresConstant();
			if (rc === false)
				continue;
			local guardName = none;
			local exposedName = "__libc_core_" + part.name;
			if (rc is none)
				guardName = "__{}_defined".format({ exposedName });
			part.cprintHeaderDeclaration(
				fp, ESCAPE_MODE_FULL, "__LIBC",
				exposedName:               exposedName,
				guardName:                 guardName,
				preferBindingMacros:       true,
				printDeclarationPrefixes:  true,
				onlyPrintPrimaryPrototype: true,
				ignoreNamespaceBindings:   true,
				ignoreFastBindings:        true);
		}
		fp << "\n"
			"__SYSDECL_END\n"
			"\n"
			"#endif /* __CC__ */\n"
			"\n"
			"#endif /* !" << guardName << " */\n";
	}

	private function cprintInternalLibraryHeader(fp: CWriter, isAuto: bool) {
		local guardName = "GUARD_LIBC_{}_{}_H".format({
			isAuto ? "AUTO" : "USER",
			name.replace("-", "_").replace(".", "_").upper()
		});
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n"
			"\n"
			"#include \"../api.h\"\n";
		if (!isAuto && order_libcAutoHeader)
			fp << "#include \"../auto/" << name << ".h\"\n";
		fp << "\n"
			"#include <hybrid/typecore.h>\n"
			"#include <kos/types.h>\n"
			"#include <" << name.replace(".", "/") << ".h>\n"
			"\n"
			"DECL_BEGIN\n"
			"\n";
		for (local part: isAuto ? order_libcAutoHeader : order_libcUserHeader) {
			if (part is LibraryFunction) {
				part.cprintInLibraryDeclaration(fp, ESCAPE_MODE_NONE, "INTDEF");
			} else {
				fp << part;
			}
		}
		fp << "\n"
			"DECL_END\n"
			"\n"
			"#endif /* !" << guardName << " */\n";
	}

	@@Print the header /kos/src/libc/auto/string.h
	public function cprintLibraryAutoHeader(fp: CWriter) {
		return cprintInternalLibraryHeader(fp, true);
	}

	@@Print the implementations from /kos/src/libc/auto/string.c
	public function cprintLibraryAutoSource(fp: CWriter) {
		local guardName = "GUARD_LIBC_AUTO_{}_C".format({
			name.replace("-", "_").replace(".", "_").upper(),
		});
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n"
			"\n"
			"#include \"../api.h\"\n"
			"#include <hybrid/typecore.h>\n"
			"#include <kos/types.h>\n"
			"#include \"";
		if (order_libcUserHeader)
			fp << "../user/";
		fp << name << ".h\"\n";
		local dependentFunctionHeaders: {string: {string...}} = Dict();
		/* Gather declaring headers of all dependent functions */
		for (local part: order_libcAutoSource) {
			if (part !is LibraryFunction)
				continue;
			for (local binding /*: LibraryFunctionBinding*/: part.functionBindings) {
				local b = binding.functionBinding;
				if (b !is FunctionImplementation)
					continue;
				local bindingDeps: {string: Function} = b.dependencyFunctions;
				if (!bindingDeps)
					continue;
				local deps: {string...} = dependentFunctionHeaders.get(binding.ppCond);
				if (deps is none)
					deps = dependentFunctionHeaders[binding.ppCond] = HashSet();
				for (local none, func: bindingDeps) {
					try {
						local intName = func.internalFunctionName;
						if (intName is none)
							continue; /* No internal name override! */
						deps.insert(allLibraryFunctionsByName[intName]
							.originalSystemHeaderName);
					} catch (...) {
						print("... while scanning dependency ",
							repr(func.name), " of function ",
							repr(part.name));
						throw;
					}
				}
			}
		}
		/* Include declaration headers of all dependent functions */
		for (local cond: dependentFunctionHeaders.keys.sorted()) {
			CWriter_ppIfEscaped(fp, cond, ESCAPE_MODE_NONE);
			for (local hdr: dependentFunctionHeaders[cond].sorted()) {
				local shdr: SystemHeader = allSystemHeaders[hdr];
				if (shdr === this)
					continue; /* Not needed! */
				if (shdr.order_libcUserHeader) {
					hdr = "\"../user/{}.h\"".format({ hdr });
				} else {
					hdr = "\"{}.h\"".format({ hdr });
				}
				fp.ppInclude(hdr);
			}
			fp.ppEndif();
		}
		/* Go through all functions once again, and print their implementations */
		fp << "\n"
			"DECL_BEGIN\n"
			"\n";
		for (local part: order_libcAutoSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryAutoImplementation(fp, ESCAPE_MODE_NONE, "INTERN");
			} else {
				fp << part;
			}
		}
		fp << "\n"
			"DECL_END\n"
			"\n";
		/* Print out the symbol export table. */
		for (local part: order_libcAutoSource) {
			if (part !is LibraryFunction)
				continue;
			if (!part.exportSymbolNames)
				continue;
			CWriter_ppIfEscaped(fp, part.implementationPpCond, ESCAPE_MODE_NONE);
			for (local ppCond, asmname: part.exportSymbolNames) {
				CWriter_ppIfEscaped(fp, ppCond, ESCAPE_MODE_NONE);
				if (!asmname.issymbol())
					asmname = repr(asmname);
				fp << "DEFINE_PUBLIC_ALIAS("
					<< asmname << ", " << part.name << ");\n";
				fp.ppEndif();
			}
			fp.ppEndif();
		}
		fp << "\n"
			"#endif /* !" << guardName << " */\n";
	}

	@@Print the export table from /kos/src/libc/auto/string.c
	public function cprintLibraryAutoSourceExports(fp: CWriter) {
		for (local part: order_libcAutoSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryExports(fp, ESCAPE_MODE_NONE);
			} else {
				fp << part;
			}
		}
	}

	@@Print the header /kos/src/libc/user/string.h
	public function cprintLibraryUserHeader(fp: CWriter) {
		return cprintInternalLibraryHeader(fp, false);
	}

	@@Print the export table from /kos/src/libc/user/string.c
	public function cprintLibraryUserSourceExports(
			fp: CWriter, skippedFunctionNames: {string...} = none) {
		for (local part /*: LibraryFunction*/ : order_libcUserSource) {
			if (part.name in skippedFunctionNames)
				continue;
			part.cprintInLibraryExports(fp, ESCAPE_MODE_NONE);
		}
	}
}







