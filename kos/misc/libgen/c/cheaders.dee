global COPYRIGHT =
"/* Copyright (c) 2019-2022 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2022 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */";



/* Definitions for data structures used to represent pre-parsed C headers
 * definition files, as well as helper functions used to construct system
 * headers, as well as automatic/user implementations */

import * from deemon;
import * from .parser;
import * from .writer;
import * from .escape;
import * from .globals;
import * from .namespace;
import * from .namespace;
import * from .typeclass;
import GCC_NCX from .gccncx;
import util;

#undef CONFIG_DOC_STRINGS_IN_LIBC_LOCAL
#if 0 /* Output documentation strings in <libc/local/...> files. (disabled to prevent bloat) */
#define CONFIG_DOC_STRINGS_IN_LIBC_LOCAL 1
#endif


global Function;
global SystemHeader;

global final LIBC_LINKAGE_DECLS = { "__LIBC", "LIBC" };
global final NAMESPACE_IMPORT_DECL = "__FORCELOCAL";
global final DEFAULT_DECL = "__LIBC";
global final INJECTED_WRAPPER_FUNCTION_ATTRIBUTES = { "ATTR_ARTIFICIAL" };

global final function keyLocalDep(symbolName: string): string {
	return "__localdep_" + symbolName;
}

@@Check if `__C[EI](DECLARE|REDIRECT)` can be used for some given declaration
function isLibcLinkage(
		decl: string | UserString, cc: string | UserString,
		asmname: string | UserString, hasEllipsis: bool): bool {
	if (decl !in LIBC_LINKAGE_DECLS)
		return false;
	cc = str(cc);
	if (hasEllipsis != (cc.startswith("V") || cc.startswith("__V")))
		return false;
	switch (cc) {

	case "LIBCCALL":
	case "VLIBCCALL":
	case "__LIBCCALL":
	case "__VLIBCCALL":
		return !asmname.startswith("DOS$") &&
		       !asmname.startswith("KOS$");

	case "LIBKCALL":
	case "VLIBKCALL":
	case "__LIBKCALL":
	case "__VLIBKCALL":
		return asmname.startswith("KOS$");

	case "LIBDCALL":
	case "VLIBDCALL":
	case "__LIBDCALL":
	case "__VLIBDCALL":
		return asmname.startswith("DOS$");

	default:
		break;
	}
	return false;
}

function CWriter_ppIfEscaped(
		fp: CWriter, ppCond: string | UserString, escapeMode: int) {
	local extendedPrefixes = [];
	local usedCond = escapeText(
		ppCond, escapeMode, extendedPrefixes: extendedPrefixes);
	if (usedCond !in ["0", "1"]) {
again:
		local newExtendedPrefixes = [];
		for (local x: extendedPrefixes) {
			escapeNonRepeatingTextIntoFile(fp, x, escapeMode,
				extendedPrefixes: newExtendedPrefixes);
		}
		if (newExtendedPrefixes) {
			extendedPrefixes = newExtendedPrefixes;
			goto again;
		}
	}
	fp.ppIf(usedCond);
}

@@@return: true:  #elif was used
@@@return: false: #else; #if was used
function CWriter_ppElifEscaped(
		fp: CWriter, ppCond: string | UserString, escapeMode: int): bool {
	local extendedPrefixes = [];
	local usedCond = escapeText(
		ppCond, escapeMode, extendedPrefixes: extendedPrefixes);
	local useElseIf = false;
	if (usedCond !in ["0", "1"]) {
again:
		local newExtendedPrefixes = [];
		for (local x: extendedPrefixes) {
			local newText = escapeText(x, escapeMode, extendedPrefixes: newExtendedPrefixes);
			if (newText && !fp.wasPrefixPrinted(newText)) {
				if (!useElseIf) {
					fp.ppElse();
					useElseIf = true;
				}
				fp.forceStartOfLine();
				fp.printPrefix(str newText);
			}
		}
		if (newExtendedPrefixes) {
			extendedPrefixes = newExtendedPrefixes;
			goto again;
		}
	}
	if (useElseIf) {
		fp.ppIf(usedCond);
		return false;
	}
	fp.ppElif(usedCond);
	return true;
}

class CType {
	this = default;

	public operator str(): string {
		return beforeName + afterName;
	}

	@@A string to insert before the name of the associated variable (e.g. @"fd_t")
	@@NOTE: This string will have already been stripped of leading/trailing spaces
	public member beforeName: string | UserString;

	@@A string to insert after the name of the associated variable (e.g. @"[2]")
	@@NOTE: This string will have already been stripped of leading/trailing spaces
	public member afterName: string | UserString = "";

	/* TODO: public member commentBefore: string; */
	/* TODO: public member commentAfter: string; */

	public function equals(other: CType): bool {
		if (this === other)
			return true;
		if (beforeName != str(other.beforeName))
			return false;
		if (afterName != str(other.afterName))
			return false;
		return true;
	}

	@@Same as @typeClass, but throw an @Error if the class cannot be deduced
	public property requireTypeClass: string = {
		get(): string {
			local result = typeClass;
			if (result !is none)
				return result;
			throw Error(f"Unable to deduce typeclass of {repr this}");
		}
	}

	@@Returns the type classification for @this @CType
	@@Note that this class only applies when @this type is used in an argument list
	@@For more information, see @(import .typeclass)
	@@If the type class cannot be deduced, this property returns @none instead
	public property typeClass: string | none = {
		get(): string {
			if (afterName) {
				/* An after-string only exists for the following cases, all
				 * of which are pointers when they appear in argument lists:
				 * >> int x[];         // Flexible array (C convention passes this as a pointer)
				 * >> int x[42];       // Fixed-length array (Passed like its flexible counterpart)
				 * >> int (*x)(int a); // Function pointer */
				return "TP";
			}
			local typename = str(beforeName).strip();
			if (typename.endswith("__restrict"))
				return "TP"; /* Only pointer can be marked as __restrict */
			if (typename.endswith("*") || typename.endswith("&"))
				return "TP"; /* Pointer type */
again:
			typename = typename.replace("$", "");
			for (;;) {
				if (typename.startswith("unsigned ")) {
					typename = typename[9:].lstrip();
					continue;
				}
				if (typename.startswith("signed ")) {
					typename = typename[7:].lstrip();
					continue;
				}
				if (typename.startswith("int ")) {
					typename = typename[4:].lstrip();
					continue;
				}
				if (typename.endswith(" unsigned")) {
					typename = typename[:-9].rstrip();
					continue;
				}
				if (typename.endswith(" signed")) {
					typename = typename[:-7].rstrip();
					continue;
				}
				if (typename.endswith(" int")) {
					typename = typename[:-4].rstrip();
					continue;
				}
				break;
			}
			if (typename.startswith("struct ")) {
				typename = typename[7:];
do_handle_struct_type:
				return f"TS(__SIZEOF_{typename.lstrip().lstrip("_").upper()})";
			}
			if (typename.startswith("union ")) {
				typename = typename[6:];
				goto do_handle_struct_type;
			}
			if (typename.startswith("enum "))
				return "TD"; /* Enums always get passed like `int` */
			local result = knownTypeClasses.get(typename);
			if (result !is none)
				return result;
			/* Also check if the escaped variant may be known */
			for (local map: { keywordEscapes, partialKeywordEscapes }) {
				local escaped = map.get(typename);
				if (escaped is none)
					continue;
				result = knownTypeClasses.get(escaped);
				if (result !is none)
					return result;
				if (escaped.endswith("__restrict"))
					return "TP";
				if (escaped.endswith("*") || escaped.endswith("&"))
					return "TP"; /* Pointer type */
				if (escaped.startswith("struct ") || escaped.startswith("union ") ||
				    escaped.startswith("enum ") || escaped.startswith("unsigned ") ||
				    escaped.startswith("signed ") || escaped.startswith("int ") ||
				    escaped.endswith(" unsigned") || escaped.endswith(" signed") ||
				    escaped.endswith(" int")) {
					typename = escaped;
					goto again;
				}
			}
			return none;
		}
	}

	@@Returns @true if @this @CType is implicitly convertible to @other
	public function implicitlyConvertibleTo(other: CType): bool {
		if (equals(other))
			return true;
		local typename = str(beforeName).strip();
		if (typename.endswith("__restrict"))
			typename = typename[:-10].rstrip();
		local an = str(afterName);
		if (an.startswith("[") && an.endswith("]"))
			an = "*";
		typename = typename + an;
		local otTypename = str(other.beforeName).strip();
		if (otTypename.endswith("__restrict"))
			otTypename = otTypename[:-10].rstrip();
		local an = str(other.afterName);
		if (an.startswith("[") && an.endswith("]"))
			an = "*";
		otTypename = otTypename + an;
again_compare_typenames:
		if (typename == otTypename)
			return true;
		typename = typename.replace("\t", " ");
		otTypename = otTypename.replace("\t", " ");
		while ("  " in typename)
			typename = typename.replace("  ", " ");
		while ("  " in otTypename)
			otTypename = otTypename.replace("  ", " ");
		if (typename == otTypename)
			return true;
		if ("const" in otTypename) {
			if ((otTypename.count("*") + otTypename.count("&")) < 2) {
				otTypename = otTypename.replace("const", "");
				goto again_compare_typenames;
			}
			/* Only replace "const" up until the second-to-last "*" or "&":
			 *  - "char const *"          -> "char *"
			 *  - "char *const *"         -> "char **"
			 *  - "char const *const *"   -> "char const **" */
			local replStart = #otTypename;
			while (otTypename[replStart - 1] !in "*&")
				--replStart;
			--replStart;
			while (otTypename[replStart - 1] !in "*&")
				--replStart;
			/* `replStart` now points after the second-to-last "*" or "&" */
			local after = otTypename[replStart:];
			if ("const" in after) {
				otTypename = otTypename[:replStart] + after.replace("const", "");
				goto again_compare_typenames;
			}
		}
		return false;
	}

	@@Returns @true if @this @CType is @"void"
	public property isVoid: bool = {
		get(): bool {
			return beforeName == "void" && !afterName;
		}
	}

	@@Returns @true if @this @CType is a pointer
	public property isPointer: bool = {
		get(): bool {
			if (str(beforeName).endswith("*"))
				return true;
			return typeClass == "TP";
		}
	}


	@@Prints the c-cast prefix (e.g. @"(int)") for @this
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintCCastPrefix(fp: CWriter, escapeMode: int) {
		fp << "(";
		local typename = str(beforeName).strip();
		if (typename.endswith("__restrict"))
			typename = typename[:-10].rstrip();
		local an = str(afterName);
		escapeTextIntoFile(fp, typename, escapeMode);
		if (an.startswith("[") && an.endswith("]"))
			fp << " *";
		fp << ")";
	}

	@@Same @cprintCCastPrefix, but meant to be used by generators
	public function cprintCCastPrefixForGenerator(fp: CWriter) {
		fp << "(";
		local typename = str(beforeName).strip();
		if (typename.endswith("__restrict"))
			typename = typename[:-10].rstrip();
		local an = str(afterName);
		fp << typename;
		if (an.startswith("[") && an.endswith("]"))
			fp << " *";
		fp << ")";
	}

	@@Print a stub-value for @this type (e.g. @"(char const *)0")
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintStubValue(fp: CWriter | File, escapeMode: int) {
		cprintCCastPrefix(fp, escapeMode);
		fp << "0";
	}

	@@Same @cprintStubValue, but meant to be used by generators
	public function cprintStubValueForGenerator(fp: CWriter | File) {
		cprintCCastPrefixForGenerator(fp);
		fp << "0";
	}

	public function cprintToString(name: string | UserString = ""): string {
		local tempFp = File.Writer();
		local tempWriter = CWriter(tempFp);
		this.cprint(tempWriter, ESCAPE_MODE_NONE, name);
		tempWriter.flush();
		return tempFp.string;
	}

	@@Output @this @CType to a @CWriter
	@@Returns @true if the type string must be followed by whitespace if
	@@immediately  succeeded  by  a keyword.  Returns  @false otherwise.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprint(fp: CWriter, escapeMode: int, name: string | UserString = ""): bool {
		local beforeNameStr = str beforeName;
		local afterNameStr = str afterName;
		escapeTextIntoFile(fp, beforeName, escapeMode);
		if (name) {
			if (!beforeNameStr.endswith("*"))
				fp << " ";
			escapeTextIntoFile(fp, name, escapeMode);
		}
		if (afterNameStr) {
			if (afterNameStr.first !in ")[")
				fp << " ";
			escapeTextIntoFile(fp, afterName, escapeMode);
		}
		if (afterNameStr)
			return true;
		if (name)
			return true;
		if (beforeNameStr)
			return !beforeNameStr.endswith("*");
		return false;
	}

	@@Same @cprint, but meant to be used by generators
	public function cprintForGenerator(fp: CWriter, name: string = ""): bool {
		local beforeNameStr = str beforeName;
		local afterNameStr = str afterName;
		fp << beforeNameStr;
		if (name) {
			if (!beforeNameStr.endswith("*"))
				fp << " ";
			fp << name;
		}
		if (afterNameStr) {
			if (afterNameStr.first !in ")[")
				fp << " ";
			fp << afterName;
		}
		if (afterNameStr)
			return true;
		if (name)
			return true;
		if (beforeNameStr)
			return !beforeNameStr.endswith("*");
		return false;
	}

}


class Argument {
	this = default;

	@@Argument name (fully escaped; empty string if the argument is unnamed)
	@@NOTE: Ellipsis arguments have this field set to @""
	public member name: string | UserString;

	@@The  argument name that  should be combined with  @ctype in the prototype
	@@Usually this is  the same as  @name, but  in the case  of functions  such
	@@as @"execv", this would be  an empty string to  accout for the fact  that
	@@the set @ctype  is actually  the name of  a macro  that already  includes
	@@the name of the argument (meaning that the name mustn't be written twice)
	public member protoTypeName: string | UserString;

	@@C Typing of this argument.
	@@NOTE: Ellipsis arguments have this field set to @CType("...")
	public member ctype: CType;

	@@Output @this @Argument to a @CWriter
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprint(fp: CWriter, escapeMode: int) {
		ctype.cprint(fp, escapeMode, protoTypeName);
	}

	public operator hash(): int -> Object.id(this);
	public operator == (other: Argument): bool -> this === other;
	public operator != (other: Argument): bool -> this !== other;
}

class FunctionPrototype {
	this = default;

	@@List of attributes that should be applied to this function (e.g. @{ "ATTR_NORETURN" })
	public member attributes: {(string | UserString | Callable)...} = ();

	@@The nothrow behavior of this function. Should be one of:
	@@  - @"":                   Unspecified (assume THROWING, but don't warn if used from NOTHROW)
	@@  - @"NOTHROW":            Function doesn't throw
	@@  - @"NOTHROW_NCX":        Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS)
	@@  - @"NOTHROW_RPC":        Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS)
	@@  - @"NOTHROW_RPC_KOS":    Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS) && defined(__KOS__)
	@@  - @"NOTHROW_RPC_NOKOS":  Function is nothrow when: #if !defined(__NON_CALL_EXCEPTIONS) && defined(__NO_RPC_EXCEPTIONS) && !defined(__KOS__)
	@@  - @"NOTHROW_RPC_PURE":   Function is nothrow when: #if defined(__NO_RPC_EXCEPTIONS)
	@@  - @"THROWS(...)":        Function can  throw  and  should  be  warned  about  if  used  from  NOTHROW.
	@@                           The given @"..." is a comma-seperated list of `E_*' codes from <kos/except.h>
	public member nothrow: string | UserString = "";

	@@Calling convention of this function prototype (e.g. @"ATTR_CDECL")
	@@Set to  an empty  string to  use the  default calling  convention.
	public member cc: string | UserString;

	@@The type that is returned by this function prototype
	public member returnType: CType;

	@@The actual List of arguments
	public member argv: {Argument...} = ();

	@@When set to non-@none, these are the types of the arguments passed through ellipsis
	@@This information  can  be  helpful  when  trying  to  construct  an  argument  list
	public member ellipsisArgumentTypes: {CType...} = none;

	@@Pieces of code that must be written before @this @FunctionPrototype can be printed
	@@NOTE: These prefixes are only printed in local function implementations, as well as
	@@      their  dependencies,  as  well  as  the  dependencies  of  inline   functions
	public member declPrefix: {(string | UserString)...} = ();

	@@Check if this function is annotated as `ATTR_PURE` or `ATTR_LEAF`
	public property isPureOrLeaf: bool = {
		get(): bool {
			for (local attr: attributes) {
				if (attr is UserString)
					attr = str attr;
				if (attr is string && attr in {
						"__ATTR_LEAF", "ATTR_LEAF",
						"__ATTR_PURE", "ATTR_PURE",
						"__ATTR_CONST", "ATTR_CONST",
					})
					return true;
			}
			return false;
		}
	}

	@@List all types used by this prototype
	public property referencedTypes: {CType...} = {
		get(): {CType...} {
			yield returnType;
			for (local arg: argv) {
				yield arg.ctype;
			}
		}
	}

	@@List all headers included by @declPrefix
	public property declPrefixHeaders: {string...} = {
		get(): {string...} {
			for (local prefix: declPrefix) {
				prefix = str(prefix).strip();
				for (local line: prefix.splitlines(false)) {
					try {
						line = line.scanf(" # include %[^]")...;
					} catch (...) {
						break;
					}
					line = line.strip();
					if ((line.startswith("\"") && line.endswith("\"")) ||
					    (line.startswith("<") && line.endswith(">"))) {
						yield line;
					} else {
						break;
					}
				}
			}
		}
	}

	@@Wrapper around @attributes that will automatically sort and unwind attributes
	public property prototypeAttributes: {(string | UserString)...} = {
		get(): {(string | UserString)...} {
			local result = attributes;
			if (!m_attributesSorted) {
				local wip = []; /* WIthParen */
				local wop = []; /* WithOutParen */
#define APPEND_ATTRIBUTE(a)            \
				a = str(a);            \
				if ("(" in a) {        \
					if (a !in wip)     \
						wip.append(a); \
				} else {               \
					if (a !in wop)     \
						wop.append(a); \
				}
				for (local a: result) {
					if (a is Callable) {
						a = a();
						if (a is Sequence) {
							for (local e: a) {
								APPEND_ATTRIBUTE(e)
							}
							continue;
						}
						if (a is none)
							continue;
					}
					APPEND_ATTRIBUTE(a)
					continue;
				}
#undef APPEND_ATTRIBUTE
				wip.sort();
				wop.sort();
				wop.extend(wip);
				result = wop;
				attributes = result;
				m_attributesSorted = true;
			}
			return result;
		}
	}
	private member m_attributesSorted: bool = false;


	@@Returns @true if this prototype contains a @"ATTR_NORETURN" attribute
	public property isNoreturn: bool = {
		get(): bool {
			for (local at: attributes) {
				if (at in ["ATTR_NORETURN", "__ATTR_NORETURN"])
					return true;
			}
			return false;
		}
	}

	@@Returns @true if @nothrow describes @"THROWS(...)"
	public property isNothrowThrowing: bool = {
		get(): bool {
			if (m_isNothrowThrowing !is bound) {
				local nts = str nothrow;
				m_isNothrowThrowing =
					nts.startswith("THROWS(") ||
					nts.startswith("__THROWS(");
			}
			return m_isNothrowThrowing;
		}
	}
	private member m_isNothrowThrowing: bool;

	@@Returns  @true  if @nothrow  describes @"NOTHROW_NCX"  or something
	@@else that needs the `__COMPILER_HAVE_GCCNCX_BUILTIN_BUG'-workaround
	public property isNothrowGCCNCX: bool = {
		get(): bool {
			if (m_isNothrowGCCNCX !is bound) {
				local nts = str nothrow;
				m_isNothrowGCCNCX = nts !in ["NOTHROW", "__NOTHROW"];
			}
			return m_isNothrowGCCNCX;
		}
	}
	private member m_isNothrowGCCNCX: bool;

	@@Returns @"__THROWING" or @"THROWING" based on the escape-state of @nothrow
	@@The caller must ensure that @isNothrowThrowing is @true
	public property nothrowThrowingSpec: string = {
		get(): bool {
			local nts = str nothrow;
			if (nts.startswith("THROWS("))
				return "THROWING";
			return "__THROWING";
		}
	}


	public property argsByName: {string: Argument} = {
		get(): {string: Argument} {
			if (m_argsByName !is bound) {
				local result = Dict();
				for (local a: argv) {
					local usedName = str(a.name);
					if (usedName)
						result[usedName] = a;
				}
				m_argsByName = result;
				return result;
			}
			return m_argsByName;
		}
	}
	private member m_argsByName: {string: Argument};

	public operator # (): string -> #argv;
	public operator [] (i: int): Argument -> argv[i];

	@@Evaluate to @true if @this @FunctionPrototype ends with an ellipsis argument (i.e. @"...")
	public property hasEllipsis: bool = {
		get(): bool {
			return argv && argv.last.ctype.beforeName == "...";
		}
	}

	public operator str(): string {
		File.Writer fp;
		for (local a: prototypeAttributes)
			fp << a << " ";
		fp << returnType.beforeName << returnType.afterName
			<< " " << cc << " ...(";
		local isFirst = true;
		for (local a: argv) {
			if (!isFirst)
				fp << ", ";
			isFirst = false;
			fp << a.ctype.beforeName << a.protoTypeName << a.ctype.afterName;
		}
		fp << ")";
		return fp.string;
	}

	@@Check if @this FunctionPrototype is compatible with @other
	@@i.e.: uses identical items, attributes, and calling convention.
	@@Note  however  that  argument  names  are  not  checked   here!
	public function compatibleWith(other: FunctionPrototype): bool {
		if (this === other)
			return true;
		if (!returnType.equals(other.returnType))
			return false;
		local n = #argv;
		if (n != #other.argv)
			return false;
		for (local i = 0; i < n; ++i) {
			local my = argv[i];
			local ot = other.argv[i];
			if (!my.ctype.equals(ot.ctype))
				return false;
		}
		if (nothrow != other.nothrow)
			return false;
		if (cc != other.cc)
			return false;
		if (ellipsisArgumentTypes is none) {
			if (other.ellipsisArgumentTypes !is none)
				return false;
		} else {
			if (other.ellipsisArgumentTypes is none)
				return false;
			if (ellipsisArgumentTypes != other.ellipsisArgumentTypes)
				return false;
		}
		if (declPrefix != other.declPrefix)
			return false;
		if (prototypeAttributes != other.prototypeAttributes)
			return false;
		return true;
	}

	@@Print the attribute list (returns @false if
	@@nothing was printed,  and @true  otherwise)
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintAttributeList(fp: CWriter, escapeMode: int): bool {
		local isFirst = true;
		for (local attr: prototypeAttributes) {
			if (!isFirst)
				fp << " ";
			escapeTextIntoFile(fp, attr, escapeMode);
			isFirst = false;
		}
		return !isFirst;
	}

	@@Output the argument list including types to @fp
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintArgumentListWithTypes(fp: CWriter, escapeMode: int) {
		local isFirst = true;
		fp << "(";
		if (!argv) {
			fp << "void";
		} else {
			for (local arg: argv) {
				if (!isFirst)
					fp << ", ";
				arg.cprint(fp, escapeMode);
				isFirst = false;
			}
		}
		fp << ")";
	}

	@@Output the argument list excluding types to @fp
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintArgumentListWithoutTypes(fp: CWriter, escapeMode: int) {
		local isFirst = true;
		fp << "(";
		for (local arg: argv) {
			if (!isFirst)
				fp << ",";
			escapeTextIntoFile(fp, arg.name, escapeMode);
			isFirst = false;
		}
		fp << ")";
	}

	@@Print a declaration akin to:
	@@> __LIBC __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t __NOTHROW_NCX(__LIBCCALL strlen)(char const *__restrict __str) __CASMNAME_SAME("open");
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintDeclarationWithOptionalAsmname(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string,
			isSameAsname: bool) {
		local hasGccNCX = decl in LIBC_LINKAGE_DECLS && fp.externLinkage in ["", "C"] &&
		                  exposedName in GCC_NCX && isNothrowGCCNCX;
		if (hasGccNCX) {
			fp << "#ifdef __COMPILER_HAVE_GCCNCX_BUILTIN_BUG\n";
			fp << "extern \"C++\" {\n";
			fp << "#endif /* __COMPILER_HAVE_GCCNCX_BUILTIN_BUG */\n";
		}
		/* Same symbol name -> declare normally (or with `__ASMNAME()' suffix) */
		cprintDeclarationWithoutTerminator(fp, escapeMode, decl, exposedName);
		if (decl in LIBC_LINKAGE_DECLS) {
			/* Always use __CASMNAME for anything declared in the context of libc.
			 * This is  required to  ensure proper  assembly linkage,  as well  as
			 * symbol visibility when libc.so is including its own headers. */
			fp << " __CASMNAME";
			local suffix = "";
			if (assemblyName.startswith("DOS$")) {
				suffix       = "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				suffix       = "_KOS";
				assemblyName = assemblyName[4:];
			}
			if (isSameAsname)
				fp << "_SAME";
			if (hasGccNCX)
				fp << "_GCCNCX";
			fp << suffix << "(" << repr(assemblyName) << ")";
		} else if (!isSameAsname) {
			fp << " __ASMNAME(" << repr(assemblyName) << ")";
		}
		fp << ";\n";
		if (hasGccNCX) {
			fp << "#ifdef __COMPILER_HAVE_GCCNCX_BUILTIN_BUG\n";
			fp << "} /* extern \"C++\" */\n";
			fp << "#endif /* __COMPILER_HAVE_GCCNCX_BUILTIN_BUG */\n";
		}
	}

	@@Print a declaration akin to:
	@@> __CDECLARE(__ATTR_WUNUSED __ATTR_NONNULL((1)),__SIZE_TYPE__,__NOTHROW_NCX,wcslen,(__WCHAR_TYPE__ const *__restrict __str),(__str))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintCDECLARE(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, optSuffix: bool = false) {
		/* Special case: Make use of __CDECLARE */
		local isVoidReturn = this.returnType.isVoid;
		fp << "__CDECLARE";
		if (isVoidReturn)
			fp << "_VOID";
		if (fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
			fp << "_GCCNCX";
		if (optSuffix)
			fp << "_OPT";
		fp << "(";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		fp << ",";
		/* Return type */
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		/* Exposed name */
		fp << "," << exposedName << ",";
		cprintArgumentListWithTypes(fp, escapeMode);
		fp << ",";
		cprintArgumentListWithoutTypes(fp, escapeMode);
		fp << ")\n";
	}

	@@Print a declaration akin to:
	@@> __LIBC __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t
	@@> __NOTHROW_NCX(__LIBCCALL strlen)(char const *__restrict __str)
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintDeclarationWithoutTerminator(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			injectedAttributes: {string...} = none,
			breakAfterReturnType: bool = false,
			oneArgumentPerLine: bool = false) {
		/* Same symbol name -> declare normally */
		escapeTextIntoFile(fp, decl, escapeMode);
		if (decl)
			fp << " ";
		if (injectedAttributes) {
			local isFirst = true;
			for (local a: injectedAttributes) {
				if (!isFirst)
					fp << " ";
				isFirst = false;
				escapeTextIntoFile(fp, a, escapeMode);
			}
			if (!isFirst)
				fp << " ";
		}
		if (cprintAttributeList(fp, escapeMode))
			fp << " ";
		if (returnType.cprint(fp, escapeMode) && !breakAfterReturnType)
			fp << " ";
		if (breakAfterReturnType)
			fp << "\n";
		if (!isNothrowThrowing)
			escapeTextIntoFile(fp, nothrow, escapeMode);
		fp << "(";
		escapeTextIntoFile(fp, cc, escapeMode);
		if (cc)
			fp << " ";
		fp << exposedName << ")";
		if (oneArgumentPerLine && #argv >= 2) {
			local indentWidth;
			{
				local tempfp = File.Writer();
				local tempWriter = CWriter(tempfp, ppAssume: fp.ppAssume);
				if (!breakAfterReturnType) {
					escapeTextIntoFile(tempWriter, decl, escapeMode);
					if (decl)
						tempWriter << " ";
					if (injectedAttributes) {
						local isFirst = true;
						for (local a: injectedAttributes) {
							if (!isFirst)
								tempWriter << " ";
							isFirst = false;
							escapeTextIntoFile(tempWriter, a, escapeMode);
						}
						if (!isFirst)
							tempWriter << " ";
					}
					if (cprintAttributeList(tempWriter, escapeMode))
						tempWriter << " ";
					if (returnType.cprint(tempWriter, escapeMode))
						tempWriter << " ";
				}
				if (!isNothrowThrowing)
					escapeTextIntoFile(tempWriter, nothrow, escapeMode);
				tempWriter << "(";
				escapeTextIntoFile(tempWriter, cc, escapeMode);
				tempWriter.flush();
				del tempWriter;
				tempfp = tempfp.string;
				local i = tempfp.rfind("\n");
				if (i >= 0)
					tempfp = tempfp[i + 1:];
				indentWidth = #tempfp + #exposedName + 2;
				if (cc)
					++indentWidth;
			}
			fp << "(";
			local isFirst = true;
			indentWidth = " " * indentWidth;
			for (local arg: argv) {
				if (!isFirst)
					fp << ",\n" << indentWidth;
				arg.cprint(fp, escapeMode);
				isFirst = false;
			}
			fp << ")";
		} else {
			cprintArgumentListWithTypes(fp, escapeMode);
		}
		if (isNothrowThrowing) {
			fp << " ";
			escapeTextIntoFile(fp, nothrow, escapeMode);
		}
	}

	@@Print a declaration akin to:
	@@> #define wcslen (*(size_t(LIBCCALL*)(wchar_t const *__restrict))&__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))
	@@If the types from @callToPrototype different from those in @this prototype,
	@@insert casts where- and as necessary.
	@@NOTE: This function will not print a trailing line-feed after the declaration!
	@@@param: escapeMode:      One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: exposedName:     In the above example: @"wcslen"
	@@@param: callToName:      In the above example: @"__LIBC_LOCAL_NAME(wcslen)"
	@@@param: callToPrototype: In the above example: @(allLocalFunctionsByName["wcslen"].prototype)
	@@@param: callToNamespace: In the above example: @LOCAL_NAMESPACE
	public function cprintCallToMacro(
			fp: CWriter, escapeMode: int, exposedName: string,
			callToName: string, callToPrototype: FunctionPrototype,
			callToNamespace: Namespace, explicitCastAllTypes: bool = false) {
		fp << "#define " << exposedName;
		/* Check if the prototypes are already compatible */
		if (this.compatibleWith(callToPrototype)) {
			if (callToNamespace.prefix && (callToNamespace !== LOCAL_NAMESPACE || fp.namespace !== LOCAL_NAMESPACE))
				fp << " " << callToNamespace.prefix;
			fp << " " << callToName << "\n";
			return;
		}
		local myArgc = #argv;
		local otArgc = #callToPrototype.argv;
		local myHaveEllipsis = hasEllipsis;
		local otHaveEllipsis = callToPrototype.hasEllipsis;
		/* Prevent GCC from complaining about nonsense... (*ugh*) */
		if (myArgc != otArgc || myHaveEllipsis != otHaveEllipsis) {
			/* Different # of arguments (shouldn't happen, but can only be dealt  with
			 * by generating a function-like macro, though obviously this macro cannot
			 * be used in a situation where it's address would have to be taken) */
			fp << "(";
			local isFirst = true;
			for (local a: argv) {
				if (!isFirst)
					fp << ", ";
				isFirst = false;
				fp << a.name;
			}
			if (myHaveEllipsis) {
				if (!isFirst)
					fp << ", ";
				fp << "...";
			}
			fp << ") " << callToName << "(";
			if (otHaveEllipsis)
				--otArgc;
			if (myHaveEllipsis)
				--myArgc;
			local commonArgc = otArgc;
			if (commonArgc > myArgc)
				commonArgc = myArgc;
			for (local i: [:commonArgc]) {
				if (i)
					fp << ", ";
				local myArg = argv[i];
				local otArg = callToPrototype.argv[i];
				if (!myArg.ctype.implicitlyConvertibleTo(otArg.ctype)) {
					otArg.ctype.cprintCCastPrefix(fp, escapeMode);
					fp << "(" << myArg.name << ")";
				} else {
					fp << myArg.name;
				}
			}
			if (otArgc > commonArgc) {
				if (commonArgc)
					fp << ", ";
				for (local i: [commonArgc:otArgc]) {
					if (commonArgc != commonArgc)
						fp << ", ";
					callToPrototype.argv[i].cprintStubValue(fp, escapeMode);
				}
			}
			if (myHaveEllipsis && otHaveEllipsis) {
				if (otArgc)
					fp << ", ";
				fp << "__VA_ARGS__";
			}
			fp << ")\n";
			return;
		}
		/* Same   #   of   arguments,   and   same   ellipsis   behavior.
		 * Assume that a  difference in  CC is intentional  and cast  the
		 * other function's pointer into the intended prototype's format. */
		function printFunctionPrototype(kind: string) {
			returnType.cprint(fp, escapeMode);
			fp << "(";
			if (cc)
				escapeTextIntoFile(fp, cc, escapeMode);
			fp << kind << ")(";
			local isFirst = true;
			for (local a: argv) {
				if (!isFirst)
					fp << ",";
				isFirst = false;
				a.ctype.cprint(fp, escapeMode);
			}
			/* Ellipsis are already printed by the preceding for-loop */
//			if (myHaveEllipsis) {
//				if (!isFirst)
//					fp << ",";
//				fp << "...";
//			}
			fp << ")";
		}
		if (fp.namespace === LOCAL_NAMESPACE &&
		    callToNamespace === LOCAL_NAMESPACE &&
		    callToName.startswith("__LIBC_LOCAL_NAME(") &&
		    callToName.endswith(")")) {
			/* Workaround so that the namespace prefix can be used unconditionally
			 * when calling  local  functions  from within  the  local  namespace. */
			fp << " __NAMESPACE_LOCAL_TYPEHAX(";
			printFunctionPrototype("*");
			fp << ",";
			printFunctionPrototype("&");
			fp << "," << callToName[18:-1] << ")\n";
		} else {
			fp << " (*(";
			printFunctionPrototype("*");
			fp << ")&";
			if (callToNamespace.prefix)
				fp << callToNamespace.prefix << " ";
			fp << callToName << ")\n";
		}
	}

	@@Print a declaration akin to:
	@@> FORCELOCAL ATTR_PURE ATTR_WUNUSED ATTR_NONNULL((1)) size_t
	@@> NOTHROW_NCX(LIBCCALL wcslen)(wchar_t const *__restrict string) {
	@@> return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))(string); }
	@@If the types from @callToPrototype different from those in @this prototype,
	@@insert casts where- and as necessary.
	@@NOTE: This function will not print a trailing line-feed after the declaration!
	@@@param: escapeMode:      One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:            In the above example: @"FORCELOCAL"
	@@@param: exposedName:     In the above example: @"wcslen"
	@@@param: callToName:      In the above example: @"(__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))"
	@@@param: callToPrototype: In the above example: @(allLocalFunctionsByName["wcslen"].prototype)
	public function cprintCallToFunction(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			callToName: string, callToPrototype: FunctionPrototype,
			explicitCastAllTypes: bool = false, callToEscapeMode: int = none) {
		if (callToEscapeMode is none)
			callToEscapeMode = escapeMode;
		cprintDeclarationWithoutTerminator(fp, escapeMode, decl, exposedName,
			injectedAttributes: INJECTED_WRAPPER_FUNCTION_ATTRIBUTES);
		fp << " { ";
		if (!returnType.isVoid)
			fp << "return ";
		if (explicitCastAllTypes || !callToPrototype.returnType.implicitlyConvertibleTo(returnType))
			returnType.cprintCCastPrefix(fp, callToEscapeMode);
		fp << callToName << "(";
		local argc = #callToPrototype.argv;
		local isFirst = true;
		for (local argi: [:argc]) {
			if (!isFirst)
				fp << ", ";
			isFirst = false;
			local arg = callToPrototype.argv[argi];
			if (argi >= #argv) {
				/* Shouldn't happen... */
				arg.ctype.cprintCCastPrefix(fp, callToEscapeMode);
				fp << "0";
				continue;
			}
			local myArg = this.argv[argi];
			if (myArg.ctype.beforeName == "...") {
				fp << "__builtin_va_arg_pack()";
			} else {
				if (explicitCastAllTypes || !myArg.ctype.implicitlyConvertibleTo(arg.ctype))
					arg.ctype.cprintCCastPrefix(fp, callToEscapeMode);
				escapeTextIntoFile(fp, myArg.name, escapeMode);
			}
		}
		fp << "); }";
	}

	@@Print a declaration akin to:
	@@> __COMPILER_CREDIRECT(__LIBC,__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,__NOTHROW_NCX,
	@@>                      __LIBCCALL,strlen,(char const *__str),strlen_alias,(__str))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintREDIRECT(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string,
			isLcl: bool) {
		fp << (isLcl ? "__CREDIRECT" : "__COMPILER_CREDIRECT");
		local isVoidReturn = returnType.isVoid;
		if (isVoidReturn)
			fp << "_VOID";
		if (isLcl) {
			if (assemblyName.startswith("DOS$")) {
				fp << "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				fp << "_KOS";
				assemblyName = assemblyName[4:];
			}
		}
		if (isLcl && fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
			fp << "_GCCNCX";
		fp << "(";
		/* Linkage */
		if (!isLcl)
			fp << decl << ",";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		/* Return type */
		fp << ",";
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		fp << ",";
		/* Calling convention */
		if (!isLcl) {
			escapeTextIntoFile(fp, cc, escapeMode);
			fp << ",";
		}
		/* Exposed symbol name */
		fp << exposedName << ",";
		/* Argument list */
		cprintArgumentListWithTypes(fp, escapeMode);
		/* Assembly import symbol name */
		fp << "," << assemblyName << ",";
		/* Argument names */
		cprintArgumentListWithoutTypes(fp, escapeMode);
		fp << ")\n";
	}

	@@Print a declaration akin to:
	@@> __CVREDIRECT(__ATTR_NONNULL((1)),__pid_t,__NOTHROW_NCX,clone,
	@@>              (__clone_func_t __fn, void *__child_stack, int __flags, void *__arg),
	@@>              __clone,(__fn,__child_stack,__flags,__arg),
	@@>              __arg,3,(__pid_t,void *,__pid_t))
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintVREDIRECT(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string,
			isLcl: bool) {
		fp << (isLcl ? "__CVREDIRECT" : "__COMPILER_CVREDIRECT");
		local isVoidReturn = returnType.isVoid;
		if (isVoidReturn)
			fp << "_VOID";
		if (isLcl) {
			if (assemblyName.startswith("DOS$")) {
				fp << "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				fp << "_KOS";
				assemblyName = assemblyName[4:];
			}
		}
		if (isLcl && fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
			fp << "_GCCNCX";
		fp << "(";
		/* Linkage */
		if (!isLcl)
			fp << decl << ",";
		/* Attributes */
		cprintAttributeList(fp, escapeMode);
		/* Return type */
		fp << ",";
		if (!isVoidReturn) {
			returnType.cprint(fp, escapeMode);
			fp << ",";
		}
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		fp << ",";
		/* Calling convention */
		if (!isLcl) {
			escapeTextIntoFile(fp, cc, escapeMode);
			fp << ",";
		}
		/* Exposed symbol name */
		fp << exposedName << ",";
		/* Argument list */
		local isFirst = true;
		fp << "(";
		for (local arg: argv[:-1]) {
			if (!isFirst)
				fp << ", ";
			arg.cprint(fp, escapeMode);
			isFirst = false;
		}
		fp << ")";
		/* Assembly import symbol name */
		fp << "," << assemblyName << ",";
		/* Argument names */
		local isFirst = true;
		fp << "(";
		for (local arg: argv[:-1]) {
			if (!isFirst)
				fp << ",";
			escapeTextIntoFile(fp, arg.protoTypeName, escapeMode);
			isFirst = false;
		}
		fp << "),";
		/* Next up: print the name of the last argument before ellipsis starts */
		escapeTextIntoFile(fp, argv[#argv - 2].name, escapeMode);
		/* Then print the # of known ellipsis argument types */
		fp << "," << #ellipsisArgumentTypes << ",(";
		/* And finally, print the actual list of ellipsis argument types */
		local isFirst = true;
		for (local typ: ellipsisArgumentTypes) {
			if (!isFirst)
				fp << ",";
			typ.cprint(fp, escapeMode);
			isFirst = false;
		}
		fp << "))\n";
	}

	@@Check if __CDECLARE will be used by @cprintRedirectionBinding,
	@@when called with the given arguments.
	public function cprintRedirectionBindingUsesCDECLARE(
			fp: CWriter, decl: string, exposedName: string,
			assemblyName: string): bool {
		if (exposedName != assemblyName)
			return false;
		if (fp.externLinkage !in ["", "C"])
			return false;
		if (this.hasEllipsis)
			return false;
		return isLibcLinkage(decl, cc, assemblyName, false);
	}

	@@Print a redirection- or declaration-binding, based on
	@@the   exposed-  and  assembly  name  being  the  same
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintRedirectionBinding(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string) {
		local hasEllipsis = this.hasEllipsis;
		local isLcl = isLibcLinkage(decl, cc, assemblyName, hasEllipsis);
		local isSameAsname = exposedName == assemblyName && fp.externLinkage in ["", "C"];
		if (hasEllipsis) {
			if (!isSameAsname) {
				if (ellipsisArgumentTypes !is none) {
					return cprintVREDIRECT(
						fp, escapeMode, decl, exposedName, assemblyName, isLcl);
				}
				/* XXX: This is the one corner-case, where there's no real way
				 *      of implementing redirections  portably... So for  now,
				 *      simply  fall through to use the non-portable ASMNAME()
				 *      notation... */
			}
			return cprintDeclarationWithOptionalAsmname(
				fp, escapeMode, decl, exposedName,
				assemblyName, isSameAsname);
		}
		if (isLcl) {
			if (!isSameAsname)
				return cprintREDIRECT(fp, escapeMode, decl, exposedName, assemblyName, isLcl);
			return cprintCDECLARE(fp, escapeMode, decl, exposedName);
		}
		if (!isSameAsname) {
			return cprintREDIRECT(
				fp, escapeMode, decl, exposedName, assemblyName, isLcl);
		}
		return cprintDeclarationWithOptionalAsmname(
			fp, escapeMode, decl, exposedName,
			assemblyName, isSameAsname);
	}

	@@Print the start of an EXTERN-INLINE redirection- or declaration-binding,
	@@based on the exposed- and assembly name being the same
	@@Upon return, the caller should proceed to print the inline implementation body,
	@@followed by a single @')'-terminator that will then complete the macro  started
	@@by this function.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintExternInlineBindingStart(
			fp: CWriter, escapeMode: int, decl: string,
			exposedName: string, assemblyName: string) {
		local hasEllipsis = this.hasEllipsis;
		local isLcl = isLibcLinkage(decl, cc, assemblyName, hasEllipsis);
		local isSameAsname = exposedName == assemblyName && fp.externLinkage in ["", "C"];
		fp << (isLcl
		       ? isSameAsname ? "__CEIDECLARE" : "__CEIREDIRECT"
		       : isSameAsname ? "__COMPILER_CEIDECLARE" : "__COMPILER_CEIREDIRECT");
		if (isLcl) {
			if (assemblyName.startswith("DOS$")) {
				fp << "_DOS";
				assemblyName = assemblyName[4:];
			} else if (assemblyName.startswith("KOS$")) {
				fp << "_KOS";
				assemblyName = assemblyName[4:];
			}
			if (fp.externLinkage in ["", "C"] && exposedName in GCC_NCX && isNothrowGCCNCX)
				fp << "_GCCNCX";
		}
		fp << "(";
//		if (!isLcl)
//			fp << decl << ","; /* Declaration linkage */
		/* Attribute list */
		cprintAttributeList(fp, escapeMode);
		fp << ",";
		/* Return type */
		returnType.cprint(fp, escapeMode);
		fp << ",";
		/* NOTHROW behavior */
		escapeTextIntoFile(fp, isNothrowThrowing
			? nothrowThrowingSpec
			: nothrow, escapeMode);
		if (!isLcl)
			escapeTextIntoFile(fp << ",", cc, escapeMode); /* Calling convention */
		/* Exposed name */
		fp << "," << exposedName << ",";
		cprintArgumentListWithTypes(fp, escapeMode);
		fp << ",";
		if (!isSameAsname)
			fp << assemblyName << ",";
	}

}


class FunctionImplementation {
	this = default;

	@@The actual local implementation body of this function
	@@NOTE: This string has already been fully escaped!
	public member body: string | UserString;

	@@Name of the function itself within the implementation
	public member name: string | UserString;

	@@Pieces of code that must be written before @impl can be generated
	@@This  code   is  inserted   at   the  global   namespace   scope!
	public member implPrefix: {(string | UserString)...} = ();

	@@Other functions for which prototypes (though not necessarily c++ overloads) must
	@@be  provided in order to use this  implementation. Functions that appear in this
	@@list will be linked locally by their specified names.
	@@This mapping usually takes the form @("__localdep_strlen" : "strlen")
	@@NOTE: When  this points to  a Callable object,  then that function is
	@@      invoked and should then return one of the other accepted types.
	@@NOTE: Additionally, this member  may also be  assigned a Callable  object,
	@@      in which case that object's return value is used as the dependencies
	@@      @Mapping
	public member dependencies
		: {string: (string | UserString | Function | Callable)} | Callable = none;

	@@Same as @dependencies, but enumerate the actual Function objects
	public property dependencyFunctions: {string: Function} = {
		get(): {Function...} {
			if (m_dependencyFunctions !is bound) {
				local result = Dict();
				local usedDeps = dependencies;
				if (usedDeps is Callable)
					usedDeps = usedDeps();
				for (local name, elem: usedDeps) {
					if (elem is Callable)
						elem = elem();
					if (elem !is Function)
						elem = findFunctionByName(elem);
					result[name] = elem;
				}
				m_dependencyFunctions = result;
				dependencies          = result;
				return result;
			}
			return m_dependencyFunctions;
		}
	}
	private member m_dependencyFunctions: {string: Function};

	public function preload() {
		dependencyFunctions;
	}

	@@Truncate @body for use in a truncated inline function binding
	public function truncateBodyForInline(): FunctionImplementation {
		local result = copy this;
		local newBody = str(result.body);
		/* Simple: Unescape escaped line-feeds */
		newBody = newBody.replace("\\\n", "");
		/* TODO:
		 *  - Delete all C/C++-style comments from @result.body
		 *  - Replace all new-line characters from @result.body with " ",
		 *    except for those that was  followed by an arbitrary  amount
		 *    of  whitespace, followed by  a "#"-character. However, also
		 *    make
		 *  - Replace  all instances of  multiple consecutive space characters
		 *    with only a single space character, except for those that appear
		 *    in string-/character-literals
		 */
		/* TODO: This is hacky, and imperfect! (See the above comment) */
		newBody = newBody.replace("\n", " ").replace("\t", " ");
		for (;;) {
			local temp = newBody.replace("  ", " ");
			if (temp == newBody)
				break;
			newBody = temp;
		}
		result.body = newBody;
		return result;
	}

	@@Print everything necessary for this implmentation
	@@@param: dependencyDecl: Declaration prefix for dependencies (usually @"__LIBC")
	@@@param: escapeMode:     One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: keyDependency:  Transformation key for the names of dependent functions
	public function cprintLocalFunctionImplementation(
			fp: CWriter, escapeMode: int, name: string,
			prototype: FunctionPrototype, dependencyDecl: string,
#ifdef CONFIG_DOC_STRINGS_IN_LIBC_LOCAL
			doc: string,
#endif /* CONFIG_DOC_STRINGS_IN_LIBC_LOCAL */
			namespace: Namespace, keyDependency: Callable with string) {
		fp.forceStartOfLine();
		local oldNs = fp.namespace;
		fp.namespace = namespace;
		local oldExternLinkage = fp.externLinkage;
		if (oldExternLinkage !in ["", "C"])
			fp.externLinkage = "";
		/* Bind dependent functions. */
		local deps: {string: Function} = dependencyFunctions;
		for (local depName: deps.keys.sorted()) {
			local depFun = deps[depName];
#ifdef CONFIG_DOC_STRINGS_IN_LIBC_LOCAL
			fp << "/* Dependency: "
				<< depFun.name << " from "
				<< depFun.originalSystemHeaderName << " */\n";
#endif /* CONFIG_DOC_STRINGS_IN_LIBC_LOCAL */
			depName = keyDependency(depName);
			depFun.cprintHeaderDeclaration(
				fp, escapeMode, dependencyDecl,
				exposedName: depName,
				guardName:   namespace.keyDefaultGuard(depName),
				preferBindingMacros:       true,
				printDeclarationPrefixes:  true,
				onlyPrintPrimaryPrototype: true,
				/* FIXME: Must currently ignore fast function bindings to prevent dependency loops:
				 *
				 *     <stdlib.h>
				 *     <libc/local/wchar/wcsrtombs.h>
				 *     <optimized/string.h>      (for dependency `mempcpy()'; `__local___localdep_mempcpy_defined' was already defined)
				 *     <libc/core/string.h>
				 *     <libc/local/string/mempcpyc.h>
				 *
				 * The local implementation for `mempcpyc()'  now won't pull in  `mempcpy()',
				 * since `__local___localdep_mempcpy_defined' is already defined, even though
				 * the associated function hasn't been declared, yet.
				 *
				 * (Temporary) solution:
				 *     Break the dependency loop in <libc/local/wchar/wcsrtombs.h> by not including
				 *     <optimized/string.h>,   which   is   done   by   ignoring   fast   bindings.
				 *
				 * (Better) solution:
				 *     Have one <optimized/string/xxx.h> file for every function that provides
				 *     inline optimizations (possibly auto-generate these files via a separate
				 *     generator script).
				 *     That way, `mempcpy()' wouldn't have an implicit dependency on `mempcpyc()',
				 *     as it  is this  loop that  makes it  impossible to  form a  proper tree  of
				 *     dependencies  between  <libc/local/...>  implementations,   <libc/core/...>
				 *     bindings, and <optimized/...> wrappers.
				 */
				ignoreFastBindings:        true,
				printDoc: __TPP_EVAL(defined(CONFIG_DOC_STRINGS_IN_LIBC_LOCAL))
				);
		}
		if (implPrefix) {
			fp.namespace = GLOBAL_NAMESPACE;
			for (local x: implPrefix) {
				escapeNonRepeatingTextIntoFile(
					fp, x, escapeMode,
					keyEscape: (keyword: string): string -> {
						if (keyword in deps) {
							local res = keyDependency(keyword);
							if (LOCAL_NAMESPACE.prefix)
								res = f"({LOCAL_NAMESPACE.prefix} {res})";
							return res;
						}
						return none;
					},
					forceKeyEscape: true);
			}
			fp.namespace = namespace;
		}
#ifdef CONFIG_DOC_STRINGS_IN_LIBC_LOCAL
		if (doc)
			fp.printComment(doc);
#endif /* CONFIG_DOC_STRINGS_IN_LIBC_LOCAL */
		fp << "__LOCAL_LIBC(" << name << ") ";
		if (prototype.cprintAttributeList(fp, escapeMode))
			fp << " ";
		prototype.returnType.cprint(fp, escapeMode);
		fp << "\n";
		if (!prototype.isNothrowThrowing)
			escapeTextIntoFile(fp, prototype.nothrow, escapeMode);
		fp << "(";
		escapeTextIntoFile(fp, prototype.cc, escapeMode);
		if (prototype.cc)
			fp << " ";
		local csymbolName = namespace.keyCSymbolName(name);
		fp << csymbolName << ")";
		prototype.cprintArgumentListWithTypes(fp, escapeMode);
		if (prototype.isNothrowThrowing) {
			fp << " ";
			escapeTextIntoFile(fp, prototype.nothrow, escapeMode);
		}
		fp << " ";
		local selfName = this.name;
		escapeTextIntoFile(fp, body, escapeMode,
			keyEscape: (keyword: string): string -> {
				if (keyword == selfName) {
					if (LOCAL_NAMESPACE.prefix) {
						/* Must always wrap in parenthesis to guard against user-defined function-like macros. */
						return f"({LOCAL_NAMESPACE.prefix} {csymbolName})";
					}
					return csymbolName;
				}
				if (keyword in deps) {
					/* Always prefix with the  LOCAL namespace prefix. We  can't rely on the  compiler
					 * being able to figure out what we want to do by using relative names. It doesn't
					 * matter  that we're currently  inside the local namespace,  because c++ has this
					 * weird,  non-sensical rule that  causes functions between  different names to be
					 * ambiguous with each other, even when called  from the same namespace as one  of
					 * the functions is defined within:
					 *
					 * >> struct opaque;
					 * >> typedef struct opaque *opaque_struct_t;
					 * >> typedef void          *opaque_void_t;
					 * >> extern int foo_void(opaque_void_t p);
					 * >> extern int foo_struct(opaque_struct_t p);
					 * >> namespace ns {
					 * >> extern int foo_void(opaque_void_t p);
					 * >> extern int foo_struct(opaque_struct_t p);
					 * >> int bar_void(opaque_void_t p)     { return foo_void(p); }    // OK
					 * >> int bar_struct(opaque_struct_t p) { return foo_struct(p); }  // ERROR
					 * >> }
					 *
					 * The call in  `bar_struct' is ambiguous  because `struct opaque' was  first
					 * declared in the global namespace (it doesn't matter if `ns' were to  import
					 * `opaque' via `using ::opaque;'). But if one were to move the declaration of
					 * `struct opaque' into the `ns' namespace, then the above would compile.
					 *
					 * In other words, c++ overload resolution with user-defined structure takes
					 * into account which  namespaces those structures  were originally  defined
					 * within, increasing the priority of  `::foo_struct' to the point of  being
					 * equal to `ns::foo_struct', even though the call is made from `ns',  which
					 * if you'd ask me should be much more important of an indicator!!!
					 *
					 * Originally, I though this  was a g++ bug,  but testing the above  snippet
					 * with  practically  every compiler  on godbolt  ended  with _all_  of them
					 * reporting on the same ambiguous call to `foo_struct', so I can only guess
					 * that this is actually something the standard requires...
					 *
					 * *UGH* Anyways: the easiest work-around to this problem is to just always
					 * use absolute symbol names in local implementations, thus preventing  any
					 * issues from relying on compiler overload resolution order for  functions
					 * that have been defined by different namespace.
					 */
					local res = keyDependency(keyword);
					if (LOCAL_NAMESPACE.prefix) {
						/* Must always wrap in parenthesis to guard against user-defined function-like macros. */
						res = f"({LOCAL_NAMESPACE.prefix} {res})";
					}
					return res;
				}
				return none;
			},
			forceKeyEscape: true
		);
		fp << "\n";
		fp.externLinkage = oldExternLinkage;
		fp.namespace = oldNs;
	}
}


@@Only used by the @(import .loader)
class LoaderFunctionImplementation {
	this = default;
	public member impl: FunctionImplementation;
	public member ppCond: string | UserString = "1";
	public member ppCondPrefix: {(string | UserString)...} = ();
	public function preload() {
		impl.preload();
	}
}


@@Name of the return-type used by the using-import-return-type trick.
function usingImportReturnTypeNameOf(exposedName: string): string {
	return f"__PRIVATE_{exposedName}_rt";
}

@@Set  of functions that are imported from the global namespace. Functions
@@in this set may need to be able to support the cast-to-return-type trick
@@if they are ever defined as macros.
global everImportedFromGlobalNamespace: HashSet with string = HashSet();


class LocalFunction {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash(): int -> Object.id(this);

	@@Name of this local function (e.g. "strlen")
	public member name: string | UserString;

	@@Name of this declaring system header (e.g. "string" for <string.h>)
	public member originalSystemHeaderName: string | UserString;

	@@The prototype adhered to by all local implementation variants
	public member prototype: FunctionPrototype | Callable;

	@@Preprocessor conditions that  must be  met in  order
	@@for this local function implementation to be chosed.
	public member ppCond: string | UserString = "1";

	@@Pieces of code that must be written before @ppCond can be evaluated
	@@This  code   is   inserted   at   the   global   namespace   scope!
	public member ppCondPrefix: {(string | UserString)...} = ();

	@@The bound implementation for the local function
	public member impl: FunctionImplementation | Callable;

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Helper wrapper for @prototype that will automatically unwind @Callable objects
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				result = prototype = result();
			return result;
		}
	}

	@@Wrapper for @impl that will automatically unwind @Callable bindings
	public property functionImpl: FunctionImplementation = {
		get(): FunctionImplementation {
			local result = impl;
			if (result is Callable)
				result = impl = result();
			return result;
		}
	}

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				result = documentation = result();
			return result;
		}
	}

	public function preload() {
		if (prototype is bound)
			functionPrototype;
		if (impl is bound)
			functionImpl.preload();
		documentationString;
	}

	@@@param: dependencyDecl: Declaration prefix for dependencies (usually @"__LIBC")
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintLocalFunctionHeader(
			fp: CWriter, escapeMode: int, dependencyDecl: string,
			keyDependency: Callable with string = none,
			printCopyright: bool = true, namespace: Namespace = none) {
		try {
			if (keyDependency is none)
				keyDependency = keyLocalDep;
			if (namespace is none)
				namespace = LOCAL_NAMESPACE;
			if (printCopyright)
				fp << COPYRIGHT << "\n";
			local usedPrototype = functionPrototype;
			local localGuardName = namespace.keyDefaultGuard(name);
			fp.ppIfndef(localGuardName);
			fp.ppDefine(localGuardName, "");
			fp.ppInclude("<__crt.h>");
			/* Include the preprocessor-condition prefix texts. */
			for (local x: ppCondPrefix)
				escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
			CWriter_ppIfEscaped(fp, ppCond, escapeMode);
			/* Print out the declaration prefix. */
			for (local x: usedPrototype.declPrefix)
				escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
			fp.forceStartOfLine();
			/* Print the binding */
			functionImpl.cprintLocalFunctionImplementation(
				fp, escapeMode, name, usedPrototype,
				dependencyDecl,
#ifdef CONFIG_DOC_STRINGS_IN_LIBC_LOCAL
				documentationString,
#endif /* CONFIG_DOC_STRINGS_IN_LIBC_LOCAL */
				namespace, keyDependency);
			local myLocalDepName = keyLocalDep(name);
			local myLocalDepGuard = namespace.keyDefaultGuard(myLocalDepName);
			fp.forceStartOfLine();
			/* Also bind ourself as a local dependency function */
			fp << "#ifndef " << myLocalDepGuard << "\n"
				"#define " << myLocalDepGuard << "\n"
				"#define " << myLocalDepName << " " << namespace.keyCSymbolName(name) << "\n"
				"#endif /* !" << myLocalDepGuard << " */\n";
			fp.ppElse();
			fp.ppUndef(localGuardName);
			fp.ppEndif();
			fp.ppEndif();
		} catch (...) {
			print("... while printing local-header <libc/local/",
				originalSystemHeaderName, "/", name, ".h>");
			throw;
		}
	}

	@@Print a binding for this function
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintFunctionBinding(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			prototypes: {FunctionPrototype...}, doc: string, preferBindingMacros: bool) {
		local usedPrototype = functionPrototype;
		local oldExternLinkage = fp.externLinkage;
		if (oldExternLinkage !in ["", "C"])
			fp.externLinkage = "";
		local oldNs = fp.namespace;
		fp.namespace = GLOBAL_NAMESPACE;
		/* Include the local-header for this function */
		fp.ppInclude(f"<libc/local/{originalSystemHeaderName}/{name}.h>");
		/* Remember that we'll be needing the local implementation of this function */
		neededLocalFunction.insert(this);
		fp.namespace = oldNs;
		fp.externLinkage = oldExternLinkage;
		local callToLocalName = LOCAL_NAMESPACE.keyCSymbolName(name);
		/* When only doing partial escaping of declaration, we must  still
		 * do  full escaping within call-to-local expressions, since local
		 * functions may use types in their declarations (which we in turn
		 * have  to cast our  prototypes to), that  aren't declared in the
		 * current header (meaning that their representation must be fully
		 * escaped) */
		local callToEscapeMode = escapeMode;
		if (callToEscapeMode == ESCAPE_MODE_PART)
			callToEscapeMode = ESCAPE_MODE_FULL;
		if (preferBindingMacros) {
			if (doc)
				fp.printComment(doc);
			if (#prototypes == 1) {
				prototypes.first.cprintCallToMacro(
					fp, callToEscapeMode, exposedName,
					callToLocalName, usedPrototype,
					LOCAL_NAMESPACE);
			} else {
				fp << "#define " << exposedName << "(...) (";
				if (oldNs !== LOCAL_NAMESPACE && LOCAL_NAMESPACE.prefix)
					fp << LOCAL_NAMESPACE.prefix << " ";
				fp << callToLocalName << ")(__VA_ARGS__)";
			}
			return;
		}
		if (oldNs !== LOCAL_NAMESPACE && LOCAL_NAMESPACE.prefix)
			callToLocalName = f"({LOCAL_NAMESPACE.prefix} {callToLocalName})";
		if (prototypes.each.hasEllipsis || ...) {
			/* _Must_ (try to) use keyUsing for c++, or a macro for C */
			if (doc)
				fp.printComment(doc);
			if (exposedName == name) {
				fp.ppIf(usedPrototype.hasEllipsis
					? "defined(__cplusplus) && __has_builtin(__builtin_va_arg_pack)"
					: "defined(__cplusplus)");
				LOCAL_NAMESPACE.keyUsingOrImpl(fp, exposedName, () -> {
					prototypes.first.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, callToLocalName, usedPrototype,
						callToEscapeMode: callToEscapeMode);
				});
			}
			if (fp.namespace != GLOBAL_NAMESPACE || exposedName in everImportedFromGlobalNamespace) {
				if (exposedName == name) {
					fp.ppElif("defined(__cplusplus)");
				} else {
					fp.ppIf("defined(__cplusplus)");
				}
				/* Use the cast-to-return-type-for-namespace-prefix trick. */
				fp << "typedef ";
				usedPrototype.returnType.cprint(fp, escapeMode);
				local rtName = usingImportReturnTypeNameOf(exposedName);
				fp	<< " " << rtName << ";\n"
					<< "#define " << rtName << " " << rtName << "\n"
					<< "#define " << exposedName << "(...) "
					<< rtName << "(" << callToLocalName << "(__VA_ARGS__))\n";
				fp.ppElse();
				fp << "#define " << exposedName << "(...) " << callToLocalName << "(__VA_ARGS__)\n";
				if (exposedName != name)
					fp.ppEndif();
			} else {
				if (exposedName == name)
					fp.ppElse();
				fp << "#define " << exposedName << "(...) " << callToLocalName << "(__VA_ARGS__)\n";
			}
			if (exposedName == name)
				fp.ppEndif();
			return;
		}
		for (local ptype: prototypes) {
			if (doc)
				fp.printComment(doc);
			local allowUsing = exposedName == name && #prototypes == 1 &&
			                   ptype.compatibleWith(usedPrototype);
			if (allowUsing) {
				/* Can only be done if the prototypes match up! */
				LOCAL_NAMESPACE.keyUsingOrImpl(fp, exposedName, () -> {
					ptype.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, callToLocalName, usedPrototype,
						callToEscapeMode: callToEscapeMode);
				});
			} else {
				ptype.cprintCallToFunction(
					fp, escapeMode, NAMESPACE_IMPORT_DECL,
					exposedName, callToLocalName, usedPrototype,
					callToEscapeMode: callToEscapeMode);
				fp << "\n";
			}
		}
	}

}

class InlineFunction {
	this = default;

	@@Inline mode. One of:
	@@  - @"LOCAL"
	@@  - @"FORCELOCAL"
	@@  - @"__EXTERN_INLINE"
	public member mode: string = "LOCAL";

	@@The different, possible methods by which this function can be implemented.
	@@During   compile-time,   the   first   variant   is   chosen   for   which
	@@the @ppCond evaluates to a true-expression
	public member impl: FunctionImplementation | Callable = ();

	@@Name of  the assembly  symbol against  which
	@@to link in case @(mode == "__EXTERN_INLINE")
	public member externInlineAsmname: string | UserString;

	@@Set to true for so-called  `fast` function bindings. Such bindings  will
	@@not be linked in `<libc/core/string.h>`, through fast bindings will then
	@@still be linked everywhere else, including in `<libc/string.h>`
	public member isFastBinding: bool = false;

	@@Returns @impl, but will unwind @Callable wrappers
	public property functionImpl: FunctionImplementation = {
		get(): FunctionImplementation {
			local result = impl;
			if (result is Callable)
				result = impl = result();
			return result;
		}
	}

	public function preload() {
		functionImpl.preload();
	}

	@@Bind the inline function's body.
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintFunctionBinding(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			prototypes: {FunctionPrototype...}, doc: string,
			preferBindingMacros: bool, keyDependency: Callable with string = none,
			dependenciesNamespace: Namespace = none, dependencyDecl: string = "__LIBC") {
		local impl: FunctionImplementation = functionImpl;
		local implName = impl.name;
		/* Bind dependent functions. */
		local deps: {string: Function} = impl.dependencyFunctions;
		local depKey = none;
		if (deps) {
			if (dependenciesNamespace is none)
				dependenciesNamespace = NAMESPACES["local"];
			if (keyDependency is none)
				keyDependency = keyLocalDep;
			depKey = (keyword: string): string -> {
				if (keyword == implName)
					return exposedName;
				if (keyword in deps) {
					local res = keyDependency(keyword);
					if (fp.namespace === dependenciesNamespace || !dependenciesNamespace.prefix)
						return f"({res})";
					return f"({dependenciesNamespace.prefix} {res})";
				}
				return none;
			};
			local oldExternLinkage = fp.externLinkage;
			if (oldExternLinkage !in ["", "C"])
				fp.externLinkage = "";
			local oldNs = fp.namespace;
			fp.namespace = dependenciesNamespace;
			for (local depName: deps.keys.sorted()) {
				local depFun = deps[depName];
				depName = keyDependency(depName);
				depFun.cprintHeaderDeclaration(fp, escapeMode, dependencyDecl,
					exposedName:              depName,
					guardName:                dependenciesNamespace.keyDefaultGuard(depName),
					preferBindingMacros:      true,
					printDeclarationPrefixes: true);
			}
			fp.namespace = oldNs;
			fp.externLinkage = oldExternLinkage;
		} else {
			depKey = (keyword: string): string -> {
				if (keyword == implName)
					return exposedName;
				return none;
			};
		}
		if (impl.implPrefix) {
			local oldExternLinkage = fp.externLinkage;
			if (oldExternLinkage !in ["", "C"])
				fp.externLinkage = "";
			local oldNs = fp.namespace;
			fp.namespace = GLOBAL_NAMESPACE;
			for (local x: impl.implPrefix) {
				escapeNonRepeatingTextIntoFile(
					fp, x, escapeMode,
					keyEscape: (keyword: string): string -> {
						if (keyword in deps) {
							local res = keyDependency(keyword);
							if (!dependenciesNamespace.prefix)
								return f"({res})";
							return f"({dependenciesNamespace.prefix} {res})";
						}
						return none;
					},
					forceKeyEscape: true);
			}
			fp.namespace = oldNs;
			fp.externLinkage = oldExternLinkage;
		}
		for (local prototype: prototypes) {
			if (doc)
				fp.printComment(doc);
			if (mode == "__EXTERN_INLINE") {
				prototype.cprintExternInlineBindingStart(
					fp, escapeMode, decl, exposedName,
					str externInlineAsmname);
				/* Inline implementation */
				escapeTextIntoFile(
					fp, impl.body, escapeMode,
					keyEscape: depKey,
					forceKeyEscape: true);
				fp << ")\n";
			} else {
				/* Generic inlining (use the inlining mode as declaration prefix) */
				prototype.cprintDeclarationWithoutTerminator(
					fp, escapeMode, this.mode, exposedName);
				fp << " ";
				escapeTextIntoFile(
					fp, impl.body, escapeMode,
					keyEscape: depKey,
					forceKeyEscape: true);
				fp << "\n";
			}
		}
	}
}


@@Return  the  @FunctionPrototype.cc that  is  common to  all  of the
@@given @prototypes. If different CCs are used, return @none instead.
function getCommonCCFromPrototypes(
		prototypes: {(string | UserString, {FunctionPrototype...})...}): string | none {
	local result = none;
	for (local none, protos: prototypes) {
		for (local proto: protos) {
			local pcc = str(proto.cc);
			if (result is none) {
				result = pcc;
			} else if (result != pcc) {
				return none;
			}
		}
	}
	return result;
}

@@Check if the given 2 lists of function prototypes
@@and  conditions  are compatible  with  each other
function areFunctionPrototypesCompatible(
		a: {(string | UserString, {FunctionPrototype...})...},
		b: {(string | UserString, {FunctionPrototype...})...}): bool {
	if (a === b)
		return true;
	local an = #a;
	if (an != #b)
		return false;
	for (local i = 0; i < an; ++i) {
		local ea = a[i];
		local eb = b[i];
		if (ea[0] != str(eb[0]))
			return false;
		ea = ea[1];
		eb = eb[1];
		local apn = #ea;
		if (apn != #eb)
			return false;
		for (local j = 0; j < apn; ++j) {
			if (!ea[j].compatibleWith(eb[j]))
				return false;
		}
	}
	return true;
}



class NamespaceBinding {
	this = default;

	@@The namespace from which to import the function
	public member namespace: Namespace;

	@@Name of the function within @namespace
	public member importName: string | UserString;

	@@The  prototype  to  match  when  doing  a  call-to  import
	@@Ignored   when   @namespace  doesn't   do   any  escaping.
	@@i.e. @(namespace.keyCSymbolName(importName) == importName)
	public member prototype: FunctionPrototype | Callable;

	@@Wrapper for @prototype
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				result = prototype = result();
			return result;
		}
	}

	public function preload() {
		if (prototype is bound)
			functionPrototype;
	}

	@@Print a binding for this namespace import
	@@@param: preferBindingMacros: Prefer function bindings to be done with macros, rather than
	@@                             through use of inline functions.
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintNamespaceImportBinding(
			fp: CWriter, escapeMode: int, exposedName: string,
			conditionalPrototypes: {(string | UserString, {FunctionPrototype...})...},
			doc: string, preferBindingMacros/*unused*/: bool) {
		assert namespace !== fp.namespace;
		assert importName == exposedName;
		if (doc)
			fp.printComment(doc);
		local callToEscapeMode = escapeMode;
		if (callToEscapeMode == ESCAPE_MODE_PART)
			callToEscapeMode = ESCAPE_MODE_FULL;
		/* There are 2 ways in which we must import namespace imports:
		 * The (simple) C++ way:
		 * >> namespace.keyUsing(fp, exposedName);
		 * And the (complicated) C way:
		 * >> __NAMESPACE_FAST_USING_OR_IMPL(<exposedName>, ...) */
		local cSymbolName = namespace.keyCSymbolName(exposedName);
		if (cSymbolName == exposedName) {
			/* The namespace  doesn't  do  any sort  of  name  escape
			 * (this is the case for the std- and global  namespaces)
			 * In this case, we can simply do a conditional namespace
			 * import in  C++-mode, and  don't  have to  do  anything
			 * in C-mode  (since the  symbol will  have already  been
			 * imported in that case) */
			if (namespace === STD_NAMESPACE) {
				/* We can always simply use keyUsing() in this case! */
				if ((for (local none, protos: conditionalPrototypes)
						protos.each.hasEllipsis || ...
					) || ...) {
					local tn = usingImportReturnTypeNameOf(exposedName);
					fp.ppIfdef(tn);
					namespace.keyUsing(fp, tn);
					fp.ppElse();
					namespace.keyUsing(fp, exposedName);
					fp.ppEndif();
				} else {
					namespace.keyUsing(fp, exposedName);
				}
				return;
			}
			local nsPrefix = namespace.prefix;
			if (namespace === GLOBAL_NAMESPACE)
				nsPrefix = "::";
			if (nsPrefix)
				cSymbolName = f"{nsPrefix} {cSymbolName}";
			if (#conditionalPrototypes == 1 && conditionalPrototypes.first[0] == "1") {
				local prototypes = conditionalPrototypes.first[1];
				local doUsingPpCond = "1";
				local isFirst = true;
				if (#prototypes == 1) {
					local usedCallToPrototype = prototypes.first;
					if (prototype is bound)
						usedCallToPrototype = functionPrototype;
					if (usedCallToPrototype.hasEllipsis) {
						/* Deal with the using-import-return-type trick */
						local tn = usingImportReturnTypeNameOf(exposedName);
						fp.ppIfdef(tn);
						isFirst = false;
						namespace.keyUsing(fp, tn);
						doUsingPpCond = "__has_builtin(__builtin_va_arg_pack)";
					}
				}
				(isFirst ? fp.ppIf : fp.ppElif)(doUsingPpCond);
				namespace.keyUsingOrImpl(fp, exposedName, () -> {
					if (#prototypes == 1) {
						local callToPrototype = prototypes.first;
						if (prototype is bound)
							callToPrototype = functionPrototype;
						prototypes.first.cprintCallToFunction(
							fp, escapeMode, NAMESPACE_IMPORT_DECL,
							exposedName, cSymbolName, callToPrototype,
							callToEscapeMode: callToEscapeMode);
					} else {
						fp.forceStartOfLine();
						local oldExternLinkage = fp.externLinkage;
						fp.externLinkage = "C++";
						for (local p: prototypes) {
							local callToPrototype = p;
							if (prototype is bound)
								callToPrototype = functionPrototype;
							p.cprintCallToFunction(
								fp, escapeMode, NAMESPACE_IMPORT_DECL,
								exposedName, cSymbolName, callToPrototype,
								callToEscapeMode: callToEscapeMode);
							fp.forceStartOfLine();
						}
						fp.externLinkage = oldExternLinkage;
					}
				});
				if (doUsingPpCond != "1") {
					if (fp.namespace === GLOBAL_NAMESPACE) {
						fp.ppElse();
						fp << "#define " << exposedName << "(...) " << cSymbolName << "(__VA_ARGS__)\n";
					} else {
						fp.ppElse();
						namespace.keyUsing(fp, exposedName);
					}
				}
				fp.ppEndif();
			} else {
				local cond = "!defined(__COMPILER_HAVE_BUG_BLOATY_CXX_USING)";
				if (namespace === GLOBAL_NAMESPACE || namespace === STD_NAMESPACE)
					cond = "!defined(__COMPILER_HAVE_BUG_BLOATY_CXX_USING) || defined(__NO_NAMESPACE_STD)";
				fp.ppIf(cond);
				namespace.keyUsing(fp, exposedName);
				fp.ppElse();
				local isFirst = true;
				local numAdditionalEndifs = 0;
				for (local ppCond, prototypes: conditionalPrototypes) {
					if (!prototypes)
						continue;
					if (isFirst) {
						CWriter_ppIfEscaped(fp, ppCond, escapeMode);
						isFirst = false;
					} else {
						if (!CWriter_ppElifEscaped(fp, ppCond, escapeMode))
							++numAdditionalEndifs;
					}
					if (#prototypes == 1) {
						local callToPrototype = prototypes.first;
						if (prototype is bound)
							callToPrototype = functionPrototype;
						prototypes.first.cprintCallToFunction(
							fp, escapeMode, NAMESPACE_IMPORT_DECL,
							exposedName, cSymbolName, callToPrototype,
							callToEscapeMode: callToEscapeMode);
					} else {
						fp.forceStartOfLine();
						local oldExternLinkage = fp.externLinkage;
						fp.externLinkage = "C++";
						for (local p: prototypes) {
							local callToPrototype = p;
							if (prototype is bound)
								callToPrototype = functionPrototype;
							p.cprintCallToFunction(
								fp, escapeMode, NAMESPACE_IMPORT_DECL,
								exposedName, cSymbolName, callToPrototype,
								callToEscapeMode: callToEscapeMode);
							fp.forceStartOfLine();
						}
						fp.externLinkage = oldExternLinkage;
					}
				}
				fp.ppEndifN(numAdditionalEndifs);
				if (!isFirst)
					fp.ppEndif();
				fp.ppEndif();
			}
			return;
		}
		if (!conditionalPrototypes)
			return; /* Shouldn't happen... */
		if (namespace.prefix)
			cSymbolName = f"{namespace.prefix} {cSymbolName}";
		cSymbolName = f"({cSymbolName})";
		local isFirst = true;
		local numAdditionalEndifs = 0;
		for (local ppCond, prototypes: conditionalPrototypes) {
			if (isFirst) {
				CWriter_ppIfEscaped(fp, ppCond, escapeMode);
				isFirst = false;
			} else {
				if (!CWriter_ppElifEscaped(fp, ppCond, escapeMode))
					++numAdditionalEndifs;
			}
			if (#prototypes == 1) {
				/* The complicated case: Must use `keyUsingOrImpl' */
				local usedPrototype = prototypes.first;
				local usedCallToPrototype = usedPrototype;
				if (prototype is bound)
					usedCallToPrototype = functionPrototype;
				local doUsingPpCond = "1";
				if (usedPrototype.hasEllipsis)
					doUsingPpCond = "__has_builtin(__builtin_va_arg_pack)";
				fp.ppIf(doUsingPpCond);
				namespace.keyUsingOrImpl(fp, exposedName, () -> {
					usedPrototype.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, cSymbolName, usedCallToPrototype,
						callToEscapeMode: callToEscapeMode);
				});
				if (doUsingPpCond != "1") {
					fp.ppElse();
					if (fp.namespace === GLOBAL_NAMESPACE) {
						fp << "#define " << exposedName << "(...) " << cSymbolName << "(__VA_ARGS__)\n";
					} else {
						namespace.keyUsing(fp, exposedName);
					}
				}
				fp.ppEndif();
			} else {
				/* TODO: preferBindingMacros */
				/* The even more complicated case:
				 * >> #ifdef __cplusplus
				 * >> __NAMESPACE_FAST_USING(<exposedName>)
				 * >> #else
				 * >> <CallToProto1>
				 * >> <CallToProto2>
				 * >> <CallToProto...>
				 * >> <CallToProtoN>
				 * >> #endif */
				fp.ppIf("defined(__cplusplus) && !defined(__COMPILER_HAVE_BUG_BLOATY_CXX_USING)");
				namespace.keyUsing(fp, exposedName);
				fp.ppElse();
				for (local proto: prototypes) {
					local callToPrototype = proto;
					if (prototype is bound)
						callToPrototype = functionPrototype;
					proto.cprintCallToFunction(
						fp, escapeMode, NAMESPACE_IMPORT_DECL,
						exposedName, cSymbolName, callToPrototype,
						callToEscapeMode: callToEscapeMode);
					fp << "\n";
				}
				fp.ppEndif();
			}
		}
		fp.ppEndifN(numAdditionalEndifs);
		if (!isFirst)
			fp.ppEndif();
	}
}


class MacroBinding {
	this = default;

	@@The macro's body against which to bind
	public member body: string | UserString | Callable;

	public function preload() {
		if (body is Callable)
			body = body();
	}

	@@Print a macro binding
	public function cprintMacroBinding(
			fp: CWriter, escapeMode: int, exposedName: string,
			prototype: FunctionPrototype, doc: string) {
		if (doc)
			fp.printComment(doc);
		local bodyFp = File.Writer();

		/* Setup keyword escaping to not escape argument names */
		local unescapedArgumentNames: {string...} = HashSet(
			for (local argName: prototype.argv.each.name)
				str(argName));
		local keyEscape = (keyword: string): string -> {
			if (keyword in unescapedArgumentNames)
				return keyword; /* We don't escape macro arguments */
			return none;
		};

		bodyFp << "#define " << exposedName << "("
			<< ", ".join(prototype.argv.each.name)
			<< ")" << "\n";
		if (body is Callable)
			body = body();
		escapeTextIntoFile(bodyFp, body, escapeMode,
		                   keyEscape: keyEscape,
		                   forceKeyEscape: true);
		local macroDefLines = List(bodyFp.string.splitlines(false));
		if (#macroDefLines == 2) {
			macroDefLines = [f"{macroDefLines[0]} {macroDefLines[1]}"];
		} else {
			macroDefLines = List({
				macroDefLines[0],
				(for (local line: macroDefLines[1:])
					f"\t{line}"
				)...
			});
		}
		local macroDefLongestLine = macroDefLines.each.expandtabs(4).length > ...;
		local pendingWhitespace = "";
		for (local line: macroDefLines) {
			fp << pendingWhitespace << line;
			local expandedLine = line.expandtabs(4);
			pendingWhitespace = f"{" " * (macroDefLongestLine - #expandedLine)}\\\n";
		}
	}

	@@Print the macro binding a normal function (needed when printing outside the global namespace)
	public function cprintMacroBindingAsFunction(
			fp: CWriter, escapeMode: int, exposedName: string,
			prototype: FunctionPrototype, doc: string) {
		if (doc)
			fp.printComment(doc);
		prototype.cprintDeclarationWithoutTerminator(
			fp, escapeMode, "__FORCELOCAL", exposedName);
		if (body is Callable)
			body = body();
		fp << " { return ";
		escapeTextIntoFile(fp, body, escapeMode);
		fp << "; }\n";
	}
}


class FunctionBinding {
	this = default;

	@@Preprocessor  condition  that must  be  evaluate to  true  at compile-time
	@@in order for this binding to be considered usable by the hosting compiler.
	public member ppCond: string | UserString = "1";

	@@Pieces of code that must be written before @ppCond can be evaluated
	@@This  code   is   inserted   at   the   global   namespace   scope!
	public member ppCondPrefix: {(string | UserString)...} = ();

	@@Prototype selectors (usually simply @({ "1", { <primaryPrototype> } }))
	@@This is a list of pairs (ppCond, prototypes) to select which prototypes
	@@should be used to bind the function.
	@@Different prototypes can be provided with a dependency on some preprocessor
	@@expression in  order  to  support  CORRECT_ISO_CXX_OVERLOADS  declarations.
	@@NOTE: In practice, the preprocessor conditions for prototype selection
	@@      should  always be done  such that a prototype  will exist in all
	@@      conditions. However, this is not a requirement.
	public member prototypes: {(string | UserString, {FunctionPrototype...})...} | Callable = ();

	@@The actual binding provided by this function:
	@@  - @LocalFunction:    Provide   a  local  function   implementation,  via  inclusion  of
	@@                       <libc/local/@(binding.originalSystemHeaderName)/@(binding.name).h>
	@@  - @InlineFunction:   Provide an in-line function implementation, possibly alongside
	@@                       support for @"__EXTERN_INLINE"
	@@  - @string:           External assembly symbol (bind the function against
	@@                       an   assembly  symbol  by  the  name  of  @binding)
	@@  - @UserString:       Same as @string
	@@  - @NamespaceBinding: Import an existing declaration from some other namespace
	@@  - @MacroBinding:     Bind as a macro
	@@  - @Callable:         A callback that takes no arguments, and returns one of the above
	public member binding: LocalFunction | InlineFunction | string | UserString | NamespaceBinding | MacroBinding | Callable;

	public property functionPrototypes: {(string | UserString, {FunctionPrototype...})...} = {
		get(): {(string | UserString, {FunctionPrototype...})...} {
			local result = prototypes;
			if (result is Callable)
				result = prototypes = result();
			return result;
		}
	}

	@@Check if this binding has a *primary*  prototype (or return @none if it  doesn't)
	@@A primary prototype  exists if at  least one @prototypes  has a condition  string
	@@that  evaluates  to @"1".  The first  set of  prototypes that  does this  is then
	@@considered  the set of  primary prototypes. Furthermore, should  this set then be
	@@made up of exactly one prototype, that prototype is then *the* primary prototype.
	@@In all other cases, no primary prototype exists, and this property returns  @none
	public property primaryPrototype: FunctionPrototype | none = {
		get(): FunctionPrototype | none {
			for (local ppCond, protos: functionPrototypes) {
				if (ppCond != "1")
					continue;
				if (#protos == 1)
					return protos.first;
				break;
			}
			return none;
		}
	}

	@@Return @binding, but unwind @Callable wrappers
	public property functionBinding: LocalFunction | InlineFunction | string | UserString | NamespaceBinding | MacroBinding = {
		get(): LocalFunction | InlineFunction | string | UserString | NamespaceBinding | MacroBinding {
			local result = binding;
			if (result is Callable)
				result = binding = result();
			return result;
		}
	}

	public function preload() {
		functionPrototypes;
		local bind = functionBinding;
		if (hasattr(bind, "preload"))
			bind.preload();
	}

	@@Simple helper to peek  if the ppCond  part of @this  binding is known  already
	@@Note that it may become known at a later point in time, and that this function
	@@may not necessary  detect it as  being known.  Only note that  a return  value
	@@other than @none indicates a guarantied, known value
	public function getRequiresConstant(): bool | none {
		if (ppCond == "0")
			return false;
		if (functionBinding is NamespaceBinding) {
			if (ppCond == "1")
				return false;
			return none;
		}
		local usedProtos = functionPrototypes;
		if (!usedProtos)
			return false;
		local hasBindablePrototype = false;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "1") {
				/* Universal prototype */
				if (ppCond == "1")
					return true;
				return none;
			} else if (protoCond != "0") {
				hasBindablePrototype = true;
			}
		}
		if (!hasBindablePrototype)
			return false;
		return none;
	}

	@@Print requires-conditions for this function (has used by @"$has_function(...)")
	public function cprintRequires(
			fp: CWriter | File,
			extendedPrefixes: List | none) {
		if (ppCond == "0") {
			fp << "0";
			return;
		}
		if (functionBinding is NamespaceBinding)
			goto do_universal_binding;
		local usedProtos = functionPrototypes;
		if (!usedProtos) {
			fp << "0";
			return;
		}
		local hasUniversalPrototype = false;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "1") {
				hasUniversalPrototype = true;
				break;
			}
		}
		if (hasUniversalPrototype) {
do_universal_binding:
			if (extendedPrefixes !is none)
				extendedPrefixes.extend(ppCondPrefix);
			fp << "(";
			escapeTextIntoFile(fp, ppCond, ESCAPE_MODE_FULL,
				extendedPrefixes: extendedPrefixes);
			fp << ")";
			return;
		}
		if (ppCond != "1") {
			if (extendedPrefixes !is none)
				extendedPrefixes.extend(ppCondPrefix);
			fp << "((";
			escapeTextIntoFile(fp, ppCond, ESCAPE_MODE_FULL,
				extendedPrefixes: extendedPrefixes);
			fp << ")&&";
		}
		local hasMultiplePrototypes = 0;
		for (local protoCond, none: usedProtos) {
			if (protoCond != "0")
				++hasMultiplePrototypes;
		}
		if (hasMultiplePrototypes > 1)
			fp << "(";
		local isFirst = true;
		for (local protoCond, none: usedProtos) {
			if (protoCond == "0")
				continue;
			if (!isFirst)
				fp << "||";
			fp << "(";
			escapeTextIntoFile(fp, protoCond, ESCAPE_MODE_FULL,
				extendedPrefixes: extendedPrefixes);
			fp << ")";
			isFirst = false;
		}
		if (hasMultiplePrototypes > 1)
			fp << ")";
		if (ppCond != "1")
			fp << ")";
	}

	@@Print a normal binding, as may be found in `<string.h>`
	@@NOTE: The caller is responsible to ensure that @ppCond evaluates to non-zero at compile-time
	@@@param: escapeMode:                One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:                      Declaration prefix (e.g. @"__LIBC")
	@@@param: exposedName:               The name by which to expose this binding (e.g. @"strlen")
	@@@param: doc:                       A human-readable description of the associated function
	@@@param: guardName:                 The  name  of  a  macro  that   must  be  #undef'd  if  no   prototype
	@@                                   has been exposed at compile-time. Set to @none if no such macro exists
	@@@param: preferBindingMacros:       Prefer function bindings to be done with macros, rather than
	@@                                   through use of inline functions.
	@@@param: printDeclarationPrefixes:  Print prototype declaration prefixes
	@@@param: onlyPrintPrimaryPrototype: Only bind against @primaryPrototype (but fall back to binding
	@@                                   against   all  prototypes  if  no  @primaryPrototype  exists)
	public function cprintBindFunction(
			fp: CWriter, escapeMode: int, decl: string, exposedName: string,
			guardName: string | none = none, doc: string = "",
			preferBindingMacros: bool = false,
			printDeclarationPrefixes: bool = false,
			onlyPrintPrimaryPrototype: bool = false) {
		local usedBinding = functionBinding;
		local usedPrototypes = functionPrototypes;
		if (usedBinding is NamespaceBinding) {
			local usedNs = usedBinding.namespace;
			assert usedNs !== fp.namespace, "The caller must check this!";
			assert usedBinding.importName == exposedName, "The caller must check this!";
			usedBinding.cprintNamespaceImportBinding(
				fp, escapeMode, exposedName,
				usedPrototypes, doc, preferBindingMacros);
			return;
		}
		if (usedBinding is MacroBinding) {
			local prim = primaryPrototype;
			if (prim is none)
				throw Error(f"{repr exposedName}: Can't use macro bindings without primary prototype");
			if (fp.namespace === GLOBAL_NAMESPACE) {
				usedBinding.cprintMacroBinding(fp, escapeMode, exposedName, prim, doc);
			} else {
				usedBinding.cprintMacroBindingAsFunction(fp, escapeMode, exposedName, prim, doc);
			}
			return;
		}
		if (onlyPrintPrimaryPrototype && #usedPrototypes > 1) {
			local prim = primaryPrototype;
			if (prim !is none)
				usedPrototypes = { ("1", { prim }) };
		}
		if (#usedPrototypes >= 2) {
			for (local ppCond, none: usedPrototypes) {
				if (ppCond != "1")
					continue;
				if (usedBinding is LocalFunction) {
					/* Include the local-implementation beforehard! */
					local oldExternLinkage = fp.externLinkage;
					if (oldExternLinkage !in ["", "C"])
						fp.externLinkage = "";
					local oldNs = fp.namespace;
					fp.namespace = GLOBAL_NAMESPACE;
					/* Include the local-header for this function */
					fp.ppInclude(f"<libc/local/{
						usedBinding.originalSystemHeaderName
					}/{usedBinding.name}.h>");
					fp.namespace = oldNs;
					fp.externLinkage = oldExternLinkage;
				}
				if (printDeclarationPrefixes) {
					/* TODO: Print declaration prefixes common to all of @usedPrototypes,
					 *       so-long as at least one of @usedPrototypes has a ppCond that
					 *       always evaluates to true */
				}
				break;
			}
		}
		local isFirst = true;
		local numAdditionalEndifs = 0;
		for (local ppCond, associatedPrototypes: usedPrototypes) {
			if (isFirst) {
				CWriter_ppIfEscaped(fp, ppCond, escapeMode);
				isFirst = false;
			} else {
				if (!CWriter_ppElifEscaped(fp, ppCond, escapeMode))
					++numAdditionalEndifs;
			}
			if (printDeclarationPrefixes) {
				if (usedBinding is LocalFunction &&
				    (#usedPrototypes == 1 && #associatedPrototypes == 1) &&
				    associatedPrototypes.first.declPrefix ==
				    usedBinding.functionPrototype.declPrefix) {
					/* The same prefix will already be printed
					 * inside of  the  local-function  header. */
				} else {
					/* Print declaration prefixes */
					local oldNs = none;
					local oldExternLinkage;
					for (local proto: associatedPrototypes) {
						for (local x: proto.declPrefix) {
							if (oldNs is none) {
								oldExternLinkage = fp.externLinkage;
								if (oldExternLinkage !in ["", "C"])
									fp.externLinkage = "";
								oldNs = fp.namespace;
								fp.namespace = GLOBAL_NAMESPACE;
							}
							escapeNonRepeatingTextIntoFile(fp, x, escapeMode);
						}
					}
					if (oldNs !is none) {
						fp.namespace = oldNs;
						fp.externLinkage = oldExternLinkage;
					}
				}
			}
			local oldExternLinkage = fp.externLinkage;
			if (#associatedPrototypes >= 2)
				fp.externLinkage = "C++";
			if (usedBinding is string || usedBinding is UserString) {
				usedBinding = str usedBinding;
				for (local ptype: associatedPrototypes) {
					if (doc)
						fp.printComment(doc);
					ptype.cprintRedirectionBinding(
						fp, escapeMode, decl,
						exposedName, usedBinding);
				}
			} else {
				usedBinding.cprintFunctionBinding(
					fp, escapeMode, decl, exposedName, associatedPrototypes,
					doc, preferBindingMacros);
			}
			fp.externLinkage = oldExternLinkage;
		}
		fp.ppEndifN(numAdditionalEndifs);
		if (guardName !is none) {
			if (!isFirst)
				fp.ppElse();
			fp.ppUndef(guardName);
		}
		if (!isFirst)
			fp.ppEndif();
	}
}



class Function {
	this = default;

	public operator == (other: Function): bool -> this === other;
	public operator != (other: Function): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of the function in public headers (e.g. @"strlen")
	public member name: string | UserString;

	@@Name of the function inside of the actual library
	@@Set to @none if the function isn't actually being exported from its associated library
	public member internalName: string | UserString | none | Callable = none;

	@@Name  of the original  defining system header (may  differ from the containing
	@@header in case @"%[insert:extern(...)]" was used to inject a foreign function)
	public member originalSystemHeaderName: string | UserString;

	@@Ordered list of bindings with which this function is exposed in system headers
	@@This list is enumerated, and  the first binding who's  @FunctionBinding.ppCond
	@@field evaluates to @true will then be used as the binding exposed.
	public member bindings: {(FunctionBinding | Callable)...} | Callable = [];

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Helper wrapper for @internalName to automatically unwind callable objects
	public property internalFunctionName: string | UserString | none = {
		get(): string | UserString {
			local result = internalName;
			if (result is Callable)
				result = internalName = result();
			return result;
		}
	}

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				result = documentation = result();
			return result;
		}
	}

	@@Return  the only  prototype in use  (if only one,  common prototype is
	@@defined across all @functionBinding), or @none if multiple prototypes,
	@@or no prototypes at all have been defined
	public property onlyPrototype: FunctionPrototype | none = {
		get(): FunctionPrototype | none {
			local result = none;
			for (local binding /*: FunctionBinding*/ : functionBindings) {
				for (local none, protos /*: {FunctionPrototype...}*/ : binding.functionPrototypes) {
					for (local proto /*: FunctionPrototype*/: protos) {
						if (result is none) {
							result = proto;
						} else if (!result.compatibleWith(proto)) {
							/* Incompatible prototypes! */
							return none;
						}
					}
				}
			}
			return result;
		}
	}

	@@Similar to @onlyPrototype, but return the set of prototypes+conditions
	@@common  to   all  bindings,   or  @none   if  no   such  set   exists.
	public property onlyPrototypes: {(string | UserString, {FunctionPrototype...})...} | none = {
		get(): {(string | UserString, {FunctionPrototype...})...} | none {
			local result = none;
			for (local binding /*: FunctionBinding*/ : functionBindings) {
				local conditionalProtos = binding.functionPrototypes;
				if (result is none) {
					result = conditionalProtos;
					continue;
				}
				if (areFunctionPrototypesCompatible(result, conditionalProtos))
					continue;
				return none;
			}
			return result;
		}
	}

	@@Same as @bindings, however Callable objects will have been flattened
	public property functionBindings: {FunctionBinding...} = {
		get(): {FunctionBinding...} {
			if (m_functionBindings !is bound) {
				local usedBindings = bindings;
				if (usedBindings is Callable)
					usedBindings = usedBindings();
				local newBindings = List();
				for (local bind: usedBindings) {
					if (bind is Callable) {
						bind = bind();
						if (bind is Sequence) {
							newBindings.extend(bind);
						} else if (bind !is none) {
							newBindings.append(bind);
						}
					} else {
						newBindings.append(bind);
					}
				}
				m_functionBindings = newBindings;
				bindings           = newBindings;
				return newBindings;
			}
			return m_functionBindings;
		}
	}
	private member m_functionBindings: {FunctionBinding...};

	@@Check if @this @Function has any @bindings for imports from the given @ns
	public function hasNamespaceImportBinding(ns: Namespace): bool {
		for (local b: functionBindings) {
			b = b.functionBinding;
			if (b is NamespaceBinding && b.namespace === ns)
				return true;
		}
		return false;
	}

	@@Check if @this @Function has any fast bindings
	public property hasFastBindings: bool = {
		get(): bool {
			for (local b: functionBindings) {
				b = b.functionBinding;
				if (b is InlineFunction && b.isFastBinding)
					return true;
			}
			if (hasNamespaceImportBinding(NAMESPACES["fast"])) /* TODO: REMOVE_ME */
				return true;
			return false;
		}
	}

	public function preload() {
		try {
			documentationString;
			for (local b: functionBindings)
				b.preload();
			internalFunctionName;
		} catch (...) {
			print "... while preloading Function", repr(name);
			throw;
		}
	}

	@@Check if this function is always, never, or only dynamically available
	@@@return: true:  Always available
	@@@return: false: Never available
	@@@return: none:  Availability must be determined at compile-time
	public function getRequiresConstant(): bool | none {
		local usedBindings = functionBindings;
		if (!usedBindings)
			return false;
		local hasDynamicBindings = false;
		for (local bind: usedBindings) {
			if (bind.functionBinding is NamespaceBinding)
				continue;
			local c = bind.getRequiresConstant();
			if (c === true)
				return true;
			if (c is none)
				hasDynamicBindings = true;
		}
		if (hasDynamicBindings)
			return none;
		return false;
	}

	@@Print requires-conditions for this function (has used by @"$has_function(...)")
	public function cprintRequires(
			fp: CWriter | File,
			extendedPrefixes: List | none) {
		local usedBindings = functionBindings;
		if (!usedBindings) {
no_usable_bindings:
			fp << "0";
			return;
		}
		local hasUsableBindings = 0;
		local hasUnusableBindings = false;
		for (local bind: usedBindings) {
			if (bind.functionBinding is NamespaceBinding)
				continue;
			local c = bind.getRequiresConstant();
			if (c === true) {
				fp << "1";
				return;
			}
			if (c === false)
				hasUnusableBindings = true;
			if (c is none)
				++hasUsableBindings;
		}
		if (!hasUsableBindings)
			goto no_usable_bindings;
		if (hasUsableBindings == 1) {
			local bind;
			for (bind: usedBindings) {
				if (bind.functionBinding is NamespaceBinding)
					continue;
				if (bind.getRequiresConstant() is none)
					break;
			}
			bind.cprintRequires(fp, extendedPrefixes);
		} else {
			fp << "(";
			local isFirst = true;
			for (local bind: usedBindings) {
				if (bind.functionBinding is NamespaceBinding)
					continue;
				if (hasUnusableBindings) {
					if (bind.getRequiresConstant() === false)
						continue;
				}
				if (!isFirst)
					fp << "||";
				bind.cprintRequires(fp, extendedPrefixes);
				isFirst = false;
			}
			fp << ")";
		}
	}

	@@Print this function's normal declaration, as might be found in `<string.h>`
	@@@param: escapeMode:                One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	@@@param: decl:                      The declaration prefix (e.g. @"__LIBC") with which to link
	@@@param: exposedName:               The name under which functions should be exposed (or @none
	@@                                   if @this.name should be used instead)
	@@@param: guardName:                 The name of a guard that should be used to wrap the  declaration
	@@                                   When set to @true, use fp.namespace.keyDefaultGuard(exposedName)
	@@@param: preferBindingMacros:       Prefer function bindings to be done with macros, rather than
	@@                                   through use of inline functions.
	@@@param: printDeclarationPrefixes:  Print prototype declaration prefixes
	@@@param: onlyPrintPrimaryPrototype: Try to only bind against primary prototypes
	@@@param: ignoreNamespaceBindings:   Ignore namespace import bindings
	@@@param: ignoreFastBindings:        True if bindings with @FunctionBinding.isFastBinding should be ignored
	public function cprintHeaderDeclaration(
			fp: CWriter, escapeMode: int, decl: string = "__LIBC",
			exposedName: string = none, guardName: string | bool = none,
			preferBindingMacros: bool = false,
			printDeclarationPrefixes: bool = false,
			onlyPrintPrimaryPrototype: bool = false,
			ignoreNamespaceBindings: bool = false,
			ignoreFastBindings: bool = false,
			printDoc: bool = true) {
		try {
			local usedBindings = [];
			if (exposedName is none)
				exposedName = this.name;
			for (local b: functionBindings) {
				local bBind = b.functionBinding;
				if (bBind is InlineFunction) {
					if (ignoreFastBindings && bBind.isFastBinding)
						continue;
				} else if (bBind is NamespaceBinding) {
					if (ignoreNamespaceBindings)
						continue;
					if (bBind.namespace === fp.namespace)
						continue;
					if (bBind.importName != exposedName)
						continue;
				}
				usedBindings.append(b);
			}
			if (!usedBindings)
				return; /* No bindings -> Noop */
			local doc = documentationString;
			if (!printDoc)
				doc = "";
			if (guardName is bool) {
				guardName = guardName
					? fp.namespace.keyDefaultGuard(exposedName)
					: none;
			}
			if (printDeclarationPrefixes) {
				/* TODO: Print declaration prefixes common to all bindings,
				 *       when at least one one binding exists that can  get
				 *       bound unconditionally. */
			}
			if (guardName !is none) {
				if (#usedBindings == 1) {
					/* Try to optimize special case: Only 1 binding
					 * Instead  of  writing  something  like  this:
					 * >> #ifndef __wcslen_defined
					 * >> #define __wcslen_defined
					 * >> #if $has_function(wcslen) || defined(__std_wcslen_defined)
					 * >> __NAMESPACE_STD_USING(wcslen)
					 * >> #else // <$has_function(wcslen)> || __std_wcslen_defined
					 * >> #undef __wcslen_defined
					 * >> #endif // !<$has_function(wcslen)> && !__std_wcslen_defined
					 * >> #endif // !__wcslen_defined
					 *
					 * Write the following instead:
					 * >> #if !defined(__wcslen_defined) && (defined(__std_wcslen_defined) || $has_function(wcslen))
					 * >> #define __wcslen_defined
					 * >> __NAMESPACE_STD_USING(wcslen)
					 * >> #endif // !__wcslen_defined && (__std_wcslen_defined || $has_function(wcslen)) */
					local bind = usedBindings.first;
					/* Special case: Can't bind against a declaration from the current namespace! */
					local bindBinding = bind.functionBinding;
					local extendedPrefixes = [];
					for (local x: bind.ppCondPrefix) {
						if (!fp.wasPrefixPrinted(escapeText(x, escapeMode,
								extendedPrefixes: extendedPrefixes)))
							goto normal_guardName_binding;
					}
again_check_extendedPrefixes:
					local newExtendedPrefixes = [];
					for (local x: extendedPrefixes) {
						if (!fp.wasPrefixPrinted(escapeText(x, escapeMode,
								extendedPrefixes: newExtendedPrefixes)))
							goto normal_guardName_binding;
					}
					if (newExtendedPrefixes) {
						extendedPrefixes = newExtendedPrefixes;
						goto again_check_extendedPrefixes;
					}
					fp.ppIf(f"!defined({guardName}) && ({
						escapeText(bind.ppCond, escapeMode)
					})");
					fp.ppDefine(guardName, "");
					bind.cprintBindFunction(
						fp, escapeMode, decl, exposedName, guardName,
						doc, preferBindingMacros,
						printDeclarationPrefixes,
						onlyPrintPrimaryPrototype);
					fp.ppEndif();
					return;
				}
normal_guardName_binding:
				fp.ppIfndef(guardName);
				fp.ppDefine(guardName, "");
			} else /* if (guardName is none) */ {
				/* Check if we can use `__CDECLARE_OPT()' */
				if (#usedBindings == 1) {
					local bind: FunctionBinding = usedBindings.first;
					local bindBinding = bind.functionBinding;
					if (bindBinding is string || bindBinding is UserString) {
						bindBinding = str bindBinding;
						if (bind.ppCond == f"defined(__CRT_HAVE_{bindBinding})") {
							local bindingPrototypes: {(string | UserString, {FunctionPrototype...})...}
								= bind.functionPrototypes;
							if (#bindingPrototypes == 1) {
								local protoCond: string | UserString;
								local protos: {FunctionPrototype...};
								protoCond, protos = bindingPrototypes.first...;
								if (protoCond == "1" && #protos == 1) {
									local ptype: FunctionPrototype = protos.first;
									if (ptype.cprintRedirectionBindingUsesCDECLARE(
											fp, decl, exposedName, bindBinding)) {
										/* Use __CDECLARE_OPT() for the declaration! */
										if (doc)
											fp.printComment(doc);
										ptype.cprintCDECLARE(
											fp, escapeMode, decl, exposedName,
											optSuffix: true);
										return;
									}
								}
							}
						}
					}
				} /* if (#usedBindings == 1) */
			} /* if (guardName is none) */
			local isFirst = true;
			local numNeededEndif = [];
			for (local bind: usedBindings) {
				/* Special case: Can't bind against a declaration from the current namespace! */
				local bindBinding = bind.functionBinding;
				local extendedPrefixes = [];
				local newExtendedPrefixes = [];
				local usedPpCond = escapeText(
					bind.ppCond, escapeMode, extendedPrefixes: newExtendedPrefixes);
				local oldNs: Namespace | none = none;
				local oldExternLinkage;
				local extendedPrefixes = bind.ppCondPrefix;
handle_extendedPrefixes:
				for (local text: extendedPrefixes) {
					text = str(escapeText(text, escapeMode,
						extendedPrefixes: newExtendedPrefixes))
						.rstrip().lstrip("\n");
					if (fp._wasPrefixPrinted(text))
						continue;
					if (oldNs is none) {
						if (!isFirst) {
							fp.ppElse();
							numNeededEndif.last = false;
						}
						/* Include the preprocessor-condition prefix texts. */
						oldExternLinkage = fp.externLinkage;
						if (oldExternLinkage !in ["", "C"])
							fp.externLinkage = "";
						oldNs = fp.namespace;
						fp.namespace = GLOBAL_NAMESPACE;
					}
					fp.forceStartOfLine() << text << "\n";
					fp._rememberPrefixAlreadyPrinted(text);
				}
				if (newExtendedPrefixes) {
					extendedPrefixes = newExtendedPrefixes;
					newExtendedPrefixes = [];
					goto handle_extendedPrefixes;
				}
				if (oldNs !is none) {
					fp.namespace = oldNs;
					fp.externLinkage = oldExternLinkage;
					fp.ppIf(usedPpCond);
					numNeededEndif.pushback(true);
				} else if (isFirst) {
					fp.ppIf(usedPpCond);
					numNeededEndif.pushback(true);
				} else {
					fp.ppElif(usedPpCond);
				}
				bind.cprintBindFunction(
					fp, escapeMode, decl, exposedName, guardName,
					doc, preferBindingMacros,
					printDeclarationPrefixes,
					onlyPrintPrimaryPrototype);
				isFirst = false;
			}
			while (numNeededEndif) {
				local l = numNeededEndif.popback();
				if (l && guardName !is none) {
					fp.ppElse();
					fp.ppUndef(guardName);
				}
				fp.ppEndif();
			}
			if (guardName !is none)
				fp.ppEndif();
		} catch (...) {
			print "... while printing header declaration for",
				repr(this.name), "as", repr(exposedName);
			throw;
		}
	}

}


@@An optional wrapper for exposing a @Function within headers
class ExposedFunction {
	this = default;

	@@The associated function
	public member func: Function | Callable;

	@@Declaration prefix for this function exposure
	public member decl: string = "__LIBC";

	@@The actual, exposed name of the function (or @none to use @func.name instead)
	public member exposedName: string = none;

	@@The  name  of a  guard that  should  be used  to wrap
	@@the declaration. Set to @false to not provide a guard
	@@NOTE: When set to @true, use fp.namespace.keyDefaultGuard(exposedName)
	public member guardName: string | bool = false;

	@@Prefer function bindings to be done with macros,
	@@rather  than  through use  of  inline functions.
	public member preferBindingMacros: bool = false;

	@@Print @FunctionPrototype.declPrefix
	public member printDeclarationPrefixes: bool = false;

	@@Only bind against @FunctionBinding.primaryPrototype (but fall back to binding
	@@against   all  prototypes  if  no  @FunctionBinding.primaryPrototype  exists)
	public member onlyPrintPrimaryPrototype: bool = false;

	@@Don't bind against @NamespaceBinding
	public member ignoreNamespaceBindings: bool = false;

	@@An override for the active namespace during function declaration
	public member namespaceOverride: Namespace | UserString | string | none = none;

	@@An override for the active `extern "<externLinkage>"` during function declaration
	public member externLinkageOverride: string | none = none;

	@@Wrapper for @func
	public property exposedFunc: Function = {
		get(): Function {
			local result = func;
			if (result is Callable)
				result = func = result();
			return result;
		}
	}

	public function preload() {
		try {
			exposedFunc.preload();
		} catch (...) {
			print "... while preloading ExposedFunction",
				repr(func is Function ? func.name : none),
				"as", repr(exposedName);
			throw;
		}
	}

	@@Print this function's normal declaration, as might be found in `<string.h>`
	@@@param: escapeMode: One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
	public function cprintHeaderDeclaration(fp: CWriter, escapeMode: int) {
		local oldNs = fp.namespace;
		local oldExternLinkage = fp.externLinkage;
		if (namespaceOverride !is none) {
			if (oldNs !== namespaceOverride) {
				if (oldExternLinkage != "")
					fp.externLinkage = "";
			}
			fp.namespace = namespaceOverride;
		}
		if (externLinkageOverride !is none)
			fp.externLinkage = externLinkageOverride;
		exposedFunc.cprintHeaderDeclaration(
			fp, escapeMode, decl, exposedName,
			guardName, preferBindingMacros,
			printDeclarationPrefixes,
			onlyPrintPrimaryPrototype,
			ignoreNamespaceBindings);
		if (fp.externLinkage != oldExternLinkage) {
			if (fp.namespace !== oldNs) {
				if (fp.externLinkage != "")
					fp.externLinkage = "";
				fp.namespace     = oldNs;
				fp.externLinkage = oldExternLinkage;
			} else {
				fp.externLinkage = oldExternLinkage;
			}
		} else {
			fp.namespace = oldNs;
		}
	}

}




class LibraryFunctionBinding {
	this = default;

	@@Preprocessor  condition  that  must be  evaluate  to true  at  compile-time in
	@@order for this implementation to be considered usable by the hosting compiler.
	public member ppCond: string | UserString = "1";

	@@Binding,   which   is  either   a  @FunctionImplementation,
	@@specifying how the function should actually be implemented,
	@@or is the symbol name of some other function for which this
	@@one should be defined as an INTERN-ALIAS
	public member binding: FunctionImplementation | MacroBinding | string | UserString | Callable;

	@@Name  of  the section  in which  this  function's body  should be
	@@placed in order to provide the libc auto- or user-implementations
	@@NOTE: Ignored when binding isn't a @FunctionImplementation
	public member implSection: string | UserString | none = none;

	@@Some extra attributes to inject into the in-library implementation
	public member extraAttributes: {string | UserString...} | none = none;

	@@Returns @binding, but unwind @Callable wrappers
	public property functionBinding: FunctionImplementation | string | UserString = {
		get(): FunctionImplementation | string | UserString {
			local result = binding;
			if (result is Callable)
				result = binding = result();
			return result;
		}
	}

	public function preload() {
		functionBinding.preload();
	}

}

class LibraryFunction {
	this = default;

	public operator == (other: LibraryFunction): bool -> this === other;
	public operator != (other: LibraryFunction): bool -> this !== other;
	public operator hash (): int -> Object.id(this);

	@@Name of the function in public headers (e.g. @"libc_strlen")
	public member name: string | UserString;

	@@Preprocessor condition that must be evaluate to true at compile-time
	@@in  order  for this  library  function to  actually  be implemented.
	public member ppCond: string | UserString;

	@@Name  of the original  defining system header (may  differ from the containing
	@@header in case @"%[insert:extern(...)]" was used to inject a foreign function)
	public member originalSystemHeaderName: string | UserString;

	@@The documentation text of this function
	public member documentation: string | UserString | Callable = "";

	@@Prototype used for the library implementation
	public member prototype: FunctionPrototype | Callable;

	@@The different ways by which this library function can be implemented.
	public member bindings: {(LibraryFunctionBinding | Callable)...} | Callable = [];

	@@Pairs of @(ppCond, symbolName) of how @this Binding should be exported from the library.
	public member exportSymbolNames: {(string | UserString, string | UserString)...} = [];

	@@The preprocessor-condition that must be met for @this @LibraryFunction
	@@to actually  be  implemented  as  part of  its  auto-  or  user-source
	@@This condition is essentially:
	@@    @(this.ppCond && (functionBindings.each.ppCond || ...))
	public property implementationPpCond: string = {
		get(): string {
			local ppCond = str(this.ppCond);
			if (ppCond == "0")
				return "0";
			local hasUniversalBinding = false;
			for (local b: functionBindings) {
				if (b.binding is MacroBinding)
					break;
				if (b.ppCond == "1") {
					hasUniversalBinding = true;
					break;
				}
			}
			if (hasUniversalBinding)
				return ppCond;
			local bindingConditions = [];
			for (local b: functionBindings) {
				if (b.ppCond == "0")
					continue;
				if (b.binding is MacroBinding) {
					/* Macro bindings suppress normal implementations */
					bindingConditions.append(f"(!({b.ppCond}))");
				} else {
					bindingConditions.append(f"({b.ppCond})");
				}
			}
			bindingConditions = "||".join(bindingConditions);
			if (!bindingConditions)
				return "0";
			if (ppCond != "1")
				bindingConditions = f"({ppCond})&&({bindingConditions})";
			return bindingConditions;
		}
	}

	@@The preprocessor-condition that must be met for @this @LibraryFunction
	@@to actually be implemented somewhere within libc:
	public property isImplementedPpCond: string = {
		get(): string {
			local conditions = [str(this.ppCond)];
			for (local b: functionBindings) {
				/* Macro bindings can be used to suppress libc implementations */
				if (b.binding is MacroBinding)
					conditions.append(f"!({b.ppCond})");
			}
			return "&&".join(conditions);
		}
	}

	@@Helper wrapper for @documentation to automatically unwind callable objects
	public property documentationString: string | UserString = {
		get(): string | UserString {
			local result = documentation;
			if (result is Callable)
				result = documentation = result();
			return result;
		}
	}

	@@Helper wrapper for @prototype to automatically unwind callable objects
	public property functionPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = prototype;
			if (result is Callable)
				result = prototype = result();
			return result;
		}
	}

	@@Helper wrapper for @bindings that automates invocation of Callable objects
	public property functionBindings: {LibraryFunctionBinding...} = {
		get(): {LibraryFunctionBinding...} {
			if (m_functionBindings !is bound) {
				local usedBindings = bindings;
				if (usedBindings is Callable)
					usedBindings = usedBindings();
				local newBindings = [];
				for (local b: usedBindings) {
					if (b is Callable)
						b = b();
					if (b is Sequence) {
						newBindings.extend(b);
					} else if (b !is none) {
						newBindings.append(b);
					}
				}
				m_functionBindings = newBindings;
				bindings           = newBindings;
				return newBindings;
			}
			return m_functionBindings;
		}
	}
	private member m_functionBindings: {LibraryFunctionBinding...};

	public function preload() {
		documentationString;
		functionPrototype;
		for (local b: functionBindings)
			b.preload();
	}

	@@Print the in-library declaration of this function
	public function cprintInLibraryDeclaration(
			fp: CWriter, escapeMode: int, decl: string) {
		local usedBindings = functionBindings;
		if (!usedBindings)
			return;
		if (ppCond == "0")
			return;
		CWriter_ppIfEscaped(fp, ppCond, escapeMode);
		local doc = documentationString;

		/* Special handling for macro-bindings (those also get bound here) */
		local numExtraEndIfs = 0;
		for (local functionBinding: usedBindings) {
			local binding = functionBinding.binding;
			if (binding is MacroBinding) {
				if (numExtraEndIfs == 0) {
					CWriter_ppIfEscaped(fp, functionBinding.ppCond, escapeMode);
					numExtraEndIfs = 1;
				} else {
					if (CWriter_ppElifEscaped(fp, functionBinding.ppCond, escapeMode))
						++numExtraEndIfs;
				}
				binding.cprintMacroBinding(
					fp, escapeMode, exposedName: this.name,
					prototype: this.functionPrototype, doc: doc);
			}
		}

		if (numExtraEndIfs)
			fp.ppElse();
		if (doc)
			fp.printComment(doc);
		this.functionPrototype.cprintDeclarationWithoutTerminator(
			fp, escapeMode, decl: decl, exposedName: this.name);
		fp << ";\n";
		while (numExtraEndIfs) {
			fp.ppEndif();
			--numExtraEndIfs;
		}
		fp.ppEndif();
	}

	@@Print the in-library auto-implementation of this function
	public function cprintInLibraryAutoImplementation(
			fp: CWriter, escapeMode: int, decl: string) {
		try {
			local usedBindings = functionBindings;
			if (!usedBindings)
				return;
			CWriter_ppIfEscaped(fp, ppCond, escapeMode);
			local isFirst = true;
			local doc = documentationString;
			local proto = functionPrototype;
			local numAdditionalEndifs = 0;
			for (local bind /*: LibraryFunctionBinding*/: usedBindings) {
				if (isFirst) {
					CWriter_ppIfEscaped(fp, bind.ppCond, escapeMode);
					isFirst = false;
				} else {
					if (!CWriter_ppElifEscaped(fp, bind.ppCond, escapeMode))
						++numAdditionalEndifs;
				}
				local impl: FunctionImplementation |
				            string |
				            UserString |
				            MacroBinding
						= bind.functionBinding;
				if (impl is FunctionImplementation) {
					local deps: {string: Function} = impl.dependencyFunctions;
					local keyEscape = (keyword: string): string -> {
						if (keyword == impl.name)
							return this.name;
						local depFun = deps.get(keyword);
						if (depFun !is none) {
							local intName = depFun.internalFunctionName;
							if (intName !is none)
								return intName;
						}
						return none;
					};
					for (local x: impl.implPrefix) {
						escapeNonRepeatingTextIntoFile(
							fp, x, escapeMode,
							keyEscape: keyEscape,
							forceKeyEscape: true);
					}
					if (doc)
						fp.printComment(doc);
					local extraAttributes = bind.extraAttributes;
					if (bind.implSection !is none) {
						if (extraAttributes is none)
							extraAttributes = ();
						extraAttributes = List(extraAttributes);
						extraAttributes.append(f"ATTR_SECTION({repr bind.implSection})");
					}
					proto.cprintDeclarationWithoutTerminator(
						fp, escapeMode,
						decl:                 decl,
						exposedName:          this.name,
						injectedAttributes:   extraAttributes,
						breakAfterReturnType: true,
						oneArgumentPerLine:   true);
					fp << " ";
					escapeTextIntoFile(
						fp, impl.body, escapeMode,
						keyEscape: keyEscape,
						forceKeyEscape: true);
					fp << "\n";
				} else if (impl is MacroBinding) {
					/* Don't generate code for this case! */
				} else {
					fp << "DEFINE_" << decl << "_ALIAS("
						<< this.name << ", "
						<< impl << ");\n";
				}
			}
			fp.ppEndifN(numAdditionalEndifs);
			if (!isFirst)
				fp.ppEndif();
			fp.ppEndif();
		} catch (...) {
			print("... while printing in-library auto implementation for ",
				repr(this.name));
			throw;
		}
	}

	@@Print the in-library export table of this function
	public function cprintInLibraryExports(fp: CWriter, escapeMode: int) {
		local hasUsableExport = false;
		for (local ppCond, none: exportSymbolNames) {
			if (ppCond != "0") {
				hasUsableExport = true;
				break;
			}
		}
		if (!hasUsableExport)
			return;
		local usedBindings = functionBindings;
		CWriter_ppIfEscaped(fp, ppCond, escapeMode);
		local hasUniversalBinding = false;
		for (local bind: usedBindings) {
			if (bind.ppCond == "1") {
				hasUniversalBinding = true;
				break;
			}
		}
		if (!hasUniversalBinding) {
			File.Writer mergedCond;
			local isFirst = true;
			for (local bind: usedBindings) {
				if (!isFirst)
					mergedCond << "||";
				mergedCond << "(" << bind.ppCond << ")";
				isFirst = false;
			}
			CWriter_ppIfEscaped(fp, mergedCond.string, escapeMode);
		}
		for (local ppCond, symbolName: exportSymbolNames) {
			CWriter_ppIfEscaped(fp, ppCond, escapeMode);
			if (!symbolName.issymbol())
				symbolName = repr(symbolName);
			fp << "DEFINE_PUBLIC_ALIAS(" << symbolName << ", " << this.name << ");\n";
			fp.ppEndif();
		}
		if (!hasUniversalBinding)
			fp.ppEndif();
		fp.ppEndif();
	}
}



class SystemHeader {
	this = default;

	@@Name of @this system header (e.g. @"sys.stat" for <sys/stat.h>)
	public member name: string;

	@@Functions declared in this system header
	@@If a function is declared multiple times under the same name,
	@@it will appear  as @DuplicateFunctionMarker  in this  mapping
	public member functionsByName: {string: (Function | _DuplicateFunctionMarker)} = Dict();

	@@Same as @functionsByName, but for local functions
	@@Duplicate entries aren't allowed
	public member localFunctionsByName: {string: LocalFunction} = Dict();

	public function preload() {
		for (local none, f: functionsByName) {
			if (f === DuplicateFunctionMarker)
				continue;
			f.preload();
		}
		for (local none, f: localFunctionsByName)
			f.preload();
	}

	@@Output order of <string.h> (when empty, don't generate that header)
	@@This is one of:
	@@  - @Function:            Call @Function.cprintHeaderDeclaration(fp, escapeMode) (other arguments are defaulted)
	@@  - @ExposedFunction:     Call @ExposedFunction.cprintHeaderDeclaration(fp, escapeMode)
	@@  - @string, @UserString: Insert the string as-is
	@@  - @Callable:            Invoke @Callable(fp, escapeMode)
	public member order_header: {(Function | ExposedFunction | string | UserString | Callable)...} = [];

	@@Output order of <libc/string.h> (when empty, don't generate that file)
	public member order_libcHeader: {(Function | string | UserString)...} = [];

	@@Output order of <libc/core/string.h> (when empty, don't generate that file)
	public member order_libcCoreHeader: {(Function | string | UserString)...} = [];

	@@Output order of /src/libc/auto/string.h (when empty, don't generate that file)
	public member order_libcAutoHeader: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/auto/string.c (when empty, don't generate that file)
	public member order_libcAutoSource: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/libc/dosabi-*.h (when empty, don't generate that file)
	public member order_libcDosabiSource: {LibraryFunction...} = [];

	@@Output order of /src/libc/user/string.h (when empty, don't generate that file)
	public member order_libcUserHeader: {(LibraryFunction | string | UserString)...} = [];

	@@Output order of /src/libc/user/string.c (when empty, don't generate that file)
	public member order_libcUserSource: {LibraryFunction...} = [];

	@@Print the contents of the exposed header (such as `<string.h>`),
	@@excluding the leading COPYRIGHT
	public function cprintHeader(fp: CWriter, escapeMode: int) {
		for (local part: order_header) {
			if (part is Function || part is ExposedFunction) {
				part.cprintHeaderDeclaration(fp, escapeMode);
			} else if (part is Callable) {
				part(fp, escapeMode);
			} else {
				fp << part;
			}
		}
	}

	@@Print the header <libc/string.h>
	public function cprintLibcHeader(fp: CWriter) {
		local nsFast = NAMESPACES["fast"];
		local guardName = f"_LIBC_{name.replace("-", "_").replace(".", "_").upper()}_H";
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n" /* This "1" must stay for compat */
			"\n"
			"#include <__stdinc.h>\n"
			"\n"
			"#ifdef __CC__\n"
			"#include <__crt.h>\n";
		for (local part: order_libcHeader) {
			if (part !is Function)
				continue;
			if (part.hasFastBindings) {
				fp << "#ifdef __LIBC_BIND_OPTIMIZATIONS\n"
					"#include <optimized/" << name << ".h>\n"
					"#endif /* __LIBC_BIND_OPTIMIZATIONS */\n";
				break;
			}
		}
		fp << "#include \"core/" << name << ".h\"\n"
			"\n";
		for (local part: order_libcHeader) {
			if (part !is Function) {
				fp << part;
				continue;
			}
			local rc = part.getRequiresConstant();
			if (rc === false)
				continue;
			local partName = part.name;
			local partDoc  = part.documentationString;
			local partFast = part.hasFastBindings;
			if (rc is none) {
				/* Conditionally link against some guard. */
				local coreGuardName = f"____libc_core_{partName}_defined";
				local myGuardName = f"____libc_{partName}_defined";
				if (partFast) {
					fp << "#ifndef " << myGuardName << "\n"
						"#ifdef __fast_" << partName << "_defined\n"
						"#define " << myGuardName << "\n"
						"#define __libc_" << partName << " ("
							<< nsFast.prefix << " "
							<< nsFast.keyCSymbolName(partName) << ")\n"
						"#elif defined(" << coreGuardName << ")\n"
						"#define " << myGuardName << "\n"
						"#define __libc_" << partName << " __libc_core_" << partName << "\n"
						"#endif /* ... */\n"
						"#endif /* !" << myGuardName << " */\n";
				} else {
					fp << "#if !defined(" << myGuardName << ") && defined(" << coreGuardName << ")\n"
						"#define " << myGuardName << "\n"
						"#define __libc_" << partName << " __libc_core_" << partName << "\n"
						"#endif /* !" << myGuardName << " && " << coreGuardName << " */\n";
				}
			} else {
				if (partFast) {
					fp << "#ifdef __fast_" << partName << "_defined\n";
					if (partDoc)
						fp.printComment(partDoc);
					fp << "#define __libc_" << partName << " ("
						<< nsFast.prefix << " "
						<< nsFast.keyCSymbolName(partName) << ")\n"
						<< "#else /* __fast_" << partName << "_defined */\n";
				}
				if (partDoc)
					fp.printComment(partDoc);
				fp << "#define __libc_" << partName << " __libc_core_" << partName << "\n";
				if (partFast)
					fp << "#endif /* !__fast_" << partName << "_defined */\n";
			}
		}
		fp << "\n"
			"#endif /* __CC__ */\n"
			"\n"
			"#endif /* !" << guardName << " */\n";
	}

	@@Print the header <libc/core/string.h>
	public function cprintLibcCoreHeader(fp: CWriter) {
		for (local part: order_libcHeader) {
			if (part !is Function)
				continue;
		}
		local guardName = f"_LIBC_CORE_{name.replace("-", "_").replace(".", "_").upper()}_H";
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n" /* This "1" must stay for compat */
			"\n"
			"#include <__stdinc.h>\n"
			"\n"
			"#ifdef __CC__\n"
			"#include <__crt.h>\n"
			"#include <hybrid/typecore.h>\n"
			"\n"
			"__SYSDECL_BEGIN\n"
			"\n";
		for (local part: order_libcHeader) {
			if (part !is Function)
				continue;
			local rc = part.getRequiresConstant();
			if (rc === false)
				continue;
			local guardName = none;
			local exposedName = "__libc_core_" + part.name;
			if (rc is none)
				guardName = f"__{exposedName}_defined";
			part.cprintHeaderDeclaration(
				fp, ESCAPE_MODE_FULL, "__LIBC",
				exposedName:               exposedName,
				guardName:                 guardName,
				preferBindingMacros:       true,
				printDeclarationPrefixes:  true,
				onlyPrintPrimaryPrototype: true,
				ignoreNamespaceBindings:   true,
				ignoreFastBindings:        true);
		}
		fp << "\n"
			"__SYSDECL_END\n"
			"\n"
			"#endif /* __CC__ */\n"
			"\n"
			"#endif /* !" << guardName << " */\n";
	}

	private function cprintInternalLibraryHeader(fp: CWriter, isAuto: bool) {
		local guardName = f"GUARD_LIBC_{isAuto ? "AUTO" : "USER"}_{
			name.replace("-", "_").replace(".", "_").upper()
		}_H";
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n" /* This "1" must stay for compat */
			"\n"
			"#include \"../api.h\"\n";
		if (!isAuto && order_libcAutoHeader)
			fp << "#include \"../auto/" << name << ".h\"\n";
		fp << "\n"
			"#include <hybrid/typecore.h>\n"
			"#include <kos/types.h>\n"
			"#include <" << name.replace(".", "/") << ".h>\n"
			"\n"
			"DECL_BEGIN\n"
			"\n";
		for (local part: isAuto ? order_libcAutoHeader : order_libcUserHeader) {
			if (part is LibraryFunction) {
				part.cprintInLibraryDeclaration(fp, ESCAPE_MODE_NONE, "INTDEF");
			} else {
				fp << part;
			}
		}
		fp << "\n"
			"DECL_END\n"
			"\n"
			"#endif /* !" << guardName << " */\n";
	}

	@@Print the header /kos/src/libc/auto/string.h
	public function cprintLibraryAutoHeader(fp: CWriter) {
		return cprintInternalLibraryHeader(fp, true);
	}

	@@Print the implementations from /kos/src/libc/auto/string.c
	public function cprintLibraryAutoSource(fp: CWriter) {
		local guardName = f"GUARD_LIBC_AUTO_{
			name.replace("-", "_").replace(".", "_").upper()}_C";
		fp << "#ifndef " << guardName << "\n"
			"#define " << guardName << " 1\n" /* This "1" must stay for compat */
			"\n"
			"#include \"../api.h\"\n"
			"#include <hybrid/typecore.h>\n"
			"#include <kos/types.h>\n"
			"#include \"";
		if (order_libcUserHeader)
			fp << "../user/";
		fp << name << ".h\"\n";
		local dependentFunctionHeaders: {string: {string...}} = Dict();
		/* Gather declaring headers of all dependent functions */
		for (local part: order_libcAutoSource) {
			if (part !is LibraryFunction)
				continue;
			for (local binding /*: LibraryFunctionBinding*/: part.functionBindings) {
				local b = binding.functionBinding;
				if (b !is FunctionImplementation)
					continue;
				local bindingDeps: {string: Function} = b.dependencyFunctions;
				if (!bindingDeps)
					continue;
				local condStr = str(binding.ppCond);
				local deps: {string...} = dependentFunctionHeaders.get(condStr);
				if (deps is none)
					deps = dependentFunctionHeaders[condStr] = HashSet();
				for (local none, func: bindingDeps) {
					try {
						local intName = func.internalFunctionName;
						if (intName is none)
							continue; /* No internal name override! */
						deps.insert(allLibraryFunctionsByName[intName]
							.originalSystemHeaderName);
					} catch (...) {
						print("... while scanning dependency ",
							repr(func.name), " of function ",
							repr(part.name));
						throw;
					}
				}
			}
		}
		/* Include declaration headers of all dependent functions */
		for (local cond: dependentFunctionHeaders.keys.sorted()) {
			CWriter_ppIfEscaped(fp, cond, ESCAPE_MODE_NONE);
			for (local hdr: dependentFunctionHeaders[cond].sorted()) {
				local shdr: SystemHeader = allSystemHeaders[hdr];
				if (shdr === this)
					continue; /* Not needed! */
				if (shdr.order_libcUserHeader) {
					hdr = f'"../user/{hdr}.h"';
				} else {
					hdr = f'"{hdr}.h"';
				}
				fp.ppInclude(hdr);
			}
			fp.ppEndif();
		}
		/* Go through all functions once again, and print their implementations */
		fp << "\n"
			"DECL_BEGIN\n"
			"\n";
		for (local part: order_libcAutoSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryAutoImplementation(fp, ESCAPE_MODE_NONE, decl: "INTERN");
			} else {
				fp << part;
			}
		}
		fp << "\n"
			"DECL_END\n"
			"\n";
		/* Print out the symbol export table. */
		for (local part: order_libcAutoSource) {
			if (part !is LibraryFunction)
				continue;
			if (!part.exportSymbolNames)
				continue;
			CWriter_ppIfEscaped(fp, part.implementationPpCond, ESCAPE_MODE_NONE);
			for (local ppCond, asmname: part.exportSymbolNames) {
				CWriter_ppIfEscaped(fp, ppCond, ESCAPE_MODE_NONE);
				if (!asmname.issymbol())
					asmname = repr(asmname);
				fp << "DEFINE_PUBLIC_ALIAS("
					<< asmname << ", " << part.name << ");\n";
				fp.ppEndif();
			}
			fp.ppEndif();
		}
		fp << "\n"
			"#endif /* !" << guardName << " */\n";
	}

	@@Print the export table from /kos/src/libc/auto/string.c
	public function cprintLibraryAutoSourceExports(fp: CWriter) {
		for (local part: order_libcAutoSource) {
			if (part is LibraryFunction) {
				part.cprintInLibraryExports(fp, ESCAPE_MODE_NONE);
			} else {
				fp << part;
			}
		}
	}

	@@Print the header /kos/src/libc/user/string.h
	public function cprintLibraryUserHeader(fp: CWriter) {
		return cprintInternalLibraryHeader(fp, false);
	}

	@@Print the export table from /kos/src/libc/user/string.c
	public function cprintLibraryUserSourceExports(
			fp: CWriter, skippedFunctionNames: {string...} = none) {
		for (local part /*: LibraryFunction*/ : order_libcUserSource) {
			if (part.name in skippedFunctionNames)
				continue;
			part.cprintInLibraryExports(fp, ESCAPE_MODE_NONE);
		}
	}
}
