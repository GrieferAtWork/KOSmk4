/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .namespace;
import * from ..optiexpr;
import * from collections;
import functools;

#define UserString Object  /* UserString from .parser */
global CWriter;

/* CGenerator part IDs */
global final CGP_STRING      = 0; /* +string | +File.Writer */
global final CGP_IF          = 1; /* +string */
global final CGP_ELIF        = 2; /* +string */
global final CGP_ELSE        = 3; /* +string */
global final CGP_ENDIF       = 4; /* +string */
global final CGP_NSENTER     = 5; /* +Namespace */
global final CGP_NSLEAVE     = 6; /* +Namespace */
global final CGP_FORCENL     = 7; /* +none */
global final CGP_EXTERNENTER = 8; /* +string */
global final CGP_EXTERNLEAVE = 9; /* +string */

@@All generator part ids that always end with a new-line
global final CGPS_FORCENL: {int...} = {
	CGP_IF, CGP_ELIF, CGP_ELSE, CGP_ENDIF,
	CGP_NSENTER, CGP_NSLEAVE, CGP_FORCENL,
	CGP_EXTERNENTER, CGP_EXTERNLEAVE
};

@@C Code generator
@@This class performs optimizations to delete unnecessary preprocessor
@@open/close directives such as:
@@> #ifndef __KERNEL__
@@> DEFINE_PUBLIC_ALIAS(DOS$wmemcpy, libd_wmemcpy);
@@> #endif /* !__KERNEL__ */
@@> #ifndef __KERNEL__
@@> DEFINE_PUBLIC_ALIAS(wmemcpy, libc_wmemcpy);
@@> #endif /* !__KERNEL__ */
@@Which will instead be printed as:
@@> #ifndef __KERNEL__
@@> DEFINE_PUBLIC_ALIAS(DOS$wmemcpy, libd_wmemcpy);
@@> DEFINE_PUBLIC_ALIAS(wmemcpy, libc_wmemcpy);
@@> #endif /* !__KERNEL__ */
class CGenerator {
	this = default;

	@@The underlying file to which to output generated text
	public member fp: File;

	@@Set to @true if the last thing written to @fp was a new-line character
	@@Also set to @true upon construction (i.e. for our purposes, the start of
	@@a file is assumed to begin with a new-line character)
	public member fpAfterNewline: bool = true;

	@@List of pending components
	@@This is a list of @(CGP_*, arg), where @arg depends on the type code
	public member pendingParts: {(int, Object)...} = [];

	@@Return a file printer with which simple strings can be appened
	@@Note that after any of the other add* functions are called, this
	@@property must be re-read to obtain a new printer!
	public property addPrinter: File = {
		get(): File {
			local result;
			if (pendingParts) {
				local last = pendingParts.last;
				if (last[0] == CGP_STRING) {
					result = last[1];
					if (result is File.Writer)
						return result;
				}
			} else {
				/* XXX: Let the caller write to @fp directly?
				 *      Though we would still have to keep
				 *      track of @fpAfterNewline */
			}
			result = File.Writer();
			pendingParts.append((CGP_STRING, result));
			return result;
		}
	}

	@@Optimize a potential trailing string parts
	private function optimizeTrailingStrings() {
		if (pendingParts) {
			local last = pendingParts.last;
			if (last[0] == CGP_STRING) {
				local s = last[1];
				if (s is File.Writer) {
					s                 = s.string;
					pendingParts.last = (CGP_STRING, s);
				}
				if (!s)
					pendingParts.popback();
			}
		}
	}

	@@Delete a possible trailing CGP_FORCENL
	private function deleteTrailingForceNl() {
		if (pendingParts && pendingParts.last[0] == CGP_FORCENL)
			pendingParts.popback();
	}

	/* Helper functions for appending certain components */
	public function addPpIf(cond: string): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		if (#pendingParts >= 2) {
			local i = none;
			local prevPartType = pendingParts.last[0];
			if (prevPartType == CGP_FORCENL) {
				i = #pendingParts - 2;
				prevPartType = pendingParts[i][0];
				--i;
			}
			if (prevPartType == CGP_ENDIF) {
				if (i is none)
					i = #pendingParts - 2;
				local recursion = 0;
				for (;;) {
					prevPartType = pendingParts[i][0];
					if (prevPartType in [CGP_ELSE, CGP_ELIF]) {
						if (recursion == 0)
							goto do_append;
					} else if (prevPartType == CGP_ENDIF) {
						++recursion;
					} else if (prevPartType == CGP_IF) {
						if (recursion) {
							--recursion;
						} else {
							if (pendingParts[i][1] != cond)
								goto do_append;
							/* Optimize:
							 * >> #if FOO
							 * >> A
							 * >> #endif
							 * >> #if FOO
							 * >> B
							 * Into:
							 * >> #if FOO
							 * >> A
							 * >> B */
							pendingParts.popback();
							goto done;
						}
					}
					if (!i)
						break;
					--i;
				}
			}
		}
do_append:
		pendingParts.append((CGP_IF, cond));
done:
		return this;
	}

	public function addPpElif(cond: string): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		if (pendingParts) {
			local lastPart = pendingParts.last;
			if (lastPart[0] in [CGP_IF, CGP_ELIF]) {
				/* Optimize:
				 * >> #if FOO
				 * >> #elif BAR
				 * >> ...
				 * Into:
				 * >> #if !FOO && BAR
				 * >> ... */
				pendingParts.popback();
				cond = optimizePreprocessorExpression("!({}) && ({})"
					.format({ lastPart[1], cond }));
				pendingParts.append((lastPart[0], cond));
				return this;
			}
		}
		pendingParts.append((CGP_ELIF, cond));
		return this;
	}

	public function addPpElse(comment: string): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		if (pendingParts) {
			local lastPart = pendingParts.last;
			if (lastPart[0] in [CGP_IF, CGP_ELIF]) {
				/* Optimize:
				 * >> #if FOO
				 * >> #else
				 * >> ...
				 * Into:
				 * >> #if !FOO
				 * >> ... */
				pendingParts.popback();
				local cond = optimizePreprocessorExpression("!({})"
					.format({ lastPart[1] }));
				pendingParts.append((lastPart[0], cond));
				return this;
			}
		}
		pendingParts.append((CGP_ELSE, comment));
		return this;
	}

	public function addPpEndif(comment: string): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		/* Optimize away if the preceding block was entirely empty.
		 * i.e. the last-written part was a CGP_IF */
		if (pendingParts) {
			local lastPart = pendingParts.last;
			if (lastPart[0] == CGP_IF) {
				pendingParts.popback();
				return this;
			} else if (lastPart[0] == CGP_ELIF) {
				/* Delete the preceding ELIF, but will write the follow-up ENDIF */
				pendingParts.popback();
			} else if (lastPart[0] == CGP_ELSE) {
				/* Same as with ELIF, but inherit the comment from the ELSE-block */
				pendingParts.popback();
				comment = lastPart[1];
			}
		}
		pendingParts.append((CGP_ENDIF, comment));
		return this;
	}

	public function addNsEnter(ns: Namespace): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		if (ns === GLOBAL_NAMESPACE)
			goto done;
		if (pendingParts) {
			local last = pendingParts.last;
			if (last[0] == CGP_NSLEAVE && last[1] === ns) {
				pendingParts.popback();
				goto done;
			}
		}
		pendingParts.append((CGP_NSENTER, ns));
done:
		return this;
	}

	public function addNsLeave(ns: Namespace): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		if (ns === GLOBAL_NAMESPACE)
			goto done;
		if (pendingParts) {
			local last = pendingParts.last;
			if (last[0] == CGP_NSENTER && last[1] === ns) {
				pendingParts.popback();
				goto done;
			}
		}
		pendingParts.append((CGP_NSLEAVE, ns));
done:
		return this;
	}

	public function addExternEnter(kind: string): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		if (pendingParts && pendingParts.last == (CGP_EXTERNLEAVE, kind)) {
			pendingParts.popback();
			goto done;
		}
		pendingParts.append((CGP_EXTERNENTER, kind));
done:
		return this;
	}

	public function addExternLeave(kind: string): CGenerator {
		deleteTrailingForceNl();
		optimizeTrailingStrings();
		if (pendingParts && pendingParts.last == (CGP_EXTERNENTER, kind)) {
			pendingParts.popback();
			goto done;
		}
		pendingParts.append((CGP_EXTERNLEAVE, kind));
done:
		return this;
	}

	public function addForceNl(): bool {
		optimizeTrailingStrings();
		if (pendingParts) {
			local last = pendingParts.last;
			local typ = last[0];
			if (typ in CGPS_FORCENL)
				goto nope;
			if (typ == CGP_STRING && str(last[1]).endswith("\n"))
				goto nope;
		}
		pendingParts.append((CGP_FORCENL, none));
		return true;
nope:
		return false;
	}


	@@Flush all @pendingParts to be printed to @fp
	public function flush() {
		optimizeTrailingStrings();
		local fp = this.fp;
		for (local code, arg: pendingParts) {
			switch (code) {

			default:
				if (arg is File.Writer)
					arg = arg.string;
				if (arg) {
					fp << arg;
					fpAfterNewline = arg.endswith("\n");
				}
				break;

			case CGP_IF:
				arg = str arg;
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				/* Try to optimize into #ifdef and #ifndef */
				if (arg.startswith("defined(") && arg.endswith(")") &&
				    arg.findmatch("(", ")", 8) == #arg - 1) {
					fp << "#ifdef " << arg[8:-1].strip();
				} else if (arg.startswith("!defined(") && arg.endswith(")") &&
				           arg.findmatch("(", ")", 9) == #arg - 1) {
					fp << "#ifndef " << arg[9:-1].strip();
				} else {
					fp << "#if " << arg;
				}
				fp << "\n";
				break;

			case CGP_ELIF:
				arg = str arg;
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				fp << "#elif " << arg << "\n";
				break;

			case CGP_ELSE:
				arg = str arg;
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				if (arg) {
					fp << "#else /* " << arg << " */\n";
				} else {
					fp << "#else\n";
				}
				break;

			case CGP_ENDIF:
				arg = str arg;
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				if (arg) {
					fp << "#endif /* " << arg << " */\n";
				} else {
					fp << "#endif\n";
				}
				break;

			case CGP_NSENTER:
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				fp << arg.enter;
				break;

			case CGP_NSLEAVE:
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				fp << arg.leave;
				break;

			case CGP_FORCENL:
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				break;

			case CGP_EXTERNENTER:
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				if (arg == "C") {
					fp << "__DECL_BEGIN\n";
				} else {
					fp << "extern " << repr(arg) << " {\n";
				}
				break;

			case CGP_EXTERNLEAVE:
				if (!fpAfterNewline) {
					fp << "\n";
					fpAfterNewline = true;
				}
				if (arg == "C") {
					fp << "__DECL_END\n";
				} else {
					fp << "} /* extern " << repr(arg) << " */\n";
				}
				break;

			}
		}
		pendingParts.clear();
	}

}


class IfDefStackEntry {
	this = default;
	public member cond: string | none = none;    /* Condition to print for #else or #endif (or none if not set) */
	public member didWriteIf: bool = false;      /* #if, #ifdef or #ifndef was printed */
	public member didWriteElse: bool = false;    /* #else was printed */
	public member encounteredElse: bool = false; /* ppElse() was called */
	public member encounteredIf0: bool = false;  /* m_IfdefDead was incremented because of ppElif("0") or ppIf("0") */
	public member encounteredIf1: bool = false;  /* didWriteElse is true because of ppElif("1") or ppIf("1") */
	public member printedPrefixes: {string...} = HashSet(); /* Set of prefix strings that have already been printed. */
}



@@Helper class for generating C code
class CWriter {

	@@@param: fp: The underlying file to which to output generated text
	this(fp: File, keepNewLinesFromDeadCode: bool = false) {
		this.keepNewLinesFromDeadCode = keepNewLinesFromDeadCode;
		this.generator = CGenerator(fp: fp);
	}

	@@The underlying generator used to produce output
	public member generator: CGenerator;

	@@Flush all output of the CWriter to the bound file
	@@NOTE: Doing this will prevent any further optimizations to be
	@@      done on anything that has already been written at this time.
	@@      As such, you should only call this function once no more
	@@      text is going to be written, or if you know for sure that
	@@      no further optimizations are possible, or don't wish any
	@@      further optimizations to be performed.
	public function flush(): CWriter {
		generator.flush();
		return this;
	}

	@@When @true, new-lines from dead code will be kept
	public member keepNewLinesFromDeadCode: bool;

	@@Returns @true if the output is ignored within the current context.
	@@This can happen following something like @ppIf("0"), and will
	@@continue on until the corresponding call to @ppEndif()
	public property isDeadCode: bool = {
		get(): bool -> m_IfdefDead != 0;
	}

	@@Stack of active #if-directives
	private member m_IfdefStack: {IfDefStackEntry...} = [];

	@@Non-zero if no text should current be emit
	private member m_IfdefDead: int = 0;

	@@@return: * : The # of printed new-line characters
	private function doPrintIf(cond: string): int {
		local result = 1;
		if (generator.addForceNl())
			result = 2;
		generator.addPpIf(cond);
		return result;
	}

	@@Insert a preprocessor directive `#if cond`
	@@@return: * : The # of printed new-line characters
	public function ppIf(cond: string): int {
		local result = 0;
		if (m_IfdefDead)
			cond = "0"; /* Speed up some code... (and won't make a difference...) */
		if (cond !is string)
			cond = str cond;
		cond = optimizePreprocessorExpression(cond);
		local ent = IfDefStackEntry(cond: cond);
		if (cond == "1") {
			ent.encounteredIf1 = true;
		} else if (cond == "0") {
			ent.encounteredIf0 = true;
			++m_IfdefDead;
		} else {
			ent.didWriteIf = true;
			ent.cond = cond;
			if (!m_IfdefDead)
				result = doPrintIf(cond);
		}
		m_IfdefStack.pushback(ent);
		return result;
	}

	@@Insert a `#elif` directive
	@@@return: * : The # of printed new-line characters
	public function ppElif(cond: string): int {
		local result = 0;
		if (!m_IfdefStack)
			throw Error("#ifdef-stack is empty");
		local ent = m_IfdefStack.last;
		if (ent.encounteredElse)
			throw Error("#elif after #else");
		if (ent.encounteredIf1) {
			/* A universal true-branch was already written.
			 * Ignore this #elif directive entirely! */
dont_emit_branch:
			if (!ent.encounteredIf0) {
				++m_IfdefDead;
				ent.encounteredIf0 = true;
			}
			goto done;
		}
		if (cond !is string)
			cond = str cond;
		cond = optimizePreprocessorExpression(cond);
		if (cond == "0") {
			/* Special case: Don't do anything and ignore
			 * everything until the next #elif or #else */
			goto dont_emit_branch;
		}
		/* Mark the end of a potential preceding `#if 0` / `#elif 0` branch. */
		if (ent.encounteredIf0) {
			ent.encounteredIf0 = false;
			--m_IfdefDead;
		}
		if (cond == "1") {
			/* Special case: Universal true-branch
			 * (must be printed the same as #else) */
			ent.encounteredIf1 = true;
			if (!ent.didWriteIf)
				goto done; /* No preceding #if-branch -> can directly inline this #elif */
			/* A preceding #if was already written (follow up with a #else) */
			assert !ent.didWriteElse;
			ent.didWriteElse = true;
			if (!m_IfdefDead) {
				result = 1;
				if (generator.addForceNl())
					result = 2;
				local condText = "...";
				if (ent.cond !is none) {
					condText = optimizePreprocessorExpressionAndRemoveDefined(ent.cond);
					ent.cond = "!({})".format({ ent.cond });
				}
				generator.addPpElse(condText);
				ent.printedPrefixes.clear();
			}
			goto done;
		}
		assert !ent.didWriteElse;
		/* If we havn't yet written a #if branch, do so now */
		if (!ent.didWriteIf) {
			ent.didWriteIf = true;
			if (!m_IfdefDead)
				result = doPrintIf(cond);
			goto done;
		}
		/* Regular case: Print the #elif as an actual #elif */
		if (!m_IfdefDead) {
			result = 1;
			if (generator.addForceNl())
				result = 2;
			generator.addPpElif(cond);
			ent.printedPrefixes.clear();
			/* Delete the saved condition so that "..."
			 * will appear as comment in generated code. */
			ent.cond = none;
		}
done:
		return result;
	}

	@@Insert a `#else` directive
	@@@return: * : The # of printed new-line characters
	public function ppElse(): int {
		local result = ppElif("1");
		m_IfdefStack.last.encounteredElse = true;
		return result;
	}

	@@Insert a `#endif` directive
	@@@return: * : The # of printed new-line characters
	public function ppEndif(): int {
		local result = 0;
		if (!m_IfdefStack)
			throw Error("#ifdef-stack is empty");
		local ent = m_IfdefStack.popback();
		if (ent.encounteredIf0) {
			ent.encounteredIf0 = false;
			--m_IfdefDead;
		}
		if (ent.didWriteIf) {
			/* Output an #endif directive */
			if (!m_IfdefDead) {
				result = 1;
				if (generator.addForceNl())
					result = 2;
				local condText = "...";
				if (ent.cond !is none) {
					condText = optimizePreprocessorExpressionAndRemoveDefined(ent.cond);
				} else if (ent.didWriteElse) {
					condText = "!...";
				}
				generator.addPpEndif(condText);
			}
		}
		return result;
	}

	@@@return: * : The # of printed new-line characters
	public function ppIfdef(macroName: string): int {
		return ppIf("defined({})".format({ macroName }));
	}

	@@@return: * : The # of printed new-line characters
	public function ppIfndef(macroName: string): int {
		return ppIf("!defined({})".format({ macroName }));
	}

	public function ppUndef(macroName: string): CWriter {
		if (m_IfdefDead)
			goto done;
		generator.addForceNl();
		generator.addPrinter << "#undef " << macroName << "\n";
done:
		return this;
	}

	public function ppDefine(macroName: string, macroValue: string): CWriter {
		if (m_IfdefDead)
			goto done;
		generator.addForceNl();
		local p = generator.addPrinter
			<< "#define " << macroName;
		if (!macroValue.startswith("("))
			p << " ";
		p << macroValue << "\n";
done:
		return this;
	}

	public function forceStartOfLine(): CWriter {
		if (m_IfdefDead)
			goto done;
		generator.addForceNl();
done:
		return this;
	}

	@@Set of prefix strings printed at the global scope
	private member m_GlobalPrintedPrefixes: {string...} = HashSet();

	@@Check if a given @prefix was already printed
	public function wasPrefixPrinted(prefix: string): bool {
		if (m_IfdefDead)
			goto done;
		prefix = prefix.rstrip().lstrip("\n");
		for (local ste: m_IfdefStack) {
			if (prefix in ste.printedPrefixes) {
done:
				return true;
			}
		}
		return prefix in m_GlobalPrintedPrefixes;
	}

	private function _wasPrefixPrinted(prefix: string): bool {
		if (m_IfdefDead)
			goto done;
		for (local ste: m_IfdefStack) {
			if (prefix in ste.printedPrefixes) {
done:
				return true;
			}
		}
		return prefix in m_GlobalPrintedPrefixes;
	}

	@@Check if all of the given prefixes were already printed
	public function wereAllPrefixesAlreadyPrinted(prefixes: {string...}): bool {
		if (m_IfdefDead)
			goto done;
		for (local p: prefixes) {
			if (!wasPrefixPrinted(p))
				return false;
		}
done:
		return true;
	}

	@@Check if all of the given prefixes were already printed
	public function printPrefix(prefix: string): CWriter {
		if (m_IfdefDead)
			goto done;
		prefix = prefix.rstrip().lstrip("\n");
		if (!_wasPrefixPrinted(prefix)) {
			rememberPrefixAlreadyPrinted(prefix);
			generator.addForceNl();
			generator.addPrinter << prefix << "\n";
		}
done:
		return this;
	}

	public function ppInclude(header: string): CWriter {
		return printPrefix("#include {}".format({ header }));
	}

	@@Remember the inclusion of a given @header
	private function rememberPrefixAlreadyPrinted(prefix: string) {
		local ppStackIndex = #m_IfdefStack - 1;
		while (ppStackIndex >= 0) {
			local ent: IfDefStackEntry = m_IfdefStack[ppStackIndex];
			if (ent.didWriteIf || ent.didWriteElse)
				break;
			--ppStackIndex;
		}
		local set = ppStackIndex >= 0
			? m_IfdefStack[ppStackIndex].printedPrefixes
			: m_GlobalPrintedPrefixes;
		set.insert(prefix);
	}

	@@Print @text as a C or C++ comment, preferring C comments.
	public function printComment(text: string): CWriter {
		generator.addForceNl();
		File.Writer tempfp;
		text = text.rstrip();
		if ("*/" in text) {
			/* Must use //-style comments (ugh... I don't like those.
			 * Why? Because those can't be parsed in reverse,
			 *      where-as / * ... * / can be...) */
			for (local l: text.splitlines(false)) {
				l = l.rstrip();
				if (!l) {
					this << "//\n";
				} else {
					this << "// " << l << "\n";
				}
			}
		} else {
			/* Print comments that look just like this one does,
			 * with every line starting with " * ", except for the
			 * first one, and the trailing * / being appeneded onto
			 * the last line. */
			local isFirst = true;
			local p = this << "/*";
			for (local l: text.splitlines(false)) {
				l = l.rstrip();
				if (!isFirst)
					p << "\n *";
				if (l)
					p << " " << l;
				isFirst = false;
			}
			p << " */\n";
		}
		return this;
	}

	@@Append the given @text
	public operator << (text: string | Bytes): CWriter | File | none {
		/* If we're not inside of dead code, simply  */
		if (!m_IfdefDead)
			return generator.addPrinter << text;
		if (keepNewLinesFromDeadCode) {
			if (text !is Bytes)
				text = str text;
			local c = text.count("\n");
			if (c) {
				generator.addPrinter << ("\n" * c);
			}
			return this;
		}
		return none;
	}

	private member m_CurrentNamespace: Namespace = GLOBAL_NAMESPACE;

	@@Get/Set the current namespace
	public property namespace: Namespace = {
		get(): Namespace {
			return m_CurrentNamespace;
		}
		set(namespace: Namespace) {
			if (namespace !is Namespace)
				namespace = NAMESPACES[str namespace];
			if (m_CurrentNamespace === namespace)
				return;
			generator.addNsLeave(m_CurrentNamespace);
			generator.addNsEnter(namespace);
			m_CurrentNamespace = namespace;
		}
	}

	private member m_CurrentExternLinkage: string = "";

	@@Get/Set the current namespace
	public property externLinkage: string = {
		get(): string {
			return m_CurrentExternLinkage;
		}
		set(linkage: string | none) {
			if (m_CurrentExternLinkage === linkage)
				return;
			if (m_CurrentExternLinkage)
				generator.addExternLeave(m_CurrentExternLinkage);
			if (linkage)
				generator.addExternEnter(linkage);
			m_CurrentExternLinkage = linkage;
		}
	}
}





















