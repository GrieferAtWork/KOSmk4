/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .cheaders;
import * from .parser;
import * from .escape;
import * from .writer;
import * from .globals;
import * from .namespace;
import * from .wchar;
import * from .generator;
import Function from .cheaders;

/* How auto vs. user implementation is selected:
 * >> if (HAS_MAGIC_IMPLEMENTION_BODY) {
 * >>     if (HAS_ANNOTATION("crt_userimpl")) {
 * >>         return USE_USER_IMPL;
 * >>     } else {
 * >>         return USE_AUTO_IMPL;
 * >>     }
 * >> } else {
 * >>     return USE_USER_IMPL;
 * >> } */


/* How [wchar] and associated %{uchar} functions are handled:
 * >> [[wchar, ATTR_WUNUSED]]
 * >> size_t wcslen([[nonnull]] wchar_t const *__restrict str) {
 * >> 	size_t result = 0;
 * >> 	while (str[result])
 * >> 		++result;
 * >> 	return result;
 * >> }
 * >>
 * >> c16len(*) %{uchar}
 * >> c32len(*) %{uchar}
 * ============================================ EXPANDED ============================================
 * >> [[if(defined(__CRT_HAVE_DOS$wcslen) && __SIZEOF_WCHAR_T__ == 2), raw_alias(DOS$wcslen)]]
 * >> [[if(defined(__CRT_HAVE_DOS$wcslen) && __SIZEOF_WCHAR_T__ == 4), raw_alias(KOS$wcslen)]]
 * >> [[ATTR_WUNUSED]]
 * >> size_t wcslen([[nonnull]] wchar_t const *__restrict str) {
 * >> 	size_t result = 0;
 * >> 	while (str[result])
 * >> 		++result;
 * >> 	return result;
 * >> }
 * >>
 * >>
 * >> [[if(__SIZEOF_WCHAR_T__ == 2), alias(wcslen)]][[alias(DOS$wcslen)]]
 * >> [[if(__SIZEOF_WCHAR_T__ == 2), bind_local_function(wcslen)]][[nocrt]][[ATTR_WUNUSED]]
 * >> size_t c16len([[nonnull]] char16_t const *__restrict str) {
 * >> 	size_t result = 0;
 * >> 	while (str[result])
 * >> 		++result;
 * >> 	return result;
 * >> }
 * >>
 * >> [[if(__SIZEOF_WCHAR_T__ == 4), alias(wcslen)]][[alias(KOS$wcslen)]]
 * >> [[if(__SIZEOF_WCHAR_T__ == 4), bind_local_function(wcslen)]][[nocrt]][[ATTR_WUNUSED]]
 * >> size_t c32len([[nonnull]] char32_t const *__restrict str) {
 * >> 	size_t result = 0;
 * >> 	while (str[result])
 * >> 		++result;
 * >> 	return result;
 * >> }
 * ============================================ HEADER ============================================
 * >> #ifdef __CRT_HAVE_wcslen
 * >> __CDECLARE(__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,,wcslen,(wchar_t const *__restrict __str),(__str))
 * >> #elif defined(__CRT_HAVE_DOS$wcslen) && __SIZEOF_WCHAR_T__ == 2
 * >> __CREDIRECT_DOS(__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,,wcslen,(wchar_t const *__restrict __str),wcslen,(__str))
 * >> #elif defined(__CRT_HAVE_DOS$wcslen) && __SIZEOF_WCHAR_T__ == 4
 * >> __CREDIRECT_KOS(__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,,wcslen,(wchar_t const *__restrict __str),wcslen,(__str))
 * >> #else // ...
 * >> #include <local/wchar/wcslen.h>
 * >> __NAMESPACE_LOCAL_USING_OR_IMPL(wcslen, __FORCELOCAL __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t (__LIBCCALL wcslen)(wchar_t const *__restrict __str) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))(str); })
 * >> #endif // !...
 * >>
 * >> #if defined(__CRT_HAVE_wcslen) && (__SIZEOF_WCHAR_T__ == 2)
 * >> __CREDIRECT(__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,,c16len,(char16_t const *__restrict __str),wcslen,(__str))
 * >> #elif defined(__CRT_HAVE_DOS$wcslen)
 * >> __CREDIRECT_DOS(__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,,c16len,(char16_t const *__restrict __str),wcslen,(__str))
 * >> #elif __SIZEOF_WCHAR_T__ == 2
 * >> #include <local/wchar/wcslen.h>
 * >> __FORCELOCAL __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t (__LIBCCALL c16len)(char16_t const *__restrict __str) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))((wchar_t const *__restrict)str); }
 * >> #else // ...
 * >> #include <local/wchar/c16len.h>
 * >> __NAMESPACE_LOCAL_USING_OR_IMPL(c16len, __FORCELOCAL __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t (__LIBCCALL c16len)(char16_t const *__restrict __str) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(c16len))(str); })
 * >> #endif // !...
 * >>
 * >> #if defined(__CRT_HAVE_wcslen) && (__SIZEOF_WCHAR_T__ == 4)
 * >> __CREDIRECT(__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,,c32len,(char32_t const *__restrict __str),wcslen,(__str))
 * >> #elif defined(__CRT_HAVE_DOS$wcslen)
 * >> __CREDIRECT_DOS(__ATTR_WUNUSED __ATTR_NONNULL((1)),size_t,,c32len,(char32_t const *__restrict __str),wcslen,(__str))
 * >> #elif __SIZEOF_WCHAR_T__ == 4
 * >> #include <local/wchar/wcslen.h>
 * >> __FORCELOCAL __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t (__LIBCCALL c32len)(char32_t const *__restrict __str) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))((wchar_t const *__restrict)str); }
 * >> #else // ...
 * >> #include <local/wchar/c32len.h>
 * >> __NAMESPACE_LOCAL_USING_OR_IMPL(c32len, __FORCELOCAL __ATTR_WUNUSED __ATTR_NONNULL((1)) size_t (__LIBCCALL c32len)(char32_t const *__restrict __str) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(c32len))(str); })
 * >> #endif // !...
 */


global final CXX_SYSTEM_HEADER_START = "#ifndef __CXX_SYSTEM_HEADER\n";
global final CXX_SYSTEM_HEADER_END   = "#endif /* !__CXX_SYSTEM_HEADER */\n";
global final DEFAULT_CC              = "LIBCCALL";
global final DEFAULT_NOTHROW         = "NOTHROW_NCX";

@@Simple return type annotations which (when used) will be converted into attributes
global final SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS: {string: string} = {
	"nonnull"  : "ATTR_RETNONNULL",
	"wunused"  : "ATTR_WUNUSED",
	"nullable" : "",
	"null"     : "",
};

@@Same as @SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS, but only applicable to functions as a whole
global final SIMPLE_ATTRIBUTE_ANNOTATIONS: {string: string} = {
	"ATTR_MCONST" : "",
};

@@Same as @SIMPLE_ATTRIBUTE_ANNOTATIONS, but used to define @FunctionPrototype.nothrow
global final SIMPLE_NOTHROW_ANNOTATIONS: {string: string} = {
	"no_nothrow"        : "",
	"nothrow"           : "NOTHROW",
	"nothrow_ncx"       : "NOTHROW_NCX",
	"nothrow_rpc"       : "NOTHROW_RPC",
	"nothrow_rpc_kos"   : "NOTHROW_RPC_KOS",
	"nothrow_rpc_nokos" : "NOTHROW_RPC_NOKOS",
	"nothrow_rpc_pure"  : "NOTHROW_RPC_PURE",

	/* CP for stdio (because of libio, custom FILE cookies may throw exceptions)
	 * Used for functions that are already CP in their syscall form. */
	"cp_stdio"          : "THROWS(...)",
	/* STDIO functions that may throw because of custom FILE cookies. */
	"stdio_throws"      : "THROWS(...)",
	"throws"            : "THROWS(...)",

	/* Cancellation point */
	"cp"                 : "NOTHROW_RPC",
	"cancellation_point" : "NOTHROW_RPC",
	"rpc"                : "NOTHROW_RPC",

	"cp_kos"             : "NOTHROW_RPC_KOS",
	"cp_nokos"           : "NOTHROW_RPC_NOKOS",
	"rpc_pure"           : "NOTHROW_RPC_PURE",
};

final global KNOWN_STRING_TAGS: {string...} = {
	"c",            /* C-part in <string.h> */
	"std",          /* std:: -part in <string.h> */
	"ccompat",      /* c-compat-part in <string.h> */
	"libc_fast",    /* <libc/string.h> */
	"libc_core",    /* <libc/core/string.h> */
	"auto_header",  /* /kos/src/libc/auto/string.h */
	"auto_source",  /* /kos/src/libc/auto/string.c */
	"user",         /* /kos/src/libc/user/string.h */
};


@@Replace a @"defined(__CRT_HAVE_xxx)" sub-part of @ppCond
function replaceCrtHaveFromPreprocessorCondition(
		ppCond: string,
		oldSymbolName: string | UserString,
		newSymbolName: string | UserString): string {
	local oldHave = keyCrtHave(oldSymbolName);
	local newHave = keyCrtHave(newSymbolName);
	if (oldHave !in ppCond) {
		if (ppCond in ["", "1"])
			return newHave;
		if (ppCond in ["0"])
			return ppCond;
		return "({})&&{}".format({ ppCond, newHave });
	}
	return ppCond.replace(oldHave, newHave);
}


function parseCTypeAndName(self: CParser): (CType, UserString | string) {
	local ctype: CType;
	local varname: UserString | string;
	local tok = self.tok;
	if (isCString(tok)) {
		local typename = tok.decode("c-escape");
		tok = self.next();
		if (isCString(tok))
			varname = tok.decode("c-escape");
		else {
			if (!tok.issymbol())
				self.err("Expected keyword or string for variable name, but got {!r}"
					.format({ tok }));
			varname = self.userTok;
		}
		tok   = self.next();
		ctype = CType(typename);
		if (isCString(tok)) {
			ctype.afterName = tok.decode("c-escape");
			self.next();
		} else if (tok in "[(") {
			local afterNameStart = self.tokStart;
			self.skipPair();
			ctype.afterName = self.getUserString(
				afterNameStart, self.tokEnd);
			self.next();
		}
	} else if (tok == "...") {
		/* Ellipsis argument */
		ctype   = CType("...");
		varname = "";
		self.next();
	} else {
		final local TWO_WORD_TYPENAME_INDICATORS = ["struct", "union", "class", "enum"];
		if (!tok.issymbol())
			self.err("Expected keyword or string for typename, but got {!r}".format({ tok }));
		local typenameStart = self.tokStart;
		local typenameEnd = self.tokEnd;
		if (tok in TWO_WORD_TYPENAME_INDICATORS)
			goto continue_typename_expression_twoword;
		tok = self.next();
		for (;;) {
			if (tok in TWO_WORD_TYPENAME_INDICATORS) {
continue_typename_expression_twoword:
				self.next();
continue_typename_expression:
				typenameEnd = self.tokEnd;
				tok = self.next();
				continue;
			}
			if (tok in cLanguageKeywords)
				goto continue_typename_expression;
			if (tok in "*&")
				goto continue_typename_expression;
			break;
		}
		if (tok.issymbol() || isCString(tok)) {
			ctype = CType(self.getUserString(typenameStart, typenameEnd));
			if (isCString(tok))
				varname = tok.decode("c-escape");
			else {
				varname = self.userTok;
			}
			tok = self.next();
			if (tok in "[(" || tok.issymbol()) {
				local suffixStart = self.tokStart;
				for (;;) {
					if (tok in "[(") {
						self.skipPair();
						tok = self.next();
						continue;
					}
					if (tok.issymbol()) {
						tok = self.next();
						continue;
					}
					break;
				}
				ctype.afterName = self.getUserString(
					suffixStart, self.tokStart);
			} else if (isCString(tok)) {
				ctype.afterName = tok.decode("c-escape");
				tok = self.next();
			}
		} else if (tok in "([") {
			/* Inner variable name: "int (*foo)(int x)"
			 * Must split into: "int (*", "foo", ")(int x)" */
			final local PAREN_TABLE = {
				"(" : ")",
				"[" : "]",
				"{" : "}",
			};
			local unwindStack = [PAREN_TABLE[tok]];
			for (;;) {
				typenameEnd = self.tokEnd;
				tok = self.next();
				if (tok in "*&")
					continue;
				if (tok in "([") {
					unwindStack.pushback(PAREN_TABLE[tok]);
					continue;
				}
				if (tok in cLanguageKeywords)
					continue;
				break;
			}
			ctype = CType(self.getUserString(typenameStart, typenameEnd));
			if (isCString(tok)) {
				varname = tok.decode("c-escape");
				self.next();
			} else if (tok.issymbol()) {
				varname = self.userTok;
			} else {
				varname = "";
			}
			local afterNameStart = self.tokStart;
			local afterNameEnd = afterNameStart;
			while (unwindStack) {
				if (tok == unwindStack.last) {
					unwindStack.popback();
				} else if (tok in "([") {
					self.skipPair();
				} else if (tok in cLanguageKeywords) {
				} else {
					self.err("Unmatched {!r} in ctype expression"
						.format({ unwindStack.last }));
				}
				afterNameEnd = self.tokEnd;
				tok = self.next();
			}
			ctype.afterName = self.getUserString(afterNameStart, afterNameEnd);
		} else {
			ctype = CType(self.getUserString(typenameStart, typenameEnd));
			varname = "";
		}
	}
	return (ctype, varname);
}






@@Parse the contents of an argument list, starting after the leading @"(",
@@such that @self.next() will return the first token _after_ that @"(", and
@@stopping such that @self.tok will point at the first character after the
@@trailing @")"
@@NOTE: Optionally, the current token may be a @"[" upon entry, in which case
@@      @defaultAttributes will not be used, but attributes will rather be
@@      read from the initial tag-list (unless one of the tags is @"[*]")
@@@param: defaultAttributes:             Default function prototype attributes
@@@param: functionArgumentNamesOverride: Names specified via @"[argument_names(...)]"
function parseArgumentList(
		self: CParser, result: FunctionPrototype,
		defaultAttributes: {(string | UserString)...} = (),
		functionArgumentNamesOverride: {(string | UserString)...} = none) {
	local tok = self.tok;
	if (tok == "[") {
		local numRBracket = 1;
		result.attributes = List();
		do {
again_parse_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "[":
					++numRBracket;
					goto again_parse_annotations;

				case "*":
					result.attributes.extend(defaultAttributes);
					tok = self.next();
					break;

				case "argument_names":
					self.next();
					self.skip("(");
					functionArgumentNamesOverride = List(
						parseCStringOrFunctionLikeExpressionList(self));
					tok = self.skip(")");
					break;

				case "cc":
					self.next();
					self.skip("(");
					result.cc = parseCStringOrAllUntilRParen(self);
					tok = self.skip(")");
					break;

				case "throws":
					self.next();
					if (self.tok == "(") {
						self.next();
						result.nothrow = "THROWS({})"
							.format({ parseCStringOrAllUntilRParen(self) });
						self.skip(")");
					} else {
						result.nothrow = "THROWS(...)";
					}
					break;

				case "nothrow":
					self.next();
					if (self.tok == "(") {
						self.next();
						result.nothrow = parseCStringOrAllUntilRParen(self);
						self.skip(")");
					} else {
						result.nothrow = "NOTHROW";
					}
					break;

				case "vartypes":
					self.next();
					self.skip("(");
					result.ellipsisArgumentTypes = [];
					while (self.tok != ")") {
						local typ, none = parseCTypeAndName(self)...;
						result.ellipsisArgumentTypes.append(typ);
						if (self.tok == ")")
							break;
						self.skip(",");
					}
					tok = self.next();
					break;

				case "decl_prefix":
					self.next();
					self.skip("(");
					if (result.declPrefix !is List)
						result.declPrefix = List(result.declPrefix);
					result.declPrefix.append(parseCStringOrAllUntilRParen(self));
					self.skip(")");
					break;

				case "decl_include":
					self.next();
					self.skip("(");
					if (result.declPrefix !is List)
						result.declPrefix = List(result.declPrefix);
					result.declPrefix.append(
						"#include " + parseCStringOrAllUntilRParen(self));
					self.skip(")");
					break;

				default:
					if (isCString(tok)) {
						result.attributes.append(tok.decode("c-escape"));
						self.next();
					} else {
						local anno = SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS.get(tok);
						if (anno is none)
							anno = SIMPLE_ATTRIBUTE_ANNOTATIONS.get(tok);
						if (anno !is none) {
							if (anno)
								result.attributes.append(anno);
							self.next();
						} else {
							anno = SIMPLE_NOTHROW_ANNOTATIONS.get(tok);
							if (anno !is none) {
								result.nothrow = anno;
								self.next();
							} else if (tok.startswith("ATTR_")) {
								/* Attribute annotation. */
								result.attributes.append(parseCStringOrAllUntilRParen(self));
							} else {
								self.err("Unknown prototype annotation {!r}"
									.format({ tok }));
							}
						}
					}
					break;
				}
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_annotation_rbracket:
			tok = self.skip("]");
			if (numRBracket > 1) {
				--numRBracket;
				if (tok != ",")
					goto again_skip_annotation_rbracket;
				goto again_parse_annotations;
			}
		} while (tok == "[");
	} else {
		result.attributes = defaultAttributes;
	}
	tok = self.skip("(");
	local nonNullArguments: {int...} = none;
	result.argv = [];
	while (tok != ")") {
		while (tok == "[") {
			local numRBracket = 1;
again_parse_arg_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "[":
					++numRBracket;
					goto again_parse_arg_annotations;

				case "nullable":
				case "null":
					tok = self.next();
					break;

				case "nonnull":
					tok = self.next();
do_add_nonnull_annotation:
					if (nonNullArguments is none)
						nonNullArguments = HashSet();
					nonNullArguments.insert(#result.argv + 1);
					break;

					/* (Mostly) ignored annotations */
				case "inp":
				case "inpb":
				case "inp_opt":
				case "inpb_opt":
				case "outp":
				case "outpb":
				case "outp_opt":
				case "outpb_opt":
				case "inoutp":
				case "inoutpb":
				case "inoutp_opt":
				case "inoutpb_opt":
					self.next();
					self.skip("(");
					self.skipPair("(", ")");
					self.skip(")");
					if (!tok.endswith("_opt"))
						goto do_add_nonnull_annotation;
					break;

				default:
					self.err("Unknown argument annotation {!r}"
						.format({ tok }));
					break;
				}
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_arg_annotation_rbracket:
			tok = self.skip("]");
			if (numRBracket > 1) {
				--numRBracket;
				if (tok != ",")
					goto again_skip_arg_annotation_rbracket;
				goto again_parse_arg_annotations;
			}
		}
		local typ, name = parseCTypeAndName(self)...;
		local arg = Argument(name: name, protoTypeName: name, ctype: typ);
		if (functionArgumentNamesOverride !is none) {
			local argi = #result.argv;
			if (argi >= #functionArgumentNamesOverride)
				self.err("Too few function argument name overrides were given");
			arg.name = functionArgumentNamesOverride[argi];
		}
		result.argv.append(arg);
		tok = self.tok;
		if (tok != ",")
			break;
		tok = self.next();
	}
	self.skip(")");
	if (nonNullArguments) {
		local attrib = "ATTR_NONNULL(({}))"
			.format({ ", ".join(nonNullArguments.sorted()) });
		if (result.attributes === defaultAttributes)
			result.attributes = List(defaultAttributes);
		result.attributes.append(attrib);
	}
}

@@Same as @parseArgumentList, but also parse an optional trailing @"-> TYPE"
@@or @": TYPE" suffix, and throw an error if such a suffix is present, but
@@some other return type had already been defined.
@@Upon return, @self will point at the first character after the return type
function parseArgumentListAndOptionalTrailingReturnType(
		self: CParser, result: FunctionPrototype,
		defaultAttributes: {(string | UserString)...} = (),
		functionArgumentNamesOverride: {(string | UserString)...} = none) {
	parseArgumentList(self, result, defaultAttributes, functionArgumentNamesOverride);
	if (self.tok in ["->", ":"]) {
		local tok = self.next();
		if (result.returnType is bound)
			self.err("A return type was already defined");
		while (tok == "[") {
			local numRBracket = 1;
again_parse_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "[":
					++numRBracket;
					goto again_parse_annotations;

				case "malloc": {
					if (result.attributes === defaultAttributes)
						result.attributes = List(defaultAttributes);
					result.attributes.append("ATTR_WUNUSED");
					result.attributes.append("ATTR_MALLOC");
					result.attributes.append("ATTR_MALL_DEFAULT_ALIGNED");
					if (self.next() == "(") {
						self.next();
						local argumentIndices = [];
						while (self.tok !in ["", ")"]) {
							local argumentNameStart = self.tokStart;
							local argumentName = parseCStringOrKeyword(self);
							try {
								argumentIndices.append(
									result.argv.index(result.argsByName[argumentName]) + 1);
							} catch (Error as e) {
								self.errAt(argumentNameStart, e.message);
							}
							if (self.tok !in [",", "*"])
								break;
							self.next();
						}
						result.attributes.append("ATTR_ALLOC_SIZE(({}))"
							.format({ ", ".join(argumentIndices) }));
						self.skip(")");
					}
				}	break;

				case "realloc": {
					self.next();
					self.skip("(");
					parseCStringOrKeyword(self);
					self.skip(",");
					local argumentIndices = [];
					while (self.tok !in ["", ")"]) {
						local argumentNameStart = self.tokStart;
						local argumentName = parseCStringOrKeyword(self);
						try {
							argumentIndices.append(
								result.argv.index(result.argsByName[argumentName]) + 1);
						} catch (Error as e) {
							self.errAt(argumentNameStart, e.message);
						}
						if (self.tok !in [",", "*"])
							break;
						self.next();
					}
					if (result.attributes === defaultAttributes)
						result.attributes = List(defaultAttributes);
					result.attributes.append("ATTR_WUNUSED");
					result.attributes.append("ATTR_MALLOC");
					result.attributes.append("ATTR_MALL_DEFAULT_ALIGNED");
					result.attributes.append("ATTR_ALLOC_SIZE(({}))"
						.format({ ", ".join(argumentIndices) }));
					self.skip(")");
				}	break;

				case "memalign": {
					self.next();
					self.skip("(");
					local minAlignmentAttrib;
					if (self.tok == "getpagesize") {
						self.next();
						self.skip("(");
						self.skip(")");
						minAlignmentAttrib = "__ATTR_MALL_PAGEALIGNED";
					} else {
						local minAlignmentArgumentNameStart = self.tokStart;
						local minAlignmentArgumentName = parseCStringOrKeyword(self);
						try {
							minAlignmentAttrib = "ATTR_ALLOC_ALIGN({})"
							.format({ result.argv.index(result.argsByName[minAlignmentArgumentName]) + 1 });
						} catch (Error as e) {
							self.errAt(minAlignmentArgumentNameStart, e.message);
						}
					}
					self.skip(",");
					local argumentIndices = [];
					while (self.tok !in ["", ")"]) {
						local argumentNameStart = self.tokStart;
						local argumentName = parseCStringOrKeyword(self);
						try {
							argumentIndices.append(
								result.argv.index(result.argsByName[argumentName]) + 1);
						} catch (Error as e) {
							self.errAt(argumentNameStart, e.message);
						}
						if (self.tok !in [",", "*"])
							break;
						self.next();
					}
					if (result.attributes === defaultAttributes)
						result.attributes = List(defaultAttributes);
					result.attributes.append("ATTR_WUNUSED");
					result.attributes.append("ATTR_MALLOC");
					result.attributes.append(minAlignmentAttrib);
					result.attributes.append("ATTR_ALLOC_SIZE(({}))"
						.format({ ", ".join(argumentIndices) }));
					self.skip(")");
				}	break;

				default: {
					local anno = SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS.get(tok);
					if (anno is none) {
						self.err("Unknown return type attribute {!r}"
							.format({ tok }));
					}
					if (anno) {
						if (result.attributes === defaultAttributes)
							result.attributes = List(defaultAttributes);
						result.attributes.append(anno);
					}
					self.next();
				}	break;
				}
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_annotation_rbracket:
			tok = self.skip("]");
			if (numRBracket > 1) {
				--numRBracket;
				if (tok != ",")
					goto again_skip_annotation_rbracket;
				goto again_parse_annotations;
			}
		}
		if (!tok.issymbol())
			self.err("Expected a keyword for function return type");
		local returnTypeStart = self.tokStart;
		local returnTypeEnd;
		for (;;) {
			returnTypeEnd = self.tokEnd;
			tok = self.next();
			if (!tok.issymbol()) {
				if (tok in "*&")
					continue;
				if (tok in "([") {
					self.skipPair(tok);
					continue;
				}
				break;
			}
		}
		result.returnType = CType(
			self.getUserString(
				returnTypeStart, returnTypeEnd));
	}
}

function parseWholeFunctionPrototype(
		self: CParser, result: FunctionPrototype,
		defaultAttributes: {(string | UserString)...} = (),
		functionArgumentNamesOverride: {(string | UserString)...} = none) {
	if (self.tok != "(") {
		/* Try to parse a leading return type designator */
		result.returnType = parseCTypeAndName(self)[0];
	}
	parseArgumentListAndOptionalTrailingReturnType(
		self, result, defaultAttributes,
		functionArgumentNamesOverride);
}


function constructAliasConditions(
		ppCond: string | none,
		assemblyName: string | UserString): string {
	local hasAssemblyName = keyCrtHave(assemblyName);
	if (ppCond is none || ppCond == "1")
		return hasAssemblyName;
	return "{} && ({})".format({ hasAssemblyName, ppCond });
}

class FunctionFeatures {
	this = default;

	/* Declaration features */
	public member decl: UserString | string = "__LIBC";              /* [decl(...)]             Declaration prefix */
	public member std: bool = false;                                 /* [std]                   Expose as part of the std:: namespace */
	public member namespaces: {string...} = ("",);                   /* [[no_]ignore]           Namespaces from which to import the function */
	public member libc: bool = false;                                /* [[no_]libc]             Export in <libc/string.h> */
	public member inline: UserString | string | none = none;         /* [[no_]inline]           Use the associated body for inline implementations, rather than including <local/...> headers */
	public member noInlineTruncate: bool = false;                    /* [[no_]inline_truncate]  Truncate spaces and new-lines from inline implementations */
	public member noExternInline: bool = false;                      /* [[no_]extern_inline]    For use with @inline: Don't convert inline */
	public member noLocal: bool = false;                             /* [[no_]local]            Prevent the creation of a LocalFunction for */
	public member requires: UserString | string = "1";               /* [[no_]requires(...)]    A preprocessor condition that must be true in order to use the local/inline implementation */
	public member requiresPrefix: {(UserString | string)...} = ();   /* [requires_prefix(...)]  A piece of text that must be inserted before @requires can be used */
	public member implPrefix: {(UserString | string)...} = ();       /* [impl_prefix(...)]      A piece of text that must be inserted before the local implementation can be used */
	public member macroBinding: bool = false;                        /* [[no_]macros]           Allow the use of macros when declaring this function */
	public member guard: bool = false;                               /* [[no_]guard]            Surround the declaration of the function with a guard */
	public member guardNames: {string: (UserString | string | none)} = none; /* Guard names in different namespaces */
	public member exposedName: UserString | string | none = none;    /* [[no_]exposed_name(...)] The name under which the function will be exposed in system headers. */
	public member forcedDependencies: {(UserString | string)...} | none = none; /* [dependency(...)] Force dependencies on the given set of functions. */
	public member unforcedDependencies: {(UserString | string)...} | none = none; /* [not_dependency(...)] Force a given set of functions to not be considered dependencies. */
	public member noAutoDependencyScanning: bool = false;            /* [[no_]auto_dependency_scanning] Automatically scan for dependencies */

	/* WCHAR function features */
	public member wchar: bool = false;         /* [[no_]wchar]       Expose and implement as a wchar-function */
	public member wchar_noAlias: bool = false; /* [[no_]wchar_alias] Prevent duplication of function aliases */

	/* CRT Features */
	public member crt_name: UserString | string | none = none;       /* [[default_]crt_name(...)]   Symbol name override for the default CRT function binding */
	public member crt_noImpl: bool = false;                          /* [[no_]crt_impl]        Don't implement function within the CRT */
	public member crt_noSelfImport: bool = false;                    /* [[no_]crt_self_import] Prevent importing from ASMNAME(crt_name || current.name) */
	public member crt_noSelfExport: bool = false;                    /* [[no_]crt_self_export] Prevent exporting as ASMNAME(crt_name || current.name) */
	public member crt_userimpl: bool = false;                        /* [[no_]userimpl]        Prevent implementation in libc/auto and always use libc/user */
	public member crt_kernel: bool = false;                          /* [[no_]kernel]          Also export in kernel-space */
	public member crt_kosSection: UserString | string | none = none; /* [kos_section(...)]     Section name for the KOS implementation */
	public member crt_dosSection: UserString | string | none = none; /* [dos_section(...)]     Section name for the DOS implementation (if @wchar) */
	public member crt_dosname: UserString | string | none = none;    /* [[default_]crt_dosname(...)] Same as @crt_name, but only for the DOS variant */

	@@Enable a given namespace binding (via `using`)
	public function addNamespaceUsingBinding(name: string) {
		if (namespaces == ("",))
			namespaces = ("", name,);
		else if (name in namespaces)
			;
		else {
			namespaces = List(namespaces);
			namespaces.append(name);
		}
	}

	@@Prevent a given namespace binding (via `using`)
	public function delNamespaceUsingBinding(name: string) {
		if (name !in namespaces)
			;
		else if (#namespaces == 2 && "" in namespaces) {
			namespaces = ("", );
		} else {
			namespaces = List(namespaces);
			namespaces.remove(name);
		}
	}

	@@Set the name of a guard (to-be used when @guard
	@@is true) for a given namespace @namespaceName
	public function setNamespaceGuardName(
			namespaceName: string, guardName: string | UserString | none) {
		if (guardName is none) {
			if (namespaceName !in guardNames)
				return;
			guardNames = Dict(guardNames);
			del guardNames[namespaceName];
		} else {
			guardNames = Dict(guardNames);
			guardNames[namespaceName] = guardName;
		}
	}

	@@Try to parse a feature attribute
	@@@return: true:  Success
	@@@return: false: Unknown attribute
	public function tryParseAttribute(
			self: CParser, ppCond: string | UserString | none = none): bool {
		local tok = self.tok;
		@@Simple annotations that only entail setting the value of some field.
		@@This is a mapping of: @(tagName: (fieldName, toBeAssignedValue))
		final local SIMPLE_SETFIELD_ANNOTATIONS: {string: (string, Object)} = {
			"nodecl"                      : ("decl", "__LIBC"),
			"no_decl"                     : ("decl", "__LIBC"),
			"ignore"                      : ("namespaces", ()),
			"no_ignore"                   : ("namespaces", ("",)),
			"libc"                        : ("libc", true),
			"nolibc"                      : ("libc", false),
			"no_libc"                     : ("libc", false),
			"inline"                      : ("inline", "LOCAL"),
			"forceinline"                 : ("inline", "FORCELOCAL"),
			"noinline"                    : ("inline", none),
			"no_inline"                   : ("inline", none),
			"inline_truncate"             : ("noInlineTruncate", false),
			"no_inline_truncate"          : ("noInlineTruncate", true),
			"extern_inline"               : ("noExternInline", false),
			"no_extern_inline"            : ("noExternInline", true),
			"local"                       : ("noLocal", false),
			"noLocal"                     : ("noLocal", true),
			"no_local"                    : ("noLocal", true),
			"norequires"                  : ("requires", "1"),
			"no_requires"                 : ("requires", "1"),
			"no_requires_prefix"          : ("requiresPrefix", ""),
			"no_impl_prefix"              : ("implPrefix", ""),
			"macro"                       : ("macroBinding", true),
			"macros"                      : ("macroBinding", true),
			"no_macro"                    : ("macroBinding", false),
			"no_macros"                   : ("macroBinding", false),
			"allow_macros"                : ("macroBinding", true), /* Deprecated name */
			"disallow_macros"             : ("macroBinding", false), /* Deprecated name */
			"noguard"                     : ("guard", false),
			"no_guard"                    : ("guard", false),
			"default_guard_names"         : ("guardNames", none),
			"default_exposed_name"        : ("exposedName", none),
			"wchar"                       : ("wchar", true),
			"no_wchar"                    : ("wchar", false),
			"wchar_alias"                 : ("wchar_noAlias", false),
			"no_wchar_alias"              : ("wchar_noAlias", true),
			"default_crt_name"            : ("crt_name", none),
			"default_dosname"             : ("crt_dosname", none),
			"crt_impl"                    : ("crt_noImpl", false),
			"no_crt_impl"                 : ("crt_noImpl", true),
			"crt_self_import"             : ("crt_noSelfImport", false),
			"no_crt_self_import"          : ("crt_noSelfImport", true),
			"crt_self_export"             : ("crt_noSelfExport", false),
			"no_crt_self_export"          : ("crt_noSelfExport", true),
			"noexport"                    : ("crt_userimpl", true), /* TODO: Deprecated */
			"export"                      : ("crt_userimpl", false), /* TODO: Deprecated */
			"userimpl"                    : ("crt_userimpl", true),
			"no_userimpl"                 : ("crt_userimpl", false),
			"kernel"                      : ("crt_kernel", true),
			"nokernel"                    : ("crt_kernel", false),
			"no_kernel"                   : ("crt_kernel", false),
			"default_kos_section"         : ("crt_kosSection", none),
			"default_dos_section"         : ("crt_dosSection", none),
			"auto_dependency_scanning"    : ("noAutoDependencyScanning", false),
			"no_auto_dependency_scanning" : ("noAutoDependencyScanning", true),
		};

		switch (tok) {

		case "crt":
			crt_noImpl       = false;
			crt_noSelfImport = false;
			crt_noSelfExport = false;
			goto oneword_nocond;

		case "static":
			/* static function:
			 *   - Doesn't actually exist in libc
			 *   - Isn't actually exposed in system headers
			 *   - Can only be used lazily as a dependency from other functions
			 *   - HINT: Can be used in conjunction with [[inline]]
			 */
			namespaces   = ();
			libc         = false;
			noLocal      = false;
			macroBinding = true;
			guard        = false;
			/* FALLTHRU */
		case "nocrt":
		case "no_crt":
			crt_noImpl       = true;
			crt_noSelfImport = true;
			crt_noSelfExport = true;
			goto oneword_nocond;

		case "hidden":
			delNamespaceUsingBinding("");
			goto oneword_nocond;

		case "exposed":
			addNamespaceUsingBinding("");
			goto oneword_nocond;

		case "std":
			std = true;                      /* Expose as part of std:: */
			addNamespaceUsingBinding("std"); /* Allow importing from std:: */
			goto oneword_nocond;

		case "nostd":
		case "no_std":
			std = false;                     /* Don't expose as part of std:: */
			delNamespaceUsingBinding("std"); /* Disallow importing from std:: */
			goto oneword_nocond;

		case "fast":
			addNamespaceUsingBinding("fast");
			goto oneword_nocond;

		case "nofast":
			delNamespaceUsingBinding("fast");
			goto oneword_nocond;

		case "requires": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			local addend = parseCStringOrAllUntilRParen(self);
			self.skip(")");
			if (requires is UserString || requires != "1")
				addend = "({}) && ({})".format({ requires, addend });
			requires = addend;
		}	break;

		case "requires_function": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			while (self.tok !in ["", ")"]) {
				local addend = "$has_function({})".format({ parseCStringOrKeyword(self) });
				if (requires is UserString || requires != "1")
					addend = "({}) && ({})".format({ requires, addend });
				requires = addend;
				if (self.tok != ",")
					break;
				self.next();
			}
			self.skip(")");
		}	break;

		case "requires_dependent_function": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			forcedDependencies = HashSet(forcedDependencies);
			while (self.tok !in ["", ")"]) {
				local functionName = parseCStringOrKeyword(self);
				forcedDependencies.insert(functionName);
				local addend = "$has_function({})".format({ functionName });
				if (requires is UserString || requires != "1")
					addend = "({}) && ({})".format({ requires, addend });
				requires = addend;
				if (self.tok != ",")
					break;
				self.next();
			}
			self.skip(")");
		}	break;

		case "requires_include": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			if (requiresPrefix !is List)
				requiresPrefix = List(requiresPrefix);
			while (tok !in ["", ")"]) {
				requiresPrefix.append(
					"#include " + parseCStringOrAllUntilRParen(self));
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
			self.skip(")");
		}	break;

		case "requires_prefix": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			if (requiresPrefix !is List)
				requiresPrefix = List(requiresPrefix);
			requiresPrefix.append(parseCStringOrAllUntilRParen(self));
			self.skip(")");
		}	break;

		case "dependency_include": /* Deprecated alias */
		case "impl_include": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			tok = self.skip("(");
			if (implPrefix !is List)
				implPrefix = List(implPrefix);
			while (tok !in ["", ")"]) {
				implPrefix.append(
					"#include " + parseCStringOrAllUntilRParen(self));
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
			self.skip(")");
		}	break;

		case "dependency_prefix": /* Deprecated alias */
		case "impl_prefix": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			if (implPrefix !is List)
				implPrefix = List(implPrefix);
			implPrefix.append(parseCStringOrAllUntilRParen(self));
			self.skip(")");
		}	break;

		case "section": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			local sectionNameStart = self.tokStart;
			local sectionName = parseCStringOrAllUntilRParen(self);
			self.skip(")");
			local strSectionName = str sectionName;
			if (strSectionName.startswith("{") && strSectionName.endswith("}") &&
			    strSectionName.findmatch("{", "}", 1) == #strSectionName - 1) {
				if ("|" !in strSectionName)
					self.errAt(sectionNameStart, "Missing '|' in [section({!r})]"
						.format({ strSectionName }));
				local a, none, b = strSectionName[1:-1].partition("|")...;
				crt_kosSection = a.strip();
				crt_dosSection = b.strip();
			} else {
				crt_kosSection = sectionName;
			}
		}	break;

		case "kos_section":
		case "dos_section": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			local name = parseCStringOrAllUntilRParen(self);
			if (tok == "kos_section")
				crt_kosSection = name;
			else {
				crt_dosSection = name;
			}
			self.skip(")");
		}	break;

		case "decl": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			decl = parseCStringOrKeyword(self);
			self.skip(")");
		}	break;

		case "guard":
			if (ppCond !is none)
				goto err_unexpected_if;
			guard = true;
			tok = self.next();
			if (tok == "(") {
				/* Define the name for the GLOBAL_NAMESPACE guard. */
				self.next();
				guardNames = Dict(guardNames);
				setNamespaceGuardName(
					"" /* GLOBAL_NAMESPACE.name */,
					parseCStringOrKeyword(self));
				self.skip(")");
			}
			break;

//	TODO: guardNames

		case "exposed_name":
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			exposedName = parseCStringOrKeyword(self);
			self.skip(")");
			break;

		case "crt_name":
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			crt_name = parseCStringOrKeyword(self);
			self.skip(")");
			break;

		case "crt_dosname":
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			crt_dosname = parseCStringOrKeyword(self);
			self.skip(")");
			break;

		case "dependency":
		case "not_dependency": {
			local my = tok;
			local myField, otField, ot = {
				"dependency"     : ("forcedDependencies", "unforcedDependencies", "not_dependency"),
				"not_dependency" : ("unforcedDependencies", "forcedDependencies", "dependency"),
			}[tok]...;
			local other = this.operator . (otField);
			local field = HashSet(this.operator . (myField));
			this.operator . (myField) = field;
			self.next();
			self.skip("(");
			for (;;) {
				if (isCString(tok))
					tok = tok.decode("c-escape");
				else if (!tok.issymbol()) {
					self.err("Expected keyword or string after [{}(...)], but got {!r}"
						.format({ my, tok }));
				}
				if (tok in other) {
					self.err("[{0}({2!r})] was already declared as [{1}({2!r})]"
						.format({ my, ot, tok }));
				}
				field.insert(tok);
				tok = self.next();
				if (tok != ",")
					break;
				self.next();
			}
			self.skip(")");
		}	break;

		case "without_dependency":
		case "without_not_dependency": {
			local my = tok;
			local myField, ot = {
				"without_dependency"     : ("forcedDependencies", "without_not_dependency"),
				"without_not_dependency" : ("unforcedDependencies", "without_dependency"),
			}[tok]...;
			local field = HashSet(this.operator . (myField));
			this.operator . (myField) = field;
			self.next();
			self.skip("(");
			for (;;) {
				if (isCString(tok))
					tok = tok.decode("c-escape");
				else if (!tok.issymbol()) {
					self.err("Expected keyword or string after [{}(...)], but got {!r}"
						.format({ my, tok }));
				}
				field.remove(tok);
				tok = self.next();
				if (tok != ",")
					break;
				self.next();
			}
			self.skip(")");
		}	break;


		default: {
			local op = SIMPLE_SETFIELD_ANNOTATIONS.get(tok);
			if (op !is none) {
				this.operator . (op[0]) = op[1];
oneword_nocond:
				if (ppCond !is none) {
err_unexpected_if:
					self.err("Annotation [{}] cannot be used with [if(...)]"
						.format({ tok }));
				}
				self.next();
				break;
			}
			return false;
		}	break;

		}
		return true;
	}

	@@Assert that all annotations that are only valid when a
	@@function body is present match the annotations of @defaultFeatures
	public function assertDefaultAttributesWithoutImplementation(
			defaultFeatures: FunctionFeatures): string {
		if (crt_kernel !== defaultFeatures.crt_kernel)
			return "[no_]kernel";
		if (inline !== defaultFeatures.inline)
			return "[no_]inline";
		if (crt_userimpl !== defaultFeatures.crt_userimpl)
			return "[no_]userimpl";
		if (noLocal !== defaultFeatures.noLocal)
			return "[no_]local";
		if (noExternInline !== defaultFeatures.noExternInline)
			return "[no_]extern_inline";
		if (requires !== defaultFeatures.requires)
			return "[no_]requires";
		if (requiresPrefix !== defaultFeatures.requiresPrefix)
			return "[no_]requires_prefix";
		if (implPrefix !== defaultFeatures.implPrefix)
			return "[no_]impl_prefix";
		if (noAutoDependencyScanning !== defaultFeatures.noAutoDependencyScanning)
			return "[no_]auto_dependency_scanning";
		if (forcedDependencies !== defaultFeatures.forcedDependencies)
			return "[without_]dependency";
		if (unforcedDependencies !== defaultFeatures.unforcedDependencies)
			return "[without_]not_dependency";
		return none;
	}

	public function assertAllDefaultAttributesWithoutImplementation(
			self: CParser, defaultFeatures: FunctionFeatures, functionName: string) {
		local altered = assertDefaultAttributesWithoutImplementation(defaultFeatures);
		if (altered !is none) {
			self.err("Annotation [{}] requires the presence of a function {!r} body"
				.format({ altered, functionName }));
		}
	}

	public function assertSymbolicAliasOnly(
			defaultFeatures: FunctionFeatures): string {
		if (crt_name !== defaultFeatures.crt_name)
			return "[default_]crt_name";
		if (crt_noImpl != defaultFeatures.crt_noImpl)
			return "[no_]crt_impl";
		if (crt_noSelfImport != defaultFeatures.crt_noSelfImport)
			return "[no_]crt_self_import";
		if (crt_noSelfExport != defaultFeatures.crt_noSelfExport)
			return "[no_]crt_self_export";
		if (crt_dosSection !== defaultFeatures.crt_dosSection)
			return "[no_]dos_section";
		if (crt_kosSection !== defaultFeatures.crt_kosSection)
			return "[no_]kos_section";
		if (crt_dosname !== defaultFeatures.crt_dosname)
			return "[default_]dosname";
		return none;
	}

	@@Assert that no annotations are given that wouldn't make sense for
	@@symbolic aliasing functions, such that %{uchar} or '= other' aliases
	public function assertAllSymbolicAliasOnly(
			self: CParser, defaultFeatures: FunctionFeatures, functionName: string) {
		local altered = assertSymbolicAliasOnly(defaultFeatures);
		if (altered !is none) {
			self.err("Annotation [{}] cannot be used with aliasing function {!r}"
				.format({ altered, functionName }));
		}
	}

}

function truncateInlineFunctionImplementation(text: string): string {
	if ("\n#" in text || text.startswith("#"))
		return text; /* XXX: This could be done better... */
	local result = text.replace("\n", " ").replace("\t", " ");
	for (;;) {
		local newText = result.replace("  ", " ");
		if (result == newText)
			break;
		result = newText;
	}
	return result;
}

@@Add @func to @mapping under @mapping[func.name]
@@If another object was already bound to under that key,
@@replace the existing object with @DuplicateFunctionMarker.
@@NOTE: This function operates atomically between multiple threads,
@@      which is required when multiple system header definition
@@      source files are loaded by seperate threads.
function defineFunctionInMapping(
		mapping: {string: Function} | {string: LocalFunction},
		func: Function | LocalFunction) {
	for (;;) {
		if (mapping.setnew(func.name, func))
			break;
		if (mapping.setold(func.name, DuplicateFunctionMarker))
			break;
	}
}


@@Print a default, stub-library-implementation for a given @prototype
function printDefaultLibraryImplementationForPrototype(
		fp: File, prototype: FunctionPrototype,
		functionName: string | UserString) {
	fp << "{\n";
	for (local a: prototype.argv)
		fp << "\t(void)" << a.name << ";\n";
	fp << "\tCRT_UNIMPLEMENTED(" << repr(functionName) << "); /* TO" "DO */\n"
		"\tlibc_seterrno(ENOSYS);\n";
	if (prototype.isNoreturn) {
		fp << "\tfor (;;) {\n"
			"\t}\n";
	} else {
		local returnType = prototype.returnType;
		if (returnType.isVoid) {
			/* No return statement in void-functions */
		} else if (returnType.isPointer) {
			fp << "\treturn NULL;\n";
		} else {
			fp << "\treturn 0;\n";
		}
	}
	fp << "}";
}

@@Return a default, stub-library-implementation for a given @prototype
function getDefaultLibraryImplementationForPrototype(
		prototype: FunctionPrototype,
		functionName: string | UserString): string {
	local fp = File.Writer();
	printDefaultLibraryImplementationForPrototype(fp, prototype, functionName);
	return fp.string;
}

@@Scan for references to dependent functions within the given @text
@@@param: prototype: The primary function prototype.
@@                   Used to detect references to arguments, and prevent those
@@                   from ever being considered references to dependencies.
@@@param: features:  Extended function features to take into consideration
function scanForNamesOfDependentFunctions(
		text: string | UserString | Callable,
		prototype: FunctionPrototype | Callable,
		features: FunctionFeatures): Callable {
	local forcedDependencies = features.forcedDependencies;
	local unforcedDependencies = features.unforcedDependencies;
	local noAutoDependencyScanning = features.noAutoDependencyScanning;
	return []{
		local usedPrototype = prototype;
		if (usedPrototype is Callable)
			usedPrototype = usedPrototype();
		/* Always include forced dependencies */
		for (local dep: features.forcedDependencies)
			yield dep;
		/* Check if we're supposed to do automatic dependency scanning? */
		if (noAutoDependencyScanning)
			return;
		local parser = CParser(text is Callable ? text() : text);
		local knownNonDependencies: {string...} = none;
		local prevToken;
		local tok = none;
		for (;;) {
next_token:
			prevToken = tok;
			tok = parser.next();
with_next_token:
			if (!tok)
				break;
			if (!tok.issymbol())
				continue; /* Dependent functions must always have keyword names */
			if (tok.startswith("$"))
				continue; /* Functions cannot start with a '$', since that would interfere with escape rules */
			if (tok in cLanguageKeywords)
				continue; /* C language keywords can never be dependencies */
			if (tok in unforcedDependencies)
				continue; /* Explicitly not a dependencies of this function */
			if (tok in keywordEscapes)
				continue; /* Keywords that can be escaped further cannot refer to dependable functions */
			if (tok in features.forcedDependencies)
				continue; /* Already a dependency */
			if (tok in usedPrototype.argsByName)
				continue; /* Argument name -> Not a dependency */
			if (tok in knownNonDependencies)
				continue; /* Already a known non-dependency */
			/* Check if there is a function by this name. */
			local func = allFunctionsByName.get(tok);
			if (func is none)
				continue;
			if (knownNonDependencies is none)
				knownNonDependencies = HashSet();
			if (func === DuplicateFunctionMarker) {
				/* Check for header-specific, explicit dependencies */
				for (local dep: forcedDependencies) {
					if ("." !in dep)
						continue;
					if (tok == dep.rpartition(".")[2]) {
						knownNonDependencies.insert(tok);
						prevToken = tok;
						goto next_token;
					}
				}
				/* Error, unless the function was explicitly annotated as _NOT_ being a dependency! */
				parser.err("Ambiguous dependency {0!r} (consider clarifying with "
					"[dependency({0!r})] or [not_dependency({0!r})])"
					.format({ tok }));
				continue;
			}
			/* don't assume a dependency based on the next word:
			 * int error;                  // Not a dependency on error()
			 * int error = 5;              // Not a dependency on error()
			 * printf("%d, %d", error, 5); // Not a dependency on error()
			 * printf("%d", error);        // Not a dependency on error()
			 * printf("%d", &error);       // Is a dependency on error() (unless 'error' was already used in a different context)
			 */
			if (prevToken == "&") {
				knownNonDependencies.insert(tok);
				yield (tok, func);
				goto next_token;
			}
			prevToken = tok;
			tok = parser.next();
			if (tok in [")", ";", ",", "="]) {
				knownNonDependencies.insert(prevToken);
				goto with_next_token;
			}
			/* Yield items in pairs of @(dependencyName, dependencyFunc) */
			yield (prevToken, func);
			goto with_next_token;
		}
	};
}


class LoaderContext {
	this = default;

	@@The associated C-parser
	public member self: CParser;

	@@Name of the header being loaded
	public member headerName: string;

	@@The system header that is being generated
	public member result: SystemHeader;

	@@A custom callback that is invoked to parse otherwise
	@@unrecognized directives. Upon entry, the parser will
	@@point at the directive's name, and upon exit, the
	@@parser should point at the trailing @"," or @"]"
	public member customDirectivesParser: Callable with LoaderContext;

	@@Default function features
	public member defaultFeatures: FunctionFeatures = FunctionFeatures();

	@@Pushed function features
	public member pushedDefaultFeatures: {FunctionFeatures...} = none;

	@@Elements inserted at @"%[insert:std]"
	@@Set to non-@none once a @"%[insert:std]" directive has been reached
	public member result_order_headerStd: {(Function | ExposedFunction | string | UserString | Callable)...} = none;

	@@Additional elements inserted at the front of @result.order_header
	public member result_order_headerCCompat: {(Function | ExposedFunction | string | UserString | Callable)...} = none;

	@@Set to @true while inside of a @"#ifndef __CXX_SYSTEM_HEADER"-block
	public member result_order_header_in_CXX_SYSTEM_HEADER: bool = false;

	@@The C-compatibility mode header name of the generated system header (or @none if not defined)
	@@NOTE: This header name may only be defined _before_ the @"%[insert:std]" directive is reached
	public member result_ccompatHeaderName: string | UserString = none;

	@@The name of the guard to-be used for the resulting header
	public member result_headerGuardName: string | UserString = none;

	public function parseDirectives() {
		local self = this.self;
		for (;;) {
			parseDirective();
			if (self.tok != ",")
				break;
			self.next();
			if (self.tok == "]")
				break;
		}
	}

	@@List of pushed macros, in the form of tuples of @(locationList, macroList)
	public member pushedMacros: {({string...}, {string...})...} | none = none;

	public function parseDirective_push_macro() {
		local self = this.self;
		local tok = self.tok;
		/* This directive has a somewhat weird syntax that is the result of its history:
		 *    '%' '[' 'push_macro' ['(' groups ')'] [@option...] '(' macros... ')' ']'
		 *    '%' '[' 'push_macro' ['(' groups ')'] [@option...] '{' macros... '}' ']'
		 *  - Where "macros..." is a space-seperated list of keywords or
		 *    C-strings, with ","-tokens in-between simply being ignored.
		 *  - The only recognized value for @option is the literal token
		 *    sequence '@' 'undef', which will cause all pushed macros to
		 *    be #undef'ed after being pushed
		 *
		 * Example:
		 * >> %[push_macro(c, std) @undef { foo bar }]
		 * >> %(c, std){
		 * >> struct foo {
		 * >>     int bar;
		 * >> };
		 * >> }
		 * >> %[push_macro(c, std) @undef { foo bar }]
		 * Output (in locations "c" and "std"):
		 * >> #ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 * >> #pragma push_macro("foo")
		 * >> #pragma push_macro("bar")
		 * >> #endif // __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 * >> #undef foo
		 * >> #undef bar
		 * >> struct foo {
		 * >>     int bar;
		 * >> };
		 * >> #ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 * >> #pragma pop_macro("bar")
		 * >> #pragma pop_macro("foo")
		 * >> #endif // __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 */
		final local DEFAULT_LOCATION_LIST = ("c", );
		local macroList;
		local locationList = DEFAULT_LOCATION_LIST;
		local locationListContainsProperComma = true;
		local doUndefMacros = false;
		tok = self.next();
		if (tok == "(") {
			locationList = [];
			tok = self.next();
			while (tok !in ["", ")"]) {
				locationList.append(parseCStringOrKeyword(self));
				tok = self.tok;
				if (tok == ",") {
					tok = self.next();
					while (tok == ",") {
						locationListContainsProperComma = false;
						tok = self.next();
					}
				} else {
					if (tok == ")")
						break;
					locationListContainsProperComma = false;
				}
			}
			tok = self.skip(")");
			if (tok !in ["@", "{", "("]) {
				/* Special case: Simple macro list */
				macroList = locationList;
				locationList = DEFAULT_LOCATION_LIST;
				goto do_push_macroList;
			}
			if (!locationListContainsProperComma)
				self.err("Improperly formated location list");
		}
		while (tok == "@") {
			tok = self.next();
			switch (tok) {

			case "undef":
				doUndefMacros = true;
				tok = self.next();
				break;

			default:
				self.err("Unknown option {!r} for %[push_macro]"
					.format({ tok }));
			}
		}
		local closeToken;
		if (tok == "(") {
			closeToken = ")";
			self.next();
		} else if (tok == "{") {
			closeToken = "}";
			self.next();
		} else {
			self.err("Unexpected token {!r} to start macro list in %[push_macro] (expected '(' or '{')"
				.format({ tok }));
		}
		macroList = [];
		for (;;) {
			while (tok == ",")
				tok = self.next();
			if (!tok || tok == closeToken)
				break;
			macroList.append(parseCStringOrKeyword(self));
			tok = self.tok;
		}
		self.skip(closeToken);
do_push_macroList:
		if (locationList && macroList) {
			File.Writer tempfp;
			tempfp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
			for (local mac: macroList)
				tempfp << "#pragma push_macro(" << repr(mac) << ")\n";
			tempfp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
			if (doUndefMacros) {
				for (local mac: macroList)
					tempfp << "#undef " << repr(mac) << "\n";
			}
			if (pushedMacros is none)
				pushedMacros = [];
			insertText(locationList, tempfp.string);
		}
		pushedMacros.pushback((locationList, macroList));
	}

	public function parseDirective_pop_macro() {
		local self = this.self;
		if (!pushedMacros)
			self.err("%[pop_macro] without preceding %[push_macro]");
		local locationList, macroList = pushedMacros.popback()...;
		if (!locationList || !macroList)
			return;
		macroList = macroList.reversed();
		File.Writer tempfp;
		tempfp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
		for (local mac: macroList)
			tempfp << "#pragma pop_macro(" << repr(mac) << ")\n";
		tempfp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
		insertText(locationList, tempfp.string);
		self.next();
	}

	public function parseDirective_define_header_guard() {
		self.next();
		self.skip("(");
		result_headerGuardName = parseCStringOrFunctionLikeExpression(self);
		self.skip(")");
	}

	public function parseDirective_define_ccompat_header() {
		if (result_ccompatHeaderName !is none)
			self.err("Duplicate '%[define_ccompat_header(...)]' directive");
		if (result_order_headerStd !is none)
			self.err("Directive '%[define_ccompat_header(...)]' must come before '%[insert:std]'");
		self.next();
		self.skip("(");
		result_ccompatHeaderName = parseCStringOrFunctionLikeExpression(self);
		result_order_headerCCompat = [];
		self.skip(")");
	}

	public function parseDirective_define_system_header_guard() {
		self.next();
		self.skip("(");
		result_headerGuardName = parseCStringOrFunctionLikeExpression(self);
		self.skip(")");
	}

	public function parseDirective_pushdefault() {
		return parseDirective_push_default();
	}
	public function parseDirective_push_default() {
		if (pushedDefaultFeatures is none)
			pushedDefaultFeatures = [];
		pushedDefaultFeatures.pushback(copy defaultFeatures);
	}

	public function parseDirective_popdefault() {
		return parseDirective_pop_default();
	}
	public function parseDirective_pop_default() {
		if (!pushedDefaultFeatures)
			self.err("%[popdefault] without %[pushdefault]");
		defaultFeatures = pushedDefaultFeatures.popback();
	}

	public function parseDirective_default_impl_section() {
		self.tok = "section"; /* Deprecated alias for "%[default:section(...)]" */
		defaultFeatures.tryParseAttribute(self, none);
	}

	public function parseDirective_default() {
		/* %[default:...] Set default function annotations */
		self.next();
		self.skip(":");
again_parse_default_annotation:
		if (!defaultFeatures.tryParseAttribute(self, none)) {
			self.err(
				"Unknown function annotation {!r}, or "
				"annotation cannot be assigned a default value"
				.format({ self.tok }));
		}
		if (self.tok == ",") {
			self.next();
			if (self.tok != "]")
				goto again_parse_default_annotation;
		}
	}

	public function parseDirective_insert() {
		self.next();
		local tok = self.skip(":");
		local cbAttrib = "parseInsertDirective_" + tok;
		if (hasattr(this, cbAttrib))
			return this.operator . (cbAttrib)();
		self.err("Unknown operand for insert-directive: {!r}"
			.format({ tok }));
	}

	public function parseInsertDirective_std_function() {
		parseInsertDirective_function(std: true);
	}

	@@>> %[insert:function(foo)]
	@@>> %[insert:function(foo, ATTRIB)]
	@@>> %[insert:function(foo = bar)]
	@@>> %[insert:function(foo = bar, ATTRIB)]
	@@>> %[insert:std_function(foo)]
	@@>> %[insert:std_function(foo, ATTRIB)]
	@@>> %[insert:std_function(foo = bar)]
	@@>> %[insert:std_function(foo = bar, ATTRIB)]
	@@
	@@Where ATTRIB is:
	@@    ',' ~~ (ATTR_NAME ':' ATTR_VALEXPR)...
	@@
	@@Where ATTR_NAME is the name of one of the members of @ExposedFunction
	@@Where ATTR_VALEXPR is a deemon expression, as executable by @(exec from deemon)
	public function parseInsertDirective_function(std: bool = false) {
		local self = this.self;
		self.next();
		self.skip("(");
		local exposedFunction = ExposedFunction();
		local insertedFunctionNameStart = self.tokStart;
		local insertedFunctionName = parseCStringOrKeyword(self);
		if (self.tok == "=") {
			exposedFunction.exposedName = insertedFunctionName;
			self.next();
			insertedFunctionNameStart = self.tokStart;
			insertedFunctionName = parseCStringOrKeyword(self);
		}
		exposedFunction.func = []{
			try {
				return findFunctionByName(insertedFunctionName);
			} catch (Error as e) {
				self.errAt(insertedFunctionNameStart, e.message);
			}
		};
		if (self.tok == ",") {
			self.next();
			while (self.tok !in ["", ")"]) {
				local propStart = self.tokStart;
				local prop = parseCStringOrKeyword(self);
				self.skip(":");
				local valExprStart = self.tokStart;
				local valExpr = parseAllUntilRParenAsString(self);
				try {
					valExpr = exec(valExpr);
				} catch (Error as e) {
					self.errAt(valExprStart, "{} (while executing {!r})"
						.format({ e.message, valExpr }));
				}
				try {
					exposedFunction.operator . (prop) = valExpr;
				} catch (Error as e) {
					self.errAt(propStart, e.message);
				}
				if (self.tok != ",")
					break;
				self.next();
			}
		}
		if (std) {
			if (result_order_headerStd is none) {
				self.err("%[insert:std_function(...)] used, but "
				         "'%[insert:std]' hasn't been encountered, yet");
			}
			result_order_headerStd.append(exposedFunction);
			local gblGuard = false;
			local nsStd = NAMESPACES["std"];
			local importCondition = "$has_function({})".format({ insertedFunctionName });
			exposedFunction.namespaceOverride = NAMESPACES["std"];
			local exposedName = exposedFunction.exposedName;
			if (exposedFunction.guardName !== false) {
				local stdGuard = exposedFunction.guardName;
				if (stdGuard === true)
					stdGuard = nsStd.keyDefaultGuard(exposedName);
				gblGuard = GLOBAL_NAMESPACE.keyDefaultGuard(exposedName);
				importCondition = "defined({})".format({ stdGuard });
			}
			local importFunction = Function(
				name:                     exposedName,
				originalSystemHeaderName: headerName,
				bindings: []{
					yield FunctionBinding(
						ppCond:     importCondition,
						prototypes: exposedFunction.func().functionBindings.first.prototypes,
						binding:    nsStd);
				});
			if (gblGuard !== false) {
				local gblExposure = copy exposedFunction;
				gblExposure.func              = importFunction;
				gblExposure.guardName         = gblGuard;
				gblExposure.namespaceOverride = GLOBAL_NAMESPACE;
				importFunction = gblExposure;
			}
			if (!result_order_header_in_CXX_SYSTEM_HEADER) {
				result.order_header.append(CXX_SYSTEM_HEADER_START);
				result_order_header_in_CXX_SYSTEM_HEADER = true;
			}
			result.order_header.append(importFunction);
			if (result_ccompatHeaderName !is none)
				result_order_headerCCompat.append(importFunction);
		} else {
			if (result_order_header_in_CXX_SYSTEM_HEADER) {
				result.order_header.append(CXX_SYSTEM_HEADER_END);
				result_order_header_in_CXX_SYSTEM_HEADER = true;
			}
			result.order_header.append(exposedFunction);
		}
		self.skip(")");
	}

	public function parseInsertDirective_extern() {
		/* >> %[insert:extern(foo)]
		 * Alias for:
		 * >> %[insert:function(foo, guardName: true)] */
		local self = this.self;
		self.next();
		self.skip("(");
		local functionNameStart = self.tokStart;
		local functionName = parseCStringOrKeyword(self);
		/* Only insert into "c" namespace! */
		if (result_order_header_in_CXX_SYSTEM_HEADER) {
			result.order_header.append(CXX_SYSTEM_HEADER_END);
			result_order_header_in_CXX_SYSTEM_HEADER = false;
		}
		result.order_header.append(ExposedFunction(
			func: [] {
				try {
					return findFunctionByName(functionName);
				} catch (Error as e) {
					self.errAt(functionNameStart, e.message);
				}
			},
			exposedName: functionName,
			guardName:   true));
		self.skip(")");
	}

	public function parseInsertDirective_std() {
		/* %[insert:std] */
		if (result_order_headerStd !is none)
			self.err("Multiple '%[insert:std]' directives");
		else {
			assert result_order_headerStd is none;
			assert result_order_header_in_CXX_SYSTEM_HEADER === false;
			result_order_headerStd = [];
			/* Inject a printer callback for generating std:: declarations */
			result.order_header.append([](fp: CWriter, escapeMode: int) {
				local oldNs = fp.namespace;
				fp.namespace = NAMESPACES["std"];
				for (local part: result_order_headerStd) {
					if (part is Function || part is ExposedFunction) {
						part.cprintHeaderDeclaration(fp, escapeMode);
					} else if (part is Callable) {
						part(fp, escapeMode);
					} else {
						fp << part;
					}
				}
				fp.namespace = oldNs;
			});
		}
		self.next();
	}

	public function parseDirective_define_wchar_replacement_header() {
		return parseDirective_define_wchar_replacement(true);
	}
	public function parseDirective_define_wchar_replacement(header: bool = false) {
		local tok = self.tok;
		local map = header
			? wcharReplacementHeaders
			: wcharReplacementEscapes;
		self.next();
		self.skip("(");
		local orig = parseCStringOrKeyword(self);
		self.skip("=");
		local c16 = parseCStringOrKeyword(self);
		self.skip(",");
		local c32 = parseCStringOrKeyword(self);
		local newRepl = (c16, c32);
		local ok, oldRepl = map.setnew_ex(orig, newRepl)...;
		if (!ok && oldRepl != newRepl) {
			self.err("wchar re-definition: {!r} defined as "
				"(c16:{!r},c32:{!r}) (was: (c16:{!r},c32:{!r}))"
				.format({ orig, c16, c32, oldRepl[0], oldRepl[1] }));
		}
		self.skip(")");
	}

	public function parseDirective_define_c_language_keyword() {
		local self = this.self;
		self.next();
		self.skip("(");
		while (self.tok !in ["", ")"]) {
			local kwd = str parseCStringOrKeyword(self);
			cLanguageKeywords.insert(kwd);
			if (self.tok != ",")
				break;
			self.next();
		}
		self.skip(")");
	}

	public function parseDirective_define_replacement() {
		self.next();
		self.skip("(");
		local a = parseCStringOrKeyword(self);
		self.skip("=");
		local b = parseCStringOrKeyword(self);
		local ok, oldRepl = keywordEscapes.setnew_ex(a, b)...;
		if (!ok && oldRepl != b) {
			self.err("Replacement re-definition: {!r} defined as {!r} (was: {!r})"
				.format({ a, b, oldRepl }));
		}
		self.skip(")");
	}

	public function parseDirective_define_str2wcs_replacement() {
		self.next();
		self.skip("(");
		local a = parseCStringOrKeyword(self);
		self.skip("=");
		local b = parseCStringOrKeyword(self);
		local ok, oldRepl = str2wcsReplacementEscapes.setnew_ex(a, b)...;
		if (!ok && oldRepl != b) {
			self.err("str2wcs replacement re-definition: {!r} defined as {!r} (was: {!r})"
				.format({ a, b, oldRepl }));
		}
		self.skip(")");
	}

	public function parseDirective_define_double_replacement() {
		local tok = self.tok;
		self.next();
		self.skip("(");
		local orig = parseCStringOrKeyword(self);
		self.skip("=");
		local flt = parseCStringOrKeyword(self);
		self.skip(",");
		local ldbl = parseCStringOrKeyword(self);
		local newRepl = (flt, ldbl);
		local ok, oldRepl = mathReplacementEscapes.setnew_ex(orig, newRepl)...;
		if (!ok && oldRepl != newRepl) {
			self.err("%[define_double_replacement]: "
			         "Re-definition of {!r} as {!r} (was: {!r})"
				.format({ orig, flt, ldbl, oldRepl[0], oldRepl[1] }));
		}
		self.skip(")");
	}

	public function parseDirective_define_double2ldouble_replacement() {
		return parseDirective_define_double2float_replacement(MATH_REPLACEMENT_MODE_LDBL);
	}
	public function parseDirective_define_double2float_replacement(mode: int = none) {
		local tok = self.tok;
		self.next();
		self.skip("(");
		local origStart = self.tokStart;
		local orig = parseCStringOrKeyword(self);
		self.skip("=");
		local repl = parseCStringOrKeyword(self);
		try {
			math_defineReplacement(orig, repl,
				mode is none ? MATH_REPLACEMENT_MODE_FLOAT : mode);
		} catch (Error as e) {
			self.errAt(origStart, e.message);
		}
		self.skip(")");
	}

	@@Define simple textual replacement macros
	@@>%[define(MACRO_NAME = TEXT INSERTED AS REPLACEMENT)]
	@@This differs from @"%[define_replacement(...)]", in that the keyword
	@@is replaced in all situations, regardless of escape mode, as well as
	@@the fact that the replacement text will be re-parsed for further macros,
	@@as well as replacements.
	@@Note that macros defined using this directive are expanded at the same
	@@time as special builtin macros such as @"$has_function"
	public function parseDirective_define() {
		self.next();
		self.skip("(");
		local a = parseCStringOrKeyword(self);
		self.skip("=");
		local b = parseCStringOrAllUntilRParen(self);
		local ok, oldDecl = keywordMacros.setnew_ex(a, b)...;
		if (!ok) {
			if (oldDecl !is string) {
				self.err("macro re-definition: {!r} defined as {!r} (was: <Custom Function>)"
					.format({ a, b }));
			} else if (oldDecl != b) {
				self.err("macro re-definition: {!r} defined as {!r} (was: {!r})"
					.format({ a, b, oldDecl }));
			}
		}
		self.skip(")");
	}


	@@Parse a directive. Upon entry, the parser will
	@@point at the directive's name, and upon exit, the
	@@parser should point at the trailing @"," or @"]"
	public function parseDirective() {
		/* %[directive...] */
		local self = this.self;
		local tok = self.tok;
		if (tok == "[") {
			self.next();
			parseDirectives();
			self.skip("]");
		} else {
			local cbAttrib = "parseDirective_" + tok;
			if (hasattr(this, cbAttrib))
				return this.operator . (cbAttrib)();
			/* Give a custom directives parser a chance */
			if (!customDirectivesParser(this))
				self.err("Unknown directive: {!r}".format({ tok }));
		}
	}

	@@Insert text at the @"c" location
	public function insertText_c(text: string | UserString) {
		if (result_order_header_in_CXX_SYSTEM_HEADER) {
			result.order_header.append(CXX_SYSTEM_HEADER_END);
			result_order_header_in_CXX_SYSTEM_HEADER = false;
		}
		result.order_header.append(text);
	}

	@@Insert text at the @"std" location
	public function insertText_std(text: string | UserString) {
		if (result_order_headerStd is none) {
			self.err("Text cannot be inserted into 'std' "
			         "before '%[insert:std]' has been encountered");
		}
		result_order_headerStd.append(text);
	}

	@@Insert text at the @"ccompat" location
	public function insertText_ccompat(text: string | UserString) {
		if (result_order_headerCCompat is none) {
			self.err("Text cannot be inserted into 'ccompat' before "
			         "'%[define_ccompat_header()]' has been encountered");
		}
		result_order_headerCCompat.append(text);
	}

	@@Insert text at the @"libc_fast" location
	public function insertText_libc_fast(text: string | UserString) {
		result.order_libcHeader.append(text);
	}

	@@Insert text at the @"libc_core" location
	public function insertText_libc_core(text: string | UserString) {
		result.order_libcCoreHeader.append(text);
	}

	@@Insert text at the @"auto_header" location
	public function insertText_auto_header(text: string | UserString) {
		result.order_libcAutoHeader.append(text);
	}

	@@Insert text at the @"auto_source" location
	public function insertText_auto_source(text: string | UserString) {
		result.order_libcAutoSource.append(text);
	}

	@@Insert text at the @"user" location
	public function insertText_user(text: string | UserString) {
		result.order_libcUserHeader.append(text);
	}

	@@Insert text at the given location
	public function insertText(
			location: string | UserString | {string...}, text: string | UserString) {
		if (location is string || location is UserString)
			return this.operator . ("insertText_" + location)(text);
		for (local loc: location)
			this.operator . ("insertText_" + loc)(text);
	}

}



@@Load system header definitions
@@@param: customDirectivesParser: A custom callback that is invoked to parse otherwise
@@                                unrecognized directives. Upon entry, the parser will
@@                                point at the directive's name, and upon exit, the
@@                                parser should point at the trailing @"," or @"]"
function loadSystemHeaderDefinitions(
		self: CParser, headerName: string,
		customDirectivesParser: Callable with LoaderContext = none): SystemHeader {
	final local result: SystemHeader = SystemHeader(name: headerName);
	if (!allSystemHeaders.setnew(headerName, result))
		throw Error("Duplicate system header: {!r}".format({ headerName }));
	final local context: LoaderContext = LoaderContext(
		self: self, headerName: headerName, result: result,
		customDirectivesParser: customDirectivesParser);
	local tok = self.tok;
	if (!tok)
		tok = self.next();
	/* Standard system header prefix */
	result.order_header.append(
		"#include {0[0]}\n"
		"#include {0[1]}\n"
		"\n"
		"#ifdef __COMPILER_HAVE_PRAGMA_GCC_SYSTEM_HEADER\n"
		"#pragma GCC system_header\n"
		"#endif /* __COMPILER_HAVE_PRAGMA_GCC_SYSTEM_HEADER */\n"
		"\n"
		.format({
			"." in headerName
				? ('<__stdinc.h>', '<__crt.h>')
				: ('"__stdinc.h"', '"__crt.h"')
			}));
	while (tok) {
		if (tok == "%") {
			/* Directive / text-injections */
			local nextCh = self.text[self.tokEnd];
			switch (nextCh) {

			case "[":
				self.next();
				self.next();
				context.parseDirectives();
				self.skip("]");
				break;

			case "(": {
				/* %(std, c, ...){ ... } */
				local tagList: {string...} = HashSet();
				self.next();
				tok = self.next();
				while (tok !in ["", ")"]) {
					if (isCString(tok))
						tok = tok.decode("c-escape");
					else if (!tok.issymbol()) {
						self.err("Expected keyword or string in embedded string tag list, but got {!r}"
							.format({ tok }));
					}
					if (tok !in KNOWN_STRING_TAGS) {
						self.err("Unknown tag for embedded strings: {!r}"
							.format({ tok }));
					}
					tagList.insert(tok);
					tok = self.next();
					if (tok != ",")
						break;
					tok = self.next();
				}
				if (tok != ")") {
					self.err("Unexpected token (expected {!r}, but got {!r})"
						.format({ ")", tok }));
				}
				local textStart = self.tokEnd;
				local textEnd = textStart;
				if (textStart + 1 < self.end) {
					if (self.text[textStart] == "{") {
						/* Block-string: %(tags...){ TEXT } */
						textStart = textStart + 1;
						self.next();
						tok = self.next();
						while (tok !in ["", "}"]) {
							if (tok in "({[")
								self.skipPair();
							tok = self.next();
						}
						textEnd = self.tokStart;
						if (self.text.islf(textStart))
							++textStart;
						self.skip("}");
					} else {
						/* Single-line: %(tags...)TEXT  */
						textEnd = self.text.find("\n", textStart, self.end);
						if (textEnd < 0)
							textEnd = self.end;
						else {
							++textEnd;
						}
						self.tokEnd = textEnd;
						self.next();
					}
				} else {
					self.next();
				}
				local text = self.getUserString(textStart, textEnd);
				/* Insert strings where appropriate */
				context.insertText(tagList, text);
			}	break;

			case "{": {
				/* %{ ... }  (Same as %(c){ ... }) */
				self.next();
				local textStart = self.tokEnd;
				tok = self.next();
				while (tok !in ["", "}"]) {
					if (tok in "({[")
						self.skipPair();
					tok = self.next();
				}
				if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_END);
					context.result_order_header_in_CXX_SYSTEM_HEADER = false;
				}
				if (self.text.islf(textStart))
					++textStart;
				result.order_header.append(
					self.getUserString(textStart, self.tokStart));
				self.skip("}");
			}	break;

			default: {
				/* Anything else following a %-character is a single-line,
				 * default target embedded string destined for <string.h> */
				local textStart = self.tokEnd;
				local textEnd = self.text.find("\n", textStart, self.end);
				if (textEnd < 0)
					textEnd = self.end;
				else {
					++textEnd;
				}
				if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_END);
					context.result_order_header_in_CXX_SYSTEM_HEADER = false;
				}
				result.order_header.append(
					self.getUserString(textStart, textEnd));
				self.tokEnd = textEnd;
				self.next();
			}	break;
			}
			tok = self.tok;
			continue;
		}
		if (tok == ";") {
			tok = self.next();
			continue;
		}
		local currentFeatures = copy context.defaultFeatures;
		local current = Function(originalSystemHeaderName: headerName);
		local currentPrototype = FunctionPrototype(cc: DEFAULT_CC, nothrow: DEFAULT_NOTHROW);
		local currentPrototypes = { ("1", { currentPrototype }) };
		local currentLibraryFunction = LibraryFunction(originalSystemHeaderName: headerName);
		local currentDosLibraryFunction: LibraryFunction = none;
		/* # of leading entires in @current.bindings that should appear before the self-binding */
		local numPreferredBindings = 0;
		@@Additional function bindings that will be
		local lateFunctionBindings: {FunctionBinding...} = ();
		local defaultAttributes: {UserString...} = none;
		local functionArgumentNamesOverride: {(string | UserString)...} = none;
continue_current:
		if (tok == "[") {
			local scopeConditions = [];
			local currentConditions = none;
again_parse_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "if": {
					/* Conditional annotations */
					self.next();
					self.skip("(");
					local ppAddend = parseCStringOrAllUntilRParen(self);
					self.skip(")");
					if (currentConditions is none)
						currentConditions = ppAddend;
					else {
						currentConditions = "({}) && ({})"
							.format({ currentConditions, ppAddend });
					}
				}	break;

				case "doc": {
					if (current.documentation !is string)
						self.err("[doc(...)] used alongside [doc_alias(...)]");
					self.next();
					self.skip("(");
					local line = parseCStringOrAllUntilRParen(self);
					self.skip(")");
					if (current.documentation)
						current.documentation += "\n";
					current.documentation += line;
				}	break;

				case "doc_alias": {
					if (current.documentation !is string)
						self.err("[doc_alias(...)] annotation already used");
					if (current.documentation)
						self.err("[doc_alias(...)] used when a custom doc string was already set");
					self.next();
					self.skip("(");
					local funcNameStart = self.tokStart;
					local funcName = parseCStringOrKeyword(self);
					self.skip(")");
					current.documentation = []{
						local func: Function;
						try {
							func = findFunctionByName(funcName);
						} catch (Error as e) {
							self.errAt(funcNameStart, e.message);
						}
						return func.documentationString;
					};
				}	break;

				case "[":
					scopeConditions.pushback(currentConditions);
					goto again_parse_annotations;

				case "argument_names":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					self.next();
					self.skip("(");
					functionArgumentNamesOverride = List(
						parseCStringOrFunctionLikeExpressionList(self));
					self.skip(")");
					break;

				case "cc":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					self.next();
					self.skip("(");
					currentPrototype.cc = parseCStringOrAllUntilRParen(self);
					self.skip(")");
					break;

				case "throws":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					self.next();
					if (self.tok == "(") {
						self.next();
						currentPrototype.nothrow = "THROWS({})"
							.format({ parseCStringOrAllUntilRParen(self) });
						self.skip(")");
					} else {
						currentPrototype.nothrow = "THROWS(...)";
					}
					break;

				case "nothrow":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					self.next();
					if (self.tok == "(") {
						self.next();
						currentPrototype.nothrow = parseCStringOrAllUntilRParen(self);
						self.skip(")");
					} else {
						currentPrototype.nothrow = "NOTHROW";
					}
					break;

				case "vartypes":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					self.next();
					self.skip("(");
					currentPrototype.ellipsisArgumentTypes = [];
					while (self.tok !in ["", ")"]) {
						local typ, none = parseCTypeAndName(self)...;
						currentPrototype.ellipsisArgumentTypes.append(typ);
						if (self.tok != ",")
							break;
						self.next();
					}
					self.skip(")");
					break;

				case "decl_prefix":
					self.next();
					self.skip("(");
					if (currentPrototype.declPrefix !is List)
						currentPrototype.declPrefix = List(currentPrototype.declPrefix);
					currentPrototype.declPrefix.append(parseCStringOrAllUntilRParen(self));
					self.skip(")");
					break;

				case "decl_include":
					self.next();
					self.skip("(");
					if (currentPrototype.declPrefix !is List)
						currentPrototype.declPrefix = List(currentPrototype.declPrefix);
					while (self.tok !in ["", ")"]) {
						currentPrototype.declPrefix.append(
							"#include " + parseCStringOrAllUntilRParen(self));
						if (self.tok != ",")
							break;
						self.next();
					}
					self.skip(")");
					break;

				case "attribute":
				case "attributes":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					if (defaultAttributes is none)
						defaultAttributes = [];
					self.next();
					self.skip("(");
					defaultAttributes.append(
						parseCStringOrAllUntilRParen(self));
					self.skip(")");
					break;

				case "intern_alias": {
					self.next();
					self.skip("(");
					if (isCString(tok))
						tok = tok.decode("c-escape");
					else if (!tok.issymbol()) {
						self.err("Expected keyword or string in [intern_alias(...)], but got {!r}"
							.format({ tok }));
					}
					currentLibraryFunction.bindings.append(
						LibraryFunctionBinding(
							ppCond:  currentConditions,
							binding: "libc_" + tok));
					self.next();
					self.skip(")");
				}	break;

				case "export_alias":
				case "export_raw_alias":
				case "preferred_export_alias":
				case "preferred_export_raw_alias": {
					local mode = tok;
					self.next();
					tok = self.skip("(");
					while (tok !in ["", ")"]) {
						if (isCString(tok))
							tok = tok.decode("c-escape");
						else if (!tok.issymbol()) {
							self.err("Expected string or keyword for [{}(...)], but got {!r}"
								.format({ mode, tok }));
						}
						local ppCond = currentConditions;
						if (!mode.endswith("raw_alias"))
							ppCond = constructAliasConditions(ppCond, tok);
						local binding = FunctionBinding(
							ppCond:     ppCond,
							prototypes: currentPrototypes,
							binding:    tok);
						if (mode.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, binding);
							++numPreferredBindings;
						} else {
							current.bindings.append(binding);
						}
						currentLibraryFunction.exportSymbolNames
							.append((currentConditions, tok));
						tok = self.next();
						if (tok != ",")
							break;
						tok = self.next();
					}
					self.skip(")");
				}	break;

				case "export_as":
				case "alternate_name":  /* Deprecated alias */
				case "alternate_names": /* Deprecated alias */
					self.next();
					tok = self.skip("(");
					while (tok !in ["", ")"]) {
						if (isCString(tok))
							tok = tok.decode("c-escape");
						else if (!tok.issymbol()) {
							self.err("Expected string or keyword for [export_as(...)], but got {!r}"
								.format({ tok }));
						}
						currentLibraryFunction.exportSymbolNames
							.append((currentConditions, tok));
						tok = self.next();
						if (tok != ",")
							break;
						tok = self.next();
					}
					self.skip(")");
					break;

				case "alias":
				case "raw_alias":
				case "preferred_alias":
				case "preferred_raw_alias":
					self.next();
					self.skip("(");
					while (self.tok !in ["", ")"]) {
						local assemblyName = parseCStringOrFunctionLikeExpression(self);
						local ppCond = currentConditions;
						if (!tok.endswith("raw_alias"))
							ppCond = constructAliasConditions(ppCond, assemblyName);
						local binding = FunctionBinding(
							ppCond:     ppCond,
							prototypes: currentPrototypes,
							binding:    assemblyName);
						if (tok.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, binding);
							++numPreferredBindings;
						} else {
							current.bindings.append(binding);
						}
						if (self.tok != ",")
							break;
						self.next();
					}
					self.skip(")");
					break;

				case "bind_local_function":
				case "preferred_bind_local_function":
					self.next();
					self.skip("(");
					while (self.tok !in ["", ")"]) {
						local functionName = parseCStringOrFunctionLikeExpression(self);
						local binding = FunctionBinding(
							ppCond:     currentConditions is none ? "1" : currentConditions,
							prototypes: currentPrototypes,
							binding:    [] -> findLocalFunctionByName(functionName));
						if (tok.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, binding);
							++numPreferredBindings;
						} else {
							current.bindings.append(binding);
						}
						if (self.tok != ",")
							break;
						self.next();
					}
					self.skip(")");
					break;

				case "inline_as":
					self.next();
					self.skip("(");
					self.inline = parseCStringOrKeyword(self);
					self.skip(")");
					break;

				case "inline":
				case "forceinline":
				case "extern_inline":
				case "raw_extern_inline":
				case "preferred_inline":
				case "preferred_forceinline":
				case "preferred_extern_inline":
				case "preferred_raw_extern_inline":
					/* >> '[' 'inline'      ']'    // Defaultable
					 * >> '[' 'forceinline' ']'    // Defaultable
					 * >> '[' [IF(...),] ('preferred_inline' | 'inline') '(' BODY ')' ']'
					 * >> '[' [IF(...),] ('preferred_forceinline' | 'forceinline') '(' BODY ')' ']'
					 * >> '[' [IF(...),] ('preferred_extern_inline' | 'extern_inline') '(' SYMBOL_NAME ',' BODY ')' ']'
					 * >> '[' [IF(...),] ('preferred_raw_extern_inline' | 'raw_extern_inline') '(' SYMBOL_NAME ',' BODY ')' ']'
					 */
					if (self.next() == "(") {
						/* With arguments: Define an inline function implementation */
						local externSymbolName;
						self.next();
						if (tok.endswith("extern_inline")) {
							externSymbolName = parseCStringOrKeyword(self);
							self.skip(",");
						}
						local body = parseCStringOrAllUntilRParen(self);
						if (!currentFeatures.noInlineTruncate)
							body = truncateInlineFunctionImplementation(str(body));
						self.skip(")");
						local bindingCond = currentConditions is none ? "1" : currentConditions;
						if (!tok.endswith("raw_extern_inline")) {
							local ppHave = keyCrtHave(externSymbolName);
							if (bindingCond == "1")
								bindingCond = ppHave;
							else {
								bindingCond = "({})&&{}".format({ bindingCond, ppHave });
							}
						}
						local binding = FunctionBinding(
							ppCond:     bindingCond,
							prototypes: currentPrototypes,
							binding:    []{
							local ifun = InlineFunction(
								impl: FunctionImplementation(
									body: body,
									name: current.name));
							if (tok.endswith("extern_inline")) {
								ifun.mode                = "__EXTERNINLINE";
								ifun.externInlineAsmname = externSymbolName;
							} else if ("force" in tok) {
								ifun.mode = "FORCELOCAL";
							}
							return ifun;
						});
						if (tok.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, binding);
							++numPreferredBindings;
						} else {
							current.bindings.append(binding);
						}
					} else {
						if (tok !in ["inline", "forceinline"])
							self.skip("(");
						if (currentConditions !is none)
							goto illegal_annotation_with_condition;
						currentFeatures.inline = {
							"inline"      : "LOCAL",
							"forceinline" : "FORCELOCAL"
						}[tok];
					}
					break;

				case "crtbuiltin": {
					/* >> [[crtbuiltin]] size_t strlen(char const *__restrict str);
					 * Same as:
					 * >> [[if(__has_builtin(__builtin_strlen) && defined(__LIBC_BIND_CRTBUILTINS)),
					 * >>   preferred_extern_inline(strlen, { return __builtin_strlen(str); })
					 * >> ]] strlen(char const *__restrict str);
					 * HEADER:
					 * >> #if __has_builtin(__builtin_strlen) && defined(__LIBC_BIND_CRTBUILTINS) && defined(__CRT_HAVE_strlen)
					 * >> __CEIDECLARE(,size_t,__NOTHROW_NCX,strlen,(char const *__restrict __str),{ return __builtin_strlen(__str); })
					 * >> #elif defined(__CRT_HAVE_strlen)
					 * >> __CDECLARE(,size_t,__NOTHROW_NCX,strlen,(char const *__restrict __str),(__str))
					 * >> #endif // ...
					 */
					local asmnameOverride = none;
					if (self.next() == "(") {
						asmnameOverride = parseCStringOrKeyword(self);
						self.skip(")");
					}
					current.bindings.insert(numPreferredBindings, []{
						local asmname = asmnameOverride;
						if (asmname is none)
							asmname = current.name;
						local builtinName = "__builtin_" + asmname;
						local bindingCond =
							"__has_builtin({})&&"
							"defined(__LIBC_BIND_CRTBUILTINS)&&"
							"{}".format({ builtinName, keyCrtHave(asmname) });
						if (currentConditions !is none)
							bindingCond = "({})&&{}".format({ currentConditions, bindingCond });
						File.Writer bodyFp;
						bodyFp << "{ return " << builtinName << "(";
						/* Print argument names */
						local isFirst = true;
						/* TODO: currentPrototype can't be used if the function ends up
						 *       inheriting some other function's prototypes:
						 * >> [[crtbuiltin]] wcslen(*) %{generate(str2wcs)} */
						for (local a: currentPrototype.argv) {
							if (!isFirst)
								bodyFp << ", ";
							isFirst = false;
							bodyFp << a.name;
						}
						bodyFp << "); }";
						return FunctionBinding(
							ppCond:     bindingCond,
							/* TODO: currentPrototypes can't be used if the function ends up
							 *       inheriting some other function's prototypes:
							 * >> [[crtbuiltin]] wcslen(*) %{generate(str2wcs)}
							 * HINT: Completeness could can be detected by:
							 *    >> (for (local none, ps: currentPrototypes)
							 *    >>     for (local p: ps)
							 *    >>         p.returnType is bound
							 *    >> ) && ...;
							 */
							prototypes: currentPrototypes,
							binding:    InlineFunction(
								mode: "__EXTERNINLINE",
								impl: FunctionImplementation(
									body: bodyFp.string,
									name: current.name),
								externInlineAsmname: asmname));
					});
					++numPreferredBindings;
				}	break;


				{
					local wholeCond;
					local assemblyName;
				case "rlim64_variant_of":
				case "time64_variant_of":
				case "off64_variant_of":
				case "largefile64_variant_of":
				case "dirent64_variant_of":
				case "statfs64_variant_of":
				case "longdouble_variant_of":
				case "preferred_rlim64_variant_of":
				case "preferred_time64_variant_of":
				case "preferred_off64_variant_of":
				case "preferred_largefile64_variant_of":
				case "preferred_dirent64_variant_of":
				case "preferred_statfs64_variant_of":
				case "preferred_longdouble_variant_of":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					wholeCond = {
						"rlim64_variant_of"      : "__SIZEOF_RLIM32_T__ == __SIZEOF_RLIM64_T__",
						"time64_variant_of"      : "__SIZEOF_TIME32_T__ == __SIZEOF_TIME64_T__",
						"off64_variant_of"       : "__SIZEOF_OFF32_T__ == __SIZEOF_OFF64_T__",
						"largefile64_variant_of" : "!defined(__O_LARGEFILE) || (__O_LARGEFILE+0) == 0",
						"dirent64_variant_of"    : "defined(_DIRENT_MATCHES_DIRENT64)",
						"statfs64_variant_of"    : "defined(_STATFS_MATCHES_STATFS64)",
						"longdouble_variant_of"  : "defined(__ARCH_LONG_DOUBLE_IS_DOUBLE)",
					}[tok.lsstrip("preferred_")];
					self.next();
					self.skip("(");
					assemblyName = parseCStringOrAllUntilRParen(self);
					goto do_handle_alt_variant_of;
				case "alt_variant_of":
				case "preferred_alt_variant_of":
					/*    [[alt_variant_of(cond, name)]]
					 * or [[if(cond), alt_variant_of(name)]]
					 * Same as:
					 * [[if(cond), alias(name)]]
					 * [[if(cond), intern_alias(name)]]
					 * In other words: When "cond" is true, link the current function
					 *                 against some other function "name" in both the
					 *                 system header, as well as the internal libc
					 *                 implementation. */
					self.next();
					self.skip("(");
					wholeCond = parseCStringOrAllUntilRParen(self);
					if (self.tok == ",") {
						self.next();
						assemblyName = parseCStringOrAllUntilRParen(self);
						if (currentConditions !is none && currentConditions != "1") {
							if (wholeCond == "1")
								wholeCond = currentConditions;
							else {
								wholeCond = "({}) && ({})"
									.format({ currentConditions, wholeCond });
							}
						}
					} else {
						assemblyName = wholeCond;
						wholeCond    = currentConditions;
					}
do_handle_alt_variant_of:
					currentLibraryFunction.bindings.append(
						LibraryFunctionBinding(
							ppCond:  wholeCond,
							binding: "libc_" + assemblyName));
					local binding = FunctionBinding(
						ppCond:     constructAliasConditions(wholeCond, assemblyName),
						prototypes: currentPrototypes,
						binding:    assemblyName);
					if (tok.startswith("preferred_")) {
						current.bindings.insert(numPreferredBindings, binding);
						++numPreferredBindings;
					} else {
						current.bindings.append(binding);
					}
					self.skip(")");
				}	break;

				default:
					if (isCString(tok)) {
						if (currentConditions !is none)
							goto illegal_annotation_with_condition;
						if (defaultAttributes is none)
							defaultAttributes = [];
						defaultAttributes.append(tok.decode("c-escape"));
						self.next();
					} else if (!currentFeatures.tryParseAttribute(self, currentConditions)) {
						local anno = SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS.get(tok);
						if (anno is none)
							anno = SIMPLE_ATTRIBUTE_ANNOTATIONS.get(tok);
						if (anno !is none) {
							if (currentConditions !is none)
								goto illegal_annotation_with_condition;
							if (anno) {
								if (defaultAttributes is none)
									defaultAttributes = List();
								defaultAttributes.append(anno);
							}
							self.next();
						} else {
							anno = SIMPLE_NOTHROW_ANNOTATIONS.get(tok);
							if (anno !is none) {
								currentPrototype.nothrow = anno;
								self.next();
							} else if (tok.startswith("ATTR_")) {
								/* Attribute annotation. */
								if (currentConditions !is none)
									goto illegal_annotation_with_condition;
								if (defaultAttributes is none)
									defaultAttributes = [];
								defaultAttributes.append(parseCStringOrAllUntilRParen(self));
							} else {
								self.err("Unknown function annotation {!r}"
									.format({ tok }));
							}
						}
					}
					break;
illegal_annotation_with_condition:
					self.err("Annotation [{}] cannot be used [if(...)]"
						.format({ tok }));
					break;
				}
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_annotation_rbracket:
			tok = self.skip("]");
			if (scopeConditions) {
				currentConditions = scopeConditions.popback();
				if (tok != ",")
					goto again_skip_annotation_rbracket;
				goto again_parse_annotations;
			}
			goto continue_current;
		}
		if (tok == "@@") {
			/* Documentation strings */
			local lineStart = self.tokEnd;
			local lineEnd = self.text.find("\n", lineStart, self.end);
			if (lineEnd < 0)
				lineEnd = self.end;
			if (current.documentation !is string)
				self.err("Documentation string used alongside [doc_alias(...)]");
			if (current.documentation)
				current.documentation += "\n";
			current.documentation += self.text[lineStart:lineEnd];
			self.tokEnd = lineEnd;
			tok = self.next();
			goto continue_current;
		}
		/* Either the function's return type, or its name */
		if (!tok.issymbol()) {
			self.err("Unexpected top-level token {!r}"
				.format({ tok }));
		}
		local currentName;
		local currentNameTokStart;
		{
			local returnTypeStart = self.tokStart;
			local returnTypeEnd = returnTypeStart;
			local lastKeyword;
			for (;;) {
				local kwdEnd = self.tokEnd;
				currentNameTokStart = self.tokStart;
				lastKeyword = tok;
				tok = self.next();
				if (!tok.issymbol() || !tok) {
					if (tok in "*&")
						continue;
					if (tok in "[{") {
						self.skipPair(tok);
						continue;
					}
					break;
				}
				returnTypeEnd = kwdEnd;
			}
			/* lastKeyword is the function's name, and the string between
			 * returnTypeStart...returnTypeEnd is the (preliminary) return type. */
			current.name = currentName = lastKeyword;
			if (tok == ":")
				tok = self.next();
			if (tok != "(")
				self.err("Expected '(' after function name {!r}, but got {!r}"
					.format({ lastKeyword, tok }));
			if (returnTypeEnd > returnTypeStart) {
				currentPrototype.returnType = CType(
					self.getUserString(returnTypeStart, returnTypeEnd));
			}
		}
		//print("Function: ", headerName, "::", currentName);

		/* Bind the function against its own symbol */
		if (!currentFeatures.crt_noSelfImport) {
			local usedCrtName = currentFeatures.crt_name;
			if (usedCrtName is none)
				usedCrtName = currentName;
			current.bindings.insert(
				numPreferredBindings, FunctionBinding(
					ppCond:     keyCrtHave(usedCrtName),
					prototypes: currentPrototypes,
					binding:    usedCrtName));
		}

		/* If the function isn't being exported from libc, then make sure
		 * that certain attributes that would affect its export behavior
		 * havn't been set. */
		if (currentFeatures.crt_noImpl) {
			if (currentFeatures.crt_kosSection != context.defaultFeatures.crt_kosSection ||
			    currentFeatures.crt_dosSection != context.defaultFeatures.crt_dosSection) {
				self.errAt(currentNameTokStart,
					"[section({!r})] used with [nocrt] or [crt_noImpl]"
					.format({ currentFeatures.crt_kosSection }));
			}
			if (currentLibraryFunction.exportSymbolNames) {
				self.errAt(currentNameTokStart,
					"[export_as(...)] used with [nocrt] or [crt_noImpl]");
			}
		}

		if (currentFeatures.wchar) {
			if (!currentFeatures.wchar_noAlias) {
				/* For every assembly-binding, create 2 additional bindings:
				 * >> [[if(COND), alias(NAME)]]
				 * Extend by:
				 * >> [[if(COND && __SIZEOF_WCHAR_T__ == 2), alias(DOS$NAME)]]
				 * >> [[if(COND && __SIZEOF_WCHAR_T__ == 4), alias(KOS$NAME)]] */
				for (local i = 0; i < #current.bindings;) {
					local bind = current.bindings[i];
					if (bind is Callable) {
						++i;
						continue;
					}
					local symbolName = bind.binding;
					if (symbolName !is string &&
						symbolName !is UserString) {
						++i;
						continue;
					}
					/* Don't alias certain objects based on their binding conditions
					 * XXX: This is imprecise, but will work for now!
					 *      In a perfect world, we would have to check if:
					 * >> oldCond = optimize(bind.ppCond);
					 * >> newCond16 = optimize("(" + bind.ppCond + ")&&(__SIZEOF_WCHAR_T__==2)");
					 * >> newCond32 = optimize("(" + bind.ppCond + ")&&(__SIZEOF_WCHAR_T__==4)");
					 * >> shouldEmit16 = newCond16 != "0" && newCond16 != oldCond;
					 * >> shouldEmit32 = newCond32 != "0" && newCond32 != oldCond;
					 * Such that we don't emit the alias if:
					 *   - The resulting condition becomes impossible
					 *     -> e.g.: "__SIZEOF_WCHAR_T__ == 4 && __SIZEOF_WCHAR_T__ == 2"
					 *              optimized to:
					 *              "0"
					 *   - The resulting condition doesn't differ from the old condition
					 *     -> e.g.: "__SIZEOF_WCHAR_T__ == 2 && __SIZEOF_WCHAR_T__ == 2"
					 *              optimized to:
					 *              "__SIZEOF_WCHAR_T__ == 2"
					 *              With wouldn't differ from @oldCond
					 *
					 * However, since this would require _a_ _very_ _smart_ optimizer to do
					 * the job for us, this isn't actually feasable, so we simply skip doing
					 * the binding if the old condition already references "__SIZEOF_WCHAR_T__"
					 */
					if (bind.ppCond && "__SIZEOF_WCHAR_T__" in str(bind.ppCond)) {
						++i;
						continue;
					}
					symbolName = str symbolName;
					local dosSymbolName = symbolName;
					if (currentFeatures.crt_dosname !is none) {
						local mySymbolName = currentFeatures.crt_name;
						if (mySymbolName is none)
							mySymbolName = currentName;
						if (dosSymbolName == mySymbolName)
							dosSymbolName = currentFeatures.crt_dosname;
					}
					dosSymbolName = "DOS$" + dosSymbolName;
					local kosSymbolName = "KOS$" + symbolName;
					local cDosPrototypes = Cell();
					local cKosPrototypes = Cell();
					local bindProtos = bind.prototypes;
					function getDosPrototypes() {
						if (!cDosPrototypes) {
							local result = replaceWcharPrototypes(
								bindProtos, WCHAR_REPLACEMENT_CHAR16);
							cDosPrototypes.value = result;
							return result;
						}
						return cDosPrototypes.value;
					}
					function getKosPrototypes() {
						if (!cKosPrototypes) {
							local result = replaceWcharPrototypes(
								bindProtos, WCHAR_REPLACEMENT_CHAR32);
							cKosPrototypes.value = result;
							return result;
						}
						return cKosPrototypes.value;
					}

					local dosBinding = FunctionBinding(
						ppCond: "({}) && __SIZEOF_WCHAR_T__ == 2".format({
							replaceCrtHaveFromPreprocessorCondition(
								bind.ppCond, symbolName, dosSymbolName)
						}),
						ppCondPrefix: bind.ppCondPrefix,
						prototypes:   getDosPrototypes,
						binding:      dosSymbolName);
					local kosBinding = FunctionBinding(
						ppCond: "({}) && __SIZEOF_WCHAR_T__ == 4".format({
							replaceCrtHaveFromPreprocessorCondition(
								bind.ppCond, symbolName, kosSymbolName)
						}),
						ppCondPrefix: bind.ppCondPrefix,
						prototypes:   getKosPrototypes,
						binding:      kosSymbolName);
					current.bindings.insert(i + 1, kosBinding);
					current.bindings.insert(i + 2, dosBinding);
					i += 3;
				}
			}
		} else { /* currentFeatures.wchar */
			if (currentFeatures.crt_dosname !== context.defaultFeatures.crt_dosname) {
				self.err("Function {!r} has a [dosname()] annotation, but no [wchar]"
					.format({ currentName }));
			}
		} /* !currentFeatures.wchar */

		if (!currentFeatures.crt_kernel) {
			/* Set-up the pp-cond of the current library function to only
			 * be implemented when not being compiled for kernel-space. */
			final local IFNDEF_KERNEL = "!defined(__KERNEL__)";
			if (currentLibraryFunction.ppCond == "1")
				currentLibraryFunction.ppCond = IFNDEF_KERNEL;
			else {
				currentLibraryFunction.ppCond = "({})&&{}"
					.format({ currentLibraryFunction.ppCond, IFNDEF_KERNEL });
			}
			if (currentDosLibraryFunction !is none) {
				if (currentDosLibraryFunction.ppCond == "1")
					currentDosLibraryFunction.ppCond = IFNDEF_KERNEL;
				else {
					currentDosLibraryFunction.ppCond = "({})&&{}"
						.format({ currentDosLibraryFunction.ppCond, IFNDEF_KERNEL });
				}
			}
		}


		/* Check for special case: @"dstFunction(*) = srcFunction;"
		 * This case is handled by:
		 * >> currentPrototypes = none;
		 * >> goto handle_eq_after_prototype; */
		if (currentPrototype.returnType !is bound) {
			local temp = self.tokStart;
			if (self.next() == "*") {
				self.next();
				tok = self.skip(")");
				/* Make sure that nothing has yet to be said about the prototype. */
				if (currentPrototype.returnType is bound) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but return type was set to {!r}"
							.format({ currentName, currentPrototype.returnType }));
				}
				if (currentPrototype.cc != DEFAULT_CC) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit CC {!r}"
							.format({ currentName, currentPrototype.cc }));
				}
				if (currentPrototype.nothrow != DEFAULT_NOTHROW) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit NOTHROW {!r}"
							.format({ currentName, currentPrototype.nothrow }));
				}
				if (currentPrototype.ellipsisArgumentTypes) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit ellipsis arguments {!r}"
							.format({ currentName, currentPrototype.ellipsisArgumentTypes }));
				}
				if (currentPrototype.declPrefix) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but an explicit [decl_prefix({!r})]"
							.format({ currentName, currentPrototype.declPrefix }));
				}
				if (defaultAttributes !is none && defaultAttributes) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit attributes {!r}"
							.format({ currentName, defaultAttributes }));
				}
				if (functionArgumentNamesOverride !is none) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit argument names {!r}"
							.format({ currentName, functionArgumentNamesOverride }));
				}
				currentPrototype  = none;
				currentPrototypes = none;
				for (local binding: current.bindings) {
					if (binding !is Callable)
						binding.prototypes = none;
				}
				if (tok == "=")
					goto handle_eq_after_prototype;
				if (tok == "%")
					goto handle_percent_after_prototype;
				self.err("Expected '=' or '%' after '{}(*)', but got {!r}"
					.format({ currentName, tok }));
			}
			self.tokEnd = temp;
			tok = self.next();
			assert tok == "(";
		}

		/* Right now, `tok == "("', pointing at the '('-character
		 * before the argument list. So parse that argument list */
		parseArgumentListAndOptionalTrailingReturnType(
			self, currentPrototype, defaultAttributes);
		tok = self.tok;
		/* Default to having a void returnType */
		if (currentPrototype.returnType !is bound)
			currentPrototype.returnType = CType("void");
		if (tok == "[") {
			/* C++ overloads */
			local cxxPrototypes: {FunctionPrototype...} = [];
			for (;;) {
				local numBrackets = 1;
				tok = self.next();
				while (tok == "[") {
					++numBrackets;
					tok = self.next();
				}
				local cxxProto = FunctionPrototype(
					cc: currentPrototype.cc,
					nothrow: currentPrototype.nothrow);
				parseWholeFunctionPrototype(self, cxxProto, defaultAttributes);
				cxxPrototypes.append(cxxProto);
				while (numBrackets--)
					tok = self.skip("]");
				if (tok != "[")
					break;
			}
			local newCurrentPrototypes = {
				("defined(__cplusplus) && defined(__CORRECT_ISO_CPP_{}_H_PROTO)"
					.format({ headerName.upper() }), cxxPrototypes),
				("1", { currentPrototype })
			};
			/* When updating `currentPrototypes', must also update
			 * all `current.bindings' that were already using those
			 * the current set of prototypes  */
			for (local binding: current.bindings) {
				if (binding.prototypes === currentPrototypes)
					binding.prototypes = newCurrentPrototypes;
			}
			currentPrototypes = newCurrentPrototypes;
		}

		/* Right now, @tok points at the first token after the prototype
		 * This is going to be one of:
		 *   "{"  - function implementation
		 *   "%"  - automatic implementation generator
		 *   "="  - Aliasing definition
		 *   ";"  - No implementation
		 */
		switch (tok) {
			local loaderImpl: none | Callable | LoaderFunctionImplementation;

		case "%": {
handle_percent_after_prototype:
			tok = self.next();
			loaderImpl = none;
			/* Auto-generated implementation in `hdrImpls' and
			 * `libImpls', and possibly `currentPrototype' and
			 * `currentPrototypes' */
			switch (tok) {

			case "{":
				tok = self.next();
				switch (tok) {

				case "copy": /* Deprecated alias */
				case "generate": {
					/* Syntax:
					 * >> wcslen(*) %{generate(str2wcs)}
					 * >> wcslen(*) %{generate(str2wcs(*))}
					 * >> wcslen(*) %{generate(str2wcs(%auto))}
					 * >> wcslen(*) %{generate(str2wcs(strlen))} */
					if (currentFeatures.requires != "1")
						self.err("Function {!r} has a generated implementation, but uses [requires({!r})]"
							.format({ currentName, currentFeatures.requires }));
					if (currentFeatures.requiresPrefix)
						self.err("Function {!r} has a generated implementation, but uses [requires_prefix({!r})]"
							.format({ currentName, currentFeatures.requiresPrefix }));
					if (currentFeatures.implPrefix)
						self.err("Function {!r} has a generated implementation, but uses [impl_prefix({!r})]"
							.format({ currentName, currentFeatures.implPrefix }));
					self.next();
					tok = self.skip("(");
					if (!tok.issymbol()) {
						self.err("Expected keyword in %{{generate(...)}}, but got {!r}"
							.format({ tok }));
					}
					local gennetatorName = tok;
					local gen: Generator = generators.get(gennetatorName);
					if (gen is none) {
						self.err("Unknown generator {!r}"
							.format({ gennetatorName }));
					}
					tok = self.next();
					local baseFunctionName = none;
					if (tok == "(") {
						/* Explicit function name, or * or %auto */
						tok = self.next();
						if (tok == "*") {
							self.next();
						} else if (tok == "%") {
							self.next();
							self.skip("auto");
						} else {
							baseFunctionName = parseCStringOrKeyword(self);
						}
						tok = self.skip(")");
					}
					/* Check if we're supposed to automatically deduce
					 * the name of the underlying base-function. */
					if (baseFunctionName is none) {
						baseFunctionName = gen.getDefaultBaseFunctionName(currentName);
						if (baseFunctionName is none) {
							self.errAt(currentNameTokStart,
								"Unable to deduce automatic base function name for "
								"generator {!r} from current function name {!r}"
								.format({ gennetatorName, currentName }));
						}
					}
					/* Hint at the generator about the replacement. */
					gen.registerFunctionPairing(currentName, baseFunctionName);
					local baseLocalFunctionCell: Cell with LocalFunction = Cell();
					function getBaseLocalFunction(): LocalFunction {
						if (!baseLocalFunctionCell) {
							local result: LocalFunction;
							try {
								result = findLocalFunctionByName(baseFunctionName);
							} catch (Error as e) {
								self.errAt(currentNameTokStart, e.message);
							}
							baseLocalFunctionCell.value = result;
							return result;
						}
						return baseLocalFunctionCell.value;
					}
					if (currentPrototype is none) {
						local replacedPrototypeCell: Cell with FunctionPrototype = Cell();
						currentPrototype = []{
							if (!replacedPrototypeCell) {
								local result = gen.replaceFunctionPrototype(
									getBaseLocalFunction().functionPrototype);
								replacedPrototypeCell.value = result;
								return result;
							}
							return replacedPrototypeCell.value;
						};
					}
					if (currentPrototypes is none) {
						currentPrototypes = [] -> {
							("1", {
								currentPrototype is Callable
									? currentPrototype()
									: currentPrototype
							}),
						};
						for (local binding: current.bindings) {
							if (binding is Callable)
								continue;
							if (binding.prototypes is none)
								binding.prototypes = currentPrototypes;
						}
					}
					/* Define the generator for the converted function implementations */
					loaderImpl = [](): LoaderFunctionImplementation {
						local baseLocalFunction: LocalFunction = getBaseLocalFunction();
						return LoaderFunctionImplementation(
							ppCond:       gen.replaceText(baseLocalFunction.ppCond),
							ppCondPrefix: gen.replaceTextArray(baseLocalFunction.ppCondPrefix),
							impl:         gen.replaceFunctionImplementation(
								baseLocalFunction.functionImpl, currentName));
					};
					self.skip(")");
				}	break;

				case "uchar": {
					local has16 = "16" in currentName;
					local has32 = "32" in currentName;
					if (has16 && !has32)
						tok = "uchar16";
					else if (has32 && !has16)
						tok = "uchar32";
					else {
						self.err("Unable to determine uchar behavior from function name {!r}"
							.format({ currentName }));
					}
				}	/* FALLTHRU */
				case "uchar16":
				case "uchar32": {
					local mode = tok;
					if (currentFeatures.wchar) {
						self.err("uchar function {!r} cannot have the [wchar] annotation"
							.format({ currentName }));
					}
					local wcsFunctionName = none;
					tok = self.next();
					if (tok == "(") {
						tok = self.next();
						if (tok == "*") {
							self.next();
						} else if (tok == "%") {
							self.next();
							self.skip("auto");
						} else {
							if (isCString(tok)) {
								wcsFunctionName = tok.decode("c-escape");
							} else if (tok.issymbol()) {
								wcsFunctionName = self.userTok;
							} else {
								self.err("Expected string or keyword in '%{uchar(...)}', but got {!r}"
									.format({ tok }));
							}
							self.next();
						}
						self.skip(")");
					}
					if (wcsFunctionName is none) {
						wcsFunctionName = currentName;
						if (wcsFunctionName.startswith("c16") || wcsFunctionName.startswith("c32"))
							wcsFunctionName = "wcs" + wcsFunctionName[3:];
						else {
							self.errAt(currentNameTokStart,
								"Unable to determine uchar base name for {!r} (consider using '%{uchar(base)}')"
								.format({ wcsFunctionName }));
						}
					}
					currentFeatures.assertAllDefaultAttributesWithoutImplementation(
						self, context.defaultFeatures, currentName);
					currentFeatures.assertAllSymbolicAliasOnly(
						self, context.defaultFeatures, currentName);
					if (currentLibraryFunction.exportSymbolNames) {
						self.errAt(currentNameTokStart,
							"[export_as(...)] used with %{{uchar}} function {!r}"
								.format({ currentName }));
					}
					if (currentLibraryFunction.bindings) {
						self.errAt(currentNameTokStart,
							"[intern_alias(...)] or [alt_variant_of(...)] "
							"used with %{{uchar}} function {!r}"
							.format({ currentName }));
					}
					if (#current.bindings > (currentFeatures.crt_noSelfImport ? 0 : 1))
						self.errAt(currentNameTokStart, "%{{uchar}} function {!r} has custom bindings"
							.format({ currentName }));
					mode = { "uchar16" : WCHAR_REPLACEMENT_CHAR16,
					         "uchar32" : WCHAR_REPLACEMENT_CHAR32 }[mode];
					local feat_inline         = currentFeatures.inline;
					local feat_noExternInline = currentFeatures.noExternInline;
					local feat_noLocal        = currentFeatures.noExternInline;
					local xcLocalFunction: LocalFunction = none;
					if (feat_inline is none && !feat_noLocal) {
						xcLocalFunction = LocalFunction(
							name:                     currentName,
							originalSystemHeaderName: headerName);
						defineFunctionInMapping(allLocalFunctionsByName, xcLocalFunction);
						if (!result.localFunctionsByName.setnew(xcLocalFunction.name, xcLocalFunction))
							self.errAt(currentNameTokStart, "Duplicate local function: {!r}"
								.format({ xcLocalFunction.name }));
					}
					/* Lazily construct function bindings upon first access */
					current.bindings = [](): {FunctionBinding...} {
						@@The wchar function descriptor
						local wcharFunction: WcharFunction =
							getWcharFunctionByNameWithParserAndErrorAt(
								wcsFunctionName, self, currentNameTokStart);
						/* Remember the used uchar16/uchar32 system header names
						 * This is important for dynamic implementation transformations. */
						if (wcharFunction.wc_header_uchar[mode] !is none) {
							self.errAt(currentNameTokStart,
								"Duplicate declaration of %{{uchar{}}} variant of [wchar] function {!r}"
								.format({ WCHAR_REPLACEMENT_WIDTH[mode], wcsFunctionName }));
						}
						wcharFunction.wc_header_uchar[mode] = current;
						@@The referenced [wchar]-Function
						local wc: Function = wcharFunction.wc_func;
						@@The Xchar-function implementation
						local xc: XcharImplementation = wcharFunction.getXCharImplementation(currentName, mode);
						/* Figure out which prototypes should be used */
						local usedPrototype: FunctionPrototype = currentPrototype;
						local usedPrototypes: {(string, {FunctionPrototype...})...} = currentPrototypes;
						if (usedPrototype is none)
							usedPrototype = xc.prototype;
						if (usedPrototypes is none)
							usedPrototypes = xc.prototypes;
						/* Enumerate bindings of the underlying [wchar] Function to construct
						 * new, transformed bindings for our new the Xchar function. */
						local basicBindings = [];
						for (local wc_bind/*:FunctionBinding*/ : wc.functionBindings) {
							local wc_bind_binding = wc_bind.functionBinding;
							/* Ignore namespace bindings (though we could theoretically bind these as well...) */
							if (wc_bind_binding is Namespace)
								continue;
							/* At this point, @wc_bind_binding is one of:
							 *  - LocalFunction       : Local function implementation
							 *  - InlineFunction      : Inline implementation
							 *  - string | UserString : Link against some assembly symbol
							 *
							 * The preprocessor conditions required by @wc_bind must
							 * be transformed as follows:
							 *
							 * >> local myCond;
							 * >> local assme = wc_bind.ppCond REQUIRES THAT "__SIZEOF_WCHAR_T__ == SIZEOF(mode))";
							 * >> local assot = wc_bind.ppCond REQUIRES THAT "__SIZEOF_WCHAR_T__ != SIZEOF(mode))";
							 * >> if (assme) {
							 * >>     myCond = wc_bind.ppCond WITHOUT "__SIZEOF_WCHAR_T__ == SIZEOF(mode))";
							 * >> } else if (assot) {
							 * >>     continue; // Ignore this binding
							 * >> } else {
							 * >>     myCond = "(" + wc_bind.ppCond + ") && __SIZEOF_WCHAR_T__ == SIZEOF(mode))";
							 * >> }
							 * >> basicBindings.append(FunctionBinding(myCond, TRANSFORM(wc_bind_binding), ...));
							 */
							/* TODO */
						}
						/* Last cast: Directly implement the Xchar function */
						local xcImpl: none | Callable | LoaderFunctionImplementation = xc.loaderImpl;
						if (xcImpl is Callable)
							xcImpl = xcImpl();
						if (xcImpl is none) {
							yield basicBindings...;
						} else {
							local implBinding = FunctionBinding(
								ppCond:       xcImpl.ppCond,
								ppCondPrefix: xcImpl.ppCondPrefix,
								prototypes:   usedPrototypes);
							if (feat_inline !is none) {
								if (!feat_noExternInline) {
									/* Create extern-inline bindings */
									for (local i = 0; i < #basicBindings;) {
										local existingBinding = basicBindings[i];
										if (existingBinding.binding !is string &&
										    existingBinding.binding !is UserString) {
											++i;
											continue;
										}
										/* Construct, and inject a new binding that  */
										local eiBinding = FunctionBinding(
											ppCondPrefix:   (existingBinding.ppCondPrefix as Sequence) + xcImpl.ppCondPrefix,
											prototypes:     existingBinding.prototypes,
											binding:        InlineFunction(
												mode:                "__EXTERNINLINE",
												impl:                xcImpl.impl,
												externInlineAsmname: existingBinding.binding));
										if (xcImpl.ppCond == "1") {
											eiBinding.ppCond = existingBinding.ppCond;
											basicBindings[i] = eiBinding;
											++i;
										} else {
											eiBinding.ppCond = "{} && ({})".format({
												existingBinding.ppCond,
												xcImpl.ppCond
											});
											basicBindings.insert(i, eiBinding);
											i += 2;
										}
									}
								}
								implBinding.binding = InlineFunction(
									mode: feat_inline, impl: xcImpl.impl);
							} else if (!feat_noLocal) {
								assert xcLocalFunction !is none;
								xcLocalFunction.prototype     = usedPrototype;
								xcLocalFunction.impl          = xcImpl.impl;
								xcLocalFunction.ppCond        = xcImpl.ppCond;
								xcLocalFunction.ppCondPrefix  = xcImpl.ppCondPrefix;
								xcLocalFunction.documentation = wc.documentation;
								implBinding.binding = xcLocalFunction;
							}
							yield basicBindings...;
							yield implBinding;
						}
					};
					self.skip("}");
					goto done_function;
				}	break;

				default:
					self.err("Unknown code generator function: {!r}"
						.format({ tok }));
				}
				self.skip("}");
				break;

			default:
				self.err("Unexpected token {!r} after '%', following function declaration"
					.format({ tok }));
				break;
			}
			if (loaderImpl is none)
				self.err("Unable to generate automatic implementation");
			if (currentPrototype is none)
				self.err("Prototype cannot be deduced in this context");
			if (currentPrototypes is none)
				currentPrototypes = { ("1", { currentPrototype }) };
			goto with_primaryImplementation;
		}

		case ";": {
			self.next();
			loaderImpl = none;
			goto with_primaryImplementation;
		}	break;

		case "{": {
			{
				local bodyStart = self.tokStart;
				self.skipPair();
				local body = self.getUserString(bodyStart, self.tokEnd);
				self.next();
				loaderImpl = LoaderFunctionImplementation(
					ppCond:       currentFeatures.requires,
					ppCondPrefix: currentFeatures.requiresPrefix,
					impl:         FunctionImplementation(
						body:         body,
						name:         currentName,
						implPrefix:   currentFeatures.implPrefix,
						dependencies: scanForNamesOfDependentFunctions(
							body, currentPrototype, currentFeatures))
				);
			}
with_primaryImplementation:
			if (loaderImpl is none) {
				currentFeatures.assertAllDefaultAttributesWithoutImplementation(
					self, context.defaultFeatures, currentName);
			} else if (currentFeatures.inline !is none || !currentFeatures.noLocal) {
				local existingBindings = current.bindings;
				if (loaderImpl is Callable || existingBindings is Callable) {
					/* Must implement indirectly! */
					local feat_inline = currentFeatures.inline;
					local feat_noExternInline   = currentFeatures.noExternInline;
					local feat_noInlineTruncate = currentFeatures.noInlineTruncate;
					current.bindings = []{
						local usedImpl: LoaderFunctionImplementation = loaderImpl;
						local usedExistingBindings = existingBindings;
						if (usedImpl is Callable)
							usedImpl = usedImpl();
						if (usedExistingBindings is Callable)
							usedExistingBindings = usedExistingBindings();
						local funImpl: FunctionImplementation = usedImpl.impl;
						local implBinding = FunctionBinding(
							ppCond:       usedImpl.ppCond,
							ppCondPrefix: usedImpl.ppCondPrefix,
							prototypes:   currentPrototypes);
						if (feat_inline !is none) {
							/* Bind the primary implementations as inline */
							local inlImpl = funImpl;
							if (!feat_noInlineTruncate)
								inlImpl = inlImpl.truncateBodyForInline();
							if (!feat_noExternInline) {
								/* Create secondary inline-bindings for all __EXTERNINLINE */
								for (local existingBinding /*: FunctionBinding*/: usedExistingBindings) {
									if (existingBinding is Callable)
										existingBinding = existingBinding();
									if (type(existingBinding.binding) !in [string, UserString]) {
										yield existingBinding;
										continue;
									}
									/* Construct, and inject a new binding that  */
									yield FunctionBinding(
										ppCond:       implBinding.ppCond == "1"
										              ? existingBinding.ppCond
										              : "{} && ({})".format({ existingBinding.ppCond, implBinding.ppCond }),
										ppCondPrefix: (existingBinding.ppCondPrefix as Sequence) + implBinding.ppCondPrefix,
										prototypes:   existingBinding.prototypes,
										binding:      InlineFunction(
											mode:                "__EXTERNINLINE",
											impl:                inlImpl,
											externInlineAsmname: existingBinding.binding));
								}
							}
							implBinding.binding = InlineFunction(
								mode: feat_inline, impl: inlImpl);
						} else {
							yield usedExistingBindings...;
							/* Construct a local function object */
							local localFunc = LocalFunction(
								name:                     currentName,
								originalSystemHeaderName: headerName,
								prototype:                currentPrototype,
								impl:                     funImpl,
								documentation:            current.documentation);
							defineFunctionInMapping(allLocalFunctionsByName, localFunc);
							if (!result.localFunctionsByName.setnew(localFunc.name, localFunc))
								self.errAt(currentNameTokStart, "Duplicate local function: {!r}"
									.format({ localFunc.name }));
							implBinding.binding = localFunc;
						}
						yield implBinding;
					};
				} else {
					local funImpl = loaderImpl.impl;
					local implBinding = FunctionBinding(
						ppCond:       loaderImpl.ppCond,
						ppCondPrefix: loaderImpl.ppCondPrefix,
						prototypes:   currentPrototypes);
					if (currentFeatures.inline !is none) {
						/* Bind the primary implementations as inline */
						local inlImpl = funImpl;
						if (!currentFeatures.noInlineTruncate)
							inlImpl = funImpl.truncateBodyForInline();
						if (!currentFeatures.noExternInline) {
							/* Create secondary inline-bindings for all __EXTERNINLINE */
							local n = #existingBindings;
							for (local i = 0; i < n;) {
								local existingBinding: FunctionBinding = existingBindings[i];
								if (type(existingBinding.binding) !in [string, UserString]) {
									++i;
									continue;
								}
								/* Construct, and inject a new binding that  */
								local eiBinding = FunctionBinding(
									ppCondPrefix: (existingBinding.ppCondPrefix as Sequence) + implBinding.ppCondPrefix,
									prototypes:   existingBinding.prototypes,
									binding:      InlineFunction(
										mode:                "__EXTERNINLINE",
										impl:                inlImpl,
										externInlineAsmname: existingBinding.binding));
								if (implBinding.ppCond == "1") {
									eiBinding.ppCond = existingBinding.ppCond;
									existingBindings[i] = eiBinding;
									++i;
								} else {
									eiBinding.ppCond = "{} && ({})".format({
										existingBinding.ppCond,
										implBinding.ppCond
									});
									existingBindings.insert(i, eiBinding);
									i += 2;
								}
							}
						}
						implBinding.binding = InlineFunction(
							mode: currentFeatures.inline, impl: inlImpl);
					} else {
						/* Construct a local function object */
						local localFunc = LocalFunction(
							name:                     currentName,
							originalSystemHeaderName: headerName,
							prototype:                currentPrototype,
							impl:                     funImpl,
							documentation:            current.documentation);
						defineFunctionInMapping(allLocalFunctionsByName, localFunc);
						if (!result.localFunctionsByName.setnew(localFunc.name, localFunc))
							self.errAt(currentNameTokStart, "Duplicate local function: {!r}"
								.format({ localFunc.name }));
						implBinding.binding = localFunc;
					}
					current.bindings.append(implBinding);
				}
			}
			local wcsCurrent;
			if (currentFeatures.wchar) {
				wcsCurrent = WcharFunction(
					wc_func:       current,
					wc_loaderImpl: loaderImpl,
					wc_prototype:  currentPrototype,
					wc_prototypes: currentPrototypes);
				if (currentName in allWcharFunctionsByName)
					self.errAt(currentNameTokStart, "Duplicate [wchar] function {!r}"
						.format({ currentName }));
				allWcharFunctionsByName[currentName] = wcsCurrent;
			}
			if (!currentFeatures.crt_noImpl) {
				local crtName = currentFeatures.crt_name;
				if (crtName is none)
					crtName = currentName;
				if (currentLibraryFunction.documentation is string && !currentLibraryFunction.documentation)
					currentLibraryFunction.documentation = current.documentation;
				if (currentFeatures.wchar) {
					/* Create 2 new functions that are then exported from libc. */
					local dosCrtName = currentFeatures.crt_dosname;
					if (dosCrtName is none)
						dosCrtName = crtName;
					local kosVariant: LibraryFunction = currentLibraryFunction;
					local dosVariant: LibraryFunction = currentDosLibraryFunction;
					if (dosVariant is none)
						dosVariant = LibraryFunction(ppCond: currentLibraryFunction.ppCond);
					if (dosVariant.originalSystemHeaderName !is bound)
						dosVariant.originalSystemHeaderName = kosVariant.originalSystemHeaderName;
					local kosVariantName = "libc_" + crtName;
					local dosVariantName = "libd_" + dosCrtName;
					if (!currentFeatures.crt_noSelfExport) {
						kosVariant.exportSymbolNames.append(("1", crtName));
						dosVariant.exportSymbolNames.append(("1", "DOS$" + dosCrtName));
					}
					kosVariant.name = kosVariantName;
					dosVariant.name = dosVariantName;
					dosVariant.prototype = [] -> wcsCurrent.getXCharImplementation(
						kosVariantName, WCHAR_REPLACEMENT_CHAR16).prototype;
					kosVariant.prototype = [] -> wcsCurrent.getXCharImplementation(
						dosVariantName, WCHAR_REPLACEMENT_CHAR32).prototype;
					if (dosVariant.documentation is string && !dosVariant.documentation)
						dosVariant.documentation = kosVariant.documentation;
					function createXCharBinding(
							functionName: string | UserString,
							crtName: string | UserString, mode: int,
							implSection: UserString | string | none): Callable {
						return []{
							local xc: XcharImplementation = wcsCurrent
								.getXCharImplementation(functionName, mode);
							local xcLoaderImpl: LoaderFunctionImplementation = xc.loaderImpl;
							if (xcLoaderImpl is Callable)
								xcLoaderImpl = xcLoaderImpl();
							return LibraryFunctionBinding(
								binding: xcLoaderImpl is none
									? getDefaultLibraryImplementationForPrototype(
										wcsCurrent.prototype, crtName)
									: xcLoaderImpl.impl,
								implSection: implSection);
						};
					}
					/* Link the Xchar-implementations.
					 * NOTE: This has to happen delayed, so that everything will be
					 *       available once the implementation gets generated. */
					dosVariant.bindings.append(createXCharBinding(
						dosVariantName, dosCrtName, WCHAR_REPLACEMENT_CHAR16,
						currentFeatures.crt_dosSection));
					kosVariant.bindings.append(createXCharBinding(
						kosVariantName, crtName, WCHAR_REPLACEMENT_CHAR32,
						currentFeatures.crt_kosSection));
					/* Insert the library implementations into the system header order */
					if (currentFeatures.crt_userimpl || loaderImpl is none) {
						result.order_libcUserHeader.extend({ dosVariant, kosVariant });
						result.order_libcUserSource.extend({ dosVariant, kosVariant });
					} else {
						result.order_libcAutoHeader.extend({ dosVariant, kosVariant });
						result.order_libcAutoSource.extend({ dosVariant, kosVariant });
					}
					goto done_currentLibraryFunction;
				} else {
					/* Create a default implementation for user-sources */
					local libImpl;
					if (loaderImpl is none) {
						local defaultImpl: FunctionImplementation | Callable;
						if (currentPrototype is Callable) {
							defaultImpl = [] -> getDefaultLibraryImplementationForPrototype(
								currentPrototype(), crtName);
						} else {
							defaultImpl = getDefaultLibraryImplementationForPrototype(
								currentPrototype, crtName);
						}
						libImpl = LibraryFunctionBinding(
							binding:     defaultImpl,
							implSection: currentFeatures.crt_kosSection);
					} else {
						libImpl = LibraryFunctionBinding(
							binding: loaderImpl is Callable
								? [] -> loaderImpl().impl
								: loaderImpl.impl
								,
							implSection: currentFeatures.crt_kosSection);
					}
					currentLibraryFunction.bindings.append(libImpl);
				}
				if (currentLibraryFunction.prototype !is bound)
					currentLibraryFunction.prototype = currentPrototype;
				if (!currentFeatures.crt_noSelfExport) {
					currentLibraryFunction.exportSymbolNames
						.append(("1", crtName));
				}
				currentLibraryFunction.name = "libc_" + crtName;
				if (currentFeatures.crt_userimpl || loaderImpl is none) {
					result.order_libcUserHeader.append(currentLibraryFunction);
					result.order_libcUserSource.append(currentLibraryFunction);
				} else {
					result.order_libcAutoHeader.append(currentLibraryFunction);
					result.order_libcAutoSource.append(currentLibraryFunction);
				}
done_currentLibraryFunction:
				currentLibraryFunction = none;
			}
		}	break;

		case "=": {
handle_eq_after_prototype:
			if (currentFeatures.wchar)
				self.err("[wchar] cannot be used with alias bindings");
			currentFeatures.assertAllDefaultAttributesWithoutImplementation(
				self, context.defaultFeatures, currentName);
			currentFeatures.assertAllSymbolicAliasOnly(
				self, context.defaultFeatures, currentName);
			if (#current.bindings > (currentFeatures.crt_noSelfImport ? 0 : 1))
				self.errAt(currentNameTokStart, "Aliasing function {!r} has custom bindings {!r}"
					.format({ currentName, current.bindings }));
			if (currentLibraryFunction.exportSymbolNames) {
				self.errAt(currentNameTokStart,
					"[export_as(...)] used with aliasing function {!r}"
						.format({ current. name }));
			}
			if (currentLibraryFunction.bindings) {
				self.errAt(currentNameTokStart,
					"[intern_alias(...)] or [alt_variant_of(...)] "
					"used with aliasing function {!r}"
					.format({ currentName }));
			}
			local boundFunctionName = self.next();
			if (isCString(boundFunctionName))
				boundFunctionName = boundFunctionName.decode("c-escape");
			else if (!boundFunctionName.issymbol()) {
				self.err("Expected keyword or string after =, but got {!r}"
					.format({ boundFunctionName }));
			}
			local boundFunctionNameStart = self.tokStart;
			function getBoundFunction(): Function {
				local result: Function;
				try {
					result = findFunctionByName(boundFunctionName);
				} catch (Error as e) {
					self.errAt(boundFunctionNameStart, e.message);
				}
				return result;
			}
			/* Inherit the documentation so-long as none was specified for this function. */
			if (current.documentation is string && !current.documentation)
				current.documentation = [] -> getBoundFunction().documentationString;
			if (currentPrototypes is none) {
				/* Simple case: Also inherit all prototypes (in which case we can
				 *              also simply inherit all bindings from the other
				 *              function) */
				current.bindings = [] -> getBoundFunction().functionBindings;
			} else {
				/* Difficult case: We must inherit bindings, but override them
				 *                 with our own, custom list of prototypes! */
				current.bindings = []{
					local func = getBoundFunction();
					for (local otherBind /*: FunctionBinding*/ : func.functionBindings) {
						if (otherBind.binding is Callable)
							otherBind.binding = otherBind.binding();
						yield FunctionBinding(
							ppCond:       otherBind.ppCond,
							ppCondPrefix: otherBind.ppCondPrefix,
							prototypes:   currentPrototypes,
							binding:      otherBind.binding);
					}
				};
			}
			self.next();
			self.skip(";");
		}	break;

		default:
			self.err("Unexpected token {!r} when function implementation (as '%', '=', '{{' or ';') was expected"
				.format({ tok }));
		}
done_function:
		if (currentLibraryFunction !is none) {
			/* Assert that no annotations added any special features to the library
			 * function in situations where the library function isn't actually being
			 * used */
			if (currentLibraryFunction.exportSymbolNames)
				self.errAt(currentNameTokStart, "[export_as(...)] used, but function's isn't actually being exported");
			/* Don't assert this: `alt_variant_of()' would still be allowed here! */
//			if (currentLibraryFunction.bindings)
//				self.errAt(currentNameTokStart, "[intern_alias(...)] or [alt_variant_of(...)] used, but function's isn't actually being exported");
		}

		/* Register the function, and insert it into listings where it should show up */
		defineFunctionInMapping(result.functionsByName, current);
		defineFunctionInMapping(allFunctionsByName, current);
		if (currentFeatures.namespaces) {
			local exposedName = currentFeatures.exposedName;
			if (exposedName is none)
				exposedName = currentName;
			local gblGuard = false;
			if (currentFeatures.guard) {
				/* Add namespace import bindings for all defined namespaces. */
				local moreBindings = [];
				for (local ns: currentFeatures.namespaces) {
					if (ns !is Namespace)
						ns = getNamespaceByName(ns);
					local nsGuard = currentFeatures.guardNames.get(ns.name);
					if (nsGuard is none)
						nsGuard = ns.keyDefaultGuard(exposedName);
					if (ns === GLOBAL_NAMESPACE)
						gblGuard = nsGuard;
					moreBindings.append(FunctionBinding(
						ppCond:     "defined({})".format({ nsGuard }),
						prototypes: currentPrototypes,
						binding:    ns,
					));
				}
				if (moreBindings) {
					local oldBindings = current.bindings;
					if (oldBindings is Callable) {
						current.bindings = []{
							yield moreBindings...;
							yield oldBindings...;
						};
					} else {
						if (oldBindings !is List) {
							oldBindings = List(oldBindings);
							current.bindings = oldBindings;
						}
						oldBindings.insertall(0, moreBindings);
					}
				}
				if (gblGuard === false)
					gblGuard = GLOBAL_NAMESPACE.keyDefaultGuard(exposedName);
			}
			local func = current;
			if (currentFeatures.decl != "__LIBC" || exposedName != func.name ||
			    gblGuard !== false || currentFeatures.macroBinding) {
				/* Need a custom @ExposedFunction */
				func = ExposedFunction(
					func:                func,
					decl:                currentFeatures.decl,
					exposedName:         exposedName,
					guardName:           gblGuard,
					preferBindingMacros: currentFeatures.macroBinding);
			}
			if (currentFeatures.std) {
				if (context.result_order_headerStd is none) {
					self.errAt(currentNameTokStart,
						"Function {!r} was marked as `[std]', but "
						"'%[insert:std]' hasn't been encountered, yet"
						.format({ currentName }));
				}
				context.result_order_headerStd.append(func);
				/* Insert a std-using directive at the current location */
				if (!context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_START);
					context.result_order_header_in_CXX_SYSTEM_HEADER = true;
				}
				local gblGuard = false;
				local importCondition = "$has_function({})".format({ currentName });
				local nsStd = NAMESPACES["std"];
				if (currentFeatures.guard) {
					local stdGuard = currentFeatures.guardNames.get("std");
					gblGuard = currentFeatures.guardNames.get("");
					if (stdGuard is none)
						stdGuard = nsStd.keyDefaultGuard(exposedName);
					if (gblGuard is none)
						gblGuard = GLOBAL_NAMESPACE.keyDefaultGuard(exposedName);
					importCondition = "defined({})".format({ stdGuard });
				}
				local importFunction = Function(
					name: exposedName,
					originalSystemHeaderName: headerName,
					bindings: { FunctionBinding(
						ppCond:     importCondition,
						prototypes: currentPrototypes,
						binding:    nsStd, /* Bind against the std:: namespace export */
					) });
				if (gblGuard !== false) {
					importFunction = ExposedFunction(
						func: importFunction,
						decl: currentFeatures.decl, /* This one should go unused... */
						exposedName: exposedName,
						guardName: gblGuard);
				}
				result.order_header.append(importFunction);
				if (context.result_ccompatHeaderName !is none)
					context.result_order_headerCCompat.append(importFunction);
			} else {
				if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_END);
					context.result_order_header_in_CXX_SYSTEM_HEADER = false;
				}
				result.order_header.append(func);
			}
		}
		if (currentFeatures.libc) {
			result.order_libcHeader.append(current);
			result.order_libcCoreHeader.append(current);
		}
		tok = self.tok;
	}
	/* Finalize @result.order_header */
	if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
		result.order_header.append(CXX_SYSTEM_HEADER_END);
		context.result_order_header_in_CXX_SYSTEM_HEADER = false;
	}
	if (context.result_headerGuardName is none) {
		context.result_headerGuardName = "_{}_H"
			.format({ headerName.replace(".", "_").upper() });
	}
	if (context.result_ccompatHeaderName !is none) {
		if (context.result_order_headerCCompat is none) {
			local errobj = context.result_ccompatHeaderName;
			if (errobj !is UserString)
				errobj = self;
			errobj.err("'%[define_ccompat_header({!r})]' used without '%[insert:std]'"
				.format({ context.result_ccompatHeaderName }));
		}
		local guard_CXX_STDONLY = "_CXX_STDONLY_{}"
			.format({ str(context.result_ccompatHeaderName).upper() });
		result.order_header.insert(0,
			"#ifndef {0}\n"
			"#define {0} 1\n"
			"\n"
			"#ifdef {1}\n"
			"#ifdef __CXX_SYSTEM_HEADER\n"
			"#undef {0} /* Allow the C-header to be re-included to import all std::-symbols into the global namespace. */\n"
			"#else /* __CXX_SYSTEM_HEADER */\n"
			"/* Import all symbols into the global namespace when re-including \"{2}.h\" after \"{3}\" */\n"
			.format({
				context.result_headerGuardName, guard_CXX_STDONLY,
				headerName.replace(".", "/"),
				context.result_ccompatHeaderName
			}));
		result.order_header.insert(1,
			"#undef {0}\n"
			"#endif /* !__CXX_SYSTEM_HEADER */\n"
			"#else /* {0} */\n"
			.format({ guard_CXX_STDONLY }));
		result.order_header.insertall(1, context.result_order_headerCCompat);
		result.order_header.append(
			"\n"
			"#ifdef __CXX_SYSTEM_HEADER\n"
			"#define {1} 1\n"
			"#undef {0}\n"
			"#endif /* __CXX_SYSTEM_HEADER */\n"
			"#endif /* !{1} */\n"
			"#endif /* !{0} */\n"
			.format({
				context.result_headerGuardName,
				guard_CXX_STDONLY,
			}));
	} else {
		result.order_header.insert(0,
			"#ifndef {0}\n"
			"#define {0} 1\n"
			"\n".format({ context.result_headerGuardName }));
		result.order_header.append(
			"\n"
			"#endif /* !{} */\n"
			.format({ context.result_headerGuardName }));
	}
	return result;
}


















