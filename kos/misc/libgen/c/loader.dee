/* Copyright (c) 2019-2022 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2022 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from errors;
import * from .cheaders;
import * from .parser;
import * from .escape;
import * from .writer;
import * from .globals;
import * from .namespace;
import * from .wchar;
import * from .generator;
import * from .typeclass;
import Function from .cheaders;
import util;

/* How auto vs. user implementation is selected:
 * >> if (HAS_MAGIC_IMPLEMENTION_BODY) {
 * >>     if (HAS_ANNOTATION("userimpl")) {
 * >>         return USE_USER_IMPL;
 * >>     } else {
 * >>         return USE_AUTO_IMPL;
 * >>     }
 * >> } else {
 * >>     return USE_USER_IMPL;
 * >> } */

global loadSystemHeaderDefinitions;

global final CXX_SYSTEM_HEADER_START = "#ifndef __CXX_SYSTEM_HEADER\n";
global final CXX_SYSTEM_HEADER_END   = "#endif /* !__CXX_SYSTEM_HEADER */\n";
global final DEFAULT_CC              = "LIBCCALL";
global final DEFAULT_VCC             = "VLIBCCALL";
global final DEFAULT_DOS_CC          = "LIBDCALL";
global final DEFAULT_DOS_VCC         = "VLIBDCALL";
global final DEFAULT_NOTHROW         = "NOTHROW_NCX";
global final DEFAULT_LIBFUN_COND     = "!defined(__KERNEL__)";
global final DEFAULT_KOS_SECTION     = ".text.crt.unsorted";
global final DEFAULT_DOS_SECTION     = ".text.crt.dos.unsorted";
global final INCLUDE_KOS_ANNO        = "#include <kos/anno.h>";
global final INCLUDE_CRT             = "#include <__crt.h>";
global final IF_FAST_DEFINED_PATTERN = "$extended_prefix("
                                       "#ifdef __LIBC_BIND_OPTIMIZATIONS\n"
                                       "#include <optimized/{}.h>\n"
                                       "#endif /* __LIBC_BIND_OPTIMIZATIONS */"
                                       ")defined(@__fast_{}_defined@)";
global final IF_ALWAYS_FAST_DEFINED_PATTERN = "$extended_prefix("
                                              "#include <optimized/{}.h>\n"
                                              ")defined(@__fast_{}_defined@)";

@@Simple return type annotations which (when used) will be converted into attributes
global final SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS: {string: string} = {
	"nonnull"  : "ATTR_RETNONNULL",
	"wunused"  : "WUNUSED",
	"nullable" : "",
	"null"     : "",
};

@@Same as @SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS, but only applicable to functions as a whole
global final SIMPLE_ATTRIBUTE_ANNOTATIONS: {string: string} = {
	"ATTR_MCONST"   : "",
	"returns_twice" : "ATTR_RETURNS_TWICE",
	"noreturn"      : "ATTR_NORETURN",
	"const"         : "ATTR_CONST",
	"pure"          : "ATTR_PURE",
	"cold"          : "ATTR_COLD",
	"hot"           : "ATTR_HOT",
	"leaf"          : "ATTR_LEAF",
};

@@Same as @SIMPLE_ATTRIBUTE_ANNOTATIONS, but defines annotations from <kos/anno.h>
global final SIMPLE_KOS_ATTRIBUTE_ANNOTATIONS: {string: string} = {
	"noblock"   : "__NOBLOCK",
	"user"      : "__USER",
	"checked"   : "__CHECKED",
	"unchecked" : "__UNCHECKED",
};

@@Same as @SIMPLE_ATTRIBUTE_ANNOTATIONS, but used to define @FunctionPrototype.nothrow
global final SIMPLE_NOTHROW_ANNOTATIONS: {string: string} = {
	"no_nothrow"        : "",
	"nothrow"           : "NOTHROW",
	"nothrow_ncx"       : "NOTHROW_NCX",
	"nothrow_rpc"       : "NOTHROW_RPC",
	"nothrow_rpc_kos"   : "NOTHROW_RPC_KOS",
	"nothrow_rpc_nokos" : "NOTHROW_RPC_NOKOS",
	"nothrow_rpc_pure"  : "NOTHROW_RPC_PURE",

	/* CP for stdio (because of libio, custom FILE cookies may throw exceptions)
	 * Used  for  functions  that  are   already  CP  in  their  syscall   form. */
	"cp_stdio"          : "THROWS(...)",
	/* STDIO functions that may throw because of custom FILE cookies. */
	"stdio_throws"      : "THROWS(...)",
	"throws"            : "THROWS(...)",

	/* Cancellation point */
	"cp"                 : "NOTHROW_RPC",
	"cancellation_point" : "NOTHROW_RPC",
	"rpc"                : "NOTHROW_RPC",

	"cp_kos"             : "NOTHROW_RPC_KOS",
	"cp_nokos"           : "NOTHROW_RPC_NOKOS",
	"rpc_pure"           : "NOTHROW_RPC_PURE",
};

final global KNOWN_STRING_TAGS: {string...} = {
	"c_prefix",     /* Guard-prefix in <string.h> */
	"c",            /* C-part in <string.h> */
	"std",          /* std:: -part in <string.h> */
	"ccompat",      /* c-compat-part in <string.h> */
	"libc_fast",    /* <libc/string.h> */
	"libc_core",    /* <libc/core/string.h> */
	"auto_header",  /* /kos/src/libc/auto/string.h */
	"auto_source",  /* /kos/src/libc/auto/string.c */
	"user",         /* /kos/src/libc/user/string.h */
};


@@Replace a @"defined(__CRT_HAVE_xxx)" sub-part of @ppCond
function replaceCrtHaveFromPreprocessorCondition(
		ppCond: string,
		oldSymbolName: string | UserString,
		newSymbolName: string | UserString): string {
	local oldHave = keyCrtHave(oldSymbolName);
	local newHave = keyCrtHave(newSymbolName);
	if (oldHave !in ppCond) {
		if (ppCond in ["", "1"])
			return newHave;
		if (ppCond in ["0"])
			return ppCond;
		return "({})&&{}".format({ ppCond, newHave });
	}
	return ppCond.replace(oldHave, newHave);
}


function parseCTypeAndName(self: CParser): (CType, UserString | string) {
	local ctype: CType;
	local varname: UserString | string;
	local tok = self.tok;
	if (isCString(tok)) {
		local typename = tok.decode("c-escape");
		tok = self.next();
		if (isCString(tok))
			varname = tok.decode("c-escape");
		else {
			if (!tok.issymbol())
				self.err("Expected keyword or string for variable name, but got {!r}"
					.format({ tok }));
			varname = self.userTok;
		}
		tok   = self.next();
		ctype = CType(typename);
		if (isCString(tok)) {
			ctype.afterName = tok.decode("c-escape");
			self.next();
		} else if (tok in "[(") {
			local afterNameStart = self.tokStart;
			self.skipPair();
			ctype.afterName = self.getUserString(
				afterNameStart, self.tokEnd);
			self.next();
		}
	} else if (tok == "...") {
		/* Ellipsis argument */
		ctype   = CType("...");
		varname = "";
		self.next();
	} else {
		if (!tok.issymbol())
			self.err("Expected keyword or string for typename, but got {!r}".format({ tok }));
		local typenameStart = self.tokStart;
		local typenameEnd = self.tokEnd;
		if (tok in cLanguageTwoWordTypenameKeywords)
			goto continue_typename_expression_twoword;
		tok = self.next();
		for (;;) {
			if (tok in cLanguageTwoWordTypenameKeywords) {
continue_typename_expression_twoword:
				self.next();
continue_typename_expression:
				typenameEnd = self.tokEnd;
				tok = self.next();
				continue;
			}
			if (tok in cLanguageKeywords)
				goto continue_typename_expression;
			if (tok in "*&")
				goto continue_typename_expression;
			break;
		}
		if (tok.issymbol() || isCString(tok)) {
			ctype = CType(self.getUserString(typenameStart, typenameEnd));
			if (isCString(tok))
				varname = tok.decode("c-escape");
			else {
				varname = self.userTok;
			}
			tok = self.next();
			if (tok in "[(" || tok.issymbol()) {
				local suffixStart = self.tokStart;
				for (;;) {
					if (tok in "[(") {
						self.skipPair();
						tok = self.next();
						continue;
					}
					if (tok.issymbol()) {
						tok = self.next();
						continue;
					}
					break;
				}
				ctype.afterName = self.getUserString(
					suffixStart, self.tokStart);
			} else if (isCString(tok)) {
				ctype.afterName = tok.decode("c-escape");
				tok = self.next();
			}
		} else if (tok in "([") {
			/* Inner  variable  name:   "int (*foo)(int x)"
			 * Must split into: "int (*", "foo", ")(int x)" */
			final local PAREN_TABLE = {
				"(" : ")",
				"[" : "]",
				"{" : "}",
			};
			local unwindStack = [PAREN_TABLE[tok]];
			for (;;) {
				typenameEnd = self.tokEnd;
				tok = self.next();
				if (tok in "*&")
					continue;
				if (tok in "([") {
					unwindStack.pushback(PAREN_TABLE[tok]);
					continue;
				}
				if (tok in cLanguageKeywords)
					continue;
				if (tok.issymbol() && ("CALL" in tok || "CC" in tok) && tok.upper() == tok)
					continue; /* Calling convention macro... */
				break;
			}
			ctype = CType(self.getUserString(typenameStart, typenameEnd));
			if (isCString(tok)) {
				varname = tok.decode("c-escape");
				tok = self.next();
			} else if (tok.issymbol()) {
				varname = self.userTok;
				tok = self.next();
			} else {
				varname = "";
			}
			local afterNameStart = self.tokStart;
			local afterNameEnd = afterNameStart;
			while (unwindStack) {
				if (tok == unwindStack.last) {
					unwindStack.popback();
				} else if (tok in "([") {
					self.skipPair();
				} else if (tok in cLanguageKeywords) {
				} else {
					self.err("Unmatched {!r} in ctype expression"
						.format({ unwindStack.last }));
				}
				afterNameEnd = self.tokEnd;
				tok = self.next();
			}
			while (tok in "([") {
				self.skipPair();
				afterNameEnd = self.tokEnd;
				tok = self.next();
			}
			ctype.afterName = self.getUserString(afterNameStart, afterNameEnd);
		} else {
			ctype = CType(self.getUserString(typenameStart, typenameEnd));
			varname = "";
		}
	}
	return (ctype, varname);
}




@@Try to parse a prototype annotation
function parsePrototypeAnnotation(
		self: CParser, prototype: FunctionPrototype,
		attributeList: List with (string | UserString)): bool {
	local tok = self.tok;
	switch (tok) {

	case "cc":
		self.next();
		self.skip("(");
		prototype.cc = self.parseCStringOrAllUntilRParen();
		tok = self.skip(")");
		break;

	case "throws":
		tok = self.next();
		if (tok == "(") {
			self.next();
			prototype.nothrow = "THROWS({})"
				.format({ self.parseCStringOrAllUntilRParenNoComma() });
			self.skip(")");
		} else {
			prototype.nothrow = "THROWS(...)";
		}
		if (prototype.declPrefix !is List)
			prototype.declPrefix = List(prototype.declPrefix);
		if (INCLUDE_KOS_ANNO !in prototype.declPrefix)
			prototype.declPrefix.append(INCLUDE_KOS_ANNO);
		break;

	case "nothrow":
		tok = self.next();
		if (tok == "(") {
			self.next();
			prototype.nothrow = self.parseCStringOrAllUntilRParen();
			self.skip(")");
		} else {
			prototype.nothrow = "NOTHROW";
		}
		break;

	case "vartypes":
		self.next();
		tok = self.skip("(");
		prototype.ellipsisArgumentTypes = [];
		while (tok !in ["", ")"]) {
			local typ, none = parseCTypeAndName(self)...;
			prototype.ellipsisArgumentTypes.append(typ);
			if (self.tok == ")")
				break;
			tok = self.skip(",");
		}
		tok = self.next();
		break;

	case "decl_prefix":
		self.next();
		self.skip("(");
		if (prototype.declPrefix !is List)
			prototype.declPrefix = List(prototype.declPrefix);
		prototype.declPrefix.append(self.parseCStringOrAllUntilRParen());
		self.skip(")");
		break;

	case "decl_include":
		self.next();
		tok = self.skip("(");
		if (prototype.declPrefix !is List)
			prototype.declPrefix = List(prototype.declPrefix);
		while (tok !in ["", ")"]) {
			prototype.declPrefix.append(
				"#include " + self.parseCStringOrAllUntilRParen());
			if (self.tok != ",")
				break;
			tok = self.next();
		}
		self.skip(")");
		break;

	case "attribute":
	case "attributes":
		self.next();
		tok = self.skip("(");
		while (tok !in ["", ")"]) {
			attributeList.append(self.parseCStringOrAllUntilRParen());
			if (self.tok != ",")
				break;
			tok = self.next();
		}
		self.skip(")");
		break;

	case "deprecated":
		tok = self.next();
		if (tok == "(") {
			self.next();
			attributeList.append("ATTR_DEPRECATED({!r})"
				.format({ self.parseCString() }));
			self.skip(")");
		} else {
			attributeList.append("ATTR_DEPRECATED_");
		}
		break;

	default: {
		if (isCString(tok)) {
			attributeList.append(tok.decode("c-escape"));
			self.next();
			break;
		}
		local anno = SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS.get(tok);
		if (anno is none)
			anno = SIMPLE_ATTRIBUTE_ANNOTATIONS.get(tok);
		if (anno is none) {
			anno = SIMPLE_KOS_ATTRIBUTE_ANNOTATIONS.get(tok);
			if (anno !is none) {
				if (prototype.declPrefix !is List)
					prototype.declPrefix = List(prototype.declPrefix);
				if (INCLUDE_KOS_ANNO !in prototype.declPrefix)
					prototype.declPrefix.append(INCLUDE_KOS_ANNO);
			}
		}
		if (anno !is none) {
			if (anno)
				attributeList.append(anno);
			self.next();
			break;
		}
		anno = SIMPLE_NOTHROW_ANNOTATIONS.get(tok);
		if (anno !is none) {
			if (anno.startswith("THROWS")) {
				if (prototype.declPrefix !is List)
					prototype.declPrefix = List(prototype.declPrefix);
				if (INCLUDE_KOS_ANNO !in prototype.declPrefix)
					prototype.declPrefix.append(INCLUDE_KOS_ANNO);
			}
			prototype.nothrow = anno;
			self.next();
			break;
		}
		if (tok.startswith("ATTR_")) {
			/* Attribute annotation. */
			attributeList.append(self.parseCStringOrAllUntilRParen());
			break;
		}
		return false;
	}	break;

	}
	return true;
}


@@Parse the contents of an argument list, starting after the leading  @"(",
@@such that @self.next() will return the first token _after_ that @"(", and
@@stopping such that @self.tok will point at the first character after  the
@@trailing @")"
@@NOTE: Optionally, the current token may be a @"[" upon entry, in which case
@@      @defaultAttributes will not be used, but attributes will rather be
@@      read from the initial tag-list (unless one of the tags is @"[*]")
@@@param: defaultAttributes:             Default function prototype attributes
@@@param: functionArgumentNamesOverride: Names specified via @"[argument_names(...)]"
function parseArgumentList(
		self: CParser, result: FunctionPrototype,
		defaultAttributes: {(string | UserString)...} = (),
		functionArgumentNamesOverride: {(string | UserString)...} = none,
		currentFunction: Function = none) {
	local tok = self.tok;
	if (tok == "[") {
		local numRBracket = 1;
		result.attributes = List();
		do {
again_parse_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "[":
					++numRBracket;
					goto again_parse_annotations;

				case "*":
					result.attributes.extend(defaultAttributes);
					tok = self.next();
					break;

				default:
					if (parsePrototypeAnnotation(self, result, result.attributes))
						break;
					self.err("Unknown prototype annotation {!r}"
						.format({ tok }));
					break;
				}
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_annotation_rbracket:
			tok = self.skip("]");
			if (numRBracket > 1) {
				--numRBracket;
				if (tok != ",")
					goto again_skip_annotation_rbracket;
				goto again_parse_annotations;
			}
		} while (tok == "[");
	} else {
		result.attributes = defaultAttributes;
	}
	tok = self.skip("(");
	local extraAttributes: {Callable...} = [];
	local nonNullArguments: {int...} = none;
	@@Pair of (format-method, format-string-argument-index)
	local formatArgument: (string, int)  = none;
	result.argv = [];
	while (tok != ")") {
		while (tok == "[") {
			local numRBracket = 1;
again_parse_arg_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "[":
					++numRBracket;
					goto again_parse_arg_annotations;

				case "user":
				case "kernel":
				case "checked":
				case "unchecked":
					/* TODO: Pointer  annotations  (from  <kos/anno.h>)
					 * Implement via `CType.commentBefore' (once added) */
					tok = self.next();
					break;

				case "aligned": {
					self.next();
					tok = self.skip("(");
					local alignment = try int(tok) catch(...) tok;
					if (alignment !is int)
						self.err("Expected integer for `[[aligned({})]]'".format({ alignment }));
					self.next();
					tok = self.skip(")");
					/* Do something with `alignment'? */
				}	break;

				case "access": {
					/* Low-level __attribute__((access(...))) annotations. */
					self.next();
					self.skip("(");
					local mode = str self.parseCStringOrKeyword();
					local attrib = {
						"none"       : "ATTR_ACCESS_NONE",
						"rd"         : "ATTR_ACCESS_RO",
						"ro"         : "ATTR_ACCESS_RO",
						"read_only"  : "ATTR_ACCESS_RO",
						"wr"         : "ATTR_ACCESS_WR",
						"write_only" : "ATTR_ACCESS_WR",
						"rw"         : "ATTR_ACCESS_RW",
						"rdwr"       : "ATTR_ACCESS_RW",
						"read_write" : "ATTR_ACCESS_RW",
					}.get(mode);
					if (attrib is none)
						self.err("Invalid access-mode: {!r}".format({ mode }));
					self.skip(")");
					result.attributes.append("{}({})"
						.format({ attrib, #result.argv + 1 }));
				}	break;

				case "format_arg":
					if (result.attributes === defaultAttributes)
						result.attributes = List(defaultAttributes);
					result.attributes.append("__ATTR_FORMAT_ARG({})"
						.format({ #result.argv + 1 }));
					self.next();
					break;

				case "nullable":
				case "null":
					tok = self.next();
					break;

				case "nonnull":
					tok = self.next();
do_add_nonnull_annotation:
					if (nonNullArguments is none)
						nonNullArguments = HashSet();
					nonNullArguments.insert(#result.argv + 1);
					break;

				case "format": {
					local method;
					if (formatArgument !is none) {
						self.err("[[format]] was already specified as {!r}"
							.format({ formatArgument }));
					}
					tok = self.next();
					if (tok == "(" || currentFunction is none) {
						self.skip("(");
						method = self.parseCStringOrAllUntilRParenAsString();
						self.skip(")");
					} else {
						local functionName = currentFunction.name;
						final local METHOD_MARKERS: {string...} = {
							"printf_p", "printf", "scanf" };
						method = none;
						for (local marker: METHOD_MARKERS) {
							local p = functionName.find(marker);
							if (p < 0)
								continue;
							method = marker;
							local textBefore = functionName[:p];
							for (local x: { "w", "c16", "c32" }) {
								if (textBefore.endswith(x)) {
									method = x + method;
									break;
								}
							}
							break;
						}
						if (method is none) {
							self.err("Unable to deduce [[format]] method from function name {!r}"
								.format({ functionName }));
						}
					}
					method = method.strip("_").upper();
					if (method !in {
						"PRINTF", "WPRINTF", "C16PRINTF", "C32PRINTF",
						"PRINTF_P", "WPRINTF_P", "C16PRINTF_P", "C32PRINTF_P",
						"SCANF", "WSCANF", "C16SCANF", "C32SCANF",
						"STRFTIME", "WCSFTIME", "C16FTIME", "C32FTIME",
						"STRFMON",
					}) {
						self.err("Unsupported format method: {!r}"
							.format({ method }));
					}
					formatArgument = (method, #result.argv + 1);
				}	break;

					/* Access attributes:
					 * [[in]]               -->   __attribute__((access(read_only, <I>), nonnull(<I>)))
					 * [[in_opt]]           -->   __attribute__((access(read_only, <I>)))
					 * [[out]]              -->   __attribute__((access(write_only, <I>), nonnull(<I>)))
					 * [[out_opt]]          -->   __attribute__((access(write_only, <I>)))
					 * [[inout]]            -->   __attribute__((access(read_write, <I>), nonnull(<I>)))
					 * [[inout_opt]]        -->   __attribute__((access(read_write, <I>)))
					 * [[in(sizearg)]]      -->   __attribute__((access(read_only, <I>, <indexof(sizearg)>)))
					 * [[out(sizearg)]]     -->   __attribute__((access(write_only, <I>, <indexof(sizearg)>)))
					 * [[inout(sizearg)]]   -->   __attribute__((access(read_write, <I>, <indexof(sizearg)>)))
					 *
					 * Advanced annotations:
					 * 
					 * - >> [[in(strlen(.))]] char const *p
					 *   Explicitly state that `p' is loaded as a c-string (same as `[[in]] char const *p`)
					 * - >> [[in(strnlen(., maxlen))]] char const *p, size_t maxlen
					 *   Specify that `p' is a read_only argument, and that `strnlen(p, maxlen)'
					 *   characters may be accessed. For gcc, we encode this as:
					 *   >> __attribute__((access(read_only, <I>, <indexof("maxlen")>)))
					 *   Since it seems to interprete the size-argument as a sort-of max-size (rather than exact size)
					 * - >> [[in(return <= num_bytes)]] void const *buf, size_t num_bytes
					 *   >> [[out(return <= num_bytes)]] void *buf, size_t num_bytes
					 *   Explicitly specify that up to `num_bytes' (and exactly `return' bytes) are accessed from `buf'
					 *   For gcc, we encode this as (there doesn't seem to be a way to incorporate `return'):
					 *   >> __attribute__((access(read_only, <I>, <indexof("num_bytes")>)))
					 */
				case "in":
				case "in_opt":
				case "out":
				case "out_opt":
				case "inout":
				case "inout_opt": {
					local mode = {
						"in"    : "ATTR_ACCESS_RO",
						"out"   : "ATTR_ACCESS_WR",
						"inout" : "ATTR_ACCESS_RW",
					}[tok.rsstrip("_opt")];
					local argIndex = #result.argv + 1;
					local shouldMarkAsNonNull = !tok.endswith("_opt");
					if (self.next() == "(") {
						/* A sized in/out/inout argument implies a non-NULL argument
						 * if the function it is attached to is PURE or LEAF. Being
						 * a pure or leaf function means that we don't modify the
						 * global state, meaning that NULL-arguments would simply be
						 * handled as a no-op.
						 *
						 * It therefor stands to reason to disallow NULL. */
						if (shouldMarkAsNonNull)
							shouldMarkAsNonNull = result.isPureOrLeaf;
						/* We recognize the following expressions:
						 * >> void   foo([[in]]                       void const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1)))
						 * >> void   foo([[in(sizearg)]]              void const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1, 2)))
						 * >> void   foo([[in(<= sizearg)]]           void const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1, 2)))
						 * >> size_t foo([[in(return <= sizearg)]]    void const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1, 2)))
						 * >> void   foo([[in(sizearg * <N>)]]        void const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1)))
						 * >> void   foo([[in(<N> * sizearg)]]        void const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1)))
						 * >> void   foo([[in(strlen(.))]]            char const *p, size_t sizearg);   -->   __attribute__((nonnull(1), access(read_only, 1)))
						 * >> void   foo([[in(strlen(p))]]            char const *p, size_t sizearg);   -->   __attribute__((nonnull(1), access(read_only, 1)))
						 * >> void   foo([[in(strnlen(., sizearg))]]  char const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1, 2)))
						 * >> void   foo([[in(strnlen(p, sizearg))]]  char const *p, size_t sizearg);   -->   __attribute__((access(read_only, 1, 2)))
						 *
						 * Guarantied equivalencies:
						 *  - [[in   (strlen(.))]] char const *p  <===>   [[in]]    char const *p
						 *  - [[inout(strlen(.))]] char *p        <===>   [[inout]] char const *p
						 *
						 */
						self.next();
						local sizeArgumentName;
						switch (self.tok) {

						case "return":
							self.next();
							self.expect("<=");
							/* FALLTHRU */
						case "<=":
							self.next();
							/* FALLTHRU */
						default: {
							sizeArgumentName = str self.parseCStringOrKeywordOrNumber();
							if (self.tok == "*") {
								self.next();
								local mul = self.parseCStringOrKeywordOrNumber();
								if (mul == "1") {
								} else if (sizeArgumentName == "1") {
									sizeArgumentName = mul;
								} else {
									self.skip(")");
									goto annotate_generic_access;
								}
							}
						}	break;

						case "strlen":
						case "strnlen": {
							local strlen_tok = self.tok;
							self.next();
							self.skip("(");
							if (self.tok == ".") {
								self.next();
							} else {
								local stringArg = str self.parseCStringOrKeyword();
								local expectedArgIndex = #result.argv;
								local errLog = self.tokStart;
								extraAttributes.append([]{
									local realArgName = str result.argv[expectedArgIndex].name;
									if (stringArg != realArgName) {
										self.errAt(errLog, "[[<access>(strlen({}))]] attached to wrong argument {!r}"
											.format({ stringArg, realArgName }));
									}
								});
							}
							if (strlen_tok == "strlen") {
								shouldMarkAsNonNull = true;
								self.skip(")");
								self.skip(")");
								goto annotate_generic_access;
							}
							self.skip(",");
							sizeArgumentName = str self.parseCStringOrKeyword();
							self.skip(")");
						}	break;

						}
						self.skip(")");
						extraAttributes.append([]{
							local sizeArg = result.argsByName[sizeArgumentName];
							local sizeIndex = str(result.argv.index(sizeArg) + 1);
							result.attributes.append("{}S({}, {})"
								.format({ mode, argIndex, sizeIndex }));
						});
						if (shouldMarkAsNonNull) {
							if (nonNullArguments is none)
								nonNullArguments = HashSet();
							nonNullArguments.insert(#result.argv + 1);
						}
					} else {
annotate_generic_access:
						if (shouldMarkAsNonNull) {
							result.attributes.append("{}({})"
								.format({ mode, argIndex }));
						} else {
							result.attributes.append("{}_OPT({})"
								.format({ mode, #result.argv + 1 }));
						}
					}
					tok = self.tok;
				}	break;
				

					/* (Mostly) ignored annotations */
				case "inp":
				case "inpb":
				case "inp_opt":
				case "inpb_opt":
				case "outp":
				case "outpb":
				case "outp_opt":
				case "outpb_opt":
				case "inoutp":
				case "inoutpb":
				case "inoutp_opt":
				case "inoutpb_opt":
					self.next();
					self.skip("(");
					self.skipPair("(", ")");
					self.skip(")");
					if (!tok.endswith("_opt"))
						goto do_add_nonnull_annotation;
					break;

				default:
					self.err("Unknown argument annotation {!r}"
						.format({ tok }));
					break;
				}
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_arg_annotation_rbracket:
			tok = self.skip("]");
			if (numRBracket > 1) {
				--numRBracket;
				if (tok != ",")
					goto again_skip_arg_annotation_rbracket;
				goto again_parse_arg_annotations;
			}
		}
		local typ, name = parseCTypeAndName(self)...;
		local arg = Argument(name: name, protoTypeName: name, ctype: typ);
		if (functionArgumentNamesOverride !is none) {
			local argi = #result.argv;
			if (argi >= #functionArgumentNamesOverride)
				self.err("Too few function argument name overrides were given");
			arg.name = functionArgumentNamesOverride[argi];
		}
		result.argv.append(arg);
		tok = self.tok;
		if (tok != ",")
			break;
		tok = self.next();
	}
	if (#result.argv == 1) {
		local arg0 = result.argv.first;
		if (!arg0.name && arg0.ctype.beforeName == "void" && !arg0.ctype.afterName)
			result.argv = []; /* Argument list is actually empty! */
	}
	self.skip(")");
	/* Resolve extra attributes that must be generated after arguments have all been loaded. */
	for (local extra: extraAttributes)
		extra();
	if (nonNullArguments) {
		local attrib = "NONNULL(({}))"
			.format({ ", ".join(nonNullArguments.sorted()) });
		if (result.attributes === defaultAttributes)
			result.attributes = List(defaultAttributes);
		result.attributes.append(attrib);
	}
	if (formatArgument !is none) {
		local attrib = "ATTR_LIBC_{}({}, {})".format({
			formatArgument.first,
			formatArgument.last,
			result.hasEllipsis ? #result.argv : 0,
		});
		if (result.attributes === defaultAttributes)
			result.attributes = List(defaultAttributes);
		result.attributes.append(attrib);
		if (result.declPrefix !is List)
			result.declPrefix = List(result.declPrefix);
		if (INCLUDE_CRT !in result.declPrefix)
			result.declPrefix.append(INCLUDE_CRT);
	}
}

@@Same as @parseArgumentList, but also parse an optional trailing @"-> TYPE"
@@or @": TYPE" suffix, and throw an error  if such a suffix is present,  but
@@some other return type had already been defined.
@@Upon return, @self will point at the first character after the return type
function parseArgumentListAndOptionalTrailingReturnType(
		self: CParser, result: FunctionPrototype,
		defaultAttributes: {(string | UserString)...} = (),
		functionArgumentNamesOverride: {(string | UserString)...} = none,
		currentFunction: Function = none) {
	parseArgumentList(self, result, defaultAttributes,
		functionArgumentNamesOverride, currentFunction);
	if (self.tok in ["->", ":"]) {
		local tok = self.next();
		if (result.returnType is bound)
			self.err("A return type was already defined");
		while (tok == "[") {
			local numRBracket = 1;
again_parse_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "[":
					++numRBracket;
					goto again_parse_annotations;

				case "==": {
					tok = self.next();
					if (!tok.issymbol()) {
						self.err("Expected argumet name in [== ...], but got {!r}"
							.format({ tok }));
					}
					local baseArg: Argument;
					try {
						baseArg = result.argsByName[tok];
					} catch (Error as e) {
						self.err(e.message);
					}
					tok = self.next();
					if (tok == "+") {
						self.next();
						self.parseAllUntilRParenAsString();
					}
					for (local a: result.attributes) {
						a = str a;
						local nonNullArgs;
						if (a.startswith("NONNULL((") && a.endswith("))")) {
							nonNullArgs = a[9:-2];
						} else if (a.startswith("NONNULL((") && a.endswith("))")) {
							nonNullArgs = a[16:-2];
						} else {
							continue;
						}
						nonNullArgs = nonNullArgs.split(",").each.strip();
						if (str(result.argv.index(baseArg) + 1) in nonNullArgs) {
							result.attributes.append("ATTR_RETNONNULL");
							break;
						}
					}
				}	break;

				case "malloc":
				case "malloc_unaligned": {
					if (result.attributes === defaultAttributes)
						result.attributes = List(defaultAttributes);
					result.attributes.append("WUNUSED");
					result.attributes.append("ATTR_MALLOC");
					if (tok != "malloc_unaligned")
						result.attributes.append("ATTR_MALL_DEFAULT_ALIGNED");
					if (self.next() == "(") {
						self.next();
						local argumentIndices = [];
						while (self.tok !in ["", ")"]) {
							local argumentNameStart = self.tokStart;
							local argumentName = self.parseCStringOrKeyword();
							try {
								argumentIndices.append(
									result.argv.index(result.argsByName[argumentName]) + 1);
							} catch (Error as e) {
								self.errAt(argumentNameStart, e.message);
							}
							if (self.tok !in [",", "*"])
								break;
							self.next();
						}
						result.attributes.append("ATTR_ALLOC_SIZE(({}))"
							.format({ ", ".join(argumentIndices) }));
						self.skip(")");
					}
				}	break;

				case "realloc":
				case "realloc_unaligned": {
					self.next();
					self.skip("(");
					self.parseCStringOrKeyword();
					self.skip(",");
					local argumentIndices = [];
					while (self.tok !in ["", ")"]) {
						local argumentNameStart = self.tokStart;
						local argumentName = self.parseCStringOrKeyword();
						try {
							argumentIndices.append(
								result.argv.index(result.argsByName[argumentName]) + 1);
						} catch (Error as e) {
							self.errAt(argumentNameStart, e.message);
						}
						if (self.tok !in [",", "*"])
							break;
						self.next();
					}
					if (result.attributes === defaultAttributes)
						result.attributes = List(defaultAttributes);
					result.attributes.append("WUNUSED");
					if (tok != "realloc_unaligned")
						result.attributes.append("ATTR_MALL_DEFAULT_ALIGNED");
					result.attributes.append("ATTR_ALLOC_SIZE(({}))"
						.format({ ", ".join(argumentIndices) }));
					self.skip(")");
				}	break;

				case "realign":
				case "memalign": {
					self.next();
					self.skip("(");
					if (tok == "realign") {
						self.parseCStringOrKeyword(); /* mallptr */
						self.skip(",");
					}
					local minAlignmentAttrib;
					if (self.tok == "getpagesize") {
						self.next();
						self.skip("(");
						self.skip(")");
						minAlignmentAttrib = "__ATTR_MALL_PAGEALIGNED";
					} else {
						local minAlignmentArgumentNameStart = self.tokStart;
						local minAlignmentArgumentName = self.parseCStringOrKeyword();
						try {
							minAlignmentAttrib = "ATTR_ALLOC_ALIGN({})"
							.format({ result.argv.index(result.argsByName[minAlignmentArgumentName]) + 1 });
						} catch (Error as e) {
							self.errAt(minAlignmentArgumentNameStart, e.message);
						}
					}
					self.skip(",");
					local argumentIndices = [];
					while (self.tok !in ["", ")"]) {
						local argumentNameStart = self.tokStart;
						local argumentName = self.parseCStringOrKeyword();
						try {
							argumentIndices.append(
								result.argv.index(result.argsByName[argumentName]) + 1);
						} catch (Error as e) {
							self.errAt(argumentNameStart, e.message);
						}
						if (self.tok !in [",", "*"])
							break;
						self.next();
					}
					if (result.attributes === defaultAttributes)
						result.attributes = List(defaultAttributes);
					result.attributes.append("WUNUSED");
					if (tok != "realign")
						result.attributes.append("ATTR_MALLOC");
					result.attributes.append(minAlignmentAttrib);
					result.attributes.append("ATTR_ALLOC_SIZE(({}))"
						.format({ ", ".join(argumentIndices) }));
					self.skip(")");
				}	break;

				default: {
					local anno = SIMPLE_RETURN_TYPE_ATTRIBUTE_ANNOTATIONS.get(tok);
					if (anno is none) {
						self.err("Unknown return type attribute {!r}"
							.format({ tok }));
					}
					if (anno) {
						if (result.attributes === defaultAttributes)
							result.attributes = List(defaultAttributes);
						result.attributes.append(anno);
					}
					self.next();
				}	break;
				}
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_annotation_rbracket:
			tok = self.skip("]");
			if (numRBracket > 1) {
				--numRBracket;
				if (tok != ",")
					goto again_skip_annotation_rbracket;
				goto again_parse_annotations;
			}
		}
		if (!tok.issymbol())
			self.err("Expected a keyword for function return type");
		local returnTypeStart = self.tokStart;
		local returnTypeEnd;
		for (;;) {
			returnTypeEnd = self.tokEnd;
			tok = self.next();
			if (!tok.issymbol()) {
				if (tok in "*&")
					continue;
				if (tok in "([") {
					self.skipPair(tok);
					continue;
				}
				break;
			}
		}
		result.returnType = CType(
			self.getUserString(
				returnTypeStart, returnTypeEnd));
	}
}

function parseWholeFunctionPrototype(
		self: CParser, result: FunctionPrototype,
		defaultAttributes: {(string | UserString)...} = (),
		functionArgumentNamesOverride: {(string | UserString)...} = none,
		currentFunction: Function = none) {
	if (self.tok != "(") {
		/* Try to parse a leading return type designator */
		result.returnType = parseCTypeAndName(self)[0];
	}
	parseArgumentListAndOptionalTrailingReturnType(
		self, result, defaultAttributes,
		functionArgumentNamesOverride,
		currentFunction);
	if (result.returnType !is bound)
		result.returnType = CType("void");
}


function constructAliasConditions(
		ppCond: string | none,
		assemblyName: string | UserString): string {
	local hasAssemblyName = keyCrtHave(assemblyName);
	if (ppCond is none || ppCond == "1")
		return hasAssemblyName;
	return "{} && ({})".format({ hasAssemblyName, ppCond });
}

@@Split a given section-string and return it as (dosSection, kosSection)
function splitSectionsString(s: string): (string, string) {
	if ("{" !in s)
		return (s, s);
	local dfp = File.Writer();
	local kfp = File.Writer();
	local i = 0;
	for (;;) {
		local cs = s.find("{", i);
		if (cs < 0)
			break;
		local e = s[i:cs];
		dfp << e;
		kfp << e;
		local ce = s.index("}", cs);
		local cc = s.index("|", cs, ce);
		kfp << s[cs + 1:cc]; /* First part: KOS section name */
		dfp << s[cc + 1:ce]; /* Second part: DOS section name */
		i = ce + 1;
	}
	local e = s[i:];
	return ((dfp << e).string, (kfp << e).string);
}


class FunctionFeatures {
	this = default;

	/* Declaration features */
	public member decl: UserString | string = DEFAULT_DECL;          /* [decl(...)]             Declaration prefix */
	public member std: bool = false;                                 /* [std]                   Expose as part of the std:: namespace */
	public member namespaces: {string...} = ("",);                   /* [[no_]ignore]           Namespaces from which to import the function */
	public member libc: bool = false;                                /* [[no_]libc]             Export in <libc/string.h> */
	public member inline: UserString | string | none = none;         /* [[no_]inline]           Use the associated body for inline implementations, rather than including <libc/local/...> headers */
	public member noInlineTruncate: bool = false;                    /* [[no_]inline_truncate]  Truncate spaces and new-lines from inline implementations */
	public member noExternInline: bool = false;                      /* [[no_]extern_inline]    For use with @inline: Don't convert inline */
	public member noLocal: bool = false;                             /* [[no_]local]            Prevent the creation of a LocalFunction for */
	public member requires: UserString | string = "1";               /* [[no_]requires(...)]    A preprocessor condition that must be true in order to use the local/inline implementation */
	public member requiresPrefix: {(UserString | string)...} = ();   /* [requires_prefix(...)]  A piece of text that must be inserted before @requires can be used */
	public member implPrefix: {(UserString | string)...} = ();       /* [impl_prefix(...)]      A piece of text that must be inserted before the local implementation can be used */
	public member macroBinding: bool = false;                        /* [[no_]macros]           Allow the use of macros when declaring this function */
	public member guard: bool = false;                               /* [[no_]guard]            Surround the declaration of the function with a guard */
	public member guardNames: {string: (UserString | string | none)} = none; /* Guard names in different namespaces */
	public member exposedName: UserString | string | none = none;    /* [[no_]exposed_name(...)] The name under which the function will be exposed in system headers. */
	public member forcedDependencies: {(UserString | string)...} | none = none; /* [dependency(...)] Force dependencies on the given set of functions. */
	public member unforcedDependencies: {(UserString | string)...} | none = none; /* [not_dependency(...)] Force a given set of functions to not be considered dependencies. */
	public member noAutoDependencyScanning: bool = false;            /* [[no_]auto_dependency_scanning] Automatically scan for dependencies */

	/* WCHAR function features */
	public member wchar: bool = false; /* [[no_]wchar] Expose and implement as a wchar-function (NOTE: Also implies `crt_dosVariant') */

	/* CRT Features */
	public member crt_name: UserString | string | none = none;       /* [[default_]crt_name(...)]    Symbol name override for the default CRT function binding */
	public member crt_noImpl: bool = false;                          /* [[no_]crt_impl]              Don't implement function within the CRT */
	public member crt_noSelfImport: bool = false;                    /* [[no_]crt_self_import]       Prevent importing from ASMNAME(crt_name || current.name) */
	public member crt_noSelfExport: bool = false;                    /* [[no_]crt_self_export]       Prevent exporting as ASMNAME(crt_name || current.name) */
	public member crt_userimpl: bool = false;                        /* [[no_]userimpl]              Prevent implementation in libc/auto and always use libc/user */
	public member crt_dosVariant: bool | FunctionImplementation | Callable = false;
	                                                                 /* [[no_]crt_dos_variant]       The function has a dedicated DOS-implementation (may also be set to the actual impl, or a callable to generate said impl) */
	public member crt_noDosWrapper: bool = false;                    /* [[no_]crt_dos_wrapper]       Don't generate a dos-wrapper function when (!wchar && !crt_dosVariant) */
	public member crt_kosSection: UserString | string | none = none; /* [kos_section(...)]           Section name for the KOS implementation */
	public member crt_dosSection: UserString | string | none = none; /* [dos_section(...)]           Section name for the DOS implementation (if @wchar) */
	public member crt_kosImplRequires: UserString | string = "1";    /* [crt_kos_impl_requires(...)] Condition to meet for auto implementation (does not affect declaration; e.g. `!defined(LIBC_ARCH_HAVE_MEMCHR)') */
	public member crt_dosImplRequires: UserString | string = "1";    /* [crt_dos_impl_requires(...)] Same as `crt_kosImplRequires', but for the DOS implementation */
	public member crt_kosExtraAttr: {UserString | string...} | none = none; /* [crt_kos_attr(...)]   Extra (implementation-only) in-crt attributes for KOS variant. */
	public member crt_dosExtraAttr: {UserString | string...} | none = none; /* [crt_dos_attr(...)]   Extra (implementation-only) in-crt attributes for DOS variant. */
	public member crt_dosNoOptimizeSize: bool = false;               /* [[no_]crt_dos_optimize_size] When `false', add `ATTR_OPTIMIZE_SIZE' to `crt_dosExtraAttr'. */

	@@Return extra attributes for the KOS crt implementation
	public function getCrtKosExtraAttr(): {UserString | string...} | none {
		return crt_kosExtraAttr;
	}

	@@Return extra attributes for the DOS crt implementation
	public function getCrtDosExtraAttr(): {UserString | string...} | none {
		if (crt_dosNoOptimizeSize)
			return crt_dosExtraAttr;
		local result = crt_dosExtraAttr;
		if (result is none)
			result = ();
		result = List(result);
		result.append("ATTR_OPTIMIZE_SIZE");
		return result;
	}

	@@Enable a given namespace binding (via `using`)
	public function addNamespaceUsingBinding(name: string) {
		if (namespaces == ("",))
			namespaces = ("", name,);
		else if (name in namespaces)
			;
		else {
			namespaces = List(namespaces);
			namespaces.append(name);
		}
	}

	@@Prevent a given namespace binding (via `using`)
	public function delNamespaceUsingBinding(name: string) {
		if (name !in namespaces)
			;
		else if (#namespaces == 2 && "" in namespaces) {
			namespaces = ("", );
		} else {
			namespaces = List(namespaces);
			namespaces.remove(name);
		}
	}

	@@Set the name of a guard (to-be used when @guard
	@@is true) for  a given namespace  @namespaceName
	public function setNamespaceGuardName(
			namespaceName: string, guardName: string | UserString | none) {
		if (guardName is none) {
			if (namespaceName !in guardNames)
				return;
			guardNames = Dict(guardNames);
			del guardNames[namespaceName];
		} else {
			guardNames = Dict(guardNames);
			guardNames[namespaceName] = guardName;
		}
	}

	@@Try to parse a feature attribute
	@@@return: true:  Success
	@@@return: false: Unknown attribute
	public function tryParseAttribute(
			self: CParser, ppCond: string | UserString | none = none): bool {
		local tok = self.tok;
		@@Simple annotations that only entail setting the value of some field.
		@@This  is  a mapping  of: @(tagName:  (fieldName, toBeAssignedValue))
		final local SIMPLE_SETFIELD_ANNOTATIONS: {string: (string, Object)} = {
			"nodecl"                       : ("decl", "__LIBC" /*DEFAULT_DECL*/),
			"no_decl"                      : ("decl", "__LIBC" /*DEFAULT_DECL*/),
			"ignore"                       : ("namespaces", ()),
			"no_ignore"                    : ("namespaces", ("",)),
			"libc"                         : ("libc", true),
			"nolibc"                       : ("libc", false),
			"no_libc"                      : ("libc", false),
			"inline"                       : ("inline", "LOCAL"),
			"forceinline"                  : ("inline", "FORCELOCAL"),
			"noinline"                     : ("inline", none),
			"no_inline"                    : ("inline", none),
			"inline_truncate"              : ("noInlineTruncate", false),
			"no_inline_truncate"           : ("noInlineTruncate", true),
			"extern_inline"                : ("noExternInline", false),
			"no_extern_inline"             : ("noExternInline", true),
			"local"                        : ("noLocal", false),
			"noLocal"                      : ("noLocal", true),
			"no_local"                     : ("noLocal", true),
			"norequires"                   : ("requires", "1"),
			"no_requires"                  : ("requires", "1"),
			"no_requires_prefix"           : ("requiresPrefix", ""),
			"no_impl_prefix"               : ("implPrefix", ""),
			"macro_bindings"               : ("macroBinding", true),
			"no_macro_bindings"            : ("macroBinding", false),
			"noguard"                      : ("guard", false),
			"no_guard"                     : ("guard", false),
			"default_guard_names"          : ("guardNames", none),
			"default_exposed_name"         : ("exposedName", none),
			"wchar"                        : ("wchar", true),
			"no_wchar"                     : ("wchar", false),
			"crt_dos_variant"              : ("crt_dosVariant", true),
			"no_crt_dos_variant"           : ("crt_dosVariant", false),
			"crt_dos_wrapper"              : ("crt_noDosWrapper", false),
			"no_crt_dos_wrapper"           : ("crt_noDosWrapper", true),
			"default_crt_name"             : ("crt_name", none),
			"crt_impl"                     : ("crt_noImpl", false),
			"no_crt_impl"                  : ("crt_noImpl", true),
			"crt_self_import"              : ("crt_noSelfImport", false),
			"no_crt_self_import"           : ("crt_noSelfImport", true),
			"crt_self_export"              : ("crt_noSelfExport", false),
			"no_crt_self_export"           : ("crt_noSelfExport", true),
			"no_crt_kos_impl_requires"     : ("crt_kosImplRequires", "1"),
			"no_crt_dos_impl_requires"     : ("crt_dosImplRequires", "1"),
			"userimpl"                     : ("crt_userimpl", true),
			"no_userimpl"                  : ("crt_userimpl", false),
			"default_kos_section"          : ("crt_kosSection", none),
			"default_dos_section"          : ("crt_dosSection", none),
			"auto_dependency_scanning"     : ("noAutoDependencyScanning", false),
			"no_auto_dependency_scanning"  : ("noAutoDependencyScanning", true),
			"no_crt_kos_attr"              : ("crt_kosExtraAttr", none),
			"no_crt_dos_attr"              : ("crt_dosExtraAttr", none),
			"crt_dos_optimize_size"    : ("crt_dosNoOptimizeSize", false),
			"no_crt_dos_optimize_size" : ("crt_dosNoOptimizeSize", true),
		};

		switch (tok) {

		case "no_crt_impl_requires":
			crt_kosImplRequires = "1";
			crt_dosImplRequires = "1";
			break;

		case "crt":
			crt_noImpl       = false;
			crt_noSelfImport = false;
			crt_noSelfExport = false;
			goto oneword_nocond;

		case "static":
			/* static function:
			 *  - Only exists in libc or <libc/local/...> headers if used
			 *  - Isn't actually exposed in system headers
			 *  - Can only be used lazily as a dependency from other functions
			 *  - HINT: Can be used in conjunction with [[inline]]
			 */
			namespaces       = ();
			macroBinding     = true;
			guard            = false;
			crt_noSelfImport = true;
			crt_noSelfExport = true;
			crt_noDosWrapper = true; /* Can be re-enabled if ~really~ needed... */
			goto oneword_nocond;

		case "nodos":
			crt_dosVariant = false;
			crt_noDosWrapper = true;
			goto oneword_nocond;

		case "nocrt":
		case "no_crt":
			crt_noImpl       = true;
			crt_noSelfImport = true;
			crt_noSelfExport = true;
			goto oneword_nocond;

		case "hidden":
			delNamespaceUsingBinding("");
			goto oneword_nocond;

		case "exposed":
			addNamespaceUsingBinding("");
			goto oneword_nocond;

		case "std":
			std = true;                      /* Expose as part of std:: */
			addNamespaceUsingBinding("std"); /* Allow importing from std:: */
			goto oneword_nocond;

		case "nostd":
		case "no_std":
			std = false;                     /* Don't expose as part of std:: */
			delNamespaceUsingBinding("std"); /* Disallow importing from std:: */
			goto oneword_nocond;

		case "fast": /* TODO: REMOVE_ME */
			addNamespaceUsingBinding("fast");
			goto oneword_nocond;

		case "nofast": /* TODO: REMOVE_ME */
			delNamespaceUsingBinding("fast");
			goto oneword_nocond;

		case "crt_attr":
		case "crt_kos_attr":
		case "crt_dos_attr": {
			self.next();
			self.skip("(");
			local appendTargets = [];
			if (tok != "crt_dos_attr") {
				if (crt_kosExtraAttr is none)
					crt_kosExtraAttr = [];
				appendTargets.append(crt_kosExtraAttr);
			}
			if (tok != "crt_kos_attr") {
				if (crt_dosExtraAttr is none)
					crt_dosExtraAttr = [];
				appendTargets.append(crt_dosExtraAttr);
			}
			for (local extra: self.parseCStringOrFunctionLikeExpressionList()) {
				for (local item: appendTargets)
					item.append(extra);
			}
			self.skip(")");
		}	break;

		case "requires": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			local addend = self.parseCStringOrAllUntilRParen();
			self.skip(")");
			if (requires is UserString || requires != "1")
				addend = "({}) && ({})".format({ requires, addend });
			requires = addend;
		}	break;

		case "requires_function": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			while (self.tok !in ["", ")"]) {
				local addend = "$has_function({})".format({ self.parseCStringOrKeyword() });
				if (requires is UserString || requires != "1")
					addend = "({}) && ({})".format({ requires, addend });
				requires = addend;
				if (self.tok != ",")
					break;
				self.next();
			}
			self.skip(")");
		}	break;

		case "requires_dependent_function": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			forcedDependencies = HashSet(forcedDependencies);
			while (self.tok !in ["", ")"]) {
				local functionName = self.parseCStringOrKeyword();
				forcedDependencies.insert(functionName);
				local addend = "$has_function({})".format({ functionName });
				if (requires is UserString || requires != "1")
					addend = "({}) && ({})".format({ requires, addend });
				requires = addend;
				if (self.tok != ",")
					break;
				self.next();
			}
			self.skip(")");
		}	break;

		case "requires_include": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			if (requiresPrefix !is List)
				requiresPrefix = List(requiresPrefix);
			while (tok !in ["", ")"]) {
				requiresPrefix.append(
					"#include " + self.parseCStringOrAllUntilRParen());
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
			self.skip(")");
		}	break;

		case "requires_prefix": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			if (requiresPrefix !is List)
				requiresPrefix = List(requiresPrefix);
			requiresPrefix.append(self.parseCStringOrAllUntilRParen());
			self.skip(")");
		}	break;

		case "impl_include": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			tok = self.skip("(");
			if (implPrefix !is List)
				implPrefix = List(implPrefix);
			while (tok !in ["", ")"]) {
				implPrefix.append(
					"#include " + self.parseCStringOrAllUntilRParen());
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
			self.skip(")");
		}	break;

		case "impl_prefix": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			if (implPrefix !is List)
				implPrefix = List(implPrefix);
			implPrefix.append(self.parseCStringOrAllUntilRParen());
			self.skip(")");
		}	break;

		case "section": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			local sectionNameStart = self.tokStart;
			local sectionName = self.parseCStringOrAllUntilRParen();
			self.skip(")");
			try {
				crt_dosSection, crt_kosSection =
					splitSectionsString(str(sectionName))...;
			} catch (Error as e) {
				self.errAt(sectionNameStart, e.message);
			}
		}	break;

		case "kos_section":
		case "dos_section": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			local name = self.parseCStringOrAllUntilRParen();
			if (tok == "kos_section")
				crt_kosSection = name;
			else {
				crt_dosSection = name;
			}
			self.skip(")");
		}	break;

		case "decl": {
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			decl = self.parseCStringOrKeyword();
			self.skip(")");
		}	break;

		case "guard":
			if (ppCond !is none)
				goto err_unexpected_if;
			guard = true;
			tok = self.next();
			if (tok == "(") {
				/* Define the name for the GLOBAL_NAMESPACE guard. */
				self.next();
				guardNames = Dict(guardNames);
				setNamespaceGuardName(
					"" /* GLOBAL_NAMESPACE.name */,
					self.parseCStringOrKeyword());
				self.skip(")");
			}
			break;

		case "exposed_name":
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			exposedName = self.parseCStringOrKeyword();
			self.skip(")");
			break;

		case "crt_name":
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			crt_name = self.parseCStringOrKeyword();
			self.skip(")");
			break;

		case "crt_impl_requires":
		case "crt_kos_impl_requires":
		case "crt_dos_impl_requires":
			if (ppCond !is none)
				goto err_unexpected_if;
			self.next();
			self.skip("(");
			{
				local req = self.parseCStringOrAllUntilRParen();
				if (tok != "crt_dos_impl_requires")
					crt_kosImplRequires = req;
				if (tok != "crt_kos_impl_requires")
					crt_dosImplRequires = req;
			}
			self.skip(")");
			break;

		case "dependency":
		case "not_dependency": {
			local my = tok;
			local myField, otField, ot = {
				"dependency"     : ("forcedDependencies", "unforcedDependencies", "not_dependency"),
				"not_dependency" : ("unforcedDependencies", "forcedDependencies", "dependency"),
			}[tok]...;
			local other = this.operator . (otField);
			local field = HashSet(this.operator . (myField));
			this.operator . (myField) = field;
			self.next();
			tok = self.skip("(");
			while (tok !in ["", ")"]) {
				if (isCString(tok))
					tok = tok.decode("c-escape");
				else if (!tok.issymbol()) {
					self.err("Expected keyword or string after [{}(...)], but got {!r}"
						.format({ my, tok }));
				}
				if (tok in other) {
					self.err("[{0}({2!r})] was already declared as [{1}({2!r})]"
						.format({ my, ot, tok }));
				}
				field.insert(tok);
				tok = self.next();
				if (tok != ",")
					break;
				tok = self.next();
			}
			self.skip(")");
		}	break;

		case "without_dependency":
		case "without_not_dependency": {
			local my = tok;
			local myField, ot = {
				"without_dependency"     : ("forcedDependencies", "without_not_dependency"),
				"without_not_dependency" : ("unforcedDependencies", "without_dependency"),
			}[tok]...;
			local field = HashSet(this.operator . (myField));
			this.operator . (myField) = field;
			self.next();
			tok = self.skip("(");
			while (tok !in ["", ")"]) {
				if (isCString(tok))
					tok = tok.decode("c-escape");
				else if (!tok.issymbol()) {
					self.err("Expected keyword or string after [{}(...)], but got {!r}"
						.format({ my, tok }));
				}
				field.remove(tok);
				tok = self.next();
				if (tok != ",")
					break;
				tok = self.next();
			}
			self.skip(")");
		}	break;


		default: {
			local op = SIMPLE_SETFIELD_ANNOTATIONS.get(tok);
			if (op !is none) {
				this.operator . (op[0]) = op[1];
oneword_nocond:
				if (ppCond !is none) {
err_unexpected_if:
					self.err("Annotation [{}] cannot be used with [if(...)]"
						.format({ tok }));
				}
				self.next();
				break;
			}
			return false;
		}	break;

		}
		return true;
	}

	@@Assert  that  all   annotations  that  are   only  valid  when   a
	@@function body is present match the annotations of @defaultFeatures
	public function assertDefaultAttributesWithoutImplementation(
			defaultFeatures: FunctionFeatures): string {
		if (inline !== defaultFeatures.inline)
			return "[no_]inline";
		if (crt_userimpl !== defaultFeatures.crt_userimpl)
			return "[no_]userimpl";
		if (noLocal !== defaultFeatures.noLocal)
			return "[no_]local";
		if (noExternInline !== defaultFeatures.noExternInline)
			return "[no_]extern_inline";
		if (requires !== defaultFeatures.requires)
			return "[no_]requires";
		if (requiresPrefix !== defaultFeatures.requiresPrefix)
			return "[no_]requires_prefix";
		if (implPrefix !== defaultFeatures.implPrefix)
			return "[no_]impl_prefix";
		if (noAutoDependencyScanning !== defaultFeatures.noAutoDependencyScanning)
			return "[no_]auto_dependency_scanning";
		if (forcedDependencies !== defaultFeatures.forcedDependencies)
			return "[without_]dependency";
		if (unforcedDependencies !== defaultFeatures.unforcedDependencies)
			return "[without_]not_dependency";
		return none;
	}

	public function assertAllDefaultAttributesWithoutImplementation(
			self: CParser, defaultFeatures: FunctionFeatures, functionName: string) {
		local altered = assertDefaultAttributesWithoutImplementation(defaultFeatures);
		if (altered !is none) {
			self.err("Annotation [{}] requires the presence of a function {!r} body"
				.format({ altered, functionName }));
		}
	}

	public function assertSymbolicAliasOnly(
			defaultFeatures: FunctionFeatures): string {
		if (crt_name !== defaultFeatures.crt_name)
			return "[default_]crt_name";
		if (crt_noImpl != defaultFeatures.crt_noImpl)
			return "[no_]crt_impl";
		if (crt_noSelfImport != defaultFeatures.crt_noSelfImport)
			return "[no_]crt_self_import";
		if (crt_noSelfExport != defaultFeatures.crt_noSelfExport)
			return "[no_]crt_self_export";
		if (crt_dosSection !== defaultFeatures.crt_dosSection)
			return "[no_]dos_section";
		if (crt_kosSection !== defaultFeatures.crt_kosSection)
			return "[no_]kos_section";
		if (crt_kosExtraAttr !== defaultFeatures.crt_kosExtraAttr)
			return "[no_]crt_kos_attr";
		if (crt_dosExtraAttr !== defaultFeatures.crt_dosExtraAttr)
			return "[no_]crt_dos_attr";
		if (crt_dosNoOptimizeSize !== defaultFeatures.crt_dosNoOptimizeSize)
			return "[no_]crt_dos_optimize_size";
		if (crt_dosImplRequires !== defaultFeatures.crt_dosImplRequires)
			return "[no_]crt_kos_impl_requires";
		if (crt_kosImplRequires !== defaultFeatures.crt_kosImplRequires)
			return "[no_]crt_kos_impl_requires";
		if (crt_dosVariant !== defaultFeatures.crt_dosVariant)
			return "[no_]crt_dos_variant";
		if (crt_noDosWrapper !== defaultFeatures.crt_noDosWrapper)
			return "[no_]crt_dos_wrapper";
		if (decl !== defaultFeatures.decl)
			return "decl";
		return none;
	}

	@@Assert  that no annotations  are given that  wouldn't make sense for
	@@symbolic aliasing functions, such that %{uchar} or '= other' aliases
	public function assertAllSymbolicAliasOnly(
			self: CParser, defaultFeatures: FunctionFeatures, functionName: string) {
		local altered = assertSymbolicAliasOnly(defaultFeatures);
		if (altered !is none) {
			self.err("Annotation [{}] cannot be used with aliasing function {!r}"
				.format({ altered, functionName }));
		}
	}

	@@Assert  that no annotations  are given that  wouldn't make sense for
	@@symbolic aliasing functions, such that %{uchar} or '= other' aliases
	public function assertAllGeneratedFunctionBody(
			self: CParser, functionName: string) {
		if (requires != "1")
			self.err("Function {!r} has a generated implementation, but uses [requires({!r})]"
				.format({ functionName, requires }));
		if (requiresPrefix)
			self.err("Function {!r} has a generated implementation, but uses [requires_prefix({!r})]"
				.format({ functionName, requiresPrefix }));
		if (implPrefix)
			self.err("Function {!r} has a generated implementation, but uses [impl_prefix({!r})]"
				.format({ functionName, implPrefix }));
	}

}

function truncateInlineFunctionImplementation(text: string): string {
	if ("\n#" in text || text.startswith("#"))
		return text; /* XXX: This could be done better... */
	local result = text.replace("\n", " ").replace("\t", " ");
	for (;;) {
		local newText = result.replace("  ", " ");
		if (result == newText)
			break;
		result = newText;
	}
	return result;
}

@@Add   @func   to   @mapping   under    @mapping[func.name]
@@If  another object  was already  bound to  under that key,
@@replace the existing object with @DuplicateFunctionMarker.
@@NOTE: This function operates atomically between multiple threads,
@@      which is required  when multiple  system header  definition
@@      source files are loaded by separate threads.
function defineFunctionInMapping(
		mapping: {string: Function} | {string: LocalFunction},
		func: Function | LocalFunction) {
	for (;;) {
		if (mapping.setnew(func.name, func))
			break;
		if (mapping.setold(func.name, DuplicateFunctionMarker)) {
			print "Duplicate function:", func.name;
			break;
		}
	}
}


#define DELAY_printDefaultLibraryImplementationForPrototype
#ifdef DELAY_printDefaultLibraryImplementationForPrototype
#define DELAY_cb []->
#else /* DELAY_printDefaultLibraryImplementationForPrototype */
#define DELAY_cb /* nothing */
#endif /* !DELAY_printDefaultLibraryImplementationForPrototype */

@@Print a default, stub-library-implementation for a given @prototype
function printDefaultLibraryImplementationForPrototype(
		fp: File, prototype: FunctionPrototype,
		functionName: string | UserString) {
	fp << "{\n";
	for (local a: prototype.argv) {
		if (a.name)
			fp << "\t(void)" << a.name << ";\n";
	}
#ifdef DELAY_printDefaultLibraryImplementationForPrototype
	if (!prototype.argv) {
generic_unimplemented:
#endif /* DELAY_printDefaultLibraryImplementationForPrototype */
		fp << "\tCRT_UNIMPLEMENTED(" << repr(functionName) << "); /* TO" "DO */\n";
#ifdef DELAY_printDefaultLibraryImplementationForPrototype
	} else {
		local priArgs = [];
		for (local a: prototype.argv) {
			local ct = a.ctype;
			local effectiveBeforeName = str(ct.beforeName).strip();
			if (!a.name) {
				if (effectiveBeforeName == "..." && a === prototype.argv.last) {
					priArgs.append("...");
					break;
				}
				goto generic_unimplemented;
			}
			if (ct.afterName)
				effectiveBeforeName += " *";
			effectiveBeforeName = effectiveBeforeName
				.replace("$", "").replace("\t", " ");
			for (;;) {
				local newEffectiveBeforeName = effectiveBeforeName
					.replace("  ", " ")
					.replace(" const ", " ")
					.replace(" volatile ", " ")
					.replace(" __restrict ", " ")
					.replace(" *", "*")
					.replace("* ", "*")
					.replace(" &", "&")
					.replace("& ", "&")
					.strip();
				if (newEffectiveBeforeName.endswith("const"))
					newEffectiveBeforeName = newEffectiveBeforeName[:-5];
				if (newEffectiveBeforeName.endswith("volatile"))
					newEffectiveBeforeName = newEffectiveBeforeName[:-8];
				if (newEffectiveBeforeName.endswith("__restrict"))
					newEffectiveBeforeName = newEffectiveBeforeName[:-10];
				if (newEffectiveBeforeName.startswith("const"))
					newEffectiveBeforeName = newEffectiveBeforeName[5:];
				if (newEffectiveBeforeName.startswith("volatile"))
					newEffectiveBeforeName = newEffectiveBeforeName[8:];
				if (newEffectiveBeforeName.startswith("__restrict"))
					newEffectiveBeforeName = newEffectiveBeforeName[10:];
				if (newEffectiveBeforeName == effectiveBeforeName)
					break;
				effectiveBeforeName = newEffectiveBeforeName;
			}
			local pri = {
				"char*" : "%q",
			}.get(effectiveBeforeName);
			if (pri !is none) {
				priArgs.append(pri);
				continue;
			}
			local tc = ct.typeClass;
			if (tc is none)
				goto generic_unimplemented;
			if (tc == "TV")
				goto generic_unimplemented;
			if (tc.startswith("TS("))
				goto generic_unimplemented;
			local pri = {
				"THH"  : "%hhx",
				"TH"   : "%hx",
				"TD"   : "%x",
				"TL"   : "%lx",
				"TLL"  : "%llx",
				"TF"   : "%f",
				"TFD"  : "%f",
				"TFL"  : "%lf",
				"TP"   : "%p",
				"TI"   : "%Ix",
				"TI8"  : "%\" PRIx8 \"",
				"TI16" : "%\" PRIx16 \"",
				"TI32" : "%\" PRIx32 \"",
				"TI64" : "%\" PRIx64 \"",
			}.get(tc);
			if (pri !is none) {
				priArgs.append(pri);
				continue;
			}
			if (tc.startswith("TIn(")) {
				priArgs.append("%\" PRIxN(" + tc[4:] + " \"");
				continue;
			}
			goto generic_unimplemented;
		}
		fp << "\tCRT_UNIMPLEMENTEDF(\""
			<< functionName.encode("c-escape")
			<< "(";
		local isFirst = true;
		for (local p: priArgs) {
			if (!isFirst)
				fp << ", ";
			isFirst = false;
			fp << p;
		}
		fp << ")\"";
		local i = 0;
		for (local fmt: priArgs) {
			if (fmt.startswith("%")) {
				fp << ", " << prototype.argv[i].name;
				++i;
			}
		}
		fp << "); /* TO" "DO */\n";
	}
#endif /* DELAY_printDefaultLibraryImplementationForPrototype */
	if (prototype.isNoreturn) {
		fp << "\tassert_failed(\"Not implemented\");\n";
	} else {
		local returnType = prototype.returnType;
		if (!returnType.afterName && returnType.beforeName in
				["error_t", "errno_t", "$error_t", "$errno_t", "__errno_t"]) {
			fp << "\treturn ENOSYS;\n";
		} else {
			fp << "\tlibc_seterrno(ENOSYS);\n";
			if (returnType.isVoid) {
				/* No return statement in void-functions */
			} else if (returnType.isPointer) {
				fp << "\treturn NULL;\n";
			} else {
				fp << "\treturn 0;\n";
			}
		}
	}
	fp << "}";
}

@@Return a default, stub-library-implementation for a given @prototype
function getDefaultLibraryImplementationForPrototype(
		prototype: FunctionPrototype,
		functionName: string | UserString): FunctionImplementation {
	local fp = File.Writer();
	printDefaultLibraryImplementationForPrototype(fp, prototype, functionName);
	return FunctionImplementation(body: fp.string, name: functionName);
}

function getVargargsPlaceholderArgumentName(i: int, ctype: CType): string {
	local beforeNameStr = str(ctype.beforeName).lstrip("$_");
	if (beforeNameStr.issymbol() && beforeNameStr && !ctype.afterName)
		return "v{}_{}".format({ i, beforeNameStr });
	return "v" + i;
}


@@Generate the implementation of  a call-to-wrapper for dosabi  functions
@@The caller must ensure that @dosPrototype doesn't have any var-args, or
@@has a non-@none @FunctionPrototype.ellipsisArgumentTypes field.
function generateDosWrapperFunctionImplementationForPrototype(
		dosPrototype: FunctionPrototype, kosPrototype: FunctionPrototype,
		dosFunctionName: string, kosFunctionName: string,
		headerFunction: Function): FunctionImplementation {
	assert !dosPrototype.hasEllipsis || dosPrototype.ellipsisArgumentTypes !is none;
	local fp = File.Writer();
	fp << "{\n";
	local dosArgc = #dosPrototype.argv;
	local dosArgcNonEllipsis = dosArgc;
	if (dosPrototype.hasEllipsis) {
		--dosArgc;
		dosArgcNonEllipsis = dosArgc;
		dosArgc += #dosPrototype.ellipsisArgumentTypes;
	}
	local commonArgc = dosArgc;
	local kosArgc = #kosPrototype.argv;
	if (!kosPrototype.hasEllipsis) {
		if (commonArgc > kosArgc)
			commonArgc = kosArgc;
	} else {
		--kosArgc;
	}
	local numNeededVarargs = 0;
	if (dosPrototype.hasEllipsis) {
		numNeededVarargs = commonArgc - dosArgcNonEllipsis;
		if (numNeededVarargs < 0)
			numNeededVarargs = 0;
	}
	local dosReturnsVoid = dosPrototype.returnType.isVoid;
	local kosReturnsVoid = kosPrototype.returnType.isVoid;
	if (numNeededVarargs) {
		fp << "\tva_list args;\n";
		local varArgNames = [];
		for (local i: [:numNeededVarargs]) {
			local typ = dosPrototype.ellipsisArgumentTypes[i];
			fp << "\t";
			local name = getVargargsPlaceholderArgumentName(i, typ);
			varArgNames.append(name);
			typ.cprintForGenerator(fp, name: name);
			fp << ";\n";
		}
		fp << "\tva_start(args, "
			<< dosPrototype.argv[dosArgcNonEllipsis - 1].name
			<< ");\n";
		/* Load variable arguments */
		local longestNameLen = varArgNames.each.length > ...;
		for (local i: [:numNeededVarargs]) {
			fp << "\t" << varArgNames[i].ljust(longestNameLen) << " = va_arg(args, ";
			dosPrototype.ellipsisArgumentTypes[i]
				.cprintForGenerator(fp);
			fp << ");\n";
		}
		fp << "\tva_end(args);\n";
	}
	if (commonArgc < dosArgcNonEllipsis) {
		/* void-out unused arguments */
		for (local i: [commonArgc:dosArgcNonEllipsis]) {
			local unusedArg = dosPrototype.argv[i];
			fp << "\t(void)" << unusedArg.name << ";\n";
		}
	}
	fp << "\t";
	if (!dosReturnsVoid && !kosReturnsVoid) {
		fp << "return ";
		if (!kosPrototype.returnType.implicitlyConvertibleTo(dosPrototype.returnType))
			dosPrototype.returnType.cprintCCastPrefixForGenerator(fp);
	}
	fp << kosFunctionName << "(";
	/* Pass arguments. */
	for (local i: [:commonArgc]) {
		if (i)
			fp << ", ";
		local dosArgNam: string;
		local dosArgTyp: CType;
		if (i >= dosArgcNonEllipsis) {
			local vargi = i - dosArgcNonEllipsis;
			dosArgTyp = dosPrototype.ellipsisArgumentTypes[vargi];
			dosArgNam = getVargargsPlaceholderArgumentName(vargi, dosArgTyp);
		} else {
			local dosArg: Argument = dosPrototype.argv[i];
			dosArgNam = dosArg.name;
			dosArgTyp = dosArg.ctype;
		}
		if (i < kosArgc) {
			local kosArg = kosPrototype.argv[i];
			if (!dosArgTyp.implicitlyConvertibleTo(kosArg.ctype))
				kosArg.ctype.cprintCCastPrefixForGenerator(fp);
		}
		fp << dosArgNam;
	}
	fp << ");\n";
	if (!dosReturnsVoid && kosReturnsVoid && !kosPrototype.isNoreturn) {
		fp << "\treturn ";
		dosPrototype.returnType.cprintStubValueForGenerator(fp, ESCAPE_MODE_KEEP);
		fp << ";\n";
	}
	fp << "}";
	return FunctionImplementation(body: fp.string, name: dosFunctionName);
}


class LoaderContext {
	this = default;

	@@The associated C-parser
	public member self: CParser;

	@@Name of the header being loaded
	public member headerName: string;

	@@The system header that is being generated
	public member result: SystemHeader;

	@@A custom callback that is invoked to parse otherwise
	@@unrecognized directives. Upon entry, the parser will
	@@point at the  directive's name, and  upon exit,  the
	@@parser should point at the trailing @"," or @"]"
	public member customDirectivesParser: Callable with LoaderContext;

	@@Default function features
	public member defaultFeatures: FunctionFeatures = FunctionFeatures();

	@@Pushed function features
	public member pushedDefaultFeatures: {FunctionFeatures...} = none;

	@@Elements to be inserted at the start of the system header (e.g. <string.h>)
	@@These elements will be inserted after the copyright notice, but before  the
	@@include guard macro. This section is intended to be filled with portability
	@@notes, and standard references.
	public member result_order_headerCPrefix: {(Function | ExposedFunction | string | UserString | Callable)...} = none;

	@@Elements inserted at @"%[insert:std]"
	@@Set to non-@none once a @"%[insert:std]" directive has been reached
	public member result_order_headerStd: {(Function | ExposedFunction | string | UserString | Callable)...} = none;

	@@Additional elements inserted at the front of @result.order_header
	public member result_order_headerCCompat: {(Function | ExposedFunction | string | UserString | Callable)...} = none;

	@@Set to @true while inside of a @"#ifndef __CXX_SYSTEM_HEADER"-block
	public member result_order_header_in_CXX_SYSTEM_HEADER: bool = false;

	@@The C-compatibility mode header name of the generated system header (or @none if not defined)
	@@NOTE: This header name may only be defined _before_ the @"%[insert:std]" directive is reached
	public member result_ccompatHeaderName: string | UserString = none;

	@@The name of the guard to-be used for the resulting header
	public member result_headerGuardName: string | UserString = none;

	public function parseDirectives() {
		local self = this.self;
		for (;;) {
			parseDirective();
			if (self.tok != ",")
				break;
			self.next();
			if (self.tok == "]")
				break;
		}
	}

	@@List of pushed macros, in the form of tuples of @(locationList, macroList)
	public member pushedMacros: {({string...}, {string...})...} | none = none;

	public function parseDirective_push_macro() {
		local self = this.self;
		local tok = self.tok;
		/* This directive has a somewhat weird syntax that is the result of its history:
		 *    '%' '[' 'push_macro' ['(' groups ')'] [@option...] '(' macros... ')' ']'
		 *    '%' '[' 'push_macro' ['(' groups ')'] [@option...] '{' macros... '}' ']'
		 *  - Where "macros..." is a space-seperated list of keywords  or
		 *    C-strings, with ","-tokens in-between simply being ignored.
		 *  - The only recognized value for @option is the literal  token
		 *    sequence '@' 'undef', which will cause all pushed macros to
		 *    be #undef'ed after being pushed
		 *
		 * Example:
		 * >> %[push_macro(c, std) @undef { foo bar }]
		 * >> %(c, std){
		 * >> struct foo {
		 * >>     int bar;
		 * >> };
		 * >> }
		 * >> %[push_macro(c, std) @undef { foo bar }]
		 * Output  (in  locations   "c"  and   "std"):
		 * >> #ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 * >> #pragma push_macro("foo")
		 * >> #pragma push_macro("bar")
		 * >> #endif // __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 * >> #undef foo
		 * >> #undef bar
		 * >> struct foo {
		 * >>     int bar;
		 * >> };
		 * >> #ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 * >> #pragma pop_macro("bar")
		 * >> #pragma pop_macro("foo")
		 * >> #endif // __COMPILER_HAVE_PRAGMA_PUSHMACRO
		 */
		final local DEFAULT_LOCATION_LIST = ("c", );
		local macroList;
		local locationList = DEFAULT_LOCATION_LIST;
		local locationListContainsProperComma = true;
		local doUndefMacros = false;
		tok = self.next();
		if (tok == "(") {
			locationList = [];
			tok = self.next();
			while (tok !in ["", ")"]) {
				locationList.append(self.parseCStringOrKeyword());
				tok = self.tok;
				if (tok == ",") {
					tok = self.next();
					while (tok == ",") {
						locationListContainsProperComma = false;
						tok = self.next();
					}
				} else {
					if (tok == ")")
						break;
					locationListContainsProperComma = false;
				}
			}
			tok = self.skip(")");
			if (tok !in ["@", "{", "("]) {
				/* Special case: Simple macro list */
				macroList = locationList;
				locationList = DEFAULT_LOCATION_LIST;
				goto do_push_macroList;
			}
			if (!locationListContainsProperComma)
				self.err("Improperly formated location list");
		}
		while (tok == "@") {
			tok = self.next();
			switch (tok) {

			case "undef":
				doUndefMacros = true;
				tok = self.next();
				break;

			default:
				self.err("Unknown option {!r} for %[push_macro]"
					.format({ tok }));
			}
		}
		local closeToken;
		if (tok == "(") {
			closeToken = ")";
			self.next();
		} else if (tok == "{") {
			closeToken = "}";
			self.next();
		} else {
			self.err("Unexpected token {!r} to start macro list in %[push_macro] (expected '(' or '{')"
				.format({ tok }));
		}
		macroList = [];
		for (;;) {
			while (tok == ",")
				tok = self.next();
			if (!tok || tok == closeToken)
				break;
			macroList.append(self.parseCStringOrKeyword());
			tok = self.tok;
		}
		self.skip(closeToken);
do_push_macroList:
		if (locationList && macroList) {
			File.Writer tempfp;
			tempfp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
			for (local mac: macroList)
				tempfp << "#pragma push_macro(" << repr(mac) << ")\n";
			tempfp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
			if (doUndefMacros) {
				for (local mac: macroList)
					tempfp << "#undef " << mac << "\n";
			}
			if (pushedMacros is none)
				pushedMacros = [];
			insertText(locationList, tempfp.string);
		}
		pushedMacros.pushback((locationList, macroList));
	}

	public function parseDirective_pop_macro() {
		local self = this.self;
		if (!pushedMacros)
			self.err("%[pop_macro] without preceding %[push_macro]");
		local locationList, macroList = pushedMacros.popback()...;
		if (!locationList || !macroList)
			return;
		macroList = macroList.reversed();
		File.Writer tempfp;
		tempfp << "#ifdef __COMPILER_HAVE_PRAGMA_PUSHMACRO\n";
		for (local mac: macroList)
			tempfp << "#pragma pop_macro(" << repr(mac) << ")\n";
		tempfp << "#endif /* __COMPILER_HAVE_PRAGMA_PUSHMACRO */\n";
		insertText(locationList, tempfp.string);
		self.next();
	}

	public function parseDirective_define_header_guard() {
		self.next();
		self.skip("(");
		result_headerGuardName = self.parseCStringOrFunctionLikeExpression();
		self.skip(")");
	}

	public function parseDirective_define_ccompat_header() {
		if (result_ccompatHeaderName !is none)
			self.err("Duplicate '%[define_ccompat_header(...)]' directive");
		if (result_order_headerStd !is none)
			self.err("Directive '%[define_ccompat_header(...)]' must come before '%[insert:std]'");
		self.next();
		self.skip("(");
		result_ccompatHeaderName = self.parseCStringOrFunctionLikeExpression();
		result_order_headerCCompat = [];
		self.skip(")");
	}

	public function parseDirective_pushdefault() {
		return parseDirective_push_default();
	}
	public function parseDirective_push_default() {
		if (pushedDefaultFeatures is none)
			pushedDefaultFeatures = [];
		pushedDefaultFeatures.pushback(copy defaultFeatures);
		self.next();
	}

	public function parseDirective_popdefault() {
		return parseDirective_pop_default();
	}
	public function parseDirective_pop_default() {
		if (!pushedDefaultFeatures)
			self.err("%[popdefault] without %[pushdefault]");
		defaultFeatures = pushedDefaultFeatures.popback();
		self.next();
	}

	public function parseDirective_default() {
		/* %[default:...] Set default function annotations */
		self.next();
		self.skip(":");
again_parse_default_annotation:
		if (!defaultFeatures.tryParseAttribute(self, none)) {
			self.err(
				"Unknown function annotation {!r}, or "
				"annotation cannot be assigned a default value"
				.format({ self.tok }));
		}
		if (self.tok == ",") {
			self.next();
			if (self.tok != "]")
				goto again_parse_default_annotation;
		}
	}

	public function parseDirective_include() {
		/* %[include(...)] include contents of another file here */
		local self = this.self;
		self.next();
		self.skip("(");
		local filenamePos = self.tokStart;
		local incFileName = self.parseCString();
		import fs;
		if (!fs.isabs(incFileName)) {
			local baseDir = self.filename;
			if (baseDir in ["", "?"])
				baseDir = fs.getcwd();
			else {
				baseDir = fs.headof(baseDir);
			}
			incFileName = fs.abspath(incFileName, baseDir);
		}
		local incFileParser;
		with (local fp = File.open(incFileName))
			incFileParser = CParser(fp, filename: incFileName);
		try {
			loadSystemHeaderDefinitions(
				incFileParser, headerName,
				customDirectivesParser, this);
		} catch (Error as e) {
			self.errAt(filenamePos, "Included from here... ({})"
				.format({ e.message }));
		}
		self.skip(")");
	}

	public function parseDirective_insert() {
		self.next();
		local tok = self.skip(":");
		local cbAttrib = "parseInsertDirective_" + tok;
		if (hasattr(this, cbAttrib))
			return this.operator . (cbAttrib)();
		self.err("Unknown operand for insert-directive: {!r}"
			.format({ tok }));
	}

	@@>> %[insert:prefix(
	@@>> #ifdef __LIBC_BIND_OPTIMIZATIONS
	@@>> #include <optimized/string.h>
	@@>> #endif /* __LIBC_BIND_OPTIMIZATIONS */
	@@>> )]
	@@Print a given prefix, but mark it as already having been printed for this header
	public function parseInsertDirective_prefix(functionName: string = "printPrefix") {
		local self = this.self;
		self.next();
		self.skip("(");
		local text = self.parseAllUntilRParenAsString();
		result.order_header.append([](fp: CWriter, escapeMode: int) {
			fp.forceStartOfLine();
			local extendedPrefixes = [];
			local usedText = escapeText(
				text, escapeMode, extendedPrefixes: extendedPrefixes);
again:
			local newExtendedPrefixes = [];
			for (local x: extendedPrefixes) {
				escapeNonRepeatingTextIntoFile(fp, x, escapeMode,
					extendedPrefixes: newExtendedPrefixes);
			}
			if (newExtendedPrefixes) {
				extendedPrefixes = newExtendedPrefixes;
				goto again;
			}
			return fp.operator . (functionName)(usedText);
		});
		self.skip(")");
	}
	public function parseInsertDirective_pp_if() {
		return parseInsertDirective_prefix("ppIf");
	}
	public function parseInsertDirective_pp_elif() {
		return parseInsertDirective_prefix("ppElif");
	}
	public function parseInsertDirective_pp_include() {
		return parseInsertDirective_prefix("ppInclude");
	}
	public function parseInsertDirective_pp_else(functionName: string = "ppElse") {
		local self = this.self;
		self.next();
		result.order_header.append([](fp: CWriter, escapeMode: int) -> fp.operator . (functionName)());
	}
	public function parseInsertDirective_pp_endif() {
		parseInsertDirective_pp_else("ppEndif");
	}

	public function parseInsertDirective_std_function() {
		parseInsertDirective_function(std: true, using: true);
	}

	public function parseInsertDirective_std_function_nousing() {
		parseInsertDirective_function(std: true);
	}

	public function parseInsertDirective_guarded_function() {
		parseInsertDirective_function(guarded: true);
	}

	public function parseInsertDirective_guarded_std_function() {
		parseInsertDirective_function(guarded: true, std: true, using: true);
	}

	public function parseInsertDirective_guarded_std_function_nousing() {
		parseInsertDirective_function(guarded: true, std: true);
	}

	@@>> %[insert:function(foo)]
	@@>> %[insert:function(foo, ATTRIB)]
	@@>> %[insert:function(foo = bar)]
	@@>> %[insert:function(foo = bar, ATTRIB)]
	@@>> %[insert:std_function(<Same as above...>)]
	@@>> %[insert:std_function_nousing(<Same as above...>)]
	@@>> %[insert:guarded_function(<Same as above...>)]
	@@>> %[insert:guarded_std_function(<Same as above...>)]
	@@>> %[insert:guarded_std_function_nousing(<Same as above...>)]
	@@
	@@Where ATTRIB is:
	@@    ',' ~~ (ATTR_NAME ':' ATTR_VALEXPR)...
	@@
	@@Where ATTR_NAME  is  the  name  of  one  of  the  members  of  @ExposedFunction
	@@Where ATTR_VALEXPR is a deemon expression, as executable by @(exec from deemon)
	@@
	@@HINT: %[insert:guarded_*_function(...)] is the same as %[insert:_function(guardName: true)]
	public function parseInsertDirective_function(
			guarded: bool = false, std: bool = false, using: bool = false) {
		local self = this.self;
		self.next();
		self.skip("(");
		local exposedFunction = ExposedFunction();
		local insertedFunctionNameStart = self.tokStart;
		local insertedFunctionName = self.parseCStringOrKeyword();
		if (guarded)
			exposedFunction.guardName = true;
		exposedFunction.exposedName = insertedFunctionName;
		if (self.tok == "=") {
			self.next();
			insertedFunctionNameStart = self.tokStart;
			insertedFunctionName = self.parseCStringOrKeyword();
		}
		exposedFunction.func = []{
			try {
				return findFunctionByName(insertedFunctionName);
			} catch (Error as e) {
				self.errAt(insertedFunctionNameStart, e.message);
			}
		};
		if (self.tok == ",") {
			self.next();
			while (self.tok !in ["", ")"]) {
				local propStart = self.tokStart;
				local prop = self.parseCStringOrKeyword();
				self.skip(":");
				local valExprStart = self.tokStart;
				local valExpr = self.parseAllUntilRParenAsString();
				try {
					valExpr = exec(valExpr);
				} catch (Error as e) {
					self.errAt(valExprStart, "{} (while executing {!r})"
						.format({ e.message, valExpr }));
				}
				try {
					exposedFunction.operator . (prop) = valExpr;
				} catch (Error as e) {
					self.errAt(propStart, e.message);
				}
				if (self.tok != ",")
					break;
				self.next();
			}
		}
		if (std) {
			if (result_order_headerStd is none) {
				self.err("%[insert:std_function(...)] used, but "
				         "'%[insert:std]' hasn't been encountered, yet");
			}
			local nsStd = NAMESPACES["std"];
			exposedFunction.namespaceOverride = nsStd;
			result_order_headerStd.append(exposedFunction);
			if (using) {
				local gblGuard = false;
				local importCondition = "$has_function({})".format({ insertedFunctionName });
				local exposedName = exposedFunction.exposedName;
				if (exposedFunction.guardName !== false) {
					local stdGuard = exposedFunction.guardName;
					if (stdGuard === true)
						stdGuard = nsStd.keyDefaultGuard(exposedName);
					gblGuard = GLOBAL_NAMESPACE.keyDefaultGuard(exposedName);
					importCondition = "defined({})".format({ stdGuard });
				}
				local importFunction = Function(
					name:                     exposedName,
					originalSystemHeaderName: headerName,
					bindings: []{
						local protos = exposedFunction.exposedFunc
							.functionBindings.first.prototypes;
						yield FunctionBinding(
							ppCond:     importCondition,
							prototypes: protos,
							binding:    NamespaceBinding(
								namespace:  nsStd,
								importName: exposedName));
					});
				if (gblGuard !== false) {
					local gblExposure = copy exposedFunction;
					gblExposure.func              = importFunction;
					gblExposure.guardName         = gblGuard;
					gblExposure.namespaceOverride = GLOBAL_NAMESPACE;
					importFunction = gblExposure;
				}
				if (!result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_START);
					result_order_header_in_CXX_SYSTEM_HEADER = true;
				}
				result.order_header.append(importFunction);
				if (result_ccompatHeaderName !is none)
					result_order_headerCCompat.append(importFunction);
			}
		} else {
			if (result_order_header_in_CXX_SYSTEM_HEADER) {
				result.order_header.append(CXX_SYSTEM_HEADER_END);
				result_order_header_in_CXX_SYSTEM_HEADER = false;
			}
			result.order_header.append(exposedFunction);
		}
		self.skip(")");
	}

	public function parseInsertDirective_extern() {
		/* >> %[insert:extern(foo)]
		 * Alias for:
		 * >> %[insert:function(foo, guardName: true)] */
		local self = this.self;
		self.next();
		self.skip("(");
		local functionNameStart = self.tokStart;
		local functionName = self.parseCStringOrKeyword();
		/* Only insert into "c" namespace! */
		if (result_order_header_in_CXX_SYSTEM_HEADER) {
			result.order_header.append(CXX_SYSTEM_HEADER_END);
			result_order_header_in_CXX_SYSTEM_HEADER = false;
		}
		result.order_header.append(ExposedFunction(
			func: [] {
				try {
					return findFunctionByName(functionName);
				} catch (Error as e) {
					self.errAt(functionNameStart, e.message);
				}
			},
			exposedName: functionName,
			guardName:   true));
		self.skip(")");
	}

	public function parseInsertDirective_std() {
		/* %[insert:std] */
		if (result_order_headerStd !is none)
			self.err("Multiple '%[insert:std]' directives");
		else {
			assert result_order_headerStd is none;
			assert result_order_header_in_CXX_SYSTEM_HEADER === false;
			result_order_headerStd = [];
			/* Inject a printer callback for generating std:: declarations */
			result.order_header.append([](fp: CWriter, escapeMode: int) {
				local oldNs = fp.namespace;
				fp.namespace = NAMESPACES["std"];
				for (local part: result_order_headerStd) {
					if (part is Function || part is ExposedFunction) {
						part.cprintHeaderDeclaration(fp, escapeMode);
					} else if (part is Callable) {
						part(fp, escapeMode);
					} else {
						fp << part;
					}
				}
				fp.namespace = oldNs;
			});
		}
		self.next();
	}

	public function parseDirective_define_decl_include() {
		/* Define headers needed for type declarations
		 * >> %[define_decl_include(["struct partition_def"] = "<bits/crt/partition.h>")]
		 * >> %[define_decl_include("struct partition_def" = "<bits/crt/partition.h>")]
		 * >> %[define_decl_include("<bits/crt/partition.h>": "struct partition_def")]
		 * >> %[define_decl_include("<bits/crt/partition.h>": ["struct partition_def"])]
		 */
		self.next();
		self.skip("(");
		local decls: {string...} = [];
		local newHeaderName;
		if (self.tok == "[") {
			self.next();
			for (;;) {
				decls.append(self.parseCStringOrKeyword());
				if (self.tok != ",")
					break;
				self.next();
				if (self.tok == "]")
					break;
			}
			self.skip("]");
			self.skip("=");
			newHeaderName = str(self.parseCStringOrKeyword());
		} else {
			decls.append(self.parseCStringOrKeyword());
			if (self.tok == ":") {
				newHeaderName = str(decls.first);
				decls = [];
				self.next();
				if (self.tok == "[") {
					self.next();
					for (;;) {
						decls.append(self.parseCStringOrKeyword());
						if (self.tok != ",")
							break;
						self.next();
						if (self.tok == "]")
							break;
					}
					self.skip("]");
				} else {
					decls.append(self.parseCStringOrKeyword());
				}
			} else {
				self.skip("=");
				newHeaderName = str(self.parseCStringOrKeyword());
			}
		}
		for (local decl: decls) {
			decl = normalizeForTypeHeader(str(decl));
			local ok, oldHeaderName = typeHeaders.setnew_ex(decl, newHeaderName)...;
			if (!ok && oldHeaderName != newHeaderName) {
				self.err("define_decl_include re-definition: {!r} defined as {!r} (was: {!r})"
					.format({ decl, newHeaderName, oldHeaderName }));
			}
		}
		self.skip(")");
	}

	public function parseDirective_define_decl_include_implication() {
		/* Define headers needed for type declarations
		 * >> %[define_decl_include_implication("<bits/crt/aiocb.h>" => "<bits/os/sigevent.h>")]
		 * >> %[define_decl_include_implication("<bits/crt/aiocb.h>" => ["<bits/os/sigevent.h>", "<bits/types.h>"])]
		 */
		self.next();
		self.skip("(");
		local baseHeader: string = str(self.parseCStringOrKeyword());
		self.skip("=");
		self.skip(">");
		local impliedHeaders: {string...} = [];
		if (self.tok == "[") {
			self.next();
			for (;;) {
				impliedHeaders.append(str(self.parseCStringOrKeyword()));
				if (self.tok != ",")
					break;
				self.next();
				if (self.tok == "]")
					break;
			}
			self.skip("]");
		} else {
			impliedHeaders.append(str(self.parseCStringOrKeyword()));
		}
		for (local impliedHeader: impliedHeaders) {
			local impliedBySet: HashSet with string =
				typeHeadersImplications.get(impliedHeader);
			if (impliedBySet is none) {
				/* Lazily create */
				impliedBySet = HashSet();
				local ok, oldImpliedBySet = typeHeadersImplications
					.setnew_ex(impliedHeader, impliedBySet)...;
				if (!ok)
					impliedBySet = oldImpliedBySet;
			}
			impliedBySet.insert(baseHeader);
		}
		self.skip(")");
	}

	public function parseDirective_define_wchar_replacement_header() {
		return parseDirective_define_wchar_replacement(true);
	}
	public function parseDirective_define_wchar_replacement(header: bool = false) {
		local tok = self.tok;
		local map = header
			? wcharReplacementHeaders
			: wcharReplacementEscapes;
		self.next();
		self.skip("(");
		local orig = self.parseCStringOrKeyword();
		self.skip("=");
		local c16 = self.parseCStringOrKeyword();
		self.skip(",");
		local c32 = self.parseCStringOrKeyword();
		local newRepl = (c16, c32);
		local ok, oldRepl = map.setnew_ex(orig, newRepl)...;
		if (!ok && oldRepl != newRepl) {
			self.err("wchar re-definition: {!r} defined as "
				"(c16:{!r},c32:{!r}) (was: (c16:{!r},c32:{!r}))"
				.format({ orig, c16, c32, oldRepl[0], oldRepl[1] }));
		}
		self.skip(")");
	}

	public function parseDirective_define_c_language_keyword() {
		local self = this.self;
		self.next();
		self.skip("(");
		while (self.tok !in ["", ")"]) {
			local kwd = str self.parseCStringOrKeyword();
			cLanguageKeywords.insert(kwd);
			if (self.tok != ",")
				break;
			self.next();
		}
		self.skip(")");
	}

	public function parseDirective_define_replacement(map: {string: string} = none) {
		if (map is none)
			map = keywordEscapes;
		local self = this.self;
		local mode = self.tok;
		self.next();
		self.skip("(");
		local a = self.parseCStringOrKeyword();
		self.skip("=");
		local b = self.parseCStringOrAllUntilRParenAsString();
		local ok, oldRepl = map.setnew_ex(a, b)...;
		if (!ok && ((oldRepl !is string && oldRepl !is UserString) || oldRepl != b)) {
			if (oldRepl !is string && oldRepl !is UserString) {
				self.err("Replacement re-definition: %[{}({!r} = {!r})] (previously defined as <Custom {}>)"
					.format({ mode, a, b, type(oldRepl) }));
			} else {
				self.err("Replacement re-definition: %[{}({!r} = {!r})] (previously defined as {!r})"
					.format({ mode, a, b, oldRepl }));
			}
		}
		self.skip(")");
	}

	public function parseDirective_define_type_class() {
		parseDirective_define_replacement(knownTypeClasses);
	}

	public function parseDirective_define_partial_replacement() {
		parseDirective_define_replacement(partialKeywordEscapes);
	}

	public function parseDirective_define_dos_replacement() {
		parseDirective_define_replacement(dosReplacementEscapes);
	}

	public function parseDirective_define_str2wcs_replacement() {
		parseDirective_define_replacement(str2wcsReplacementEscapes);
	}

	public function parseDirective_define_str2wcs_header_replacement() {
		parseDirective_define_replacement(str2wcsHeaderReplacementEscapes);
	}

	public function parseDirective_define_double_replacement() {
		local tok = self.tok;
		self.next();
		self.skip("(");
		local orig = self.parseCStringOrKeyword();
		self.skip("=");
		local flt = self.parseCStringOrKeyword();
		self.skip(",");
		local ldbl = self.parseCStringOrKeyword();
		local newRepl = (flt, ldbl);
		local ok, oldRepl = mathReplacementEscapes.setnew_ex(orig, newRepl)...;
		if (!ok && oldRepl != newRepl) {
			self.err("%[define_double_replacement]: "
			         "Re-definition of {!r} as {!r} (was: {!r})"
				.format({ orig, flt, ldbl, oldRepl[0], oldRepl[1] }));
		}
		self.skip(")");
	}

	public function parseDirective_define_double2ldouble_replacement() {
		return parseDirective_define_double2float_replacement(MATH_REPLACEMENT_MODE_LDBL);
	}
	public function parseDirective_define_double2float_replacement(mode: int = none) {
		local tok = self.tok;
		self.next();
		self.skip("(");
		local origStart = self.tokStart;
		local orig = self.parseCStringOrKeyword();
		self.skip("=");
		local repl = self.parseCStringOrKeyword();
		try {
			math_defineReplacement(orig, repl,
				mode is none ? MATH_REPLACEMENT_MODE_FLOAT : mode);
		} catch (Error as e) {
			self.errAt(origStart, e.message);
		}
		self.skip(")");
	}

	@@Define simple textual replacement macros
	@@>%[define(MACRO_NAME = TEXT INSERTED AS REPLACEMENT)]
	@@This  differs  from @"%[define_replacement(...)]",  in that  the keyword
	@@is  replaced in  all situations, regardless  of escape mode,  as well as
	@@the fact that the replacement text will be re-parsed for further macros,
	@@as well as replacements.
	@@Note that macros defined using this directive are expanded at the same
	@@time    as   special   builtin   macros   such   as   @"$has_function"
	public function parseDirective_define() {
		parseDirective_define_replacement(keywordMacros);
	}

	@@NOTE: The int-value is one of `CRT_NAME_LIST_*`
	public member crtNameLists: {string: {string...}} = none;

	@@Parse `foo` or `foo...`, and return { "foo" } for
	@@the former, and crtNameLists["foo"] for the later
	public function parseAliasNameOrList(): {string...} {
		local self = this.self;
		local name = self.parseCStringOrKeyword();
		if (self.tok != "...")
			return { name };
		local result = crtNameLists.get(name);
		if (result is none) {
			self.err("No CRT name list defined for {!r}"
				.format({ name }));
		}
		self.next();
		return result;
	}

	@@Define a list of CRT symbol names for use in alias() and similar attributes
	@@>%[define_crt_name_list(NAME = [FIRST_NAME, SECOND_NAME, ...])]
	@@The    list    of   names    can    then   be    used    in   declarations:
	@@>[[alias(NAME...)]]
	@@>foo();
	@@Which behaves the same as:
	@@>[[alias(FIRST_NAME, SECOND_NAME, ...)]]
	@@>foo();
	public function parseDirective_define_crt_name_list() {
		if (crtNameLists is none)
			crtNameLists = Dict();
		local self = this.self;
		self.next();
		self.skip("(");
		local listName = str(self.parseCStringOrKeyword());
		if (listName in crtNameLists)
			self.err("Duplicate CRT name list: {!r}".format({ listName }));
		self.skip("=");
		self.skip("[");
		local listElem;
		crtNameLists[listName] = listElem = [];
		while (self.tok != "]") {
			listElem.append(str(self.parseCStringOrKeyword()));
			if (self.tok != ",")
				break;
			self.next();
		}
		self.skip("]");
		self.skip(")");
	}

	@@Parse a directive.  Upon entry,  the parser  will
	@@point at the directive's name, and upon exit, the
	@@parser should point at the trailing @"," or  @"]"
	public function parseDirective() {
		/* %[directive...] */
		local self = this.self;
		local tok = self.tok;
		if (tok == "[") {
			self.next();
			parseDirectives();
			self.skip("]");
		} else {
			local cbAttrib = "parseDirective_" + tok;
			if (hasattr(this, cbAttrib))
				return this.operator . (cbAttrib)();
			/* Give a custom directives parser a chance */
			if (!customDirectivesParser(this))
				self.err("Unknown directive: {!r}".format({ tok }));
		}
	}

	@@Insert text at the @"c_prefix" location
	public function insertText_c_prefix(text: string | UserString) {
		if (result_order_headerCPrefix is none)
			result_order_headerCPrefix = [];
		result_order_headerCPrefix.append(text);
	}

	@@Insert text at the @"c" location
	public function insertText_c(text: string | UserString) {
		if (result_order_header_in_CXX_SYSTEM_HEADER) {
			result.order_header.append(CXX_SYSTEM_HEADER_END);
			result_order_header_in_CXX_SYSTEM_HEADER = false;
		}
		result.order_header.append(text);
	}

	@@Insert text at the @"std" location
	public function insertText_std(text: string | UserString) {
		if (result_order_headerStd is none) {
			self.err("Text cannot be inserted into 'std' "
			         "before '%[insert:std]' has been encountered");
		}
		result_order_headerStd.append(text);
	}

	@@Insert text at the @"ccompat" location
	public function insertText_ccompat(text: string | UserString) {
		if (result_order_headerCCompat is none) {
			self.err("Text cannot be inserted into 'ccompat' before "
			         "'%[define_ccompat_header()]' has been encountered");
		}
		result_order_headerCCompat.append(text);
	}

	@@Insert text at the @"libc_fast" location
	public function insertText_libc_fast(text: string | UserString) {
		result.order_libcHeader.append(text);
	}

	@@Insert text at the @"libc_core" location
	public function insertText_libc_core(text: string | UserString) {
		result.order_libcCoreHeader.append(text);
	}

	@@Insert text at the @"auto_header" location
	public function insertText_auto_header(text: string | UserString) {
		result.order_libcAutoHeader.append(text);
	}

	@@Insert text at the @"auto_source" location
	public function insertText_auto_source(text: string | UserString) {
		result.order_libcAutoSource.append(text);
	}

	@@Insert text at the @"user" location
	public function insertText_user(text: string | UserString) {
		result.order_libcUserHeader.append(text);
	}

	@@Insert text at the given location
	public function insertText(
			location: string | UserString | {string...}, text: string | UserString) {
		if (location is string || location is UserString)
			return this.operator . ("insertText_" + location)(text);
		for (local loc: location)
			this.operator . ("insertText_" + loc)(text);
	}

}


function String_replaceDefaultCCWithDosCC(self: string | UserString): string {
	return str(self)
		.replace(DEFAULT_CC, DEFAULT_DOS_CC)
		.replace(DEFAULT_VCC, DEFAULT_DOS_VCC);
}
function String_containsDefaultCC(self: string | UserString): bool {
	return DEFAULT_CC in self || DEFAULT_VCC in self;
}
function CType_replaceDefaultCCWithDosCC(self: CType): CType {
	if (String_containsDefaultCC(self.beforeName) ||
	    String_containsDefaultCC(self.afterName)) {
		return CType(
			beforeName: String_replaceDefaultCCWithDosCC(self.beforeName),
			afterName:  String_replaceDefaultCCWithDosCC(self.afterName));
	}
	return self;
}
function Argument_replaceDefaultCCWithDosCC(self: Argument): Argument {
	local newCType = CType_replaceDefaultCCWithDosCC(self.ctype);
	if (newCType === self.ctype)
		return self;
	local result = copy self;
	result.ctype = newCType;
	return result;
}
function Arguments_replaceDefaultCCWithDosCC(argv: {Argument...}): {Argument...} {
	local i = 0;
	for (local i, arg: util.enumerate(argv)) {
		local newArg = Argument_replaceDefaultCCWithDosCC(arg);
		if (newArg !== arg) {
			local result = List(argv[:i]);
			result.append(newArg);
			for (;;) {
				++i;
				if (i >= #argv)
					break;
				result.append(Argument_replaceDefaultCCWithDosCC(argv[i]));
			}
			return result;
		}
	}
	return argv;
}


@@Replace the @DEFAULT_CC and @DEFAULT_VCC in @prototype with their DOS equivalents
function replaceFunctionPrototypeDefaultCCWithDefaultDosCC(
		prototype: FunctionPrototype | Callable): FunctionPrototype | Callable {
	if (prototype is Callable)
		return [] -> replaceFunctionPrototypeDefaultCCWithDefaultDosCC(prototype());
	local result: FunctionPrototype = prototype;
	local didCopy: bool = false;
	if (result.cc === DEFAULT_CC) {
		result = copy result;
		didCopy = true;
		result.cc = DEFAULT_DOS_CC;
	} else if (result.cc === DEFAULT_VCC) {
		result = copy result;
		didCopy = true;
		result.cc = DEFAULT_DOS_VCC;
	}
	local newReturnType = CType_replaceDefaultCCWithDosCC(result.returnType);
	if (newReturnType !== result.returnType) {
		if (!didCopy) {
			result = copy result;
			didCopy = true;
		}
		result.returnType = newReturnType;
	}
	local newArgv = Arguments_replaceDefaultCCWithDosCC(result.argv);
	if (newArgv !== result.argv) {
		if (!didCopy) {
			result = copy result;
			didCopy = true;
		}
		result.argv = newArgv;
	}
	return result;
}


class WrapperCookie {
	this = default;
	@@Cookie type
	public member ctype: CType;
	@@Initializer expression
	public member init: string | UserString;
	function replaceAutoTypes(proto: FunctionPrototype) {
		if (this.ctype.beforeName == "auto" && this.ctype.afterName == "") {
			local arg = proto.argsByName.get(this.init);
			if (arg !is none)
				this.ctype = arg.ctype;
		}
	}
	public property cookieTypeName: string = { get() -> str this.ctype; }
	public property cookieTypePrefix: string = { get() -> this.ctype.beforeName; }
	public property cookieTypeSuffix: string = { get() -> this.ctype.afterName; }
}
class WrapperCookieStruct {
	this = default;
	@@Struct members
	public member members: {(string, WrapperCookie)...} = [];
	@@Struct name (automatically generated)
	public member name: string;
	function replaceAutoTypes(proto: FunctionPrototype) {
		for (local none, m: this.members)
			m.replaceAutoTypes(proto);
	}
	function getMemberIndexByName(name: string): int | none {
		local i = 0;
		for (local memberName, none: this.members) {
			if (memberName == name)
				return i;
			++i;
		}
		return none;
	}
	public property cookieTypeName: string = { get() -> cookieTypePrefix; }
	public property cookieTypePrefix: string = { get() -> "struct " + this.name; }
	public property cookieTypeSuffix: string = { get() -> ""; }
}

function updateCTypeForCookie(ctype: CType, cookie: WrapperCookie | WrapperCookieStruct) {
	final local COOKIE_MARKER = "$cook";
	if (ctype.beforeName == COOKIE_MARKER && ctype.afterName == "") {
		ctype.beforeName = cookie.cookieTypePrefix;
		ctype.afterName  = cookie.cookieTypeSuffix;
	} else {
		if (COOKIE_MARKER in ctype.beforeName)
			ctype.beforeName = str(ctype.beforeName).replace(COOKIE_MARKER, cookie.cookieTypeName);
		if (COOKIE_MARKER in ctype.afterName)
			ctype.afterName = str(ctype.afterName).replace(COOKIE_MARKER, cookie.cookieTypeName);
	}
}

class CrtDosVariantMetadata {
	this = default;
	/*
	public function generate(
			dosLibraryFunction: LibraryFunction,
			currentFeatures: FunctionFeatures)
			: FunctionImplementation | Callable;
	*/
}



@@Try to serialize the wrapper implementation, but return @none if that is impossible
function trySerializeDosCallbackWrapper(
		wrapperBody: string,
		wrapperPrototype: FunctionPrototype,
		cookie: WrapperCookie | WrapperCookieStruct)
		: string | none {
#undef DEBUG_DOS_CALLBACK_SERIALIZATION_FAILURE
//#define DEBUG_DOS_CALLBACK_SERIALIZATION_FAILURE
#ifdef DEBUG_DOS_CALLBACK_SERIALIZATION_FAILURE
#define SERIAL_FAIL ({ print "SERIAL_FAIL:", __LINE__; goto err; })
#else /* DEBUG_DOS_CALLBACK_SERIALIZATION_FAILURE */
#define SERIAL_FAIL goto err
#endif /* !DEBUG_DOS_CALLBACK_SERIALIZATION_FAILURE */
	function fixTypeClass(x) -> x.replace("(", "").replace(")", "");
	try {
		File.Writer result;
		/* Prevent  redundant  declarations of  binary-compatible  wrapper functions
		 * by serializing `usedWrapperBody', `cookie' (types) and `wrapperPrototype' */
		if (cookie is WrapperCookieStruct) {
			result << "s";
			for (local none, field: cookie.members)
				result << fixTypeClass(field.ctype.requireTypeClass);
		} else if (cookie is WrapperCookie) {
			result << "c" << fixTypeClass(cookie.ctype.requireTypeClass);
		} else {
			SERIAL_FAIL;
		}
		result << "_" << fixTypeClass(wrapperPrototype.returnType.requireTypeClass);
		local cookieArgument = none;
		for (local a: wrapperPrototype.argv) {
			local ct = a.ctype;
			if ("$cook" in ct.beforeName) {
				if (cookieArgument !is none)
					SERIAL_FAIL;
				cookieArgument = a;
			}
			local cl = ct.typeClass;
			if (cl is none) {
				if (ct.beforeName == "$cook" && ct.afterName == "")
					cl = "TP";
				else {
					SERIAL_FAIL;
				}
			}
			result << fixTypeClass(cl);
		}
		if (cookieArgument is none)
			SERIAL_FAIL;
		local cookieArgumentName = str(cookieArgument.name);
		result << "_";
		if (wrapperBody.startswith("{") && wrapperBody.endswith("}")) {
			wrapperBody = wrapperBody[1:-1].strip();
			if (!wrapperBody.endswith(";"))
				SERIAL_FAIL;
			wrapperBody = wrapperBody[:-1].rstrip();
			if (wrapperBody.startswith("return ")) {
				if (wrapperPrototype.returnType.isVoid)
					goto err;
				wrapperBody = wrapperBody[7:].lstrip();
			} else {
				if (!wrapperPrototype.returnType.isVoid)
					goto err;
			}
		}
		local parser = CParser(wrapperBody);
		local tok = parser.next();
		local callToSymbol;
		local callToMember = none;
		if (tok.issymbol()) {
			callToSymbol = tok;
			tok = parser.next();
			if (tok == "->") {
				callToMember = parser.next();
				tok = parser.next();
			}
		} else if (tok == "(") {
			if (parser.next() != "*")
				SERIAL_FAIL;
			callToSymbol = parser.next();
			if (!callToSymbol.issymbol())
				SERIAL_FAIL;
			tok = parser.next();
			if (tok == "->") {
				callToMember = parser.next();
				tok = parser.next();
			}
			if (tok != ")")
				SERIAL_FAIL;
			tok = parser.next();
		} else {
			SERIAL_FAIL;
		}
		if (tok != "(")
			SERIAL_FAIL;
		tok = parser.next();
		if (callToSymbol != cookieArgumentName)
			SERIAL_FAIL;
		if (callToMember is none) {
			if (cookie !is WrapperCookie)
				SERIAL_FAIL;
			result << "C";
		} else {
			if (cookie !is WrapperCookieStruct)
				SERIAL_FAIL;
			callToMember = cookie.getMemberIndexByName(callToMember);
			if (callToMember is none)
				SERIAL_FAIL;
			result << "c" << callToMember;
		}
		while (tok != ")") {
			if (!tok.issymbol())
				SERIAL_FAIL;
			if (tok == cookieArgumentName) {
				if (cookie !is WrapperCookieStruct)
					SERIAL_FAIL;
				tok = parser.next();
				if (tok != "->")
					SERIAL_FAIL;
				tok = parser.next();
				if (!tok.issymbol())
					SERIAL_FAIL;
				callToMember = cookie.getMemberIndexByName(tok);
				if (callToMember is none)
					SERIAL_FAIL;
				result << "c" << callToMember;
			} else {
				local i = 0;
				for (local a: wrapperPrototype.argv) {
					if (a.name == tok) {
						result << "A" << i;
						goto found_argument;
					}
					++i;
				}
				SERIAL_FAIL;
			}
found_argument:
			tok = parser.next();
			if (tok != ",")
				break;
			tok = parser.next();
		}
		if (tok != ")")
			SERIAL_FAIL;
		tok = parser.next();
		if (tok != "")
			SERIAL_FAIL;
		return result.string;
err:
		return none;
	} catch (e...) {
#ifdef DEBUG_DOS_CALLBACK_SERIALIZATION_FAILURE
		print "SERIAL_FAIL:", __LINE__, repr e;
		print repr Traceback.current;
#endif /* DEBUG_DOS_CALLBACK_SERIALIZATION_FAILURE */
		return none;
	}
}

function applyDosProtoOverrides(dosProto: FunctionPrototype, overrides: FunctionPrototype | none) {
	if (overrides !is none) {
		/* Override certain parts about the dos prototype */
		dosProto.cc                    = overrides.cc;
		dosProto.argv                  = overrides.argv;
		dosProto.returnType            = overrides.returnType;
		dosProto.ellipsisArgumentTypes = overrides.ellipsisArgumentTypes;
		dosProto.declPrefix            = overrides.declPrefix;
		/* Merge attributes (but overrides NONNULL). */
		local newAttrib = List(overrides.attributes);
		for (local attr: dosProto.attributes) {
			if (attr !is Callable) {
				local sattr = str(attr);
				if (sattr.startswith("NONNULL(("))
					continue; /* Skip! */
			}
			newAttrib.append(attr);
		}
		dosProto.attributes = newAttrib;
	}
}

class CrtDosVariantCallbackMetadata: CrtDosVariantMetadata {
	this = default;
	public member dosProto: FunctionPrototype | none;
	public member cookie: WrapperCookie | WrapperCookieStruct;
	public member wrapperPrototype: FunctionPrototype;
	public member wrapperBody: string | UserString;
	public member implBody: string | UserString;


	@@Helper function to trigger an error
	function err(message: string) {
		local loc = none;
		if (wrapperBody is UserString) {
			loc = wrapperBody;
		} else if (implBody is UserString) {
			loc = implBody;
		}
		loc.err(message);
		throw Error(message); /* Fallback... */
	}

	public function generate(
			dosLibraryFunction: LibraryFunction,
			currentFeatures: FunctionFeatures)
			: FunctionImplementation | Callable {
		local name = dosLibraryFunction.name;
		if (dosLibraryFunction.prototype !is bound)
			dosLibraryFunction.prototype = FunctionPrototype();
		dosLibraryFunction.ppCond = "!defined(__LIBCCALL_IS_LIBDCALL) && ({})"
			.format({ dosLibraryFunction.ppCond });
		local dosProto = dosLibraryFunction.prototype;
		if (dosProto !is FunctionPrototype) {
			this.err("Indirect prototypes are not supported "
			         "with [[crt_dos_variant(callback(...))]] (see: {!r})"
				.format({ name }));
		}
		if (dosProto.nothrow != "THROWS(...)") {
			this.err("[[crt_dos_variant(callback(...))]] used on function {!r} not marked as [[throws]]. "
			         "Because user-defined callbacks are invoked, obviously this function can throw "
			         "any kind of exception!"
				.format({ name }));
		}

		/* Override certain parts about the dos prototype */
		applyDosProtoOverrides(dosProto, this.dosProto);

		/* Figure out the section to put the wrapper function into */
		local crt_dosExtraAttr = currentFeatures.getCrtDosExtraAttr();
		local crt_dosSection = currentFeatures.crt_dosSection !is none
			? currentFeatures.crt_dosSection
			: DEFAULT_DOS_SECTION;

		/* Replace `auto' in the types used by the cookie variable. */
		this.cookie.replaceAutoTypes(dosProto);

		/* Do the remaining work asynchronously once everything has been loaded. */
		return []{
			local result = FunctionImplementation(name: name);
			local dosBody = CWriter(File.Writer());
			local dosPrefix = CWriter(File.Writer());
			local wrapperFunctionName = "_dwrap_" + name;
			local usedWrapperBody = str(wrapperBody);
			local usedImplBody = str(implBody);
			local cookie = this.cookie;
			local serial = trySerializeDosCallbackWrapper(
				wrapperBody: usedWrapperBody,
				wrapperPrototype: wrapperPrototype, cookie: cookie);
			local serialKey = none;

			/* Output the cookie struct definition. */
			if (serial !is none) {
				serialKey = "__dwrap_{}_defined".format({ serial });
				dosPrefix.ppIfndef(serialKey);
				dosPrefix.ppDefine(serialKey, "");
				wrapperFunctionName = "_dwrap_" + serial;
			}
			if (cookie is WrapperCookieStruct) {
				cookie.name = serial !is none
					? ("_dwrap_cookie_struct_" + serial)
					: (name + "_dwrap_cookie_struct_");
				dosPrefix << "struct " << cookie.name << " {\n";
				for (local fieldName, fieldCookie: cookie.members) {
					dosPrefix << "\t";
					fieldCookie.ctype.cprintForGenerator(dosPrefix, fieldName);
					dosPrefix << ";\n";
				}
				dosPrefix << "};\n";
			}

			/* Replace `$cook' with the cookie type name within the wrapper prototype */
			for (local arg: wrapperPrototype.argv)
				updateCTypeForCookie(arg.ctype, cookie);
			if ("$cook" in usedWrapperBody)
				usedWrapperBody = usedWrapperBody.replace("$cook", cookie.cookieTypeName);

			/* Generate the wrapper implementation body. */
			local usedExtraAttributes = crt_dosExtraAttr;
			if (usedExtraAttributes is none)
				usedExtraAttributes = ();
			usedExtraAttributes = List(usedExtraAttributes);
			usedExtraAttributes.append("ATTR_SECTION({!r})".format({ crt_dosSection }));
			wrapperPrototype.cprintDeclarationWithoutTerminator(
				fp:                   dosPrefix,
				escapeMode:           ESCAPE_MODE_NONE,
				decl:                 "PRIVATE",
				injectedAttributes:   usedExtraAttributes,
				exposedName:          wrapperFunctionName,
				breakAfterReturnType: true,
				oneArgumentPerLine:   true);
			dosPrefix << " {\n\t";
			if (usedWrapperBody.startswith("{") && usedWrapperBody.endswith("}")) {
				dosPrefix << usedWrapperBody[1:-1].strip() << "\n}\n";
			} else {
				if (!wrapperPrototype.returnType.isVoid)
					dosPrefix << "return ";
				dosPrefix << usedWrapperBody << ";\n";
				dosPrefix << "}\n";
			}
			if (serialKey !is none)
				dosPrefix.ppEndif();

			@@String to which to expand @"$cook" in @implBody
			local cookieVariable: string;
			dosBody << "{\n";
			if (cookie is WrapperCookieStruct) {
				cookieVariable = name + "_cookie";
				dosBody << "\tstruct " << cookie.name << " " << cookieVariable << ";\n";
				local longestNameLen = cookie.members.each.first.length > ...;
				for (local name, field: cookie.members) {
					dosBody << "\t" << cookieVariable << "."
						<< str(name).ljust(longestNameLen) << " = "
						<< field.init << ";\n";
				}
			} else {
				cookieVariable = str(cookie.init);
			}

			/* Replace marker strings in the implementation body. */
			if ("$cook" in usedImplBody)
				usedImplBody = usedImplBody.replace("$cook", cookieVariable);
			if ("$wrap" in usedImplBody)
				usedImplBody = usedImplBody.replace("$wrap", wrapperFunctionName);

			/* Generate the implementation body */
			dosBody << "\t";
			if (usedImplBody.startswith("{") && usedImplBody.endswith("}")) {
				dosBody << usedImplBody[1:-1].strip();
			} else {
				if (!dosProto.returnType.isVoid)
					dosBody << "return ";
				dosBody << usedImplBody << ";\n";
			}
			dosBody << "}";

			/* Flush generated files. */
			dosBody   = dosBody.flush().generator.fp.string;
			dosPrefix = dosPrefix.flush().generator.fp.string;

			/* Finalize the used FunctionImplementation */
			result.implPrefix = (dosPrefix,);
			result.body = dosBody;
			result.dependencies = []{
				for (local body: { usedWrapperBody, usedImplBody }) {
					local deps = scanForNamesOfDependentFunctions(body, name, dosProto);
					if (deps is Callable)
						deps = deps();
					yield deps...;
				}
			};
			return result;
		};
	}
}

@@Parse the `...' of a `[[crt_dos_variant(callback(...))]]` annotation
@@>> [[crt_dos_variant(callback(
@@>>     decl: int(void const *key, void const *base, size_t *nmemb, size_t size,
@@>>               int (LIBDCALL *compar)(void *, void const *, void const *), void *arg),
@@>>     cook: struct { auto compar = compar; auto arg = arg; },
@@>>     wrap: int($cook *c, void const *a, void const *b) { return (*c->compar)(c->arg, a, b); },
@@>>     impl: _lfind_s(key, base, nmemb, size, $wrap, &$cook),
@@>> ))]]
function parseCrtDosVariantCallbackMetadata(self: CParser): CrtDosVariantCallbackMetadata {
	local dosProto: FunctionPrototype | none = none;
	local cookie: WrapperCookie | WrapperCookieStruct = none;
	local wrapperPrototype: FunctionPrototype = FunctionPrototype(
		cc: DEFAULT_CC, nothrow: "THROWS(...)");
	local wrapperBody: string | UserString = none;
	local implBody: string | UserString = none;
	local tok = self.tok;
	while (tok != ")") {
		switch (tok) {

		case "decl":
			dosProto = FunctionPrototype(cc: DEFAULT_DOS_CC);
			self.next();
			self.skip(":");
			parseWholeFunctionPrototype(self, dosProto);
			break;

		case "cook":
			self.next();
			tok = self.skip(":");
			if (tok == "struct") {
				self.next();
				tok = self.skip("{");
				cookie = WrapperCookieStruct();
				while (tok != "}") {
					local typ, name = parseCTypeAndName(self)...;
					local field = WrapperCookie(ctype: typ);
					self.skip("=");
					field.init = self.parseAllUntilRParenOrSemi();
					cookie.members.append((name, field));
					if (self.tok !in ",;")
						break;
					tok = self.next();
				}
				tok = self.skip("}");
			} else {
				local typ, name = parseCTypeAndName(self)...;
				if (name)
					self.err("non-struct cookie has name {!r}".format({ name }));
				cookie = WrapperCookie(ctype: typ);
				self.skip("=");
				cookie.init = self.parseAllUntilRParenOrSemi();
			}
			break;

		case "wrap": {
			self.next();
			tok = self.skip(":");
			if (tok == "[") {
				parseWholeFunctionPrototype(self, wrapperPrototype);
				self.skip("]");
			} else {
				parseWholeFunctionPrototype(self, wrapperPrototype);
			}
			if (self.tok == "{") {
				local bodyStart = self.tokStart;
				self.skipPair();
				wrapperBody = self.getUserString(bodyStart, self.tokEnd);
				self.next();
			} else {
				wrapperBody = self.parseAllUntilRParen();
			}
		}	break;

		case "impl":
			self.next();
			self.skip(":");
			implBody = self.parseAllUntilRParen();
			break;

		default:
			self.err("Unknown key in [crt_dos_variant(callback(...))]: {!r}"
				.format({ tok }));
		}
		if (self.tok != ",")
			break;
		tok = self.next();
	}
	if (cookie is none)
		self.err("No cookie defined in [[crt_dos_variant(callback(...))]]");
	if (wrapperBody is none)
		self.err("No wrapper body defined in [[crt_dos_variant(callback(...))]]");
	if (implBody is none)
		self.err("No implementation body defined in [[crt_dos_variant(callback(...))]]");
	return CrtDosVariantCallbackMetadata(
		dosProto:         dosProto,
		cookie:           cookie,
		wrapperPrototype: wrapperPrototype,
		wrapperBody:      wrapperBody,
		implBody:         implBody);
}


class CrtDosVariantCustomMetadata: CrtDosVariantMetadata {
	this = default;
	public member dosProto: FunctionPrototype | none = none;
	public member implPrefix: {(string | UserString)...} = [];
	public member implBody: string | UserString;

	public function generate(
			dosLibraryFunction: LibraryFunction,
			currentFeatures: FunctionFeatures)
			: FunctionImplementation | Callable {
		local name = dosLibraryFunction.name;
		if (dosLibraryFunction.prototype !is bound)
			dosLibraryFunction.prototype = FunctionPrototype();
		local dosProto = dosLibraryFunction.prototype;
		if (dosProto !is FunctionPrototype) {
			this.err("Indirect prototypes are not supported "
			         "with [[crt_dos_variant({{...}})]] (see: {!r})"
				.format({ name }));
		}

		/* Override certain parts about the dos prototype */
		applyDosProtoOverrides(dosProto, this.dosProto);

		/* Do the remaining work asynchronously once everything has been loaded. */
		return []{
			local result = FunctionImplementation(name: name);
			result.implPrefix = implPrefix;
			local implBodyStr = str(implBody);
			if ("%[invoke_libc]" in implBodyStr) {
				/* Replace "%[invoke_libc]"  with an  expression
				 * that invokes the function's `libc_*' variant. */
				local libcCall = "{}({})".format({
					"libc_" + name[5:],
					", ".join(dosProto.argv.each.name)
				});
				implBodyStr = implBodyStr.replace("%[invoke_libc]", libcCall);
			}
			if (implBodyStr.startswith("{") && implBodyStr.endswith("}")) {
				result.body = implBody;
			} else {
				result.body = "{{\n\treturn {};\n}}".format({ implBodyStr });
			}
			result.dependencies = []{
				for (local body: { implBody, implPrefix... }) {
					local deps = scanForNamesOfDependentFunctions(str(body), name, dosProto);
					if (deps is Callable)
						deps = deps();
					yield deps...;
				}
			};
			return result;
		};
	}
}

@@Parse the `...' of a `[[crt_dos_variant(callback(...))]]` annotation
@@>> [[crt_dos_variant({
@@>>     prefix: ...
@@>>     impl: { ... },
@@>> })]]
function parseCrtDosVariantCustomMetadata(self: CParser): CrtDosVariantCustomMetadata {
	local result = CrtDosVariantCustomMetadata(implBody: none);
	local tok = self.tok;
	while (tok != "}") {
		switch (tok) {

		case "decl":
			if (result.dosProto !is none)
				self.err("Duplicate `decl' tag");
			self.next();
			self.skip(":");
			result.dosProto = FunctionPrototype(cc: DEFAULT_DOS_CC);
			parseWholeFunctionPrototype(self, result.dosProto);
			break;

		case "impl":
			if (result.implBody !is none)
				self.err("Duplicate `impl' tag");
			self.next();
			self.skip(":");
			result.implBody = self.parseAllUntilRParen();
			break;

		case "prefix": {
			self.next();
			self.skip(":");
			local prefix;
			if (self.tok == "{") {
				self.next();
				prefix = self.parseAllUntilRParen();
				self.skip("}");
			} else {
				prefix = self.parseAllUntilRParen();
			}
			result.implPrefix.append(prefix);
		}	break;

		default:
			self.err("Unknown key in [crt_dos_variant({ ... })]: {!r}"
				.format({ tok }));
		}
		if (self.tok != ",")
			break;
		tok = self.next();
	}
	if (result.implPrefix is none)
		self.err("No `impl' tag in [[crt_dos_variant({ ... })]]");
	return result;
}


function parseCrtDosVariantMetadata(self: CParser): CrtDosVariantMetadata {
	local result;
	switch (self.tok) {

	case "callback":
		self.next();
		self.skip("(");
		result = parseCrtDosVariantCallbackMetadata(self);
		self.skip(")");
		break;

	case "{":
		self.next();
		result = parseCrtDosVariantCustomMetadata(self);
		self.skip("}");
		break;

	default:
		self.err("Unknown crt_dos_variant command: {!r}".format({ self.tok }));
	}
	return result;
}



@@Load system header definitions
@@@param: customDirectivesParser: A custom callback that is invoked to parse otherwise
@@                                unrecognized directives. Upon entry, the parser will
@@                                point at the  directive's name, and  upon exit,  the
@@                                parser should point at the trailing @"," or @"]"
function loadSystemHeaderDefinitions(
		self: CParser, headerName: string,
		customDirectivesParser: Callable with LoaderContext = none,
		context: LoaderContext = none): SystemHeader {
	local result: SystemHeader;
	local isPrimaryDefinitionsFile = true;
	if (context !is none) {
		result = context.result;
		isPrimaryDefinitionsFile = false;
	} else {
		result = SystemHeader(name: headerName);
		if (!allSystemHeaders.setnew(headerName, result))
			throw Error("Duplicate system header: {!r}".format({ headerName }));
		context = LoaderContext(
			self: self, headerName: headerName, result: result,
			customDirectivesParser: customDirectivesParser);
	}
	local tok = self.tok;
	if (!tok)
		tok = self.next();
	/* Standard system header prefix */
	if (isPrimaryDefinitionsFile) {
		result.order_header.append(
			"#include {0[0]}\n"
			"#include {0[1]}\n"
			"\n"
			"#ifdef __COMPILER_HAVE_PRAGMA_GCC_SYSTEM_HEADER\n"
			"#pragma GCC system_header\n"
			"#endif /* __COMPILER_HAVE_PRAGMA_GCC_SYSTEM_HEADER */\n"
			"\n"
			.format({
				"." in headerName
					? ('<__stdinc.h>', '<__crt.h>')
					: ('"__stdinc.h"', '"__crt.h"')
				}));
	}
	while (tok) {
		if (tok == "%") {
			/* Directive / text-injections */
			local nextCh = self.text[self.tokEnd];
			switch (nextCh) {

			case "[":
				self.next();
				self.next();
				context.parseDirectives();
				self.skip("]");
				break;

			case "(": {
				/* %(std, c, ...){ ... } */
				local tagList: {string...} = HashSet();
				self.next();
				tok = self.next();
				while (tok !in ["", ")"]) {
					if (isCString(tok))
						tok = tok.decode("c-escape");
					else if (!tok.issymbol()) {
						self.err("Expected keyword or string in embedded string tag list, but got {!r}"
							.format({ tok }));
					}
					if (tok !in KNOWN_STRING_TAGS) {
						self.err("Unknown tag for embedded strings: {!r}"
							.format({ tok }));
					}
					tagList.insert(tok);
					tok = self.next();
					if (tok != ",")
						break;
					tok = self.next();
				}
				if (tok != ")") {
					self.err("Unexpected token (expected {!r}, but got {!r})"
						.format({ ")", tok }));
				}
				local textStart = self.tokEnd;
				local textEnd = textStart;
				if (textStart + 1 < self.end) {
					if (self.text[textStart] == "{") {
						/* Block-string: %(tags...){ TEXT } */
						textStart = textStart + 1;
						self.next();
						tok = self.next();
						while (tok !in ["", "}"]) {
							if (tok in "({[")
								self.skipPair();
							tok = self.next();
						}
						textEnd = self.tokStart;
						if (self.text.islf(textStart))
							++textStart;
						self.skip("}");
					} else {
						/* Single-line: %(tags...)TEXT  */
						textEnd = self.text.find("\n", textStart, self.end);
						if (textEnd < 0)
							textEnd = self.end;
						else {
							++textEnd;
						}
						self.tokEnd = textEnd;
						self.next();
					}
				} else {
					self.next();
				}
				local text = self.getUserString(textStart, textEnd);
				/* Insert strings where appropriate */
				context.insertText(tagList, text);
			}	break;

			case "{": {
				/* %{ ... }  (Same as %(c){ ... }) */
				self.next();
				local textStart = self.tokEnd;
				tok = self.next();
				while (tok !in ["", "}"]) {
					if (tok in "({[")
						self.skipPair();
					tok = self.next();
				}
				if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_END);
					context.result_order_header_in_CXX_SYSTEM_HEADER = false;
				}
				if (self.text.islf(textStart))
					++textStart;
				result.order_header.append(
					self.getUserString(textStart, self.tokStart));
				self.skip("}");
			}	break;

			default: {
				/* Anything else following a %-character is a single-line,
				 * default  target embedded string destined for <string.h> */
				local textStart = self.tokEnd;
				local textEnd = self.text.find("\n", textStart, self.end);
				if (textEnd < 0)
					textEnd = self.end;
				else {
					++textEnd;
				}
				if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_END);
					context.result_order_header_in_CXX_SYSTEM_HEADER = false;
				}
				result.order_header.append(
					self.getUserString(textStart, textEnd));
				self.tokEnd = textEnd;
				self.next();
			}	break;
			}
			tok = self.tok;
			continue;
		}
		if (tok == ";") {
			tok = self.next();
			continue;
		}
		local currentFeatures = copy context.defaultFeatures;
		local current: Function = Function(originalSystemHeaderName: headerName);
		local currentPrototype = FunctionPrototype(nothrow: DEFAULT_NOTHROW);
		local currentPrototypes: {(string, {FunctionPrototype...})...} =
			[("1", { currentPrototype })];
		local currentKosLibraryFunction: LibraryFunction = none;
		local currentDosLibraryFunction: LibraryFunction = none;
		/* # of leading entries in @current.bindings that should appear before the self-binding */
		local numPreferredBindings = 0;
		@@Additional function bindings that will be
		local lateFunctionBindings: {FunctionBinding...} = ();
		local defaultAttributes: {UserString...} = none;
		local functionArgumentNamesOverride: {(string | UserString)...} = none;
continue_current:
		if (tok == "[") {
			local scopeConditions = [];
			local currentConditions = none;
again_parse_annotations:
			tok = self.next();
			while (tok != "]") {
				switch (tok) {

				case "if": {
					/* Conditional annotations */
					self.next();
					self.skip("(");
					local ppAddend = self.parseCStringOrAllUntilRParen();
					self.skip(")");
					if (currentConditions is none)
						currentConditions = ppAddend;
					else {
						currentConditions = "({}) && ({})"
							.format({ currentConditions, ppAddend });
					}
				}	break;

				case "if_fast_defined":
				case "if_fast_defined_always": {
					/* Conditional annotations */
					self.next();
					self.skip("(");
					local ppAddend = (tok.endswith("_always")
						? IF_ALWAYS_FAST_DEFINED_PATTERN
						: IF_FAST_DEFINED_PATTERN
					).format({
						headerName,
						self.parseCStringOrAllUntilRParen()
					});
					self.skip(")");
					if (currentConditions is none)
						currentConditions = ppAddend;
					else {
						currentConditions = "({}) && ({})"
							.format({ currentConditions, ppAddend });
					}
				}	break;

				case "doc": {
					if (current.documentation !is string)
						self.err("[doc(...)] used alongside [doc_alias(...)]");
					self.next();
					self.skip("(");
					local line = self.parseCStringOrAllUntilRParen();
					self.skip(")");
					if (current.documentation)
						current.documentation += "\n";
					current.documentation += line;
				}	break;

				case "doc_alias": {
					if (current.documentation !is string)
						self.err("[doc_alias(...)] annotation already used");
					if (current.documentation)
						self.err("[doc_alias(...)] used when a custom doc string was already set");
					self.next();
					self.skip("(");
					local funcNameStart: int = self.tokStart;
					local funcName: string = self.parseCStringOrKeyword();
					self.skip(")");
					current.documentation = [](): string {
						local func: Function;
						try {
							func = findFunctionByName(funcName);
						} catch (Error as e) {
							self.errAt(funcNameStart, e.message);
						}
						return func.documentationString;
					};
				}	break;

				case "[":
					scopeConditions.pushback(currentConditions);
					goto again_parse_annotations;

				case "argument_names":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					self.next();
					self.skip("(");
					functionArgumentNamesOverride = List(
						self.parseCStringOrFunctionLikeExpressionList());
					self.skip(")");
					break;

				case "dos_only_export_as":
				case "dos_only_export_alias":
				case "dos_only_export_raw_alias":
				case "preferred_dos_only_export_alias":
				case "preferred_dos_only_export_raw_alias": {
					/* >> [[dos_only_export_as("foo")]]
					 * Same as:
					 * >> [[dos_export_as("DOS$foo")]]
					 * >> [[if(defined(__LIBCCALL_IS_LIBDCALL)), kos_export_as("foo")]]
					 *
					 * May be used to export a symbol alias that (may) only visible within
					 * the DOS namespace, unless DOS  uses the same calling convention  as
					 * the regular libc, in which case the behavior is the same as  normal
					 * use of `[[export_as("foo")]]'
					 *
					 * WARNING: Don't use this tag for [[wchar]] functions! Because those
					 *          function  _always_ have a dedicated dos-variant, you have
					 *          to use the normal `[[dos_export_as("foo")]]' instead! */
					local mode = tok;
					if (currentDosLibraryFunction is none)
						currentDosLibraryFunction = LibraryFunction();
					if (currentKosLibraryFunction is none)
						currentKosLibraryFunction = LibraryFunction();
					self.next();
					tok = self.skip("(");
					while (tok !in ["", ")"]) {
						for (local name: context.parseAliasNameOrList()) {
							if (mode.endswith("alias")) {
								local ppCond = currentConditions;
								if (!mode.endswith("raw_alias"))
									ppCond = constructAliasConditions(ppCond, name);
								if (ppCond is none)
									ppCond = "1";
								local binding = FunctionBinding(
									ppCond:     ppCond,
									prototypes: currentPrototypes,
									binding:    name);
								if (mode.startswith("preferred_")) {
									current.bindings.insert(numPreferredBindings, binding);
									++numPreferredBindings;
								} else {
									current.bindings.append(binding);
								}
							}
							currentDosLibraryFunction.exportSymbolNames.append((
								currentConditions is none
									? "1"
									: currentConditions,
								"DOS$" + name));
							currentKosLibraryFunction.exportSymbolNames.append((
								currentConditions is none
									? "defined(__LIBCCALL_IS_LIBDCALL)"
									: "defined(__LIBCCALL_IS_LIBDCALL) && ({})"
										.format({ currentConditions }),
								name));
						}
						if (self.tok != ",")
							break;
						tok = self.next();
					}
					self.skip(")");
				}	break;

				case "export_alias":
				case "dos_export_alias":
				case "kos_export_alias":
				case "export_raw_alias":
				case "dos_export_raw_alias":
				case "kos_export_raw_alias":
				case "preferred_export_alias":
				case "preferred_dos_export_alias":
				case "preferred_kos_export_alias":
				case "preferred_export_raw_alias":
				case "preferred_dos_export_raw_alias":
				case "preferred_kos_export_raw_alias": {
					local mode = tok;
					local libFuncs: {LibraryFunction...};
					if ("kos_" in mode) {
						if (currentKosLibraryFunction is none)
							currentKosLibraryFunction = LibraryFunction();
						libFuncs = { currentKosLibraryFunction };
					} else if ("dos_" in mode) {
						if (currentDosLibraryFunction is none)
							currentDosLibraryFunction = LibraryFunction();
						libFuncs = { currentDosLibraryFunction };
					} else {
						if (currentDosLibraryFunction is none)
							currentDosLibraryFunction = LibraryFunction();
						if (currentKosLibraryFunction is none)
							currentKosLibraryFunction = LibraryFunction();
						libFuncs = { currentKosLibraryFunction, currentDosLibraryFunction };
					}
					self.next();
					tok = self.skip("(");
					while (tok !in ["", ")"]) {
						for (local name: context.parseAliasNameOrList()) {
							local ppCond = currentConditions;
							if (!mode.endswith("raw_alias"))
								ppCond = constructAliasConditions(ppCond, name);
							if (ppCond is none)
								ppCond = "1";
							local binding = FunctionBinding(
								ppCond:     ppCond,
								prototypes: currentPrototypes,
								binding:    name);
							if (mode.startswith("preferred_")) {
								current.bindings.insert(numPreferredBindings, binding);
								++numPreferredBindings;
							} else {
								current.bindings.append(binding);
							}
							for (local lf: libFuncs) {
								local usedAsmname = name;
								if (lf === currentDosLibraryFunction)
									usedAsmname = "DOS$" + name;
								lf.exportSymbolNames.append((
									currentConditions is none
										? "1"
										: currentConditions,
									usedAsmname));
							}
						}
						if (self.tok != ",")
							break;
						tok = self.next();
					}
					self.skip(")");
				}	break;

				case "export_as":
				case "kos_export_as":
				case "dos_export_as": {
					local mode = tok;
					self.next();
					tok = self.skip("(");
					while (tok !in ["", ")"]) {
						for (local name: context.parseAliasNameOrList()) {
							if (mode != "dos_export_as") {
								if (currentKosLibraryFunction is none)
									currentKosLibraryFunction = LibraryFunction();
								currentKosLibraryFunction.exportSymbolNames.append((
									currentConditions !is none
										? currentConditions
										: "1",
									name));
							}
							if (mode != "kos_export_as") {
								if (mode == "export_as")
									name = "DOS$" + name;
								if (currentDosLibraryFunction is none)
									currentDosLibraryFunction = LibraryFunction();
								currentDosLibraryFunction.exportSymbolNames.append((
									currentConditions !is none
										? currentConditions
										: "1",
									name));
							}
						}
						if (self.tok != ",")
							break;
						tok = self.next();
					}
					self.skip(")");
				}	break;

				case "alias":
				case "raw_alias":
				case "preferred_alias":
				case "preferred_raw_alias":
					self.next();
					self.skip("(");
					while (self.tok !in ["", ")"]) {
						for (local assemblyName: context.parseAliasNameOrList()) {
							local ppCond = currentConditions;
							if (!tok.endswith("raw_alias"))
								ppCond = constructAliasConditions(ppCond, assemblyName);
							local binding = FunctionBinding(
								ppCond:     ppCond,
								prototypes: currentPrototypes,
								binding:    assemblyName);
							if (tok.startswith("preferred_")) {
								current.bindings.insert(numPreferredBindings, binding);
								++numPreferredBindings;
							} else {
								current.bindings.append(binding);
							}
						}
						if (self.tok != ",")
							break;
						self.next();
					}
					self.skip(")");
					break;

				case "bind_local_function":
				case "preferred_bind_local_function":
					self.next();
					self.skip("(");
					while (self.tok !in ["", ")"]) {
						local functionName = self.parseCStringOrFunctionLikeExpression();
						local binding = FunctionBinding(
							ppCond:     currentConditions is none ? "1" : currentConditions,
							prototypes: currentPrototypes,
							binding:    [] -> findLocalFunctionByName(functionName));
						if (tok.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, binding);
							++numPreferredBindings;
						} else {
							current.bindings.append(binding);
						}
						if (self.tok != ",")
							break;
						self.next();
					}
					self.skip(")");
					break;

				case "fastbind":
				case "fastbind_always":
				case "preferred_fastbind":
				case "preferred_fastbind_always": {
					/* Simplified binding for compile-time inline-optimizations
					 *
					 * >> [[preferred_fastbind]]
					 * >> void *memcpy(void *dst, void const *src, size_t num_bytes);
					 *
					 * Same as:
					 * >> [[preferred_fastbind(memcpy)]]
					 * >> void *memcpy(void *dst, void const *src, size_t num_bytes);
					 *
					 * Same as:
					 * >> [[preferred_fastbind(memcpy(dst, src, num_bytes))]]
					 * >> void *memcpy(void *dst, void const *src, size_t num_bytes);
					 *
					 * Same as:
					 * >> [[preferred_fastbind(memcpy(dst, src, num_bytes), ["memcpy"])]]
					 * >> void *memcpy(void *dst, void const *src, size_t num_bytes);
					 *
					 * Same as:
					 * >> [[if_fast_defined(memcpy), preferred_fast_extern_inline("memcpy", { return (__NAMESPACE_FAST_SYM __LIBC_FAST_NAME(@memcpy@))(dst, src, n_bytes); })]]
					 * >> [[if_fast_defined(memcpy), preferred_fast_forceinline({ return (__NAMESPACE_FAST_SYM __LIBC_FAST_NAME(@memcpy@))(dst, src, n_bytes); })]]
					 * >> void *memcpy(void *dst, void const *src, size_t num_bytes);
					 *
					 * Syntax:
					 * >> '[' [IF(...),] ('preferred_fastbind' | 'fastbind') '('
					 * >>      FAST_FUNCTION_NAME ['(' FAST_FUNCTION_ARGUMENT_LIST ')']
					 * >>      [',' '[' [(',' ~~ ASMNAME)...] ']']   // Defaults to `["<FAST_FUNCTION_NAME>"]`
					 * >> ')' ']'
					 */
					self.next();
					if (self.tok != "(") {
						/* Most simplified case: deduce everything automatically */
						local bindingsGenerator = []{
							local fastFunctionName = current.name;
							local baseCond = IF_FAST_DEFINED_PATTERN;
							if (tok.endswith("_always"))
								baseCond = IF_ALWAYS_FAST_DEFINED_PATTERN;
							baseCond = baseCond.format({ headerName, fastFunctionName });
							if (currentConditions !is none)
								baseCond = "({})&&{}".format({ currentConditions, baseCond });
							File.Writer bodyFp;
							bodyFp << "{ ";
							if (!currentPrototype.returnType.isVoid)
								bodyFp << "return ";
							bodyFp << "(__NAMESPACE_FAST_SYM __LIBC_FAST_NAME(@"
								<< fastFunctionName << "@))(";
							local isFirst: bool = true;
							for (local a: currentPrototype.argv) {
								if (!isFirst)
									bodyFp << ", ";
								isFirst = false;
								bodyFp << a.name;
							}
							if (currentPrototype.hasEllipsis)
								bodyFp << "__builtin_va_arg_pack()";
							bodyFp << "); }";
							local fastWrapperImpl = FunctionImplementation(
								body: bodyFp.string,
								name: fastFunctionName);
							yield FunctionBinding(
								ppCond:     "{}&&{}".format({ baseCond, keyCrtHave(fastFunctionName) }),
								prototypes: currentPrototypes,
								binding:    [] -> InlineFunction(
									mode:                "__EXTERN_INLINE",
									impl:                fastWrapperImpl,
									externInlineAsmname: fastFunctionName,
									isFastBinding:       true));
							yield FunctionBinding(
								ppCond:     baseCond,
								prototypes: currentPrototypes,
								binding:    [] -> InlineFunction(
									mode:          "FORCELOCAL",
									impl:          fastWrapperImpl,
									isFastBinding: true));
						};
						if (tok.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, bindingsGenerator);
							++numPreferredBindings;
						} else {
							current.bindings.append(bindingsGenerator);
						}
						break;
					}
					self.skip("(");
					local fastFunctionReturnCast: string = "";
					if (self.tok == "(") {
						local fastFunctionReturnCastStart = self.tokStart;
						self.skipPair();
						fastFunctionReturnCast = self.text[fastFunctionReturnCastStart:self.tokEnd];
						self.next();
					}
					local fastFunctionName: string = self.parseCStringOrKeyword();
					local fastFunctionArgumentList: string = none;
					if (self.tok == "(") {
						self.next();
						local fastFunctionArgumentListStart = self.tokStart;
						self.skipPair("(", ")");
						local fastFunctionArgumentListEnd = self.tokStart;
						while (fastFunctionArgumentListEnd > fastFunctionArgumentListStart &&
						       self.text.isspace(fastFunctionArgumentListEnd - 1))
							--fastFunctionArgumentListEnd;
						fastFunctionArgumentList = self.text[
							fastFunctionArgumentListStart:fastFunctionArgumentListEnd];
						self.next();
					}
					local externInlineAssemblyNames: {string...};
					if (self.tok == ",") {
						self.next();
						if (self.tok == "[") {
							self.next();
							externInlineAssemblyNames = [];
							while (self.tok != "]") {
								externInlineAssemblyNames.append(
									self.parseCStringOrKeyword());
								if (self.tok != ",")
									break;
								self.next();
							}
							self.skip("]");
						}
					} else {
						externInlineAssemblyNames = { fastFunctionName };
					}
					local baseCond = IF_FAST_DEFINED_PATTERN;
					if (tok.endswith("_always"))
						baseCond = IF_ALWAYS_FAST_DEFINED_PATTERN;
					baseCond = baseCond.format({ headerName, fastFunctionName });
					if (currentConditions !is none)
						baseCond = "({})&&{}".format({ currentConditions, baseCond });
					local inlineImplementationCell: Cell with FunctionImplementation = Cell();
					function getInlineImplementation(): FunctionImplementation {
						if (inlineImplementationCell)
							return inlineImplementationCell.value;
						File.Writer bodyFp;
						bodyFp << "{ ";
						if (!currentPrototype.returnType.isVoid)
							bodyFp << "return ";
						bodyFp << fastFunctionReturnCast
							<< "(__NAMESPACE_FAST_SYM __LIBC_FAST_NAME(@"
							<< fastFunctionName << "@))(";
						if (fastFunctionArgumentList !is none)
							bodyFp << fastFunctionArgumentList;
						else {
							/* Automatically pass all arguments from own prototype */
							local isFirst: bool = true;
							for (local a: currentPrototype.argv) {
								if (!isFirst)
									bodyFp << ", ";
								isFirst = false;
								bodyFp << a.name;
							}
							if (currentPrototype.hasEllipsis)
								bodyFp << "__builtin_va_arg_pack()";
						}
						bodyFp << "); }";
						local result = FunctionImplementation(
							body: bodyFp.string,
							name: current.name);
						inlineImplementationCell.value = result;
						return result;
					}
					/* Bind extern-inline variants */
					for (local eiAsmname: externInlineAssemblyNames) {
						local bindingCond = "{}&&{}".format({
							baseCond, keyCrtHave(eiAsmname) });
						local binding = FunctionBinding(
							ppCond:     bindingCond,
							prototypes: currentPrototypes,
							binding:    [] -> InlineFunction(
								mode:                "__EXTERN_INLINE",
								impl:                getInlineImplementation(),
								externInlineAsmname: eiAsmname,
								isFastBinding:       true));
						if (tok.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, binding);
							++numPreferredBindings;
						} else {
							current.bindings.append(binding);
						}
					}
					local binding = FunctionBinding(
						ppCond:     baseCond,
						prototypes: currentPrototypes,
						binding:    [] -> InlineFunction(
							mode:          "FORCELOCAL",
							impl:          getInlineImplementation(),
							isFastBinding: true));
					if (tok.startswith("preferred_")) {
						current.bindings.insert(numPreferredBindings, binding);
						++numPreferredBindings;
					} else {
						current.bindings.append(binding);
					}
					self.skip(")");
				}	break;

				case "inline":
				case "forceinline":
				case "extern_inline":
				case "raw_extern_inline":
				case "preferred_inline":
				case "preferred_forceinline":
				case "preferred_extern_inline":
				case "preferred_raw_extern_inline":
				case "fast_inline":
				case "fast_forceinline":
				case "fast_extern_inline":
				case "fast_raw_extern_inline":
				case "preferred_fast_inline":
				case "preferred_fast_forceinline":
				case "preferred_fast_extern_inline":
				case "preferred_fast_raw_extern_inline":
					/* >> '[' 'inline'      ']'    // Defaultable
					 * >> '[' 'forceinline' ']'    // Defaultable
					 * >> '[' [IF(...),] ('preferred_inline' | 'inline') '(' BODY ')' ']'
					 * >> '[' [IF(...),] ('preferred_forceinline' | 'forceinline') '(' BODY ')' ']'
					 * >> '[' [IF(...),] ('preferred_extern_inline' | 'extern_inline') '(' SYMBOL_NAME ',' BODY ')' ']'
					 * >> '[' [IF(...),] ('preferred_raw_extern_inline' | 'raw_extern_inline') '(' SYMBOL_NAME ',' BODY ')' ']'
					 */
					if (self.next() == "(") {
						/* With arguments: Define an inline function implementation */
						local externSymbolName;
						self.next();
						if (tok.endswith("extern_inline")) {
							externSymbolName = self.parseCStringOrKeyword();
							self.skip(",");
						}
						local body = self.parseCStringOrAllUntilRParen();
						if (!currentFeatures.noInlineTruncate)
							body = truncateInlineFunctionImplementation(str(body));
						self.skip(")");
						local bindingCond = currentConditions is none ? "1" : currentConditions;
						if (tok.endswith("extern_inline") && !tok.endswith("raw_extern_inline")) {
							local ppHave = keyCrtHave(externSymbolName);
							if (bindingCond == "1")
								bindingCond = ppHave;
							else {
								bindingCond = "({})&&{}".format({ bindingCond, ppHave });
							}
						}
						local binding = FunctionBinding(
							ppCond:     bindingCond,
							prototypes: currentPrototypes,
							binding:    []{
								local ifun = InlineFunction(
									impl: FunctionImplementation(
										body: body,
										name: current.name),
									isFastBinding: "fast_" in tok);
								if (tok.endswith("extern_inline")) {
									ifun.mode                = "__EXTERN_INLINE";
									ifun.externInlineAsmname = externSymbolName;
								} else if ("force" in tok) {
									ifun.mode = "FORCELOCAL";
								}
								return ifun;
							});
						if (tok.startswith("preferred_")) {
							current.bindings.insert(numPreferredBindings, binding);
							++numPreferredBindings;
						} else {
							current.bindings.append(binding);
						}
					} else {
						if (tok !in ["inline", "forceinline", "extern_inline"])
							self.skip("(");
						if (currentConditions !is none)
							goto illegal_annotation_with_condition;
						currentFeatures.inline = {
							"inline"        : "LOCAL",
							"forceinline"   : "FORCELOCAL",
							"extern_inline" : "LOCAL"
						}[tok];
						if (tok == "extern_inline")
							currentFeatures.noExternInline = false;
					}
					break;

				case "crtbuiltin": {
					/* >> [[crtbuiltin]] size_t strlen(char const *__restrict str);
					 * Same as:
					 * >> [[crtbuiltin(strlen)]] size_t strlen(char const *__restrict str);
					 * Same as:
					 * >> [[if(__has_builtin(__builtin_strlen) && defined(__LIBC_BIND_CRTBUILTINS)),
					 * >>   preferred_extern_inline(strlen, { return __builtin_strlen(str); })
					 * >> ]] strlen(char const *__restrict str);
					 * HEADER:
					 * >> #if __has_builtin(__builtin_strlen) && defined(__LIBC_BIND_CRTBUILTINS) && defined(__CRT_HAVE_strlen)
					 * >> __CEIDECLARE(,size_t,NOTHROW_NCX,strlen,(char const *__restrict __str),{ return __builtin_strlen(__str); })
					 * >> #elif defined(__CRT_HAVE_strlen)
					 * >> __CDECLARE(,size_t,NOTHROW_NCX,strlen,(char const *__restrict __str),(__str))
					 * >> #endif // ...
					 */
					local builtinStart: int = self.tokStart;
					local asmnameOverride: string | none = none;
					if (self.next() == "(") {
						self.next();
						asmnameOverride = self.parseCStringOrKeyword();
						self.skip(")");
					}
					function crtbuiltinBindingGenerator(): FunctionBinding {
						local asmname: string = asmnameOverride;
						if (asmname is none)
							asmname = current.name;
						local usedCurrentPrototype: FunctionPrototype = currentPrototype;
						local usedCurrentPrototypes: {(string | UserString, {FunctionPrototype...})...} = currentPrototypes;
						if (!usedCurrentPrototypes) {
							usedCurrentPrototypes = none;
							local usedBindings = current.bindings;
							if (usedBindings is Callable)
								usedBindings = usedBindings();
							for (local binding /*: FunctionBinding*/ : usedBindings) {
								/* Make sure to ignore our own binding here,
								 *so-as to  prevent an infinite recursion! */
								if (binding === crtbuiltinBindingGenerator)
									continue;
								local conditionalProtos = binding.prototypes;
								if (usedCurrentPrototypes is none) {
									usedCurrentPrototypes = conditionalProtos;
									continue;
								}
								if (usedCurrentPrototypes === conditionalProtos)
									continue;
								if (usedCurrentPrototypes is Callable)
									usedCurrentPrototypes = usedCurrentPrototypes();
								if (conditionalProtos is Callable)
									conditionalProtos = binding.prototypes = conditionalProtos();
								if (areFunctionPrototypesCompatible(
										usedCurrentPrototypes, conditionalProtos))
									continue;
								usedCurrentPrototypes = none;
								break;
							}
							if (usedCurrentPrototypes is Callable)
								usedCurrentPrototypes = usedCurrentPrototypes();
							if (usedCurrentPrototypes is none)
								self.errAt(builtinStart, "Unable to determine prototype list");
						}
						if (usedCurrentPrototype.returnType !is bound) {
							/* XXX: Must assert that all prototypes have the same
							 *      number  of arguments, and  the same names for
							 *      arguments... */
							usedCurrentPrototype = usedCurrentPrototypes.first.last.first;
						}
						local builtinName: string = "__builtin_" + asmname;
						local bindingCond: string =
							"__has_builtin({})&&"
							"defined(__LIBC_BIND_CRTBUILTINS)&&"
							"{}".format({ builtinName, keyCrtHave(asmname) });
						if (usedCurrentPrototype.hasEllipsis)
							bindingCond += "&&__has_builtin(__builtin_va_arg_pack)";
						if (currentConditions !is none)
							bindingCond = "({})&&{}".format({ currentConditions, bindingCond });
						File.Writer bodyFp;
						bodyFp << "{ ";
						if (!usedCurrentPrototype.isNoreturn &&
						    !usedCurrentPrototype.returnType.isVoid)
							bodyFp << "return ";
						bodyFp << builtinName << "(";
						/* Print argument names */
						local isFirst: bool = true;
						for (local a: usedCurrentPrototype.argv) {
							if (!isFirst)
								bodyFp << ", ";
							isFirst = false;
							bodyFp << a.name;
						}
						if (usedCurrentPrototype.hasEllipsis)
							bodyFp << "__builtin_va_arg_pack()";
						bodyFp << "); }";
						return FunctionBinding(
							ppCond:     bindingCond,
							prototypes: usedCurrentPrototypes,
							binding:    InlineFunction(
								mode: "__EXTERN_INLINE",
								impl: FunctionImplementation(
									body: bodyFp.string,
									name: current.name),
								externInlineAsmname: asmname));
					}
					current.bindings.insert(numPreferredBindings, crtbuiltinBindingGenerator);
					++numPreferredBindings;
				}	break;

				case "crt_intern_alias": {
					self.next();
					self.skip("(");
					local name = str(self.parseCStringOrKeyword());
					self.skip(")");
					if (currentKosLibraryFunction is none)
						currentKosLibraryFunction = LibraryFunction();
					if (currentDosLibraryFunction is none)
						currentDosLibraryFunction = LibraryFunction();
					currentKosLibraryFunction.bindings.append(LibraryFunctionBinding(
						ppCond:  currentConditions !is none ? currentConditions : "1",
						binding: "libc_" + name));
					currentDosLibraryFunction.bindings.append(LibraryFunctionBinding(
						ppCond:  currentConditions !is none ? currentConditions : "1",
						binding: "libd_" + name));
				}	break;

				case "crt_intern_kos_alias":
				case "crt_intern_dos_alias": {
					self.next();
					self.skip("(");
					local lfun: LibraryFunction;
					if (tok == "crt_intern_kos_alias") {
						if (currentKosLibraryFunction is none)
							currentKosLibraryFunction = LibraryFunction();
						lfun = currentKosLibraryFunction;
					} else {
						if (currentDosLibraryFunction is none)
							currentDosLibraryFunction = LibraryFunction();
						lfun = currentDosLibraryFunction;
					}
					lfun.bindings.append(LibraryFunctionBinding(
						ppCond:  currentConditions !is none ? currentConditions : "1",
						binding: self.parseCStringOrKeyword()));
					self.skip(")");
				}	break;

				{
					local wholeCond;
					local assemblyName;
				case "rlim64_variant_of":
				case "time64_variant_of":
				case "off64_variant_of":
				case "largefile64_variant_of":
				case "fts64_variant_of":
				case "dirent64_variant_of":
				case "statfs64_variant_of":
				case "longdouble_variant_of":
				case "stat64_variant_of":
				case "glob64_variant_of":
				case "preferred_rlim64_variant_of":
				case "preferred_time64_variant_of":
				case "preferred_off64_variant_of":
				case "preferred_largefile64_variant_of":
				case "preferred_fts64_variant_of":
				case "preferred_dirent64_variant_of":
				case "preferred_statfs64_variant_of":
				case "preferred_longdouble_variant_of":
				case "preferred_stat64_variant_of":
				case "preferred_glob64_variant_of":
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					wholeCond = {
						"rlim64_variant_of"      : "$extended_include_prefix(\"<bits/types.h>\")__SIZEOF_RLIM32_T__ == __SIZEOF_RLIM64_T__",
						"time64_variant_of"      : "$extended_include_prefix(\"<bits/types.h>\")__SIZEOF_TIME32_T__ == __SIZEOF_TIME64_T__",
						"off64_variant_of"       : "$extended_include_prefix(\"<bits/types.h>\")__SIZEOF_OFF32_T__ == __SIZEOF_OFF64_T__",
						"largefile64_variant_of" : "$extended_include_prefix(\"<asm/os/oflags.h>\")!defined(__O_LARGEFILE) || (__O_LARGEFILE+0) == 0",
						"fts64_variant_of"       : "$extended_include_prefix(\"<bits/crt/fts.h>\")defined(__FTS32_MATCHES_FTS64)",
						"statfs64_variant_of"    : "$extended_include_prefix(\"<bits/os/statfs.h>\")defined(_STATFS_MATCHES_STATFS64)",
						"longdouble_variant_of"  : "$extended_include_prefix(\"<hybrid/typecore.h>\")defined(__ARCH_LONG_DOUBLE_IS_DOUBLE)",
						"dirent64_variant_of"    : "$extended_include_prefix(\"<bits/os/dirent.h>\")defined(__DIRENT32_MATCHES_DIRENT64)",
						"stat64_variant_of"      : "$extended_include_prefix(\"<bits/os/stat.h>\")defined(__STAT32_MATCHES_STAT64)",
						"glob64_variant_of"      : "$extended_include_prefix(\"<bits/crt/glob.h>\")defined(__GLOB32_MATCHES_GLOB64)",
					}[tok.lsstrip("preferred_")];
					self.next();
					self.skip("(");
					assemblyName = self.parseCStringOrAllUntilRParen();
					goto do_handle_alt_variant_of;
				case "alt_variant_of":
				case "preferred_alt_variant_of":
					/*    [[alt_variant_of(cond, name)]]
					 * or [[if(cond), alt_variant_of(name)]]
					 * Same as:
					 * [[if(cond), alias(name)]]
					 * [[if(cond), crt_intern_kos_alias(libc_name)]]
					 * In other words: When "cond" is true, link the current function
					 *                 against some other function "name" in both the
					 *                 system header, as  well as  the internal  libc
					 *                 implementation. */
					self.next();
					self.skip("(");
					wholeCond = self.parseCStringOrAllUntilRParen();
					if (self.tok == ",") {
						self.next();
						assemblyName = self.parseCStringOrAllUntilRParen();
						if (currentConditions !is none && currentConditions != "1") {
							if (wholeCond == "1")
								wholeCond = currentConditions;
							else {
								wholeCond = "({}) && ({})"
									.format({ currentConditions, wholeCond });
							}
						}
					} else {
						assemblyName = wholeCond;
						wholeCond    = currentConditions;
					}
do_handle_alt_variant_of:
					if (currentKosLibraryFunction is none)
						currentKosLibraryFunction = LibraryFunction();
					currentKosLibraryFunction.bindings.append(
						LibraryFunctionBinding(
							ppCond:  wholeCond,
							binding: "libc_" + assemblyName));
					if (currentFeatures.crt_dosVariant) {
						if (currentDosLibraryFunction is none)
							currentDosLibraryFunction = LibraryFunction();
						currentDosLibraryFunction.bindings.append(
							LibraryFunctionBinding(
								ppCond:  wholeCond,
								binding: "libd_" + assemblyName));
					}
					local binding = FunctionBinding(
						ppCond:     constructAliasConditions(wholeCond, assemblyName),
						prototypes: currentPrototypes,
						binding:    assemblyName);
					if (tok.startswith("preferred_")) {
						current.bindings.insert(numPreferredBindings, binding);
						++numPreferredBindings;
					} else {
						current.bindings.append(binding);
					}
					self.skip(")");
				}	break;

				case "kernel":
					/* >> [[kernel]]
					 * Same as:
					 * >> [[crt_kos_impl_if(1)]]
					 * Whereas the default for `crt_export_if'  is:
					 * >> [[crt_kos_impl_if(!defined(__KERNEL__))]]
					 */
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					if (currentKosLibraryFunction is none)
						currentKosLibraryFunction = LibraryFunction();
					currentKosLibraryFunction.ppCond = "1";
					self.next();
					break;

				case "crt_dos_variant":
					/* >> [[crt_dos_variant(callback(
					 * >>     decl: ...,
					 * >>     cook: ...,
					 * >>     wrap: ...,
					 * >>     impl: ...,
					 * >> ))]]
					 * May be used to declare a custom implementation that
					 * is used to generate wrappers for LIBDCALL callbacks
					 * when !__LIBCCALL_IS_LIBDCALL. */
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					if (self.next() != "(") {
						currentFeatures.crt_dosVariant = true;
					} else {
						self.next();
						currentFeatures.crt_dosVariant = parseCrtDosVariantMetadata(self);
						self.skip(")");
					}
					break;

				case "crt_impl_if":
				case "crt_kos_impl_if":
				case "crt_dos_impl_if": {
					/* >> [[crt_impl_if(!defined(LIBC_ARCH_HAVE_MEMCPY))]]
					 * >> void *memcpy(void *dst, void const *src, size_t num_bytes);
					 * Specify a preprocessor condition that must be met for the function
					 * to  be  provided   as  a  libc   auto-  or   user-implementations. */
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					self.next();
					self.skip("(");
					local newCond = self.parseCStringOrAllUntilRParen();
					if (tok != "crt_dos_impl_if") {
						if (currentKosLibraryFunction is none)
							currentKosLibraryFunction = LibraryFunction();
						currentKosLibraryFunction.ppCond = newCond;
					}
					if (tok != "crt_kos_impl_if") {
						if (currentDosLibraryFunction is none)
							currentDosLibraryFunction = LibraryFunction();
						if (tok == "crt_impl_if")
							newCond = "!defined(__LIBCCALL_IS_LIBDCALL) && ({})".format({ newCond });
						currentDosLibraryFunction.ppCond = newCond;
					}
					self.skip(")");
				}	break;

				case "crt_dos_only":
					/* Prevent the definition of a DOS-variant, as well as force DOS-CC */
					if (currentConditions !is none)
						goto illegal_annotation_with_condition;
					currentPrototype.cc = DEFAULT_DOS_CC;
					currentFeatures.crt_noDosWrapper = true;
					currentFeatures.crt_dosVariant   = false;
					/* Add `ATTR_OPTIMIZE_SIZE' to the KOS variant (since it's obviously there for compat) */
					if (!currentFeatures.crt_dosNoOptimizeSize) {
						if (currentFeatures.crt_kosExtraAttr is none)
							currentFeatures.crt_kosExtraAttr = [];
						currentFeatures.crt_kosExtraAttr.append("ATTR_OPTIMIZE_SIZE");
					}
					self.next();
					break;

				default:
					if (currentConditions is none) {
						if (defaultAttributes is none)
							defaultAttributes = [];
						if (parsePrototypeAnnotation(self, currentPrototype, defaultAttributes))
							break;
					}
					if (currentFeatures.tryParseAttribute(self, currentConditions))
						break;
					self.err("Unknown function annotation {!r}"
						.format({ tok }));
					break;
illegal_annotation_with_condition:
					self.err("Annotation [{}] cannot be used [if(...)]"
						.format({ tok }));
					break;
				}
				tok = self.tok;
				if (tok != ",")
					break;
				tok = self.next();
			}
again_skip_annotation_rbracket:
			tok = self.skip("]");
			if (scopeConditions) {
				currentConditions = scopeConditions.popback();
				if (tok != ",")
					goto again_skip_annotation_rbracket;
				goto again_parse_annotations;
			}
			goto continue_current;
		}
		if (tok == "@@") {
			/* Documentation strings */
			local lineStart = self.tokEnd;
			local lineEnd = self.text.find("\n", lineStart, self.end);
			if (lineEnd < 0)
				lineEnd = self.end;
			if (current.documentation !is string)
				self.err("Documentation string used alongside [doc_alias(...)]");
			if (current.documentation)
				current.documentation += "\n";
			current.documentation += self.text[lineStart:lineEnd];
			self.tokEnd = lineEnd;
			tok = self.next();
			goto continue_current;
		}
		/* Either the function's return type, or its name */
		if (!tok.issymbol()) {
			self.err("Unexpected top-level token {!r}"
				.format({ tok }));
		}
		local currentName;
		local currentNameTokStart;
		{
			local returnTypeStart = self.tokStart;
			local returnTypeEnd = returnTypeStart;
			local lastKeyword;
			for (;;) {
				local kwdEnd = self.tokEnd;
				currentNameTokStart = self.tokStart;
				lastKeyword = tok;
				tok = self.next();
				if (!tok.issymbol() || !tok) {
					if (tok in "*&")
						continue;
					if (tok in "[{") {
						self.skipPair(tok);
						continue;
					}
					break;
				}
				returnTypeEnd = kwdEnd;
			}
			/* lastKeyword is  the  function's  name,  and  the  string  between
			 * returnTypeStart...returnTypeEnd is the (preliminary) return type. */
			current.name = currentName = lastKeyword;
			if (tok == ":")
				tok = self.next();
			if (tok != "(")
				self.err("Expected '(' after function name {!r}, but got {!r}"
					.format({ lastKeyword, tok }));
			if (returnTypeEnd > returnTypeStart) {
				currentPrototype.returnType = CType(
					self.getUserString(returnTypeStart, returnTypeEnd));
			}
		}
//		print("Function: ", headerName, "::", currentName);

		/* Bind the function against its own symbol */
		if (!currentFeatures.crt_noSelfImport) {
			local usedCrtName = currentFeatures.crt_name;
			if (usedCrtName is none)
				usedCrtName = currentName;
			current.bindings.insert(
				numPreferredBindings, FunctionBinding(
					ppCond:     keyCrtHave(usedCrtName),
					prototypes: currentPrototypes,
					binding:    usedCrtName));
		}

		/* If the function isn't being exported from libc, then make sure
		 * that certain attributes that would affect its export  behavior
		 * haven't been set. */
		if (currentFeatures.crt_noImpl) {
			if (currentFeatures.crt_kosSection !== context.defaultFeatures.crt_kosSection ||
			    currentFeatures.crt_dosSection !== context.defaultFeatures.crt_dosSection) {
				self.errAt(currentNameTokStart,
					"[section({!r})] used with [nocrt] or [crt_no_impl]"
					.format({ currentFeatures.crt_kosSection }));
			}
			if (currentFeatures.crt_kosExtraAttr !== context.defaultFeatures.crt_kosExtraAttr ||
			    currentFeatures.crt_dosExtraAttr !== context.defaultFeatures.crt_dosExtraAttr) {
				self.errAt(currentNameTokStart,
					"[crt_(kos|dos)_attr({!r})] used with [nocrt] or [crt_no_impl]"
					.format({ currentFeatures.crt_kosSection }));
			}
			if (currentKosLibraryFunction.exportSymbolNames ||
			    currentDosLibraryFunction.exportSymbolNames) {
				self.errAt(currentNameTokStart,
					"[export_as(...)] used with [nocrt] or [crt_no_impl]");
			}
		}

		/* Check for special case: @"dstFunction(*) = srcFunction;"
		 * This case is handled by:
		 * >> currentPrototypes = none;
		 * >> goto handle_eq_after_prototype; */
		if (currentPrototype.returnType !is bound) {
			local temp = self.tokStart;
			if (self.next() == "*") {
				self.next();
				tok = self.skip(")");
				/* Make sure that nothing has yet to be said about the prototype. */
				if (currentPrototype.returnType is bound) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but return type was set to {!r}"
							.format({ currentName, currentPrototype.returnType }));
				}
				if (currentPrototype.cc is bound &&
				    currentPrototype.cc !== (currentPrototype.hasEllipsis ? DEFAULT_VCC : DEFAULT_CC) &&
				    currentPrototype.cc !== (currentPrototype.hasEllipsis ? DEFAULT_DOS_VCC : DEFAULT_DOS_CC)) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit CC {!r}"
							.format({ currentName, currentPrototype.cc }));
				}
				if (currentPrototype.nothrow != DEFAULT_NOTHROW) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit NOTHROW {!r}"
							.format({ currentName, currentPrototype.nothrow }));
				}
				if (currentPrototype.ellipsisArgumentTypes) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit ellipsis arguments {!r}"
							.format({ currentName, currentPrototype.ellipsisArgumentTypes }));
				}
				if (currentPrototype.declPrefix) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but an explicit [decl_prefix({!r})]"
							.format({ currentName, currentPrototype.declPrefix }));
				}
				if (defaultAttributes !is none && defaultAttributes) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit attributes {!r}"
							.format({ currentName, defaultAttributes }));
				}
				if (functionArgumentNamesOverride !is none) {
					self.errAt(currentNameTokStart,
						"Function {!r} has an automatic prototype, but explicit argument names {!r}"
							.format({ currentName, functionArgumentNamesOverride }));
				}
				currentPrototypes.clear();
				for (local binding: current.bindings) {
					if (binding is Callable)
						continue;
					if (binding.prototypes !== currentPrototypes)
						continue;
					binding.prototypes = none;
				}
				currentPrototype  = none;
				currentPrototypes = none;
				if (tok == "=")
					goto handle_eq_after_prototype;
				if (tok == "%")
					goto handle_percent_after_prototype;
				self.err("Expected '=' or '%' after '{}(*)', but got {!r}"
					.format({ currentName, tok }));
			}
			self.tokEnd = temp;
			tok = self.next();
			assert tok == "(";
		}

		/* Right now, `tok == "("', pointing at the '('-character
		 * before the argument list. So parse that argument  list */
		parseArgumentListAndOptionalTrailingReturnType(
			self, currentPrototype, defaultAttributes,
			functionArgumentNamesOverride, current);
		tok = self.tok;
		/* Default to having a void returnType */
		if (currentPrototype.returnType !is bound)
			currentPrototype.returnType = CType("void");
		if (currentPrototype.cc !is bound)
			currentPrototype.cc = currentPrototype.hasEllipsis ? DEFAULT_VCC : DEFAULT_CC;
		else if (currentPrototype.hasEllipsis) {
			if (currentPrototype.cc === DEFAULT_CC)
				currentPrototype.cc = DEFAULT_VCC;
			else if (currentPrototype.cc === DEFAULT_DOS_CC) {
				currentPrototype.cc = DEFAULT_DOS_VCC;
			}
		}
		if (tok == "[") {
			/* C++ overloads */
			local cxxPrototypes: {FunctionPrototype...} = [];
			for (;;) {
				local numBrackets = 1;
				tok = self.next();
				while (tok == "[") {
					++numBrackets;
					tok = self.next();
				}
				local cxxProto = FunctionPrototype(
					cc:      currentPrototype.cc,
					nothrow: currentPrototype.nothrow);
				parseWholeFunctionPrototype(
					self, cxxProto, defaultAttributes,
					functionArgumentNamesOverride, current);
				cxxPrototypes.append(cxxProto);
				while (numBrackets--)
					tok = self.skip("]");
				if (tok != "[")
					break;
			}
			currentPrototypes.insert(0,
				("defined(__cplusplus) && defined(__CORRECT_ISO_CPP_{}_H_PROTO)"
					.format({ headerName.upper() }), cxxPrototypes));
		}

		/* Generate warnings about missing [[decl_include()]]-s */
		{
			local loadedHeaders: {string...} = HashSet(currentPrototype.declPrefixHeaders);
			local alreadyWarnedHeaders: {string...} = HashSet();
			for (local typ/*: CType*/: currentPrototype.referencedTypes) {
				local normalType = normalizeForTypeHeader(str(typ.beforeName));
				local neededDeclHeader: string | none = typeHeaders.get(normalType);
				if (neededDeclHeader !is none && neededDeclHeader !in loadedHeaders) {
					local impliedBy: none | HashSet with string =
						getHeadersThatImply(neededDeclHeader);
					if ((for (local x: impliedBy) x in loadedHeaders) || ...) {
						/* Implied include */
					} else if (neededDeclHeader in alreadyWarnedHeaders) {
						/* Already warned once */
					} else {
						alreadyWarnedHeaders.insert(neededDeclHeader);
						self.warnAt(currentNameTokStart,
							"Missing '[[decl_include({!r})]]' on {!r} needed for {!r} (in {!r})"
							.format({ neededDeclHeader, currentName, normalType, typ.beforeName }));
					}
				}
			}
			/* TODO: Warn about redundant [[decl_include()]]-s (iow: ones already implied by other includes) */
			/* TODO: Warn about unnecessary includes (iow: ones that could also be served by smaller implications) */
		}

		/* Right now, @tok points at the first token after the prototype
		 * This is going to be one of:
		 *   "{"  - function implementation
		 *   "%" - automatic implementation generator
		 *   "=" - Aliasing definition
		 *   ";"  - No implementation
		 */
		switch (tok) {
			local loaderImpl: none | Callable | LoaderFunctionImplementation;

		case "%": {
handle_percent_after_prototype:
			tok = self.next();
			loaderImpl = none;
			/* Auto-generated implementation in `hdrImpls' and
			 * `libImpls', and possibly `currentPrototype' and
			 * `currentPrototypes' */
			switch (tok) {

			case "{":
				tok = self.next();
				switch (tok) {

				case "chk": {
					currentFeatures.assertAllGeneratedFunctionBody(self, currentName);
					if (currentPrototype is none || currentPrototypes is none)
						self.err("Cannot use %{{chk}} on function {!r} with inherited prototype"
							.format({ currentName }));
					local chkBaseFunctionName: string | none = none;
					local chkExpr: string | none = none;
					tok = self.next();
					if (tok == "(") {
						tok = self.next();
						if (tok == "*") {
							self.next();
						} else if (tok == "%") {
							self.next();
							self.skip("auto");
						} else {
							chkBaseFunctionName = self.parseCStringOrKeyword();
						}
						if (self.tok == ",") {
							tok = self.next();
							if (tok == "*") {
								self.next();
							} else if (tok == "%") {
								self.next();
								self.skip("auto");
							} else {
								chkExpr = self.parseCStringOrAllUntilRParen();
							}
						}
						self.skip(")");
					}
					if (chkBaseFunctionName is none) {
						if (!currentName.endswith("_chk")) {
							self.errAt(currentNameTokStart, "Unable to determine chk base-function for {!r}"
								.format({ currentName }));
						}
						chkBaseFunctionName = currentName.lstrip("_")[:-4];
					}
					if (chkExpr is none) {
						@@Pairs of builtin @(requiredArgumentNames, chkExprTemplate)
						local final CHK_EXPR_VARIANTS: {({string...}, string)...} = {
							({ "dst", "n_bytes", "dst_objsize" },
								"__ssp_chk_dstbuf({base!r}, dst, n_bytes, dst_objsize)"),
							({ "dst", "n_words", "dst_objsize" },
								"__ssp_chk_dstbuf({base!r}, dst, n_words * 2, dst_objsize)"),
							({ "dst", "n_dwords", "dst_objsize" },
								"__ssp_chk_dstbuf({base!r}, dst, n_dwords * 4, dst_objsize)"),
							({ "dst", "n_qwords", "dst_objsize" },
								"__ssp_chk_dstbuf({base!r}, dst, n_qwords * 8, dst_objsize)"),
							({ "dst", "elem_count", "elem_size", "dst_objsize" },
								"__ssp_chk_dstbuf({base!r}, dst, elem_count * elem_size, dst_objsize)"),
						};
						local argsByName = currentPrototype.argsByName;
						for (local requiredArgumentNames, chkExprTemplate: CHK_EXPR_VARIANTS) {
							for (local requiredArgumentName: requiredArgumentNames) {
								if (requiredArgumentName !in argsByName)
									goto next_CHK_EXPR_VARIANTS_template;
							}
							/* Got it! */
							chkExpr = chkExprTemplate.format({
								"base" : chkBaseFunctionName
							});
							goto got_chkExpr;
next_CHK_EXPR_VARIANTS_template:
							;
						}
						self.errAt(currentNameTokStart,
							"Unable to determine automatic check expression for {!r}"
							.format({ currentName }));
					}
got_chkExpr:
					loaderImpl = LoaderFunctionImplementation(
						impl: FunctionImplementation(
							body: "{{\n"
								"\t{};\n"
								"\treturn {}({});\n"
								"}}".format({
									chkExpr,
									chkBaseFunctionName,
									", ".join(currentPrototype.argv[:-1].each.name)
								}),
							name:         currentName,
							implPrefix:   { "#include <ssp/chk.h>" },
							dependencies: { chkBaseFunctionName : chkBaseFunctionName }),
						ppCond: "$has_function({})".format({ chkBaseFunctionName }));
				}	break;

				case "printf": {
					/* Syntax:
					 * >> fprintf(*) %{printf}
					 * >> fprintf(*) %{printf(*)}
					 * >> fprintf(*) %{printf(%auto)}
					 * >> fprintf(*) %{printf(vfprintf)} */
					currentFeatures.assertAllGeneratedFunctionBody(self, currentName);
					local vprintfFunctionName: string | none = none;
					tok = self.next();
					if (tok == "(") {
						tok = self.next();
						if (tok == "*") {
							self.next();
						} else if (tok == "%") {
							self.next();
							self.skip("auto");
						} else {
							vprintfFunctionName = self.parseCStringOrKeyword();
						}
						self.skip(")");
					}
					if (vprintfFunctionName is none) {
						local n = 0;
						while (n < #currentName && currentName[n] == "_")
							++n;
						vprintfFunctionName = "{}v{}".format({
							currentName[:n], currentName[n:] });
					}
					if (currentPrototype is none) {
						local replacedPrototypeCell: Cell with FunctionPrototype = Cell();
						currentPrototype = []{
							if (!replacedPrototypeCell) {
								local origProto: FunctionPrototype;
								try {
									try {
										origProto = findLocalFunctionByName(
											vprintfFunctionName).functionPrototype;
									} catch (...) {
										/* No such local function.
										 * -> Try to search for a normal function */
										origProto = findFunctionByName(vprintfFunctionName).onlyPrototype;
										if (origProto is none) {
											throw Error("Function {!r} has multiple prototypes"
												.format({ vprintfFunctionName }));
										}
									}
								} catch (Error as e) {
									self.errAt(currentNameTokStart, e.message);
								}
								local result = FunctionPrototype(
									/* TODO: Replace 'ATTR_LIBC_PRINTF(N, 0)'
									 *          with 'ATTR_LIBC_PRINTF(N, #ARGV-1)' */
									attributes: origProto.attributes,
									nothrow:    origProto.nothrow,
									cc:         origProto.cc,
									returnType: origProto.returnType,
									argv:       { origProto.argv[:-1]..., Argument("", "", CType("...")) },
									declPrefix: origProto.declPrefix);
								replacedPrototypeCell.value = result;
								return result;
							}
							return replacedPrototypeCell.value;
						};
					}
					if (currentPrototypes is none) {
						currentPrototypes = [] -> {
							("1", {
								currentPrototype is Callable
									? currentPrototype()
									: currentPrototype
							}),
						};
						for (local binding: current.bindings) {
							if (binding is Callable)
								continue;
							if (binding.prototypes is none)
								binding.prototypes = currentPrototypes;
						}
					}
					function getLoaderFunctionImplementation(): LoaderFunctionImplementation {
						local myPrototype: FunctionPrototype = currentPrototype;
						if (myPrototype is Callable)
							myPrototype = myPrototype();
						local bodyPattern: string =
						"{{\n"
						"	{returnType0} result{returnType1};\n"
						"	va_list args;\n"
						"	va_start(args, {lastArg});\n"
						"	result = {vprintf}({positionalArgs}, args);\n"
						"	va_end(args);\n"
						"	return result;\n"
						"}}";
						/* Select different patterns based on prototype features */
						if (myPrototype.isNoreturn) {
							bodyPattern =
							"{{\n"
							"	va_list args;\n"
							"	va_start(args, {lastArg});\n"
							"	{vprintf}({positionalArgs}, args);\n"
							"}}";
						} else if (myPrototype.returnType.isVoid) {
							bodyPattern =
							"{{\n"
							"	va_list args;\n"
							"	va_start(args, {lastArg});\n"
							"	{vprintf}({positionalArgs}, args);\n"
							"	va_end(args);\n"
							"}}";
						}
						return LoaderFunctionImplementation(
							impl: FunctionImplementation(
								body: bodyPattern.format({
									"returnType0"    : myPrototype.returnType.beforeName,
									"returnType1"    : myPrototype.returnType.afterName,
									"lastArg"        : myPrototype.argv[#myPrototype.argv-2].name,
									"positionalArgs" : ", ".join(myPrototype.argv[:-1].each.name),
									"vprintf"        : vprintfFunctionName,
								}),
								name: currentName,
								dependencies: { vprintfFunctionName : vprintfFunctionName }),
							ppCond: "$has_function({})".format({ vprintfFunctionName }));
					}
					loaderImpl = getLoaderFunctionImplementation;
					if (currentPrototype !is Callable)
						loaderImpl = loaderImpl();
				}	break;


				case "generate": {
					/* Syntax:
					 * >> wcslen(*) %{generate(str2wcs)}
					 * >> wcslen(*) %{generate(str2wcs(*))}
					 * >> wcslen(*) %{generate(str2wcs(%auto))}
					 * >> wcslen(*) %{generate(str2wcs(strlen))} */
					currentFeatures.assertAllGeneratedFunctionBody(self, currentName);
					self.next();
					tok = self.skip("(");
					if (!tok.issymbol()) {
						self.err("Expected keyword in %{{generate(...)}}, but got {!r}"
							.format({ tok }));
					}
					local gennetatorName = tok;
					local gen: Generator = generators.get(gennetatorName);
					if (gen is none) {
						self.err("Unknown generator {!r}"
							.format({ gennetatorName }));
					}
					tok = self.next();
					local baseFunctionName = none;
					if (tok == "(") {
						/* Explicit function name, or * or %auto */
						tok = self.next();
						if (tok == "*") {
							self.next();
						} else if (tok == "%") {
							self.next();
							self.skip("auto");
						} else {
							baseFunctionName = self.parseCStringOrKeyword();
						}
						tok = self.skip(")");
					}
					/* Check if we're supposed to automatically deduce
					 * the  name  of  the  underlying   base-function. */
					if (baseFunctionName is none) {
						baseFunctionName = gen.getDefaultBaseFunctionName(currentName);
						if (baseFunctionName is none) {
							self.errAt(currentNameTokStart,
								"Unable to deduce automatic base function name for "
								"generator {!r} from current function name {!r}"
								.format({ gennetatorName, currentName }));
						}
					}
					/* Hint at the generator about the replacement. */
					gen.registerFunctionPairing(currentName, baseFunctionName);
					local baseLocalFunctionCell: Cell with (LocalFunction | none) = Cell();
					function getBaseLocalFunction(): LocalFunction | none {
						if (!baseLocalFunctionCell) {
							local result: LocalFunction | none;
							result = try findLocalFunctionByName(baseFunctionName) catch (...) none;
							baseLocalFunctionCell.value = result;
							return result;
						}
						return baseLocalFunctionCell.value;
					}
					if (currentPrototype is none) {
						local replacedPrototypeCell: Cell with FunctionPrototype = Cell();
						currentPrototype = []{
							if (!replacedPrototypeCell) {
								local result: FunctionPrototype =
									getBaseLocalFunction().functionPrototype;
								if (result is none) {
									/* No such local function.
									 * -> Try to search for a normal function */
									try {
										result = findFunctionByName(baseFunctionName).onlyPrototype;
										if (result is none) {
											throw Error("Function {!r} has multiple prototypes"
												.format({ baseFunctionName }));
										}
									} catch (Error as e) {
										self.errAt(currentNameTokStart, e.message);
									}
								}
								result = gen.replaceFunctionPrototype(result);
								replacedPrototypeCell.value = result;
								return result;
							}
							return replacedPrototypeCell.value;
						};
					}
					if (currentPrototypes is none) {
						currentPrototypes = [] -> {
							("1", {
								currentPrototype is Callable
									? currentPrototype()
									: currentPrototype
							}),
						};
						for (local binding: current.bindings) {
							if (binding is Callable)
								continue;
							if (binding.prototypes is none)
								binding.prototypes = currentPrototypes;
						}
					}
					if (current.documentation is string && !current.documentation) {
						local baseDocumentationTextCell: Cell with string = Cell();
						current.documentation = []{
							if (!baseDocumentationTextCell) {
								local result: Function;
								try {
									result = findFunctionByName(baseFunctionName);
								} catch (Error as e) {
									self.errAt(currentNameTokStart, e.message);
								}
								result = result.documentationString;
								if (gen.replaceDocumentation !is none)
									result = gen.replaceDocumentation(result);
								baseDocumentationTextCell.value = result;
								return result;
							}
							return baseDocumentationTextCell.value;
						};
					}
					/* Define the generator for the converted function implementations */
					local feat_noAutoDependencyScanning = currentFeatures.noAutoDependencyScanning;
					local feat_forcedDependencies       = currentFeatures.forcedDependencies;
					local feat_unforcedDependencies     = currentFeatures.unforcedDependencies;
					local generatedLoaderImplCell: Cell with (LoaderFunctionImplementation | none) = Cell();
					loaderImpl = [](): LoaderFunctionImplementation | none {
						if (!generatedLoaderImplCell) {
							local baseLocalFunction: LocalFunction | none = getBaseLocalFunction();
							local result: LoaderFunctionImplementation | none;
							/* Allow the generator to provide a custom callback for
							 * generating LoaderFunctionImplementation objects  for
							 * some given function.
							 * If the generator  doesn't provide such  a callback,  fall
							 * back to simply converting the base function's body,  and,
							 * if the base function doesn't have a Local variant, simply
							 * don't provide a local implementation ourselves. */
							if (gen.generateLoaderFunctionImplementation !is none) {
								local baseFunction: Function;
								try {
									baseFunction = findFunctionByName(baseFunctionName);
								} catch (Error as e) {
									self.errAt(currentNameTokStart, e.message);
								}
								result = gen.generateLoaderFunctionImplementation(
									baseFunction:             baseFunction,
									newFunctionName:          currentName,
									prototype:                currentPrototype,
									baseLocalFunction:        getBaseLocalFunction(),
									forcedDependencies:       feat_forcedDependencies,
									unforcedDependencies:     feat_unforcedDependencies,
									noAutoDependencyScanning: feat_noAutoDependencyScanning);
							} else {
								if (baseLocalFunction is none)
									result = none;
								else {
									result = LoaderFunctionImplementation(
										ppCond:       gen.replaceText(baseLocalFunction.ppCond),
										ppCondPrefix: gen.replaceTextArray(baseLocalFunction.ppCondPrefix),
										impl:         gen.replaceFunctionImplementation(
											baseLocalFunction.functionImpl, currentName, currentPrototype,
											forcedDependencies:       feat_forcedDependencies,
											unforcedDependencies:     feat_unforcedDependencies,
											noAutoDependencyScanning: feat_noAutoDependencyScanning));
								}
							}
							generatedLoaderImplCell.value = result;
							return result;
						}
						return generatedLoaderImplCell.value;
					};
					self.skip(")");
				}	break;

				case "uchar": {
					local has16 = "16" in currentName;
					local has32 = "32" in currentName;
					if (has16 && !has32)
						tok = "uchar16";
					else if (has32 && !has16)
						tok = "uchar32";
					else {
						self.err("Unable to determine uchar behavior from function name {!r}"
							.format({ currentName }));
					}
				}	/* FALLTHRU */
				case "uchar16":
				case "uchar32": {
					local mode = tok;
					if (currentFeatures.wchar) {
						self.err("uchar function {!r} cannot have the [[wchar]] annotation"
							.format({ currentName }));
					}
					local wcsFunctionName = none;
					tok = self.next();
					if (tok == "(") {
						tok = self.next();
						if (tok == "*") {
							self.next();
						} else if (tok == "%") {
							self.next();
							self.skip("auto");
						} else {
							if (isCString(tok)) {
								wcsFunctionName = tok.decode("c-escape");
							} else if (tok.issymbol()) {
								wcsFunctionName = self.userTok;
							} else {
								self.err("Expected string or keyword in '%{uchar(...)}', but got {!r}"
									.format({ tok }));
							}
							self.next();
						}
						self.skip(")");
					}
					if (wcsFunctionName is none) {
						wcsFunctionName = currentName;
						if (wcsFunctionName.startswith("c16") || wcsFunctionName.startswith("c32"))
							wcsFunctionName = "wcs" + wcsFunctionName[3:];
						else {
							self.errAt(currentNameTokStart,
								"Unable to determine uchar base name for {!r} (consider using '%{uchar(base)}')"
								.format({ wcsFunctionName }));
						}
					}
					currentFeatures.assertAllDefaultAttributesWithoutImplementation(
						self, context.defaultFeatures, currentName);
					currentFeatures.assertAllSymbolicAliasOnly(
						self, context.defaultFeatures, currentName);
					if (currentKosLibraryFunction.exportSymbolNames ||
					    currentDosLibraryFunction.exportSymbolNames) {
						self.errAt(currentNameTokStart,
							"[[export_as(...)]] used with %{{uchar}} function {!r}"
								.format({ currentName }));
					}
					if ((currentKosLibraryFunction !is none && currentKosLibraryFunction.ppCond is bound) ||
					    (currentDosLibraryFunction !is none && currentDosLibraryFunction.ppCond is bound)) {
						self.errAt(currentNameTokStart,
							"[[kernel]] used with %{{uchar}} function {!r}"
								.format({ currentName }));
					}
					if (currentKosLibraryFunction.bindings || currentDosLibraryFunction.bindings) {
						self.errAt(currentNameTokStart,
							"[[crt_intern_alias(...)]] or [alt_variant_of(...)] "
							"used with %{{uchar}} function {!r}"
							.format({ currentName }));
					}
					if (#current.bindings > (currentFeatures.crt_noSelfImport ? 0 : 1))
						self.errAt(currentNameTokStart, "%{{uchar}} function {!r} has custom bindings"
							.format({ currentName }));
					mode = { "uchar16" : WCHAR_REPLACEMENT_CHAR16,
					         "uchar32" : WCHAR_REPLACEMENT_CHAR32 }[mode];
					local feat_inline         = currentFeatures.inline;
					local feat_noExternInline = currentFeatures.noExternInline;
					local feat_noLocal        = currentFeatures.noExternInline;
					local xcLocalFunction: LocalFunction = none;
					@@The wchar function descriptor
					local strWcsFunctionName: string = str(wcsFunctionName);
					local wcharFunction: WcharFunction;
					for (;;) {
						wcharFunction = allWcharFunctionsByName.get(strWcsFunctionName);
						if (wcharFunction !is none)
							break;
						wcharFunction = WcharFunction();
						if (allWcharFunctionsByName.setnew(strWcsFunctionName, wcharFunction))
							break;
					}
					/* Remember  the  used   uchar16/uchar32  system  header   names
					 * This is important for dynamic implementation transformations. */
					if (wcharFunction.wc_header_uchar.xch(mode, current) !is none) {
						self.errAt(currentNameTokStart,
							"Duplicate declaration of %{{uchar{}}} variant of [[wchar]] function {!r}"
							.format({ WCHAR_REPLACEMENT_WIDTH[mode], wcsFunctionName }));
					}
					function getWcharFunction(): Function {
						try {
							return wcharFunction.wc_func;
						} catch (UnboundAttribute) {
							self.errAt(currentNameTokStart,
								"%{{uchar{}}}-function {!r} uses missing [[wchar]] function {!r}"
								.format({ WCHAR_REPLACEMENT_WIDTH[mode], currentName, wcsFunctionName }));
						}
					}
					if (feat_inline is none && !feat_noLocal) {
						xcLocalFunction = LocalFunction(
							name:                     currentName,
							originalSystemHeaderName: headerName);
						defineFunctionInMapping(allLocalFunctionsByName, xcLocalFunction);
						if (!result.localFunctionsByName.setnew(xcLocalFunction.name, xcLocalFunction))
							self.errAt(currentNameTokStart, "Duplicate local function: {!r}"
								.format({ xcLocalFunction.name }));
						xcLocalFunction.prototype = []{
							local usedPrototype: FunctionPrototype = currentPrototype;
							local xc: XcharImplementation = wcharFunction
								.getXCharImplementation(currentName, mode, false);
							if (usedPrototype is none)
								usedPrototype = xc.prototype;
							local xcImpl: none | Callable | LoaderFunctionImplementation = xc.loaderImpl;
							if (xcImpl is Callable)
								xcImpl = xc.loaderImpl = xcImpl();
							xcLocalFunction.impl          = xcImpl.impl;
							xcLocalFunction.ppCond        = xcImpl.ppCond;
							xcLocalFunction.ppCondPrefix  = xcImpl.ppCondPrefix;
							/* Replace default CC with the proper UCHAR-override */
							if (usedPrototype.cc === DEFAULT_CC)
								usedPrototype.cc = WCHAR_REPLACEMENT_CC[mode];
							else if (usedPrototype.cc === DEFAULT_VCC) {
								usedPrototype.cc = WCHAR_REPLACEMENT_VCC[mode];
							}
							return usedPrototype;
						};
						xcLocalFunction.impl = []{
							local xc: XcharImplementation = wcharFunction
								.getXCharImplementation(currentName, mode, false);
							local xcImpl: none | Callable | LoaderFunctionImplementation = xc.loaderImpl;
							if (xcImpl is Callable)
								xcImpl = xc.loaderImpl = xcImpl();
							xcLocalFunction.ppCond       = xcImpl.ppCond;
							xcLocalFunction.ppCondPrefix = xcImpl.ppCondPrefix;
							return xcImpl.impl;
						};
						xcLocalFunction.documentation = []{
							return getWcharFunction().documentation;
						};
					}
					if (current.documentation is string && !current.documentation) {
						/* Automatically inherit the documentation from @wcharFunction */
						current.documentation = [](): string {
							return getWcharFunction().documentationString;
						};
					}
					current.internalName = [] {
						if (wcharFunction.wc_internal_uchar !is bound) {
							/* Associated   [[wchar]]-function   was  marked   as  [[ignore]]
							 * In this case, the uchar-variant doesn't have an internal name! */
							return none;
						}
						return wcharFunction.wc_internal_uchar[mode].name;
					};
					/* Lazily construct function bindings upon first access */
					current.bindings = [](): {FunctionBinding...} {
						@@The referenced [[wchar]]-Function
						local wc: Function = getWcharFunction();
						@@The Xchar-function implementation
						local xc: XcharImplementation = wcharFunction
							.getXCharImplementation(currentName, mode, false);
						/* Enumerate bindings of the underlying [[wchar]] Function to construct
						 * new,  transformed  bindings   for  our  new   the  Xchar   function. */
						local basicBindings = [];
						local mySize = WCHAR_REPLACEMENT_SIZE[mode];
						/* Transform bindings to do something akin to the following:
						 *
						 * wchar-declaration:
						 * >> #ifdef __CRT_HAVE_wcslen
						 * >> __CDECLARE(ATTR_PURE WUNUSED NONNULL((1)),size_t,NOTHROW_NCX,wcslen,(wchar_t const *__restrict string),(string))
						 * >> #else // ...
						 * >> #include <libc/local/wchar/wcslen.h>
						 * >> __NAMESPACE_LOCAL_USING_OR_IMPL(wcslen, FORCELOCAL ATTR_PURE WUNUSED NONNULL((1)) size_t NOTHROW_NCX(LIBCCALL wcslen)(wchar_t const *__restrict string) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))(string); })
						 * >> #endif // !...
						 *
						 * uchar16-declaration:
						 * >> #if defined(__CRT_HAVE_wcslen) && (__SIZEOF_WCHAR_T__ == 2) && defined(__LIBCCALL_IS_LIBDCALL)
						 * >> __CREDIRECT(ATTR_PURE WUNUSED NONNULL((1)),size_t,NOTHROW_NCX,c16slen,(char16_t const *__restrict string),wcslen,(string))
						 * >> #elif defined(__CRT_HAVE_DOS$wcslen)
						 * >> __CREDIRECT_DOS(ATTR_PURE WUNUSED NONNULL((1)),size_t,NOTHROW_NCX,c16slen,(char16_t const *__restrict string),wcslen,(string))
						 * >> #elif (__SIZEOF_WCHAR_T__ == 2)
						 * >> #include <libc/local/wchar/wcslen.h>
						 * >> FORCELOCAL ATTR_PURE WUNUSED NONNULL((1)) size_t NOTHROW_NCX(__LIBDCALL c16slen)(char16_t const *__restrict string) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))((__WCHAR_TYPE__ const *)string); }
						 * >> #else // ...
						 * >> #include <libc/local/parts.uchar.string/c16slen.h>
						 * >> __NAMESPACE_LOCAL_USING_OR_IMPL(c16slen, FORCELOCAL ATTR_PURE WUNUSED NONNULL((1)) size_t NOTHROW_NCX(__LIBDCALL c16slen)(char16_t const *__restrict string) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(c16slen))(string); })
						 * >> #endif // !...
						 *
						 * uchar32-declaration:
						 * >> #if defined(__CRT_HAVE_wcslen) && (__SIZEOF_WCHAR_T__ == 4) && defined(__LIBCCALL_IS_LIBKCALL)
						 * >> __CREDIRECT(ATTR_PURE WUNUSED NONNULL((1)),size_t,NOTHROW_NCX,c32slen,(char32_t const *__restrict string),wcslen,(string))
						 * >> #elif defined(__CRT_HAVE_KOS$wcslen)
						 * >> __CREDIRECT_KOS(ATTR_PURE WUNUSED NONNULL((1)),size_t,NOTHROW_NCX,c32slen,(char32_t const *__restrict string),wcslen,(string))
						 * >> #elif (__SIZEOF_WCHAR_T__ == 4)
						 * >> #include <libc/local/wchar/wcslen.h>
						 * >> FORCELOCAL ATTR_PURE WUNUSED NONNULL((1)) size_t NOTHROW_NCX(__LIBKCALL c32slen)(char32_t const *__restrict string) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(wcslen))((__WCHAR_TYPE__ const *)string); }
						 * >> #else // ...
						 * >> #include <libc/local/parts.uchar.string/c32slen.h>
						 * >> __NAMESPACE_LOCAL_USING_OR_IMPL(c32slen, FORCELOCAL ATTR_PURE WUNUSED NONNULL((1)) size_t NOTHROW_NCX(__LIBKCALL c32slen)(char32_t const *__restrict string) { return (__NAMESPACE_LOCAL_SYM __LIBC_LOCAL_NAME(c32slen))(string); })
						 * >> #endif // !...
						 *
						 */
						for (local wc_bind/*:FunctionBinding*/ : wc.functionBindings) {
							local wc_bind_binding = wc_bind.functionBinding;
							/* Ignore namespace bindings (though we could theoretically bind these as well...) */
							if (wc_bind_binding is NamespaceBinding)
								continue;
							/* At this point, @wc_bind_binding is one of:
							 *  - LocalFunction       : Local function implementation
							 *  - InlineFunction      : Inline implementation
							 *  - string | UserString : Link against some assembly symbol
							 *
							 * The preprocessor conditions required by @wc_bind must
							 * be transformed as follows:
							 *
							 * >> local myCond;
							 * >> local assme = wc_bind.ppCond REQUIRES THAT "__SIZEOF_WCHAR_T__ == SIZEOF(mode))";
							 * >> local assot = wc_bind.ppCond REQUIRES THAT "__SIZEOF_WCHAR_T__ != SIZEOF(mode))";
							 * >> if (assme) {
							 * >>     myCond = wc_bind.ppCond WITHOUT "__SIZEOF_WCHAR_T__ == SIZEOF(mode))";
							 * >> } else if (assot) {
							 * >>     continue; // Ignore this binding
							 * >> } else {
							 * >>     myCond = "(" + wc_bind.ppCond + ") && __SIZEOF_WCHAR_T__ == SIZEOF(mode))";
							 * >> }
							 * >> basicBindings.append(FunctionBinding(myCond, TRANSFORM(wc_bind_binding), ...));
							 */
							local wc_bindCond = str(wc_bind.ppCond);
							local myCond: string;
							local wc_bindCondSimplified;
							if ("__SIZEOF_WCHAR_T__" !in wc_bindCond) {
								/* Binding makes no mention of WCHAR-size -> Append our requirement */
								wc_bindCondSimplified = wc_bindCond;
								myCond = "{} && (__SIZEOF_WCHAR_T__ == {})"
									.format({ wc_bindCond, mySize });
							} else {
								/* Scan the different usage cases of __SIZEOF_WCHAR_T__
								 * XXX: This is imperfect! (See the above comment for
								 *      what  should  ~actually~ be  happening here!) */
								local len = #wc_bindCond;
								local flushStart = 0;
								local i = 0;
								myCond = File.Writer();
								for (;;) {
									i = wc_bindCond.find("__SIZEOF_WCHAR_T__", i);
									if (i < 0)
										break;
									local e = i + 18;
									while (i > flushStart && wc_bindCond.isspace(i - 1))
										--i;
									while (e < len && wc_bindCond.isspace(e))
										++e;
									local how = wc_bindCond.substr(e, e + 2);
									local what;
									if (how in ["==", "!="]) {
										e += 2;
										while (e < len && wc_bindCond.isspace(e))
											++e;
										local whatStart = e;
										while (e < len && wc_bindCond.isalnum(e))
											++e;
										what = wc_bindCond[whatStart:e];
									} else {
										if (i < 2)
											goto wc_bind_continue_scan_bindings;
										how = wc_bindCond.substr(i - 2, i);
										if (how !in ["==", "!="])
											goto wc_bind_continue_scan_bindings;
										i -= 2;
										while (i > flushStart && wc_bindCond.isspace(i - 1))
											--i;
										local whatEnd = i;
										while (i > flushStart && wc_bindCond.isalnum(i - 1))
											--i;
										what = wc_bindCond[i:whatEnd];
									}
									try {
										what = int(what);
									} catch (...) {
										goto wc_bind_continue_scan_bindings;
									}
									if (how == "==") {
										if (what != mySize)
											goto wc_bind_continue_scan_bindings;
									} else {
										if (what == mySize)
											goto wc_bind_continue_scan_bindings;
									}
									for (;;) {
										while (i > flushStart && e < len &&
										       wc_bindCond[i - 1] == "(" &&
										       wc_bindCond[e] == ")") {
											--i;
											++e;
										}
										if (i > flushStart && wc_bindCond.isspace(i - 1)) {
											--i;
											continue;
										}
										if (e < len && wc_bindCond.isspace(e)) {
											++e;
											continue;
										}
										break;
									}
									/* Replace "__SIZEOF_WCHAR_T__ == <mySize>" with "1" */
									myCond << wc_bindCond[flushStart:i] << "1";
									flushStart = e;
									i = e;
								}
								myCond = (myCond << wc_bindCond[flushStart:]).string;
								wc_bindCondSimplified = myCond;
							}
							myCond = myCond.replace("&&1", "").replace("1&&", "");
							local wcBinding = wc_bind.functionBinding;
							local replacedPrototypes = replaceWcharPrototypes(wc_bind.functionPrototypes, mode);
							if (wcBinding is string || wcBinding is UserString) {
								local origCC = getCommonCCFromPrototypes(wc_bind.functionPrototypes);
								if (origCC is none)
									goto wc_bind_continue_scan_bindings;
								local replCC = getCommonCCFromPrototypes(replacedPrototypes);
								if (replCC is none)
									goto wc_bind_continue_scan_bindings;
								origCC = origCC.lstrip("_");
								replCC = replCC.lstrip("_");
								if (origCC != replCC) {
									/* Bind against an external symbol name.
									 * -> Must also assert (in `myCond') that `origCC' and `replCC'
									 *    are  the  same   calling  conventions  at   compile-time. */
									local wcBindingStr = str(wcBinding);
									local cc1 = replCC, cc2 = origCC;
									if (cc1 < cc2) {
										local temp = cc2;
										cc2 = cc1;
										cc1 = temp;
									}
									/* assert cc1 > cc2; */
									{
										local replacedPrototypes2 = replacedPrototypes;
										if (origCC in ["LIBCCALL", "LIBCCALL"]) {
											/* Optimize `replacedPrototypes2' to use `origCC', thus allowing
											 * their eventual declaration to make use of __CDECLARE,  rather
											 * than having to use __COMPILER_REDIRECT... */
											replacedPrototypes2 = [];
											for (local ppCond, protos: replacedPrototypes) {
												local newProtos = [];
												for (local p: protos) {
													assert str(p.cc).lstrip("_") == replCC;
													p = copy p;
													p.cc = origCC;
													newProtos.append(p);
												}
												replacedPrototypes2.append((ppCond, newProtos));
											}
										}
										basicBindings.append(FunctionBinding(
											ppCond:       "{} && defined(__{}_IS_{})".format({ myCond, cc2, cc1 }),
											ppCondPrefix: replaceWcharTextArray(wc_bind.ppCondPrefix, mode),
											prototypes:   replacedPrototypes2,
											binding:      wcBinding));
									}
									/* Try to append a namespace-specific CRT binding */
									if (!wcBindingStr.startswith("DOS$") && !wcBindingStr.startswith("KOS$")) {
										local wcBindingCrtHaveKey = keyCrtHave(wcBindingStr);
										if (wcBindingCrtHaveKey in wc_bindCondSimplified) {
											local ccSpecificPrefix = {
												"LIBKCALL"              : "KOS$",
												"VLIBKCALL"             : "KOS$",
												"__LIBKCALL"            : "KOS$",
												"__VLIBKCALL"           : "KOS$",
												"C32FORMATPRINTER_CC"   : "KOS$",
												"__C32FORMATPRINTER_CC" : "KOS$",
												"LIBDCALL"              : "DOS$",
												"VLIBDCALL"             : "DOS$",
												"__LIBDCALL"            : "DOS$",
												"__VLIBDCALL"           : "DOS$",
												"C16FORMATPRINTER_CC"   : "DOS$",
												"__C16FORMATPRINTER_CC" : "DOS$",
											}.get(replCC);
											if (ccSpecificPrefix is none)
												goto wc_bind_continue_scan_bindings;
											wcBindingStr = ccSpecificPrefix + wcBindingStr;
											basicBindings.append(FunctionBinding(
												ppCond:       wc_bindCondSimplified.replace(wcBindingCrtHaveKey, keyCrtHave(wcBindingStr)),
												ppCondPrefix: replaceWcharTextArray(wc_bind.ppCondPrefix, mode),
												prototypes:   replacedPrototypes,
												binding:      wcBindingStr));
										}
									}
									goto wc_bind_continue_scan_bindings;
								} else {
									basicBindings.append(FunctionBinding(
										ppCond:       myCond,
										ppCondPrefix: replaceWcharTextArray(wc_bind.ppCondPrefix, mode),
										prototypes:   replacedPrototypes,
										binding:      wcBinding));

									/* Try to append a namespace-specific CRT binding */
									local wcBindingStr = str(wcBinding);
									if (!wcBindingStr.startswith("DOS$") && !wcBindingStr.startswith("KOS$")) {
										local wcBindingCrtHaveKey = keyCrtHave(wcBindingStr);
										if (wcBindingCrtHaveKey in wc_bindCondSimplified) {
											local wcharSpecificPrefix = {
												WCHAR_REPLACEMENT_CHAR16 : "DOS$",
												WCHAR_REPLACEMENT_CHAR32 : "KOS$"
											}[mode];
											local wcharSpecificCC = {
												WCHAR_REPLACEMENT_CHAR16 : "LIBDCALL",
												WCHAR_REPLACEMENT_CHAR32 : "LIBKCALL"
											}[mode];
											wcBindingStr = wcharSpecificPrefix + wcBindingStr;
											local cc1 = wcharSpecificCC;
											local cc2 = replCC;
											if (cc1 < cc2) {
												local temp = cc2;
												cc2 = cc1;
												cc1 = temp;
											}
											/* Optimize `replacedPrototypes2' to use `wcharSpecificCC', thus allowing
											* their eventual declaration to make use of __CDECLARE, rather than having
											* to use __COMPILER_REDIRECT...
											*
											* We're allowed to do this because part of the ppCond we're assigning down
											* below is something like "__LIBDCALL_IS_FORMATPRINTER_CC", meaning we're
											* allowed to replace the caller's CC with one of the standard ones. */
											local replacedPrototypes2 = [];
											for (local ppCond, protos: replacedPrototypes) {
												local newProtos = [];
												for (local p: protos) {
													assert str(p.cc).lstrip("_") == replCC;
													p = copy p;
													p.cc = wcharSpecificCC;
													newProtos.append(p);
												}
												replacedPrototypes2.append((ppCond, newProtos));
											}
											basicBindings.append(FunctionBinding(
												ppCond: "{} && defined(__{}_IS_{})".format({
													wc_bindCondSimplified.replace(wcBindingCrtHaveKey, keyCrtHave(wcBindingStr)),
													cc1, cc2 }),
												ppCondPrefix: replaceWcharTextArray(wc_bind.ppCondPrefix, mode),
												prototypes:   replacedPrototypes2,
												binding:      wcBindingStr));
										}
									}
									goto wc_bind_continue_scan_bindings;
								}
							}
							/* Append the transformed binding. */
							basicBindings.append(FunctionBinding(
								ppCond:       myCond,
								ppCondPrefix: replaceWcharTextArray(wc_bind.ppCondPrefix, mode),
								prototypes:   replacedPrototypes,
								binding:      wcBinding));
wc_bind_continue_scan_bindings:
							;
						}
						/* Last cast: Directly implement the Xchar function */
						local xcImpl: none | Callable | LoaderFunctionImplementation = xc.loaderImpl;
						if (xcImpl is Callable)
							xcImpl = xc.loaderImpl = xcImpl();
						if (xcImpl is none) {
							yield basicBindings...;
						} else {
							/* Figure out which prototypes should be used */
							local usedPrototypes: {(string, {FunctionPrototype...})...} = currentPrototypes;
							if (usedPrototypes is none)
								usedPrototypes = xc.prototypes;
							else {
								/* Check if usedPrototypes uses DEFAULT_CC, and if so: Change
								 * that to instead  make use of  `WCHAR_REPLACEMENT_CC[mode]' */
								for (local none, protos: usedPrototypes) {
									for (local p: protos) {
										if (p.cc === DEFAULT_CC)
											p.cc = WCHAR_REPLACEMENT_CC[mode];
										else if (p.cc === DEFAULT_VCC) {
											p.cc = WCHAR_REPLACEMENT_VCC[mode];
										}
									}
								}
							}
							local implBinding = FunctionBinding(
								ppCond:       xcImpl.ppCond,
								ppCondPrefix: xcImpl.ppCondPrefix,
								prototypes:   usedPrototypes);
							if (feat_inline !is none) {
								if (!feat_noExternInline) {
									/* Create extern-inline bindings */
									for (local i = 0; i < #basicBindings;) {
										local existingBinding = basicBindings[i];
										if (existingBinding.binding !is string &&
										    existingBinding.binding !is UserString) {
											++i;
											continue;
										}
										/* Construct, and inject a new binding that  */
										local eiBinding = FunctionBinding(
											ppCondPrefix:   (existingBinding.ppCondPrefix as Sequence) + xcImpl.ppCondPrefix,
											prototypes:     existingBinding.prototypes,
											binding:        InlineFunction(
												mode:                "__EXTERN_INLINE",
												impl:                xcImpl.impl,
												externInlineAsmname: existingBinding.binding));
										if (xcImpl.ppCond == "1") {
											eiBinding.ppCond = existingBinding.ppCond;
											basicBindings[i] = eiBinding;
											++i;
										} else {
											eiBinding.ppCond = "{} && ({})".format({
												existingBinding.ppCond,
												xcImpl.ppCond
											});
											basicBindings.insert(i, eiBinding);
											i += 2;
										}
									}
								}
								implBinding.binding = InlineFunction(
									mode: feat_inline, impl: xcImpl.impl);
							} else if (!feat_noLocal) {
								local usedPrototype: FunctionPrototype = currentPrototype;
								if (usedPrototype is none)
									usedPrototype = xc.prototype;
								/* Replace default CC with the proper UCHAR-override */
								if (usedPrototype.cc === DEFAULT_CC)
									usedPrototype.cc = WCHAR_REPLACEMENT_CC[mode];
								else if (usedPrototype.cc === DEFAULT_VCC) {
									usedPrototype.cc = WCHAR_REPLACEMENT_VCC[mode];
								}
								assert xcLocalFunction !is none;
								xcLocalFunction.prototype     = usedPrototype;
								xcLocalFunction.impl          = xcImpl.impl;
								xcLocalFunction.ppCond        = xcImpl.ppCond;
								xcLocalFunction.ppCondPrefix  = xcImpl.ppCondPrefix;
								xcLocalFunction.documentation = wc.documentation;
								implBinding.binding = xcLocalFunction;
							}
							yield basicBindings...;
							yield implBinding;
						}
					};
					self.skip("}");
					goto done_function;
				}	break;

				default:
					self.err("Unknown code generator function: {!r}"
						.format({ tok }));
				}
				self.skip("}");
				break;

			default:
				self.err("Unexpected token {!r} after '%', following function declaration"
					.format({ tok }));
				break;
			}
			if (loaderImpl is none)
				self.err("Unable to generate automatic implementation");
			if (currentPrototype is none)
				self.err("Prototype cannot be deduced in this context");
			if (currentPrototypes is none)
				currentPrototypes = { ("1", { currentPrototype }) };
			goto with_primaryImplementation;
		}

		case ";": {
			self.next();
			loaderImpl = none;
			goto with_primaryImplementation;
		}	break;

		case "{": {
			{
				local bodyStart = self.tokStart;
				self.skipPair();
				local body = self.getUserString(bodyStart, self.tokEnd);
				self.next();
				loaderImpl = LoaderFunctionImplementation(
					ppCond:       currentFeatures.requires,
					ppCondPrefix: currentFeatures.requiresPrefix,
					impl:         FunctionImplementation(
						body:         body,
						name:         currentName,
						implPrefix:   currentFeatures.implPrefix,
						dependencies: scanForNamesOfDependentFunctions(
							body, currentName, currentPrototype,
							forcedDependencies:       currentFeatures.forcedDependencies,
							unforcedDependencies:     currentFeatures.unforcedDependencies,
							noAutoDependencyScanning: currentFeatures.noAutoDependencyScanning)
					)
				);
			}
with_primaryImplementation:
			if (loaderImpl is none) {
				currentFeatures.assertAllDefaultAttributesWithoutImplementation(
					self, context.defaultFeatures, currentName);
			} else if (currentFeatures.inline !is none || !currentFeatures.noLocal) {
				local existingBindings = current.bindings;
				if (loaderImpl is Callable || existingBindings is Callable) {
					/* Must implement indirectly! */
					local feat_inline = currentFeatures.inline;
					local feat_noExternInline   = currentFeatures.noExternInline;
					local feat_noInlineTruncate = currentFeatures.noInlineTruncate;
					local localFunc: LocalFunction = none;
					if (feat_inline is none) {
						localFunc = LocalFunction(
							name:                     currentName,
							originalSystemHeaderName: headerName,
							prototype:                currentPrototype,
							documentation:            current.documentation);
						defineFunctionInMapping(allLocalFunctionsByName, localFunc);
						if (!result.localFunctionsByName.setnew(localFunc.name, localFunc)) {
							self.errAt(currentNameTokStart, "Duplicate local function: {!r}"
								.format({ localFunc.name }));
						}
					}
					current.bindings = []{
						local usedImpl: LoaderFunctionImplementation = loaderImpl;
						local usedExistingBindings = existingBindings;
						if (usedImpl is Callable)
							usedImpl = usedImpl();
						if (usedExistingBindings is Callable)
							usedExistingBindings = usedExistingBindings();
						if (usedImpl is none) {
							yield usedExistingBindings...;
							return;
						}
						local funImpl: FunctionImplementation = usedImpl.impl;
						local implBinding = FunctionBinding(
							ppCond:       usedImpl.ppCond,
							ppCondPrefix: usedImpl.ppCondPrefix,
							prototypes:   currentPrototypes);
						if (feat_inline !is none) {
							/* Bind the primary implementations as inline */
							local inlImpl = funImpl;
							if (!feat_noInlineTruncate)
								inlImpl = inlImpl.truncateBodyForInline();
							if (!feat_noExternInline) {
								/* Create secondary inline-bindings for all __EXTERN_INLINE */
								for (local existingBinding /*: FunctionBinding*/: usedExistingBindings) {
									if (existingBinding is Callable)
										existingBinding = existingBinding();
									if (type(existingBinding.binding) !in [string, UserString]) {
										yield existingBinding;
										continue;
									}
									/* Construct, and inject a new binding that  */
									yield FunctionBinding(
										ppCond:       implBinding.ppCond == "1"
										              ? existingBinding.ppCond
										              : "{} && ({})".format({ existingBinding.ppCond, implBinding.ppCond }),
										ppCondPrefix: (existingBinding.ppCondPrefix as Sequence) + implBinding.ppCondPrefix,
										prototypes:   existingBinding.prototypes,
										binding:      InlineFunction(
											mode:                "__EXTERN_INLINE",
											impl:                inlImpl,
											externInlineAsmname: existingBinding.binding));
								}
							}
							implBinding.binding = InlineFunction(
								mode: feat_inline, impl: inlImpl);
						} else {
							yield usedExistingBindings...;
							/* Construct a local function object */
							assert localFunc !is none;
							localFunc.ppCond       = usedImpl.ppCond;
							localFunc.ppCondPrefix = usedImpl.ppCondPrefix;
							localFunc.impl         = funImpl;
							implBinding.binding = localFunc;
						}
						yield implBinding;
					};
				} else {
					local funImpl = loaderImpl.impl;
					local implBinding = FunctionBinding(
						ppCond:       loaderImpl.ppCond,
						ppCondPrefix: loaderImpl.ppCondPrefix,
						prototypes:   currentPrototypes);
					if (currentFeatures.inline !is none) {
						/* Bind the primary implementations as inline */
						local inlImpl = funImpl;
						if (!currentFeatures.noInlineTruncate)
							inlImpl = funImpl.truncateBodyForInline();
						if (!currentFeatures.noExternInline) {
							/* Create secondary inline-bindings for all __EXTERN_INLINE */
							local n = #existingBindings;
							for (local i = 0; i < n;) {
								local existingBinding: FunctionBinding = existingBindings[i];
								if (type(existingBinding.binding) !in [string, UserString]) {
									++i;
									continue;
								}
								/* Construct, and inject a new binding that  */
								local eiBinding = FunctionBinding(
									ppCondPrefix: (existingBinding.ppCondPrefix as Sequence) + implBinding.ppCondPrefix,
									prototypes:   existingBinding.prototypes,
									binding:      InlineFunction(
										mode:                "__EXTERN_INLINE",
										impl:                inlImpl,
										externInlineAsmname: existingBinding.binding));
								if (implBinding.ppCond == "1") {
									eiBinding.ppCond = existingBinding.ppCond;
									existingBindings[i] = eiBinding;
									++i;
								} else {
									eiBinding.ppCond = "{} && ({})".format({
										existingBinding.ppCond,
										implBinding.ppCond
									});
									existingBindings.insert(i, eiBinding);
									i += 2;
								}
							}
						}
						implBinding.binding = InlineFunction(
							mode: currentFeatures.inline, impl: inlImpl);
					} else {
						/* Construct a local function object */
						local localFunc = LocalFunction(
							name:                     currentName,
							originalSystemHeaderName: headerName,
							prototype:                currentPrototype,
							ppCond:                   loaderImpl.ppCond,
							ppCondPrefix:             loaderImpl.ppCondPrefix,
							impl:                     funImpl,
							documentation:            current.documentation);
						defineFunctionInMapping(allLocalFunctionsByName, localFunc);
						if (!result.localFunctionsByName.setnew(localFunc.name, localFunc))
							self.errAt(currentNameTokStart, "Duplicate local function: {!r}"
								.format({ localFunc.name }));
						implBinding.binding = localFunc;
					}
					current.bindings.append(implBinding);
				}
			}
			local wcsCurrent;
			if (currentFeatures.wchar) {
again_lookup_wcsCurrent:
				wcsCurrent = allWcharFunctionsByName.get(currentName);
				if (wcsCurrent is none) {
					wcsCurrent = WcharFunction();
					if (!allWcharFunctionsByName.setnew(currentName, wcsCurrent))
						goto again_lookup_wcsCurrent;
				}
				if (wcsCurrent.wc_func is bound)
					self.errAt(currentNameTokStart, "Duplicate [[wchar]] function {!r}"
						.format({ currentName }));
				wcsCurrent.wc_func       = current;
				wcsCurrent.wc_loaderImpl = loaderImpl;
				wcsCurrent.wc_prototype  = currentPrototype;
				wcsCurrent.wc_prototypes = currentPrototypes;
			}
			if (!currentFeatures.crt_noImpl) {
				local crtName = currentFeatures.crt_name;
				if (crtName is none)
					crtName = currentName;
				if (currentKosLibraryFunction is none)
					currentKosLibraryFunction = LibraryFunction();
				currentKosLibraryFunction.originalSystemHeaderName = headerName;
				if (currentKosLibraryFunction.ppCond !is bound)
					currentKosLibraryFunction.ppCond = DEFAULT_LIBFUN_COND;
				if (currentKosLibraryFunction.documentation is string && !currentKosLibraryFunction.documentation)
					currentKosLibraryFunction.documentation = current.documentation;
				local libc_kosName: string; /* e.g. libc_strlen() */
				if (currentKosLibraryFunction.name is bound) {
					libc_kosName = currentKosLibraryFunction.name;
				} else {
					libc_kosName = "libc_" + crtName;
					currentKosLibraryFunction.name = libc_kosName;
				}
				current.internalName = libc_kosName;
				if (!currentFeatures.crt_noSelfExport)
					currentKosLibraryFunction.exportSymbolNames.append(("1", crtName));
				if (!allLibraryFunctionsByName.setnew(libc_kosName, currentKosLibraryFunction))
					self.errAt(currentNameTokStart, "Duplicate library function: {!r}"
						.format({ libc_kosName }));
				local crt_kosSection = currentFeatures.crt_kosSection !is none
					? currentFeatures.crt_kosSection
					: DEFAULT_KOS_SECTION;
				local crt_kosExtraAttr = currentFeatures.getCrtKosExtraAttr();
				if (currentFeatures.wchar || currentFeatures.crt_dosVariant !== false) {
					/* Create 2 new functions that are then exported from libc. */
					if (currentDosLibraryFunction is none)
						currentDosLibraryFunction = LibraryFunction();
					currentDosLibraryFunction.originalSystemHeaderName = headerName;
					if (currentDosLibraryFunction.ppCond !is bound)
						currentDosLibraryFunction.ppCond = DEFAULT_LIBFUN_COND;
					if (currentDosLibraryFunction.documentation is string && !currentDosLibraryFunction.documentation)
						currentDosLibraryFunction.documentation = currentKosLibraryFunction.documentation;
					local libc_dosName: string;
					if (currentDosLibraryFunction.name is bound) {
						libc_dosName = currentDosLibraryFunction.name;
					} else {
						libc_dosName = "libd_" + crtName;
						currentDosLibraryFunction.name = libc_dosName;
					}
					if (!currentFeatures.crt_noSelfExport)
						currentDosLibraryFunction.exportSymbolNames.append(("1", "DOS$" + crtName));
					if (!allLibraryFunctionsByName.setnew(libc_dosName, currentDosLibraryFunction))
						self.errAt(currentNameTokStart, "Duplicate library function: {!r}"
							.format({ libc_dosName }));
					allDosVariantsByName[current.name] = currentDosLibraryFunction;
					local crt_dosSection = currentFeatures.crt_dosSection !is none
						? currentFeatures.crt_dosSection
						: DEFAULT_DOS_SECTION;
					local crt_dosExtraAttr = currentFeatures.getCrtDosExtraAttr();
					if (currentFeatures.wchar) {
						if (currentFeatures.crt_dosVariant !is bool)
							self.errAt(currentNameTokStart, "Custom dos implementation cannot be used with [wchar]");
						wcsCurrent.wc_internal_uchar = { currentDosLibraryFunction, currentKosLibraryFunction };
						if (currentDosLibraryFunction.prototype !is bound) {
							currentDosLibraryFunction.prototype = [] -> wcsCurrent
								.getXCharImplementation(libc_dosName, WCHAR_REPLACEMENT_CHAR16, true)
								.prototype;
						}
						if (currentKosLibraryFunction.prototype !is bound) {
							currentKosLibraryFunction.prototype = [] -> wcsCurrent
								.getXCharImplementation(libc_kosName, WCHAR_REPLACEMENT_CHAR32, true)
								.prototype;
						}
						function createXCharBinding(
								functionName: string | UserString,
								ppCond: string | UserString,
								crtName: string | UserString, mode: int,
								implSection: UserString | string | none,
								extraAttrib: {UserString | string...} | none): Callable {
							return []{
								local xc: XcharImplementation = wcsCurrent
									.getXCharImplementation(functionName, mode, true);
								local xcLoaderImpl: LoaderFunctionImplementation = xc.loaderImpl;
								if (xcLoaderImpl is Callable)
									xcLoaderImpl = xcLoaderImpl();
								return LibraryFunctionBinding(
									ppCond:      ppCond,
									binding:     xcLoaderImpl is none
										? getDefaultLibraryImplementationForPrototype(
											wcsCurrent.wc_prototype, crtName)
										: xcLoaderImpl.impl,
									implSection: implSection,
									extraAttributes: extraAttrib);
							};
						}
						/* Link the Xchar-implementations.
						 * NOTE: This has to happen delayed, so that everything will be
						 *       available  once  the  implementation  gets  generated. */
						currentDosLibraryFunction.bindings.append(createXCharBinding(
							libc_dosName, currentFeatures.crt_dosImplRequires,
							"DOS$" + crtName, WCHAR_REPLACEMENT_CHAR16, crt_dosSection, crt_dosExtraAttr));
						currentKosLibraryFunction.bindings.append(createXCharBinding(
							libc_kosName, currentFeatures.crt_kosImplRequires,
							crtName, WCHAR_REPLACEMENT_CHAR32, crt_kosSection, crt_kosExtraAttr));
					} else {
						if (currentDosLibraryFunction.prototype !is bound) {
							/* Generate the default prototype used by the dos-variant */
							currentDosLibraryFunction.prototype =
								replaceFunctionPrototypeDefaultCCWithDefaultDosCC(currentPrototype);
						}
						if (currentKosLibraryFunction.prototype !is bound)
							currentKosLibraryFunction.prototype = currentPrototype;
						local kosLibImpl: FunctionImplementation | Callable;
						local dosLibImpl: FunctionImplementation | Callable;
						if (loaderImpl !is none) {
							kosLibImpl = loaderImpl is Callable
								? [] -> loaderImpl().impl
								: loaderImpl.impl;
						} else {
							/* Create a default implementation for user-sources */
							local kosProto = currentKosLibraryFunction.prototype;
							kosLibImpl = kosProto is Callable
								? [] -> getDefaultLibraryImplementationForPrototype(kosProto(), crtName)
								: DELAY_cb getDefaultLibraryImplementationForPrototype(kosProto, crtName);
						}
						if (currentFeatures.crt_dosVariant !is bool) {
							/* Custom override for the dos implementation */
							dosLibImpl = currentFeatures.crt_dosVariant.generate(
								currentDosLibraryFunction, currentFeatures);
						} else if (loaderImpl !is none) {
							/* Replace "libc_" prefix in calls to functions with DOS variants with "libd_"
							 * Do this by explicitly replacing dependencies. */
							dosLibImpl = []{
								local usedKosLibImpl: FunctionImplementation = kosLibImpl;
								if (usedKosLibImpl is Callable)
									usedKosLibImpl = usedKosLibImpl();
								return replaceWcharFunctionImplementation(
									usedKosLibImpl, WCHAR_REPLACEMENT_CHAR16,
									libc_dosName, currentPrototype, true);
							};
						} else {
							local dosProto = currentDosLibraryFunction.prototype;
							dosLibImpl = dosProto is Callable
								? [] -> getDefaultLibraryImplementationForPrototype(dosProto(), crtName)
								: DELAY_cb getDefaultLibraryImplementationForPrototype(dosProto, crtName);
						}
						currentDosLibraryFunction.bindings.append(LibraryFunctionBinding(
							ppCond:          currentFeatures.crt_dosImplRequires,
							binding:         dosLibImpl,
							implSection:     crt_dosSection,
							extraAttributes: crt_dosExtraAttr));
						currentKosLibraryFunction.bindings.append(LibraryFunctionBinding(
							ppCond:          currentFeatures.crt_kosImplRequires,
							binding:         kosLibImpl,
							implSection:     crt_kosSection,
							extraAttributes: crt_kosExtraAttr));
					}
					/* Insert the library implementations into the system header order */
					if (currentFeatures.crt_userimpl || loaderImpl is none) {
						result.order_libcUserHeader.extend({ currentDosLibraryFunction, currentKosLibraryFunction });
						result.order_libcUserSource.extend({ currentDosLibraryFunction, currentKosLibraryFunction });
					} else {
						result.order_libcAutoHeader.extend({ currentDosLibraryFunction, currentKosLibraryFunction });
						result.order_libcAutoSource.extend({ currentDosLibraryFunction, currentKosLibraryFunction });
					}
				} else {
					local libImpl: FunctionImplementation | Callable;
					if (currentKosLibraryFunction.prototype !is bound)
						currentKosLibraryFunction.prototype = currentPrototype;
					local kosProto: FunctionPrototype | Callable = currentKosLibraryFunction.prototype;
					if (loaderImpl !is none) {
						libImpl = loaderImpl is Callable
							? [] -> loaderImpl().impl
							: loaderImpl.impl;
					} else {
						/* Create a default implementation for user-sources */
						libImpl = kosProto is Callable
							? [] -> getDefaultLibraryImplementationForPrototype(kosProto(), crtName)
							: DELAY_cb getDefaultLibraryImplementationForPrototype(kosProto, crtName);
					}
					currentKosLibraryFunction.bindings.append(LibraryFunctionBinding(
						ppCond:          currentFeatures.crt_kosImplRequires,
						binding:         libImpl,
						implSection:     crt_kosSection,
						extraAttributes: crt_kosExtraAttr));
					if (!currentFeatures.crt_noDosWrapper) {
						if (kosProto !is Callable) {
							/* XXX: This assumes that LIBDCALL functions that take no
							 *      arguments behave identical to LIBKCALL functions,
							 *      and as such don't require a wrapper. */
							if (!kosProto.argv) {
								/* Deal with [[dos_only_export_alias()]] annotations, which are normally
								 * generated to only link the DOS  symbol name against the libc  variant
								 * when `__LIBCCALL_IS_LIBDCALL' is defined.
								 *
								 * Because we're assuming that zero-argments implies `__LIBCCALL_IS_LIBDCALL',
								 * we have to adjust `currentKosLibraryFunction.exportSymbolNames' in order to
								 * replace `defined(__LIBCCALL_IS_LIBDCALL)' with `1' */
								currentKosLibraryFunction.exportSymbolNames = List(
									for (local cond, name: currentKosLibraryFunction.exportSymbolNames)
										(cond.replace("defined(__LIBCCALL_IS_LIBDCALL)", "1"), name));
								goto continue_without_dosabi_wrapper;
							}
						}
						/* dosabi-generated functions? */
						if (currentDosLibraryFunction is none)
							currentDosLibraryFunction = LibraryFunction();
						currentDosLibraryFunction.originalSystemHeaderName = headerName;
						if (currentDosLibraryFunction.prototype !is bound) {
							/* Generate the default prototype used by the dos-variant */
							currentDosLibraryFunction.prototype =
								replaceFunctionPrototypeDefaultCCWithDefaultDosCC(currentPrototype);
						}
						if (currentDosLibraryFunction.ppCond !is bound) {
							currentDosLibraryFunction.ppCond = currentKosLibraryFunction.ppCond == "1"
								? "!defined(__LIBCCALL_IS_LIBDCALL) && " + DEFAULT_LIBFUN_COND
								: "!defined(__LIBCCALL_IS_LIBDCALL) && ({})"
								.format({ currentKosLibraryFunction.ppCond });
						}
						if (currentDosLibraryFunction.documentation is string && !currentDosLibraryFunction.documentation)
							currentDosLibraryFunction.documentation = currentKosLibraryFunction.documentation;
						local libc_dosName: string;
						if (currentDosLibraryFunction.name is bound) {
							libc_dosName = currentDosLibraryFunction.name;
						} else {
							libc_dosName = "libd_" + crtName;
							currentDosLibraryFunction.name = libc_dosName;
						}
						if (!currentFeatures.crt_noSelfExport)
							currentDosLibraryFunction.exportSymbolNames.append(("1", "DOS$" + crtName));
						if (!allLibraryFunctionsByName.setnew(libc_dosName, currentDosLibraryFunction))
							self.errAt(currentNameTokStart, "Duplicate library function: {!r}"
								.format({ libc_dosName }));
						local crt_dosSection = currentFeatures.crt_dosSection !is none
							? currentFeatures.crt_dosSection
							: DEFAULT_DOS_SECTION;
						local crt_dosExtraAttr = currentFeatures.getCrtDosExtraAttr();
						local dosProto: FunctionPrototype | Callable = currentDosLibraryFunction.prototype;
						if (dosProto is Callable || !dosProto.hasEllipsis || dosProto.ellipsisArgumentTypes !is none) {
							currentDosLibraryFunction.bindings.append(LibraryFunctionBinding(
								ppCond:          currentFeatures.crt_dosImplRequires,
								/* Special trigger to cause a DFUN() wrapper to be generated. */
								binding:         FunctionImplementation(name: libc_kosName),
								implSection:     crt_dosSection,
								extraAttributes: crt_dosExtraAttr));
							result.order_libcAutoHeader.append(currentDosLibraryFunction);
							result.order_libcDosabiSource.append(currentDosLibraryFunction);
						} else {
							local dosLibImpl: FunctionImplementation | Callable;
							/* Generate the wrapper/ */
							if (dosProto is Callable ||
							    (kosProto is Callable && dosProto.hasEllipsis &&
							     dosProto.ellipsisArgumentTypes is none)) {
								dosLibImpl = []{
									local usedDosProto: FunctionPrototype;
									usedDosProto = dosProto is Callable ? dosProto() : dosProto;
									if (!usedDosProto.hasEllipsis || usedDosProto.ellipsisArgumentTypes !is none) {
										return generateDosWrapperFunctionImplementationForPrototype(
											usedDosProto, kosProto is Callable ? kosProto() : kosProto,
											libc_dosName, libc_kosName, current);
									}
									return libImpl;
								};
							} else if (!dosProto.hasEllipsis || dosProto.ellipsisArgumentTypes !is none) {
								dosLibImpl = generateDosWrapperFunctionImplementationForPrototype(
									dosProto, kosProto, libc_dosName, libc_kosName, current);
							} else {
								dosLibImpl = libImpl;
							}
							currentDosLibraryFunction.bindings.append(LibraryFunctionBinding(
								ppCond:          currentFeatures.crt_dosImplRequires,
								binding:         dosLibImpl,
								implSection:     crt_dosSection,
								extraAttributes: crt_dosExtraAttr));
							if ((currentFeatures.crt_userimpl || loaderImpl is none) &&
							    (dosProto !is Callable && dosProto.hasEllipsis && dosProto.ellipsisArgumentTypes is none)) {
								result.order_libcUserHeader.append(currentDosLibraryFunction);
								result.order_libcUserSource.append(currentDosLibraryFunction);
							} else {
								result.order_libcAutoHeader.append(currentDosLibraryFunction);
								result.order_libcAutoSource.append(currentDosLibraryFunction);
							}
						}
					}
continue_without_dosabi_wrapper:
					if (currentFeatures.crt_userimpl || loaderImpl is none) {
						result.order_libcUserHeader.append(currentKosLibraryFunction);
						result.order_libcUserSource.append(currentKosLibraryFunction);
					} else {
						result.order_libcAutoHeader.append(currentKosLibraryFunction);
						result.order_libcAutoSource.append(currentKosLibraryFunction);
					}
				}
				currentDosLibraryFunction = none;
				currentKosLibraryFunction = none;
			}
		}	break;

		case "=": {
handle_eq_after_prototype:
			if (currentFeatures.wchar)
				self.err("[[wchar]] cannot be used with alias bindings");
			currentFeatures.assertAllDefaultAttributesWithoutImplementation(
				self, context.defaultFeatures, currentName);
			currentFeatures.assertAllSymbolicAliasOnly(
				self, context.defaultFeatures, currentName);
			if (#current.bindings > (currentFeatures.crt_noSelfImport ? 0 : 1))
				self.errAt(currentNameTokStart, "Aliasing function {!r} has custom bindings {!r}"
					.format({ currentName, current.bindings }));
			if (currentKosLibraryFunction.exportSymbolNames ||
			    currentDosLibraryFunction.exportSymbolNames) {
				self.errAt(currentNameTokStart,
					"[[export_as(...)]] used with aliasing function {!r}"
						.format({ current. name }));
			}
			if ((currentKosLibraryFunction !is none && currentKosLibraryFunction.ppCond is bound) ||
			    (currentDosLibraryFunction !is none && currentDosLibraryFunction.ppCond is bound)) {
				self.errAt(currentNameTokStart,
					"[[kernel]] used with aliasing function {!r}"
					.format({ currentName }));
			}
			if (currentKosLibraryFunction.bindings || currentDosLibraryFunction.bindings) {
				self.errAt(currentNameTokStart,
					"[[crt_intern_alias(...)]] or [[alt_variant_of(...)]] "
					"used with aliasing function {!r}"
					.format({ currentName }));
			}
			local boundFunctionName = self.next();
			if (isCString(boundFunctionName))
				boundFunctionName = boundFunctionName.decode("c-escape");
			else if (!boundFunctionName.issymbol()) {
				self.err("Expected keyword or string after =, but got {!r}"
					.format({ boundFunctionName }));
			}
			local boundFunctionNameStart = self.tokStart;
			function getBoundFunction(): Function {
				local result: Function;
				try {
					result = findFunctionByName(boundFunctionName);
				} catch (Error as e) {
					self.errAt(boundFunctionNameStart, e.message);
				}
				return result;
			}
			/* Inherit the documentation so-long as none was specified for this function. */
			if (current.documentation is string && !current.documentation)
				current.documentation = [] -> getBoundFunction().documentationString;
			current.internalName = [] -> getBoundFunction().internalFunctionName;
			if (currentPrototypes is none) {
				/* Simple case: Also inherit all prototypes (in which case we can
				 *              also  simply inherit all  bindings from the other
				 *              function) */
				current.bindings = [] -> getBoundFunction().functionBindings;
				/* Need to bind @currentPrototypes properly, as it may
				 * still  be used for @(NamespaceBinding)s down below! */
				if (currentFeatures.namespaces) {
					currentPrototypes = []{
						local bfun: Function = getBoundFunction();
						local result = bfun.onlyPrototypes;
						if (result !is none)
							return result;
						for (local x: bfun.functionBindings) {
							print "BINDING:", x.functionBinding;
							for (local none, protos: x.functionPrototypes) {
								for (local p: protos)
									print("\t", p);
							}
						}
						self.errAt(boundFunctionNameStart,
							"Bound function {!r} has ambiguous prototypes, and thus "
							"cannot be used for namespace imports together with aliasing "
							"function {!r} (consider using %[insert:function(...)] instead)"
							.format({ bfun.name, currentName }));
					};
				}
			} else {
				/* Difficult case: We must inherit bindings, but override them
				 *                 with our  own, custom  list of  prototypes! */
				current.bindings = []{
					local func = getBoundFunction();
					for (local otherBind /*: FunctionBinding*/ : func.functionBindings) {
						if (otherBind.binding is Callable)
							otherBind.binding = otherBind.binding();
						/* Special case: For  all prototypes that  use same-object  DEFAULT_CC
						 * as calling convention, we must still inherit the calling convention
						 * from the bound @otherBind (should there  be a single one common  to
						 * all of them)
						 * This special case is required to properly deal with differing CCs
						 * for  different bindings, as  is the case  when the function being
						 * bound is a [[wchar]]-function.
						 * An example for where this behavior is necessary is `_wspawnv(...) = wspawnv',
						 * which overrides  the  prototype  to  change the  return  type  in  compliance
						 * with DOS,  but  still  needs  to inherit  specific  calling  conventions  for
						 * the different binding cases */
						local usedPrototypes = currentPrototypes;
						local otherCommonCC = getCommonCCFromPrototypes(
							otherBind.functionPrototypes);
						if (otherCommonCC != DEFAULT_CC) {
							usedPrototypes = [];
							for (local ppCond, protos: currentPrototypes) {
								local newProtos = [];
								for (local p: protos) {
									if (p.cc === DEFAULT_CC) {
										p = copy p;
										p.cc = otherCommonCC;
									}
									newProtos.append(p);
								}
								usedPrototypes.append((ppCond, newProtos));
							}
						}
						yield FunctionBinding(
							ppCond:       otherBind.ppCond,
							ppCondPrefix: otherBind.ppCondPrefix,
							prototypes:   usedPrototypes,
							binding:      otherBind.binding);
					}
				};
			}
			self.next();
			self.skip(";");
		}	break;

#if 0 /* TODO? */
		case ">>": {
			/* Optimized function implementation */
			if (self.text.substr(self.tokEnd, self.tokEnd + 2) != ">>")
				goto default_function_implementation_token;
			self.next();
			self.next();
			if (self.tok != "{") {
				self.err("Expected '{' after '>>>>', but got {!r}"
					.format({ self.tok }));
			}
			if (current.documentation !is string || current.documentation)
				self.errAt(currentNameTokStart, "Optimized function {!r} with custom documentation"
					.format({ currentName }));
			@@The names of the arguments taken by the optimized function, or @none to automatically deduce
			local argumentNames = none;
			if (currentPrototype !is none) {
				if (#currentPrototypes != 1 || currentPrototypes[0][0] != "1" ||
				    (#currentPrototypes[0][1] != 1 || currentPrototypes[0][1][0] !== currentPrototype))
					self.errAt(currentNameTokStart, "Optimized function {!r} with c++ overloaded prototypes is not allowed"
						.format({ currentName }));
				if (currentPrototype.attributes)
					self.errAt(currentNameTokStart, "Optimized function {!r} has custom attributes {!r}"
						.format({ currentName, currentPrototype.attributes }));
				if (currentPrototype.nothrow !== DEFAULT_NOTHROW)
					self.errAt(currentNameTokStart, "Optimized function {!r} has a throws-annotation {!r}"
						.format({ currentName, currentPrototype.nothrow }));
				if (currentPrototype.cc is bound &&
				    currentPrototype.cc !== (currentPrototype.hasEllipsis ? DEFAULT_VCC : DEFAULT_CC) &&
				    currentPrototype.cc !== (currentPrototype.hasEllipsis ? DEFAULT_DOS_VCC : DEFAULT_DOS_CC))
					self.errAt(currentNameTokStart, "Optimized function {!r} has a custom calling convention {!r}"
						.format({ currentName, currentPrototype.cc }));
				if (currentPrototype.returnType is bound &&
				    (currentPrototype.returnType.beforeName != "void" ||
				     currentPrototype.returnType.afterName))
					self.errAt(currentNameTokStart, "Optimized function {!r} has a custom return type {!r}"
						.format({ currentName, str(currentPrototype.returnType) }));
				if (currentPrototype.ellipsisArgumentTypes !is none)
					self.errAt(currentNameTokStart, "Optimized function {!r} has ellipsis argument types {!r}"
						.format({ currentName, currentPrototype.ellipsisArgumentTypes }));
				if (currentPrototype.declPrefix)
					self.errAt(currentNameTokStart, "Optimized function {!r} has a custom declaration prefix {!r}"
						.format({ currentName, currentPrototype.declPrefix }));
				/* Optimized functions  are written  as:
				 * >> memcpyq(dst, src, n_qwords) >>>> {
				 * >>     ...
				 * >> }
				 * As such, the regular argument list parser will have set-up what are
				 * actually the argument names as the argument types. */
				argumentNames = [];
				for (local a: currentPrototype.argv) {
					if (a.name || a.protoTypeName || a.ctype.afterName || !a.ctype.beforeName) {
						self.errAt(currentNameTokStart, "Optimized function {!r} has a malformed argument {!r}"
							.format({ currentName, a }));
					}
					argumentNames.append(a.ctype.beforeName);
				}
			}
			local badField;
			if (currentFeatures.std != context.defaultFeatures.std)
				badField = "[no_]std";
			else if (currentFeatures.namespaces != context.defaultFeatures.namespaces)
				badField = "namespace";
			else if (currentFeatures.libc != context.defaultFeatures.libc)
				badField = "[no_]libc";
			else if (currentFeatures.exposedName != context.defaultFeatures.exposedName)
				badField = "[no_]exposed_name";
			else if (currentFeatures.inline != context.defaultFeatures.inline)
				badField = "[no_]inline";
			else if (currentFeatures.noInlineTruncate != context.defaultFeatures.noInlineTruncate)
				badField = "[no_]inline_truncate";
			else if (currentFeatures.noExternInline != context.defaultFeatures.noExternInline)
				badField = "[no_]extern_inline";
			else if (currentFeatures.noLocal != context.defaultFeatures.noLocal)
				badField = "[no_]local";
			else if (currentFeatures.macroBinding != context.defaultFeatures.macroBinding)
				badField = "[no_]macros";
			else if (currentFeatures.guard != context.defaultFeatures.guard)
				badField = "[no_]guard";
			else if (currentFeatures.exposedName != context.defaultFeatures.exposedName)
				badField = "[default_]exposed_name";
			else if (currentFeatures.wchar != context.defaultFeatures.wchar)
				badField = "[no_]wchar";
			else if (currentFeatures.crt_userimpl != context.defaultFeatures.crt_userimpl)
				badField = "[no_]userimpl";
			else {
				badField = currentFeatures.assertSymbolicAliasOnly(context.defaultFeatures);
			}
			if (badField !is none) {
				self.errAt(currentNameTokStart, "Annotation {!r} cannot be used on optimized function {!r}"
					.format({ badField, currentName }));
			}
			local optimizedImplStart = self.tokStart;
			self.skipPair();
			local body: UserString = self.getUserString(optimizedImplStart, self.tokEnd);
			@@The actual optimized function as a @LocalFunction object
			local optiFunction: LocalFunction = LocalFunction(
				name:                     currentName,
				originalSystemHeaderName: headerName,
				prototype:                currentPrototype, /* TODO: Inherit */
				ppCond:                   currentFeatures.requires,
				ppCondPrefix:             currentFeatures.requiresPrefix,
				impl: FunctionImplementation(
					body:         body,
					name:         currentName,
					implPrefix:   currentFeatures.implPrefix,
					dependencies: scanForNamesOfDependentFunctions(
						body, "", currentPrototype,
						forcedDependencies:       currentFeatures.forcedDependencies,
						unforcedDependencies:     currentFeatures.unforcedDependencies,
						noAutoDependencyScanning: currentFeatures.noAutoDependencyScanning)
					),
				documentation: current.documentation /* TODO: Inherit */
				);
			self.next();
			goto continue_main_loop;
		}	break;
#endif

		default:
//default_function_implementation_token:
			self.err("Unexpected token {!r} when function implementation (as '%', '=', '{{' or ';') was expected"
				.format({ tok }));
		}
done_function:
		if (currentKosLibraryFunction !is none || currentDosLibraryFunction !is none) {
			/* Assert that no annotations added  any special features to the  library
			 * function in situations where the library function isn't actually being
			 * used */
			if (currentKosLibraryFunction.exportSymbolNames || currentDosLibraryFunction.exportSymbolNames)
				self.errAt(currentNameTokStart, "[export_as(...)] used, but function's isn't actually being exported");
			/* Don't assert this: `alt_variant_of()' would still be allowed here! */
//			if (currentKosLibraryFunction.bindings || currentDosLibraryFunction.bindings)
//				self.errAt(currentNameTokStart, "[crt_intern_alias(...)] or [alt_variant_of(...)] used, but function's isn't actually being exported");
		}

		/* Register the function, and insert it into listings where it should show up */
		defineFunctionInMapping(result.functionsByName, current);
		defineFunctionInMapping(allFunctionsByName, current);
		if (currentFeatures.namespaces) {
			local exposedName = currentFeatures.exposedName;
			if (exposedName is none)
				exposedName = currentName;
			local dflGuard = false;
			local dflNamespace = GLOBAL_NAMESPACE;
			if (currentFeatures.std)
				dflNamespace = NAMESPACES["std"];
			/* Add namespace import bindings for all defined namespaces. */
			local moreBindings = [];
			for (local ns: currentFeatures.namespaces) {
				if (ns !is Namespace)
					ns = getNamespaceByName(ns);
				if (!currentFeatures.guard) {
					if (ns === GLOBAL_NAMESPACE || ns === dflNamespace)
						continue;
				}
				local nsGuard = currentFeatures.guardNames.get(ns.name);
				if (nsGuard is none)
					nsGuard = ns.keyDefaultGuard(exposedName);
				if (ns === dflNamespace)
					dflGuard = nsGuard;
				moreBindings.append(FunctionBinding(
					ppCond:     "defined({})".format({ nsGuard }),
					prototypes: currentPrototypes,
					binding:    NamespaceBinding(
						namespace:  ns,
						importName: exposedName,
						prototype:  currentPrototype),
				));
			}
			if (moreBindings) {
				local oldBindings = current.bindings;
				if (oldBindings is Callable) {
					current.bindings = []{
						yield moreBindings...;
						yield oldBindings()...;
					};
				} else {
					if (oldBindings !is List) {
						oldBindings = List(oldBindings);
						current.bindings = oldBindings;
					}
					oldBindings.insertall(0, moreBindings);
				}
			}
			if (dflGuard === false && currentFeatures.guard)
				dflGuard = dflNamespace.keyDefaultGuard(exposedName);
			local func = current;
			if (currentFeatures.decl != DEFAULT_DECL || exposedName != func.name ||
			    dflGuard !== false || currentFeatures.macroBinding) {
				/* Need a custom @ExposedFunction */
				func = ExposedFunction(
					func:                func,
					decl:                currentFeatures.decl,
					exposedName:         exposedName,
					guardName:           dflGuard,
					preferBindingMacros: currentFeatures.macroBinding);
			}
			if (currentFeatures.std) {
				if (context.result_order_headerStd is none) {
					self.errAt(currentNameTokStart,
						"Function {!r} was marked as `[[std]]', but "
						"'%[insert:std]' hasn't been encountered, yet"
						.format({ currentName }));
				}
				context.result_order_headerStd.append(func);
				/* Insert a std-using directive at the current location */
				if (!context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_START);
					context.result_order_header_in_CXX_SYSTEM_HEADER = true;
				}
				local gblGuard = false;
				local importCondition;
				local nsStd = NAMESPACES["std"];
				if (currentFeatures.guard) {
					local stdGuard = currentFeatures.guardNames.get("std");
					gblGuard = currentFeatures.guardNames.get("");
					if (stdGuard is none)
						stdGuard = nsStd.keyDefaultGuard(exposedName);
					if (gblGuard is none)
						gblGuard = GLOBAL_NAMESPACE.keyDefaultGuard(exposedName);
					importCondition = "defined({})".format({ stdGuard });
				} else {
					importCondition = "$has_function({})".format({ currentName });
				}
				local importFunction = Function(
					name:                     exposedName,
					originalSystemHeaderName: headerName,
					bindings: {
						FunctionBinding(
							ppCond:     importCondition,
							prototypes: currentPrototypes,
							/* Bind against the std:: namespace export */
							binding: NamespaceBinding(
								namespace:  nsStd,
								importName: exposedName),
						),
					});
				if (gblGuard !== false) {
					importFunction = ExposedFunction(
						func:        importFunction,
						decl:        currentFeatures.decl, /* This one should go unused... */
						exposedName: exposedName,
						guardName:   gblGuard);
				}
				result.order_header.append(importFunction);
				if (context.result_ccompatHeaderName !is none)
					context.result_order_headerCCompat.append(importFunction);
			} else {
				if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
					result.order_header.append(CXX_SYSTEM_HEADER_END);
					context.result_order_header_in_CXX_SYSTEM_HEADER = false;
				}
				result.order_header.append(func);
			}
		}
		if (currentFeatures.libc) {
			result.order_libcHeader.append(current);
			result.order_libcCoreHeader.append(current);
		}
//continue_main_loop:
		tok = self.tok;
	}
	if (!isPrimaryDefinitionsFile)
		return result;
	/* Finalize @result.order_header */
	if (context.result_order_header_in_CXX_SYSTEM_HEADER) {
		result.order_header.append(CXX_SYSTEM_HEADER_END);
		context.result_order_header_in_CXX_SYSTEM_HEADER = false;
	}
	if (context.result_headerGuardName is none) {
		context.result_headerGuardName = "_{}_H".format({
			headerName
				.replace(".", "_")
				.replace("-", "_")
				.upper()
		});
	}
	if (context.result_ccompatHeaderName !is none) {
		if (context.result_order_headerCCompat is none) {
			local errobj = context.result_ccompatHeaderName;
			if (errobj !is UserString)
				errobj = self;
			errobj.err("'%[define_ccompat_header({!r})]' used without '%[insert:std]'"
				.format({ context.result_ccompatHeaderName }));
		}
		local guard_CXX_STDONLY = "_CXX_STDONLY_{}"
			.format({ str(context.result_ccompatHeaderName).upper() });
		result.order_header.insert(0,
			"#ifndef {0}\n"
			"#define {0} 1\n"
			"\n"
			"#ifdef {1}\n"
			"#ifdef __CXX_SYSTEM_HEADER\n"
			"#undef {0} /* Allow the C-header to be re-included to import all std::-symbols into the global namespace. */\n"
			"#else /* __CXX_SYSTEM_HEADER */\n"
			"/* Import all symbols into the global namespace when re-including \"{2}.h\" after \"{3}\" */\n"
			.format({
				context.result_headerGuardName, guard_CXX_STDONLY,
				headerName.replace(".", "/"),
				context.result_ccompatHeaderName
			}));
		result.order_header.insert(1, [](fp: CWriter, escapeMode: int)
			-> fp.clearGlobalPrintedPrefixes());
		result.order_header.insert(1,
			"#undef {0}\n"
			"#endif /* !__CXX_SYSTEM_HEADER */\n"
			"#else /* {0} */\n"
			.format({ guard_CXX_STDONLY }));
		result.order_header.insertall(1, context.result_order_headerCCompat);
		result.order_header.append(
			"#ifdef __CXX_SYSTEM_HEADER\n"
			"#define {1}\n"
			"#undef {0}\n"
			"#endif /* __CXX_SYSTEM_HEADER */\n"
			"#endif /* !{1} */\n"
			"#endif /* !{0} */\n"
			.format({
				context.result_headerGuardName,
				guard_CXX_STDONLY,
			}));
	} else {
		result.order_header.insert(0,
			"#ifndef {0}\n"
			"#define {0} 1\n"
			"\n".format({ context.result_headerGuardName }));
		result.order_header.append(
			"#endif /* !{} */\n"
			.format({ context.result_headerGuardName }));
	}
	if (context.result_order_headerCPrefix !is none)
		result.order_header.insertall(0, context.result_order_headerCPrefix);
	return result;
}
