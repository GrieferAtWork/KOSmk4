/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .parser;
import * from .globals;
import * from .writer;
import * from .namespace;

#define Function          Object /* Function from .cheaders */
#define LocalFunction     Object /* LocalFunction from .cheaders */
#define SystemHeader      Object /* SystemHeader from .cheaders */
#define FunctionPrototype Object /* FunctionPrototype from .cheaders */

global escapeText;

@@Replace:
@@   - @"$size_t" -> "$size_t"
@@   - @"size_t"  -> "size_t"
@@   - @"foo"     -> "foo"
global final ESCAPE_MODE_KEEP = -1;

@@Replace:
@@   - @"$size_t" -> "size_t"
@@   - @"size_t"  -> "size_t"
@@   - @"foo"     -> "foo"
global final ESCAPE_MODE_NONE = 0;

@@Replace:
@@   - @"$size_t" -> "__SIZE_TYPE__"
@@   - @"size_t"  -> "size_t"
@@   - @"foo"     -> "__foo"
global final ESCAPE_MODE_PART = 1;

@@Replace:
@@   - @"$size_t" -> "__SIZE_TYPE__"
@@   - @"size_t"  -> "__SIZE_TYPE__"
@@   - @"foo"     -> "__foo"
global final ESCAPE_MODE_FULL = 2;

global cLanguageKeywords: {string...} = HashSet({
	"if", "else", "while", "for", "return", "do", "switch",
	"case", "default", "goto", "continue", "break", "sizeof",
	"alignof", "struct", "union", "extern", "void", "char",
	"int", "short", "long", "signed", "unsigned", "const",
	"__const", "__const__", "volatile", "__volatile", "__volatile__",
	"static", "_Pragma", "typedef", "float", "double", "restrict",
	"__restrict", "attribute", "__attribute", "__attribute__",
	"_declspec", "__declspec", "char16_t", "char32_t", "wchar_t",
	"inline", "__inline", "__inline__", "__extension__",

	/* Preprocessor-only keywords */
	"defined", "ifdef", "ifndef", "elif", "endif", "define",
	"include", "undef", "pragma",
});

global cLanguageTwoWordTypenameKeywords: {string...} = HashSet({
	"struct", "union", "class", "enum"
});

@@Special replacements for certain keywords during escaping.
@@By   default,   all  keywords   are  escaped   by  either:
@@  - Inserting 2 leading "__"
@@  - Inserting 1 leading "_", and having the following character be upper-case
@@Keywords that already appear escaped are not re-escaped
global keywordEscapes: {string: string} = Dict({
	"size_t" : "__SIZE_TYPE__",
	"ssize_t" : "__SSIZE_TYPE__",
	"intptr_t" : "__INTPTR_TYPE__",
	"longptr_t" : "__LONGPTR_TYPE__",
	"uintptr_t" : "__UINTPTR_TYPE__",
	"ulongptr_t" : "__ULONGPTR_TYPE__",
	"ptrdiff_t" : "__PTRDIFF_TYPE__",
	"intmax_t" : "__INTMAX_TYPE__",
	"uintmax_t" : "__UINTMAX_TYPE__",
	"byte_t" : "__BYTE_TYPE__",
	"int8_t" : "__INT8_TYPE__",
	"int16_t" : "__INT16_TYPE__",
	"int32_t" : "__INT32_TYPE__",
	"int64_t" : "__INT64_TYPE__",
	"uint8_t" : "__UINT8_TYPE__",
	"uint16_t" : "__UINT16_TYPE__",
	"uint32_t" : "__UINT32_TYPE__",
	"uint64_t" : "__UINT64_TYPE__",
	"u_int8_t" : "__UINT8_TYPE__",
	"u_int16_t" : "__UINT16_TYPE__",
	"u_int32_t" : "__UINT32_TYPE__",
	"u_int64_t" : "__UINT64_TYPE__",
	"wchar_t" : "__WCHAR_TYPE__",
	"char16_t" : "__CHAR16_TYPE__",
	"char32_t" : "__CHAR32_TYPE__",
	"wint_t" : "__WINT_TYPE__",
	"wint16_t" : "__WINT16_TYPE__",
	"wint32_t" : "__WINT32_TYPE__",
	"int_least8_t" : "__INT_LEAST8_TYPE__",
	"int_least16_t" : "__INT_LEAST16_TYPE__",
	"int_least32_t" : "__INT_LEAST32_TYPE__",
	"int_least64_t" : "__INT_LEAST64_TYPE__",
	"uint_least8_t" : "__UINT_LEAST8_TYPE__",
	"uint_least16_t" : "__UINT_LEAST16_TYPE__",
	"uint_least32_t" : "__UINT_LEAST32_TYPE__",
	"uint_least64_t" : "__UINT_LEAST64_TYPE__",
	"int_fast8_t" : "__INT_FAST8_TYPE__",
	"int_fast16_t" : "__INT_FAST16_TYPE__",
	"int_fast32_t" : "__INT_FAST32_TYPE__",
	"int_fast64_t" : "__INT_FAST64_TYPE__",
	"uint_fast8_t" : "__UINT_FAST8_TYPE__",
	"uint_fast16_t" : "__UINT_FAST16_TYPE__",
	"uint_fast32_t" : "__UINT_FAST32_TYPE__",
	"uint_fast64_t" : "__UINT_FAST64_TYPE__",
	"INTMAX_MIN" : "__INTMAX_MIN__",
	"INTMAX_MAX" : "__INTMAX_MAX__",
	"UINTMAX_MAX" : "__UINTMAX_MAX__",
	"INT8_MIN" : "__INT8_MIN__",
	"INT16_MIN" : "__INT16_MIN__",
	"INT32_MIN" : "__INT32_MIN__",
	"INT8_MAX" : "__INT8_MAX__",
	"INT16_MAX" : "__INT16_MAX__",
	"INT32_MAX" : "__INT32_MAX__",
	"UINT8_MAX" : "__UINT8_MAX__",
	"UINT16_MAX" : "__UINT16_MAX__",
	"UINT32_MAX" : "__UINT32_MAX__",
	"INT64_MIN" : "__INT64_MIN__",
	"INT64_MAX" : "__INT64_MAX__",
	"UINT64_MAX" : "__UINT64_MAX__",
	"INT_LEAST8_MIN" : "__INT_LEAST8_MIN__",
	"INT_LEAST16_MIN" : "__INT_LEAST16_MIN__",
	"INT_LEAST32_MIN" : "__INT_LEAST32_MIN__",
	"INT_LEAST8_MAX" : "__INT_LEAST8_MAX__",
	"INT_LEAST16_MAX" : "__INT_LEAST16_MAX__",
	"INT_LEAST32_MAX" : "__INT_LEAST32_MAX__",
	"UINT_LEAST8_MAX" : "__UINT_LEAST8_MAX__",
	"UINT_LEAST16_MAX" : "__UINT_LEAST16_MAX__",
	"UINT_LEAST32_MAX" : "__UINT_LEAST32_MAX__",
	"INT_LEAST64_MIN" : "__INT_LEAST64_MIN__",
	"INT_LEAST64_MAX" : "__INT_LEAST64_MAX__",
	"UINT_LEAST64_MAX" : "__UINT_LEAST64_MAX__",
	"INT_FAST8_MIN" : "__INT_FAST8_MIN__",
	"INT_FAST16_MIN" : "__INT_FAST16_MIN__",
	"INT_FAST32_MIN" : "__INT_FAST32_MIN__",
	"INT_FAST8_MAX" : "__INT_FAST8_MAX__",
	"INT_FAST16_MAX" : "__INT_FAST16_MAX__",
	"INT_FAST32_MAX" : "__INT_FAST32_MAX__",
	"UINT_FAST8_MAX" : "__UINT_FAST8_MAX__",
	"UINT_FAST16_MAX" : "__UINT_FAST16_MAX__",
	"UINT_FAST32_MAX" : "__UINT_FAST32_MAX__",
	"INT_FAST64_MIN" : "__INT_FAST64_MIN__",
	"INT_FAST64_MAX" : "__INT_FAST64_MAX__",
	"UINT_FAST64_MAX" : "__UINT_FAST64_MAX__",
	"INTPTR_MIN" : "__INTPTR_MIN__",
	"INTPTR_MAX" : "__INTPTR_MAX__",
	"UINTPTR_MAX" : "__UINTPTR_MAX__",
	"SIZE_MAX" : "__SIZE_MAX__",
	"PTRDIFF_MIN" : "__PTRDIFF_MIN__",
	"PTRDIFF_MAX" : "__PTRDIFF_MAX__",
	"SIG_ATOMIC_MIN" : "__SIG_ATOMIC_MIN__",
	"SIG_ATOMIC_MAX" : "__SIG_ATOMIC_MAX__",
	"WCHAR_MIN" : "__WCHAR_MIN__",
	"WCHAR_MAX" : "__WCHAR_MAX__",
	"WINT_MIN" : "__WINT_MIN__",
	"WINT_MAX" : "__WINT_MAX__",
	"CHAR_BIT" : "__CHAR_BIT__",
	"SCHAR_MIN" : "__SCHAR_MIN__",
	"SCHAR_MAX" : "__SCHAR_MAX__",
	"UCHAR_MAX" : "__UCHAR_MAX__",
	"CHAR_MIN" : "__CHAR_MIN__",
	"CHAR_MAX" : "__CHAR_MAX__",
	"SHRT_MIN" : "__SHRT_MIN__",
	"SHRT_MAX" : "__SHRT_MAX__",
	"USHRT_MAX" : "__USHRT_MAX__",
	"INT_MIN" : "__INT_MIN__",
	"INT_MAX" : "__INT_MAX__",
	"UINT_MAX" : "__UINT_MAX__",
	"LONG_MIN" : "__LONG_MIN__",
	"LONG_MAX" : "__LONG_MAX__",
	"ULONG_MAX" : "__ULONG_MAX__",
	"LLONG_MIN" : "__LONG_LONG_MIN__",
	"LLONG_MAX" : "__LONG_LONG_MAX__",
	"ULLONG_MAX" : "__ULONG_LONG_MAX__",
	"s8" : "__INT8_TYPE__",
	"s16" : "__INT16_TYPE__",
	"s32" : "__INT32_TYPE__",
	"s64" : "__INT64_TYPE__",
	"u8" : "__UINT8_TYPE__",
	"u16" : "__UINT16_TYPE__",
	"u32" : "__UINT32_TYPE__",
	"u64" : "__UINT64_TYPE__",
	"va_list" : "__builtin_va_list",
	"uchar" : "unsigned char",
	"u_char" : "unsigned char",
	"__u_char" : "unsigned char",
	"ushort" : "unsigned short",
	"u_short" : "unsigned short",
	"__u_short" : "unsigned short",
	"uint" : "unsigned int",
	"u_int" : "unsigned int",
	"__u_int" : "unsigned int",
	"ulong" : "unsigned long",
	"u_long" : "unsigned long",
	"__u_long" : "unsigned long",
	"quad_t" : "__INT64_TYPE__",
	"__quad_t" : "__INT64_TYPE__",
	"u_quad_t" : "__UINT64_TYPE__",
	"__u_quad_t" : "__UINT64_TYPE__",
	"fsid_t" : "__fsid_t",
	"daddr_t" : "__daddr_t",
	"caddr_t" : "__caddr_t",
	"nlink_t" : "__nlink_t",
	"uid_t" : "__uid_t",
	"pid_t" : "__pid_t",
	"id_t" : "__id_t",
	"clock_t" : "__clock_t",
	"key_t" : "__key_t",
	"clockid_t" : "__clockid_t",
	"timer_t" : "__timer_t",
	"useconds_t" : "__useconds_t",
	"suseconds_t" : "__suseconds_t",
});

@@Special replacements for keywords in @ESCAPE_MODE_PART contexts
global partialKeywordEscapes: {string: string} = Dict({
	"va_start" : "__builtin_va_start",
	"va_copy" : "__builtin_va_copy",
	"va_end" : "__builtin_va_end",
	"va_arg" : "__builtin_va_arg",
	"offsetof" : "__builtin_offsetof",
	"offsetafter" : "__COMPILER_OFFSETAFTER",
	"container_of" : "__COMPILER_CONTAINER_OF",
	"bool" : "__BOOL",
	"true" : "1",
	"false" : "0",
	"NULL" : "__NULLPTR",
	"ATTR_NOINLINE" : "__ATTR_NOINLINE",
	"ATTR_NORETURN" : "__ATTR_NORETURN",
	"ATTR_FASTCALL" : "__ATTR_FASTCALL",
	"ATTR_STDCALL" : "__ATTR_STDCALL",
	"ATTR_CDECL" : "__ATTR_CDECL",
	"ATTR_SYSVABI" : "__ATTR_SYSVABI",
	"ATTR_MSABI" : "__ATTR_MSABI",
	"ATTR_PURE" : "__ATTR_PURE",
	"ATTR_PURE_T" : "__ATTR_PURE_T",
	"ATTR_CONST" : "__ATTR_CONST",
	"ATTR_CONST_T" : "__ATTR_CONST_T",
	"ATTR_LEAF" : "__ATTR_LEAF",
	"ATTR_LEAF_P" : "__ATTR_LEAF_T",
	"ATTR_FLATTEN" : "__ATTR_FLATTEN",
	"ATTR_MALLOC" : "__ATTR_MALLOC",
	"ATTR_HOT" : "__ATTR_HOT",
	"ATTR_COLD" : "__ATTR_COLD",
	"ATTR_WEAK" : "__ATTR_WEAK",
	"ATTR_ALLOC_SIZE" : "__ATTR_ALLOC_SIZE",
	"ATTR_ASSUME_ALIGNED" : "__ATTR_ASSUME_ALIGNED",
	"ATTR_ALLOC_ALIGN" : "__ATTR_ALLOC_ALIGN",
	"ATTR_NOTHROW" : "__ATTR_NOTHROW",
	"ATTR_DLLIMPORT" : "__ATTR_DLLIMPORT",
	"ATTR_DLLEXPORT" : "__ATTR_DLLEXPORT",
	"ATTR_NOCLONE" : "__ATTR_NOCLONE",
	"ATTR_USED" : "__ATTR_USED",
	"ATTR_UNUSED" : "__ATTR_UNUSED",
	"ATTR_SENTINEL" : "__ATTR_SENTINEL",
	"ATTR_SENTINEL_O" : "__ATTR_SENTINEL_O",
	"ATTR_THREAD" : "__ATTR_THREAD",
	"ATTR_DEPRECATED" : "__ATTR_DEPRECATED",
	"ATTR_DEPRECATED_" : "__ATTR_DEPRECATED_",
	"ATTR_WARNING" : "__ATTR_WARNING",
	"ATTR_ERROR" : "__ATTR_ERROR",
	"ATTR_SECTION" : "__ATTR_SECTION",
	"ATTR_RETNONNULL" : "__ATTR_RETNONNULL",
	"ATTR_ALIGNED" : "__ATTR_ALIGNED",
	"ATTR_ALIAS" : "__ATTR_ALIAS",
	"ATTR_INLINE" : "__ATTR_INLINE",
	"ATTR_FORCEINLINE" : "__ATTR_FORCEINLINE",
	"ATTR_FALLTHROUGH" : "__ATTR_FALLTHROUGH",
	"ATTR_PACKED" : "__ATTR_PACKED",
	"ATTR_RETURNS_TWICE" : "__ATTR_RETURNS_TWICE",
	"ATTR_EXTERNALLY_VISIBLE" : "__ATTR_EXTERNALLY_VISIBLE",
	"lengthof" : "__COMPILER_LENOF",
	"COMPILER_LENOF" : "__COMPILER_LENOF",
	"COMPILER_ENDOF" : "__COMPILER_ENDOF",
	"COMPILER_STRLEN" : "__COMPILER_STRLEN",
	"COMPILER_STREND" : "__COMPILER_STREND",
	"COMPILER_UNUSED" : "__COMPILER_UNUSED",
	"COMPILER_UNIPOINTER" : "__COMPILER_UNIPOINTER",
	"COMPILER_ALIGNOF" : "__COMPILER_ALIGNOF",
	"COMPILER_OFFSETOF" : "__COMPILER_OFFSETOF",
	"COMPILER_OFFSETAFTER" : "__COMPILER_OFFSETAFTER",
	"COMPILER_CONTAINER_OF" : "__COMPILER_CONTAINER_OF",
	"COMPILER_BARRIER" : "__COMPILER_BARRIER",
	"COMPILER_READ_BARRIER" : "__COMPILER_READ_BARRIER",
	"COMPILER_WRITE_BARRIER" : "__COMPILER_WRITE_BARRIER",
	"COMPILER_IGNORE_UNINITIALIZED" : "__COMPILER_IGNORE_UNINITIALIZED",
	"COMPILER_FLEXIBLE_ARRAY" : "__COMPILER_FLEXIBLE_ARRAY",
	"COMPILER_IMPURE" : "__COMPILER_IMPURE",
	"DEFINE_PRIVATE_ALIAS" : "__DEFINE_PRIVATE_ALIAS",
	"DEFINE_PUBLIC_ALIAS" : "__DEFINE_PUBLIC_ALIAS",
	"DEFINE_INTERN_ALIAS" : "__DEFINE_INTERN_ALIAS",
	"DEFINE_PRIVATE_WEAK_ALIAS" : "__DEFINE_PRIVATE_WEAK_ALIAS",
	"DEFINE_PUBLIC_WEAK_ALIAS" : "__DEFINE_PUBLIC_WEAK_ALIAS",
	"DEFINE_INTERN_WEAK_ALIAS" : "__DEFINE_INTERN_WEAK_ALIAS",
	"likely" : "__likely",
	"unlikely" : "__unlikely",
	"DECL_BEGIN" : "__DECL_BEGIN",
	"DECL_END" : "__DECL_END",
	"ASMNAME" : "__COMPILER_ASMNAME",
	"XBLOCK" : "__XBLOCK",
	"XRETURN" : "__XRETURN",
	"NOTHROW" : "__NOTHROW",
	"NOTHROW_NCX" : "__NOTHROW_NCX",
	"NOTHROW_RPC" : "__NOTHROW_RPC",
	"NOTHROW_RPC_KOS" : "__NOTHROW_RPC_KOS",
	"NOTHROW_RPC_NOKOS" : "__NOTHROW_RPC_NOKOS",
	"NOTHROW_RPC_PURE" : "__NOTHROW_RPC_PURE",
	"REDIRECT" : "__COMPILER_REDIRECT",
	"REDIRECT_VOID" : "__COMPILER_REDIRECT_VOID",
	"VREDIRECT" : "__COMPILER_VREDIRECT",
	"VREDIRECT_VOID" : "__COMPILER_VREDIRECT_VOID",
	"VFREDIRECT" : "__COMPILER_VFREDIRECT",
	"VFREDIRECT_VOID" : "__COMPILER_VFREDIRECT_VOID",
	"XREDIRECT" : "__COMPILER_XREDIRECT",
	"XREDIRECT_VOID" : "__COMPILER_XREDIRECT_VOID",
	"PP_PRIVATE_STR" : "__PP_PRIVATE_STR",
	"PP_STR" : "__PP_STR",
	"PP_PRIVATE_CAT2" : "__PP_PRIVATE_CAT2",
	"PP_PRIVATE_CAT3" : "__PP_PRIVATE_CAT3",
	"PP_PRIVATE_CAT4" : "__PP_PRIVATE_CAT4",
	"PP_CAT2" : "__PP_CAT2",
	"PP_CAT3" : "__PP_CAT3",
	"PP_CAT4" : "__PP_CAT4",
	"PP_PRIVATE_MUL8" : "__PP_PRIVATE_MUL8",
	"PP_MUL8" : "__PP_MUL8",
	"STATIC_ASSERT" : "__STATIC_ASSERT",
	"STATIC_ASSERT_MSG" : "__STATIC_ASSERT_MSG",
	"NONNULL" : "__ATTR_NONNULL",
	"NONNULL_CXX" : "__ATTR_NONNULL_CXX",
	"WUNUSED" : "__ATTR_WUNUSED",
	"UNUSED" : "__UNUSED",
	"IMPDAT" : "__IMPDAT",
	"IMPDEF" : "__IMPDEF",
	"EXPDEF" : "__EXPDEF",
	"FUNDEF" : "__PUBDEF",
	"DATDEF" : "__DATDEF",
	"PUBLIC" : "__PUBLIC",
	"INTERN" : "__INTERN",
	"PUBLIC_CONST" : "__PUBLIC_CONST",
	"INTERN_CONST" : "__INTERN_CONST",
	"INTDEF" : "__INTDEF",
	"PRIVATE" : "__PRIVATE",
	"FORCELOCAL" : "__FORCELOCAL",
	"LOCAL" : "__LOCAL",
	"DFL" : "__DFL",
	"ATTR_LIBC_PRINTF" : "__ATTR_LIBC_PRINTF",
	"ATTR_LIBC_PRINTF_P" : "__ATTR_LIBC_PRINTF_P",
	"ATTR_LIBC_SCANF" : "__ATTR_LIBC_SCANF",
	"ATTR_LIBC_STRFMON" : "__ATTR_LIBC_STRFMON",
	"ATTR_LIBC_WPRINTF" : "__ATTR_LIBC_WPRINTF",
	"ATTR_LIBC_WPRINTF_P" : "__ATTR_LIBC_WPRINTF_P",
	"ATTR_LIBC_WSCANF" : "__ATTR_LIBC_WSCANF",
});


@@Names that were used in lookups to @typeHeaders, but weren't found
global usedButNotDefinedTypeHeaders: {string: {(CParser, int)...}} = Dict();

global final defaultTypeHeaders: {string: string} = {
	/* <bits/types.h> */
	"__int8_t" : "<bits/types.h>",
	"__int16_t" : "<bits/types.h>",
	"__int32_t" : "<bits/types.h>",
	"__int64_t" : "<bits/types.h>",
	"__uint8_t" : "<bits/types.h>",
	"__uint16_t" : "<bits/types.h>",
	"__uint32_t" : "<bits/types.h>",
	"__uint64_t" : "<bits/types.h>",
	"__u_char" : "<bits/types.h>",
	"__u_short" : "<bits/types.h>",
	"__u_int" : "<bits/types.h>",
	"__u_long" : "<bits/types.h>",
	"__ptrdiff_t" : "<bits/types.h>",
	"__size_t" : "<bits/types.h>",
	"__ssize_t" : "<bits/types.h>",
	"__intptr_t" : "<bits/types.h>",
	"__uintptr_t" : "<bits/types.h>",
	"__byte_t" : "<bits/types.h>",
	"__register_t" : "<bits/types.h>",
	"__sregister_t" : "<bits/types.h>",
	"__quad_t" : "<bits/types.h>",
	"__u_quad_t" : "<bits/types.h>",
	"__syscall_slong_t" : "<bits/types.h>",
	"__syscall_ulong_t" : "<bits/types.h>",
	"__errno_t" : "<bits/types.h>",
	"__signo_t" : "<bits/types.h>",
	"__iomode_t" : "<bits/types.h>",
	"__fd_t" : "<bits/types.h>",
	"__ufd_t" : "<bits/types.h>",
	"__major_t" : "<bits/types.h>",
	"__minor_t" : "<bits/types.h>",
	"__dev_t" : "<bits/types.h>",
	"__id_t" : "<bits/types.h>",
	"__pid_t" : "<bits/types.h>",
	"__upid_t" : "<bits/types.h>",
	"__key_t" : "<bits/types.h>",
	"__daddr_t" : "<bits/types.h>",
	"__qaddr_t" : "<bits/types.h>",
	"__off32_t" : "<bits/types.h>",
	"__off64_t" : "<bits/types.h>",
	"__fsblkcnt32_t" : "<bits/types.h>",
	"__fsblkcnt64_t" : "<bits/types.h>",
	"__fsfilcnt32_t" : "<bits/types.h>",
	"__fsfilcnt64_t" : "<bits/types.h>",
	"__ino32_t" : "<bits/types.h>",
	"__ino64_t" : "<bits/types.h>",
	"__pos32_t" : "<bits/types.h>",
	"__pos64_t" : "<bits/types.h>",
	"__loff_t" : "<bits/types.h>",
	"__lpos_t" : "<bits/types.h>",
	"__socklen_t" : "<bits/types.h>",
	"__ssocklen_t" : "<bits/types.h>",
	"__rlim32_t" : "<bits/types.h>",
	"__rlim64_t" : "<bits/types.h>",
	"__nlink_t" : "<bits/types.h>",
	"__quantum_diff_t" : "<bits/types.h>",
	"__clock_t" : "<bits/types.h>",
	"__suseconds_t" : "<bits/types.h>",
	"__clockid_t" : "<bits/types.h>",
	"__gid_t" : "<bits/types.h>",
	"__uid_t" : "<bits/types.h>",
	"__useconds_t" : "<bits/types.h>",
	"__fsword_t" : "<bits/types.h>",
	"__port_t" : "<bits/types.h>",
	"__physaddr_t" : "<bits/types.h>",
	"__physpage_t" : "<bits/types.h>",
	"__sa_family_t" : "<bits/types.h>",
	"__time32_t" : "<bits/types.h>",
	"__time64_t" : "<bits/types.h>",
	"__ioctl_t" : "<bits/types.h>",
	"__fcntl_t" : "<bits/types.h>",
	"__oflag_t" : "<bits/types.h>",
	"__atflag_t" : "<bits/types.h>",
	"__blkcnt32_t" : "<bits/types.h>",
	"__blkcnt64_t" : "<bits/types.h>",
	"__blksize_t" : "<bits/types.h>",
	"__mode_t" : "<bits/types.h>",
	"__caddr_t" : "<bits/types.h>",
	"__fsid_t" : "<bits/types.h>",
	"__timer_t" : "<bits/types.h>",
	"__le8" : "<bits/types.h>",
	"__be8" : "<bits/types.h>",
	"__le16" : "<bits/types.h>",
	"__be16" : "<bits/types.h>",
	"__le32" : "<bits/types.h>",
	"__be32" : "<bits/types.h>",
	"__le64" : "<bits/types.h>",
	"__be64" : "<bits/types.h>",
	"__s8" : "<bits/types.h>",
	"__u8" : "<bits/types.h>",
	"__s16" : "<bits/types.h>",
	"__u16" : "<bits/types.h>",
	"__s32" : "<bits/types.h>",
	"__u32" : "<bits/types.h>",
	"__s64" : "<bits/types.h>",
	"__u64" : "<bits/types.h>",

	/* <hybrid/typecore.h> */
	"__CHAR8_TYPE__": "<hybrid/typecore.h>",
	"__INT8_TYPE__": "<hybrid/typecore.h>",
	"__INT16_TYPE__": "<hybrid/typecore.h>",
	"__INT32_TYPE__": "<hybrid/typecore.h>",
	"__INT64_TYPE__": "<hybrid/typecore.h>",
	"__UINT8_TYPE__": "<hybrid/typecore.h>",
	"__UINT16_TYPE__": "<hybrid/typecore.h>",
	"__UINT32_TYPE__": "<hybrid/typecore.h>",
	"__UINT64_TYPE__": "<hybrid/typecore.h>",
	"__INT_LEAST8_TYPE__": "<hybrid/typecore.h>",
	"__INT_LEAST16_TYPE__": "<hybrid/typecore.h>",
	"__INT_LEAST32_TYPE__": "<hybrid/typecore.h>",
	"__INT_LEAST64_TYPE__": "<hybrid/typecore.h>",
	"__UINT_LEAST8_TYPE__": "<hybrid/typecore.h>",
	"__UINT_LEAST16_TYPE__": "<hybrid/typecore.h>",
	"__UINT_LEAST32_TYPE__": "<hybrid/typecore.h>",
	"__UINT_LEAST64_TYPE__": "<hybrid/typecore.h>",
	"__INT_FAST8_TYPE__": "<hybrid/typecore.h>",
	"__INT_FAST16_TYPE__": "<hybrid/typecore.h>",
	"__INT_FAST32_TYPE__": "<hybrid/typecore.h>",
	"__INT_FAST64_TYPE__": "<hybrid/typecore.h>",
	"__UINT_FAST8_TYPE__": "<hybrid/typecore.h>",
	"__UINT_FAST16_TYPE__": "<hybrid/typecore.h>",
	"__UINT_FAST32_TYPE__": "<hybrid/typecore.h>",
	"__UINT_FAST64_TYPE__": "<hybrid/typecore.h>",
	"__INTPTR_TYPE__": "<hybrid/typecore.h>",
	"__UINTPTR_TYPE__": "<hybrid/typecore.h>",
	"__SIZE_TYPE__": "<hybrid/typecore.h>",
	"__SSIZE_TYPE__": "<hybrid/typecore.h>",
	"__INTMAX_TYPE__": "<hybrid/typecore.h>",
	"__UINTMAX_TYPE__": "<hybrid/typecore.h>",
	"__LONGPTR_TYPE__": "<hybrid/typecore.h>",
	"__ULONGPTR_TYPE__": "<hybrid/typecore.h>",
	"__INTPTR_HALF_TYPE__": "<hybrid/typecore.h>",
	"__UINTPTR_HALF_TYPE__": "<hybrid/typecore.h>",
	"__INTPTR_QUARTER_TYPE__": "<hybrid/typecore.h>",
	"__UINTPTR_QUARTER_TYPE__": "<hybrid/typecore.h>",
	"__SBYTE_TYPE__": "<hybrid/typecore.h>",
	"__BYTE_TYPE__": "<hybrid/typecore.h>",
	"__WCHAR_TYPE__": "<hybrid/typecore.h>",
	"__WCHAR16_TYPE__": "<hybrid/typecore.h>",
	"__WCHAR32_TYPE__": "<hybrid/typecore.h>",
	"__WINT_TYPE__": "<hybrid/typecore.h>",
	"__WINT16_TYPE__": "<hybrid/typecore.h>",
	"__WINT32_TYPE__": "<hybrid/typecore.h>",
	"__CHAR16_TYPE__": "<hybrid/typecore.h>",
	"__CHAR32_TYPE__": "<hybrid/typecore.h>",
	"__SHIFT_TYPE__": "<hybrid/typecore.h>",
	"__SIG_ATOMIC_TYPE__": "<hybrid/typecore.h>",
	"__INTSIZE_TYPE__": "<hybrid/typecore.h>",
	"__INTSSIZE_TYPE__": "<hybrid/typecore.h>",
	"__LONGSIZE_TYPE__": "<hybrid/typecore.h>",
	"__LONGSSIZE_TYPE__": "<hybrid/typecore.h>",
	"__LONG32_TYPE__": "<hybrid/typecore.h>",
	"__ULONG32_TYPE__": "<hybrid/typecore.h>",
	"__LONG64_TYPE__": "<hybrid/typecore.h>",
	"__ULONG64_TYPE__": "<hybrid/typecore.h>",
	"__BUSINT_TYPE__": "<hybrid/typecore.h>",
	"__UBUSINT_TYPE__": "<hybrid/typecore.h>",
	"__REGISTER_TYPE__": "<hybrid/typecore.h>",
	"__SREGISTER_TYPE__": "<hybrid/typecore.h>",
	"__MAX_ALIGN_TYPE__": "<hybrid/typecore.h>",
	"__FIFTHINT_TYPE__": "<hybrid/typecore.h>",
	"__UFIFTHINT_TYPE__": "<hybrid/typecore.h>",
	"__FIFTHINT_ALIAS_TYPE__": "<hybrid/typecore.h>",
	"__UFIFTHINT_ALIAS_TYPE__": "<hybrid/typecore.h>",
	"__PTRDIFF_TYPE__": "<hybrid/typecore.h>",

	/* <features.h> */
	"__STDC_INT_AS_SSIZE_T": "<features.h>",
	"__STDC_INT_AS_SIZE_T": "<features.h>",
	"__STDC_LONG_AS_SIZE_T": "<features.h>",
	"__STDC_INT32_AS_SSIZE_T": "<features.h>",
	"__STDC_INT32_AS_SIZE_T": "<features.h>",
	"__STDC_UINT_AS_SIZE_T": "<features.h>",
	"__STDC_UINT32_AS_SIZE_T": "<features.h>",
	"__STDC_INT_AS_UINT_T": "<features.h>",
	"__KOS_FIXED_CONST": "<features.h>",

	/* <bits/os/...> */
	"__timespec": "<bits/os/timespec.h>",
	"__timespec32": "<bits/os/timespec.h>",
	"__timespec64": "<bits/os/timespec.h>",
	"__timeval": "<bits/os/timeval.h>",
	"__timeval32": "<bits/os/timeval.h>",
	"__timeval64": "<bits/os/timeval.h>",
};

@@Mapping of typenames to headers that must be included to get them
@@e.g. "__fd_t" -> "<bits/types.h>"
@@
@@Used for generating warnings about missing include prefixes
global typeHeaders: {string: string} = Dict(defaultTypeHeaders);

@@Include implications.
@@e.g. "<bits/types.h>" implies "<hybrid/typecore.h>"
@@Written     as     @{headerName:    {impliedBy...}}
global typeHeadersImplications: {string: HashSet with string} = Dict({
	"<hybrid/typecore.h>" : HashSet({ "<bits/types.h>" }),
	"<features.h>" : HashSet({ "<bits/types.h>" }),
	"<bits/types.h>" : HashSet({
		"<bits/os/timeval.h>",
		"<bits/os/timespec.h>",
	}),
});


@@Get all headers that implicitly include @thisHeader
function getHeadersThatImply(thisHeader: string): none | HashSet with string {
	local result = typeHeadersImplications.get(thisHeader);
	if (result !is none) {
		result = HashSet(result);
		for (;;) {
			local gotMore = false;
			for (local x: result) {
				for (local more: typeHeadersImplications.get(x)) {
					if (result.insert(more))
						gotMore = true;
				}
				if (gotMore)
					break;
			}
			if (!gotMore)
				break;
		}
	}
	return result;
}



@@Construct a preprocessor expression to check if the to-be linked CRT is exporting @symbolName
function keyCrtHave(symbolName: string | UserString): string {
	local usedSymbolName = str symbolName;
	if (usedSymbolName.startswith("?")) /* Encode DOS special symbol characters */
		usedSymbolName = usedSymbolName.replace("?", "$Q").replace("@", "$A");
	return f"defined(__CRT_HAVE_{usedSymbolName})";
}


@@Builtin macro function @"$has_function(FUNCTION_NAME)"
function builtin_has_function(
		self: CParser, fp: File | CWriter, escapeMode: int,
		extendedPrefixes: List | none): int {
	self.next();
	local tok = self.skip("(");
	if (isCString(tok)) {
		tok = tok.decode("c-escape");
	} else if (!tok.issymbol()) {
		self.err(f"Expected keyword or in after '$has_function(...)', but got {repr tok}");
	}
	local fun;
	try {
		fun = findFunctionByName(tok);
	} catch (Error as e) {
		self.err(e.message);
	}
	tok = self.next();
	if (tok == ",") {
		tok = self.next();
		if (tok == ")")
			goto print_single;
		fp << "(";
		fun.cprintRequires(fp, extendedPrefixes);
		for (;;) {
			if (tok == ")")
				break;
			try {
				fun = findFunctionByName(tok);
			} catch (Error as e) {
				self.err(e.message);
			}
			fp << "&&";
			fun.cprintRequires(fp, extendedPrefixes);
			tok = self.next();
			if (tok != ",")
				break;
			tok = self.next();
		}
		fp << ")";
	} else {
print_single:
		fun.cprintRequires(fp, extendedPrefixes);
	}
	local result = self.tokEnd;
	self.skip(")");
	/* Print requires-conditions for this function */
	return result;
}

@@Builtin macro function @"$crt_has_function(ASM_NAME)"
function builtin_crt_has_function(
		self: CParser, fp: File | CWriter, escapeMode: int,
		extendedPrefixes: List | none): int {
	self.next();
	local tok = self.skip("(");
	if (isCString(tok)) {
		tok = tok.decode("c-escape");
	} else if (!tok.issymbol()) {
		self.err(f"Expected keyword or in after '$crt_has_function(...)', but got {repr tok}");
	}
	self.next();
	local result = self.tokEnd;
	self.skip(")");
	/* Print the __CRT_HAVE_* expression for the given assembly name */
	fp << keyCrtHave(tok);
	return result;
}

@@Builtin macro function @"$extended_prefix(PREFIX)"
function builtin_extended_prefix(
		self: CParser, fp: File | CWriter, escapeMode: int,
		extendedPrefixes: List | none): int {
	self.next();
	self.skip("(");
	extendedPrefixes.append(self.parseAllUntilRParen());
	local result = self.tokEnd;
	self.skip(")");
	return result;
}

@@Builtin macro function @"$extended_include_prefix(HEADER_NAME)"
function builtin_extended_include_prefix(
		self: CParser, fp: File | CWriter, escapeMode: int,
		extendedPrefixes: List | none): int {
	self.next();
	self.skip("(");
	do {
		extendedPrefixes.append("#include " +
			self.parseCStringOrAllUntilRParenAsString());
		if (self.tok != ",")
			break;
		self.next();
	} while (self.tok != ")");
	local result = self.tokEnd;
	self.skip(")");
	return result;
}

@@Custom keyword-style macro handlers.
@@The associated values are either @(string)s that are pasted as-is, or @(Callable)s
@@that are invoked as @(Callable(self: CParser, fp: File | CWriter, escapeMode: int, extendedPrefixes: List | none): int), where
@@the given @self will point to the the macro's name token, that is expected to be
@@skipped over before the callback returns.
@@Text generated by the macro can then simply be written to @fp
@@The Callable's return value is the new `flushStart`-value from which normal text
@@printing should be resumed.
global final keywordMacros: {string: string | Callable with (CParser, File | CWriter, int)} = Dict({
	"$extended_prefix"         : builtin_extended_prefix,
	"$extended_include_prefix" : builtin_extended_include_prefix,
	"$has_function"            : builtin_has_function,
	"$crt_has_function"        : builtin_crt_has_function,
});


@@Keywords that may look escaped, but must be escaped again
global final special_escapes: {string...} = {
	"__used",          /* Macro in <sys/cdefs.h> */
	"__unused",        /* Macro in <sys/cdefs.h> */
	"__packed",        /* Macro in <sys/cdefs.h> */
	"__value",         /* Compiler keyword in MSVC */
	"__event",         /* Compiler keyword in MSVC */
	"__in",            /* SAL macro */
	"__in_z",          /* SAL macro */
	"__in_opt",        /* SAL macro */
	"__in_z_opt",      /* SAL macro */
	"__out",           /* SAL macro */
	"__out_z",         /* SAL macro */
	"__out_opt",       /* SAL macro */
	"__inout",         /* SAL macro */
	"__inout_z",       /* SAL macro */
	"__inout_opt",     /* SAL macro */
	"__inout_z_opt",   /* SAL macro */
	"__argv",          /* Macro from <stdlib.h> */
	"__envp",          /* Macro from <stdlib.h> */
	"__environ",       /* Macro from <stdlib.h> */
	"__progname",      /* Macro from <stdlib.h> */
	"__progname_full", /* Macro from <stdlib.h> */
};


@@Escape the given keyword if it isn't already escaped
function escapeKeywordIfNotAlreadyEscaped(
		word: string | UserString): string {
	if (word is UserString)
		word = word.text;
	if (word !in special_escapes) {
		if (word.startswith("__"))
			return word;
		if (word.startswith("_") && #word >= 2 && word.isupper(1))
			return word;
	}
	local result = "__" + word;
	if (result in special_escapes)
		result = "_" + result;
	return result;
}


@@Skip ahead until after the next next @"@@else", @"@@endif", @"@@elif"
@@@return: 0: Returned after @"@@else"
@@@return: 1: Returned after @"@@endif"
@@@return: 2: Returned after @"@@elif"
function skipEscapingPreproessorBlock(self: CParser): int {
	local start = self.tokStart;
	local recursion = 0;
	for (;;) {
		local tok = self.tok;
		if (tok != "@@") {
			if (!tok)
				self.errAt(start, "Unmatched conditional block");
			tok = self.next();
			continue;
		}
		tok = self.next();
		if (tok == "if") {
			++recursion;
		} else if (tok == "endif") {
			if (recursion == 0) {
				self.next();
				return 1; /* @@endif */
			}
			--recursion;
		} else if (recursion == 0) {
			if (tok == "elif") {
				self.next();
				return 2;
			}
			if (tok == "else") {
				self.next();
				return 0;
			}
		}
		/* Parse the remainder of the directive */
		do {
			tok = self.next();
		} while (tok !in ["", "@@"]);
		tok = self.next();
	}
}


function normalizeForTypeHeader(typename: string): string {
	if (typename.endswith("__restrict"))
		typename = typename[:-10].rstrip();
	if (typename.startswith("struct ")) {
		typename = typename[7:].lstrip();
	} else if (typename.startswith("union ")) {
		typename = typename[6:].lstrip();
	} else if (typename.startswith("enum ")) {
		typename = typename[5:].lstrip();
	}
	typename = typename
		.replace("\t", " ")
		.replace("const", "")
		.replace("volatile", "")
		.replace("*", "")
		.replace("&", "")
		.strip()
		.lstrip("$")
		.lstrip();
	while ("  " in typename)
		typename = typename.replace("  ", " ");


	local escaped = partialKeywordEscapes.get(typename);
	if (escaped !is none)
		return escaped;
	local escaped = keywordEscapes.get(typename);
	if (escaped !is none)
		return escaped;
	if (typename in cLanguageKeywords)
		return typename;
	return escapeKeywordIfNotAlreadyEscaped(typename);
}



@@Escape keywords  from the  given text  via the  given  @keyEscape.
@@If the  given callback  returns @none  for some  given word,  then
@@use @keywordEscapes and @escapeKeywordIfNotAlreadyEscaped instead.
@@Language keywords are not passed to @keyEscape
@@@param: mode:           One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
@@@param: evalEnviron:    Global variables during execution of directives
@@                        When not given, then an anonymous @Dict() is used instead.
@@@param: forceKeyEscape: When set to  @true, force  use of @keyEscape  for _all_  keywords
@@                        before doing anything else, irregardless of what @mode is, except
@@                        for when @mode is set to @ESCAPE_MODE_KEEP
function escapeTextIntoFile(
		fp: File | CWriter, text: string | CParser | UserString,
		mode: int, keyEscape: Callable with string = none,
		evalEnviron: {string: Object} | none = none,
		forceKeyEscape: bool = false,
		extendedPrefixes: List | none = none) {
	/* Check for simple case: @text is a single keyword */
	{
		local usedText = text;
		if (usedText is UserString)
			usedText = usedText.text;
		if (usedText is string) {
			if (!usedText)
				return;
			if (usedText.issymbol()) {
				if (mode == ESCAPE_MODE_KEEP) {
single_dont_escape:
					fp << usedText;
				} else {
					local escapedTok;
					escapedTok = keywordMacros.get(usedText);
					if (escapedTok !is none) {
						/* Macro expansion */
						if (escapedTok is Callable) {
							fp << usedText[escapedTok(
								CParser(usedText), fp, mode, extendedPrefixes):];
						} else {
							/* Re-escape the text generated by the macro */
							escapeTextIntoFile(
								fp, escapedTok, mode, keyEscape,
								evalEnviron, forceKeyEscape);
						}
						return;
					}
					if (forceKeyEscape) {
						escapedTok = keyEscape(usedText);
						if (escapedTok !is none)
							goto single_got_escapedTok;
					}
					if (mode != ESCAPE_MODE_FULL) {
						if (mode == ESCAPE_MODE_NONE) {
							escapedTok = usedText;
							if (escapedTok.startswith("$"))
								escapedTok = usedText[1:];
						} else {
							/* mode == ESCAPE_MODE_PART */
							if (usedText.startswith("$"))
								goto single_do_escape_keyword;
							/* Do a partial escape */
							if (!forceKeyEscape) {
								escapedTok = keyEscape(usedText);
								if (escapedTok !is none)
									goto single_got_escapedTok;
							}
							escapedTok = partialKeywordEscapes.get(usedText);
							if (escapedTok is none) {
								if (usedText in keywordEscapes || usedText in cLanguageKeywords) {
									escapedTok = usedText;
								} else {
									escapedTok = escapeKeywordIfNotAlreadyEscaped(usedText);
								}
							}
						}
					} else {
single_do_escape_keyword:
						if (usedText.startswith("$"))
							usedText = usedText[1:];
						/* Escape this keyword */
						if (!forceKeyEscape) {
							escapedTok = keyEscape(usedText);
							if (escapedTok !is none)
								goto single_got_escapedTok;
						}
						escapedTok = keywordEscapes.get(usedText);
						if (escapedTok is none)
							escapedTok = partialKeywordEscapes.get(usedText);
						if (escapedTok is none) {
							if (usedText in cLanguageKeywords)
								goto single_dont_escape;
							escapedTok = escapeKeywordIfNotAlreadyEscaped(usedText);
						}
					}
single_got_escapedTok:
					fp << escapedTok;
				}
				return;
			}
		}
	}

	local self = CParser(text);
	local flushStart = self.tokEnd;
	@@Stack for @@if ...@@, @@elif ...@@, @@else@@ and @@endif@@
	@@Elements are:
	@@  - @false  If no @@else@@ has been encountered, yet
	@@  - @true   If @@else@@ was encountered
	local ppStack: {bool...} = none;
	local namespaceStack: {Namespace...} = none;
	local oldKeepNewLinesFromDeadCode: bool | none = none;
	local mustFlushFp: bool = false;
	for (;;) {
		local tok = self.next();
again_handle_tok:
		switch (tok) {
			local numLines;

		case "":
			goto done;

		case "#":
			tok = self.next();
			switch (tok) {

			case "import":
			case "include":
			case "include_next": {
				/* Don't escape anything within this line! */
				local eol = self.text.find("\n", self.tokEnd);
				if (eol < 0)
					eol = self.end;
				self.tokEnd = eol;
			}	break;

			default:
				break;
			}
			continue;

		case "@": {
			/* Escaped text sequence */
			if (flushStart < self.tokStart)
				fp << self.text[flushStart:self.tokStart];
			/* Find the next @-character */
			flushStart = self.tokEnd;
			local escapeEnd = self.text.find("@", flushStart);
			if (escapeEnd < 0)
				self.errAt(self.tokStart, "Unmatched @-character");
			fp << self.text[flushStart:escapeEnd];
			flushStart = escapeEnd + 1;
			self.tokEnd = flushStart;
		}	continue;

		case "@@": {
			/* Formating directive */
			if (flushStart < self.tokStart)
				fp << self.text[flushStart:self.tokStart];
			local skipStart = self.tokStart;
			tok = self.next();
			switch (tok) {

			case "exec":
			case "yield": {
				self.next();
				local exprStart = self.tokStart;
				local exprEnd   = exprStart;
				while (self.tok !in ["", "@@"]) {
					exprEnd = self.tokEnd;
					self.next();
				}
				if (evalEnviron is none)
					evalEnviron = Dict();
				local evalExpr = self.text[exprStart:exprEnd];
				local evalResult;
				try {
					evalResult = exec(evalExpr.replace("@", ""), globals: evalEnviron);
				} catch (Error as e) {
					self.errAt(exprStart, e);
					throw;
				}
				if (tok == "yield")
					fp << str evalResult;
			}	break;

			case "push_namespace": {
				if (namespaceStack is none)
					namespaceStack = [];
				if (fp !is CWriter) {
					fp = CWriter(fp);
					mustFlushFp = true;
				}
				self.next();
				self.skip("(");
				local nsName = self.parseCStringOrKeyword();
				namespaceStack.append(fp.namespace);
				try {
					fp.namespace = NAMESPACES[nsName];
				} catch (Error as e) {
					self.err(e.message);
				}
				self.skip(")");
				numLines = 1;
				goto handle_numLines_after_pp_directive;
			}	break;

			case "pop_namespace": {
				if (!namespaceStack)
					self.err("Empty namespace stack");
				self.next();
				fp.namespace = namespaceStack.popback();
				numLines = 1;
				goto handle_numLines_after_pp_directive;
			}	break;

			case "if":
			case "elif": {
				self.next();
parse_if_or_elif_condition:
				local exprStart = self.tokStart;
				local exprEnd   = exprStart;
				while (self.tok !in ["", "@@"]) {
					exprEnd = self.tokEnd;
					self.next();
				}
				if (evalEnviron is none)
					evalEnviron = Dict();
				local evalExpr = self.text[exprStart:exprEnd];
				local evalResult;
				try {
					evalResult = !!exec(evalExpr, globals: evalEnviron);
				} catch (Error as e) {
					self.errAt(exprStart, e);
					throw;
				}
				if (evalResult) {
					if (tok == "if") {
						if (ppStack is none)
							ppStack = [];
						ppStack.pushback(false);
					} else {
						if (!ppStack)
							self.errAt(exprStart, "elif without if");
						if (ppStack.last)
							self.errAt(exprStart, "elif after else");
					}
				} else {
					self.skip("@@");
					/* Skip the current block */
					local nextPart = skipEscapingPreproessorBlock(self);
					if (nextPart == 0) {
						/* @@else@@ encountered */
						if (ppStack is none)
							ppStack = [];
						ppStack.pushback(true);
					} else if (nextPart == 1) {
						/* @@endif@@ encountered */
					} else {
						/* @@elif ... encountered
						 * Act as though the skipped block didn't exist,
						 * at this  elif's condition  was replacing  the
						 * original if/elif's condition. */
						goto parse_if_or_elif_condition;
					}
				}
			}	break;

			case "else": {
				if (!ppStack)
					self.err("else without if");
				if (ppStack.last)
					self.err("else after else");
				self.next();
				self.skip("@@");
				ppStack.last = true;
				/* Skip the current block */
				local nextPart = skipEscapingPreproessorBlock(self);
				if (nextPart == 0) {
					self.err("else after else");
				} else if (nextPart == 1) {
					/* @@endif@@ encountered */
				} else {
					self.err("elif after else");
				}
			}	break;

			case "endif": {
				if (!ppStack)
					self.err("endif without if");
				ppStack.popback();
				self.next();
			}	break;

			case "pp_if":
			case "pp_ifdef":
			case "pp_ifndef":
			case "pp_elif":
			case "pp_elifdef":
			case "pp_elifndef": {
				local cond;
				self.next();
				local exprStart = self.tokStart;
				local exprEnd = exprStart;
				while (self.tok !in ["", "@@"]) {
					exprEnd = self.tokEnd;
					self.next();
				}
				cond = self.text[exprStart:exprEnd];
				if (tok.endswith("ndef")) {
					cond = f"!defined({cond})";
				} else if (tok.endswith("def")) {
					cond = f"defined({cond})";
				}
				cond = escapeText(cond, mode);
				if (tok.startswith("pp_if")) {
					if (oldKeepNewLinesFromDeadCode is none) {
						if (fp !is CWriter) {
							fp = CWriter(fp);
							mustFlushFp = true;
						}
						oldKeepNewLinesFromDeadCode = fp.keepNewLinesFromDeadCode;
						if (!fp.isDeadCode)
							fp.keepNewLinesFromDeadCode = true;
					}
					numLines = fp.ppIf(cond);
				} else {
					if (oldKeepNewLinesFromDeadCode is none)
						self.err("@@pp_elif@@ without @@pp_if@@");
					numLines = fp.ppElif(cond);
				}
handle_numLines_after_pp_directive:
				flushStart = self.tokEnd;
				tok = self.skip("@@");
				/* Even though we  do remove  directives, we do  keep their  lines,
				 * such that #line directives over generated code remain consistent
				 * with their origins. */
				local count = self.text.count("\n", skipStart, flushStart);
				if (count > numLines) {
					fp << ("\n" * (count - numLines));
				} else if (count < numLines) {
					numLines -= count;
					/* Try to skip up to @numLines lines from follow-up text
					 * -> Figure out the # of new-lines between the current flush-start,
					 *    and the next of the first token to follow after the  directive */
					count = self.text.count("\n", flushStart, self.tokEnd);
					if (count) {
						if (count <= numLines) {
							/* Use the end of the last line-feed as the new flush-start */
							flushStart = self.text.rindex("\n", flushStart, self.tokEnd) + 1;
						} else {
							/* There  are @count line-feeds  in total, but we
							 * only need to skip the first @numLines of them! */
							while (numLines) {
								--numLines;
								flushStart = self.text.index(
									"\n", flushStart, self.tokEnd) + 1;
							}
						}
					}
				}
			}	goto again_handle_tok;

			case "pp_else":
				if (oldKeepNewLinesFromDeadCode is none)
					self.err("@@pp_else@@ without @@pp_if@@");
				numLines = fp.ppElse();
				self.next();
				goto handle_numLines_after_pp_directive;

			case "pp_endif":
				if (oldKeepNewLinesFromDeadCode is none)
					self.err("@@pp_endif@@ without @@pp_if@@");
				numLines = fp.ppEndif();
				self.next();
				goto handle_numLines_after_pp_directive;

			case "c":
				self.next();
				tok = self.skip(":");
				switch (tok) {

				case "inline_memcpy": {
					self.next();
					self.skip("(");
					/* @@c:inline_memcpy(void *dst, void const *src, HOW)@@
					 *
					 * HOW ::= '+' ~~ (
					 *     ('u8' | 'u16' | 'u32' | 'u64') '[' COUNT_AS_IMMEDIATE_INTEGER ']'
					 * )...;
					 */
					local dstExpr = self.parseAllUntilRParenAsString();
					self.skip(",");
					local srcExpr = self.parseAllUntilRParenAsString();
					self.skip(",");
					if (!dstExpr.issymbol())
						dstExpr = f"({dstExpr.strip()})";
					if (!srcExpr.issymbol())
						srcExpr = f"({srcExpr.strip()})";
					local offset = 0;
					local isFirst = true;
					for (;;) {
						local typName = self.tok;
						local typSize = {
							"u8"  : 1,
							"u16" : 2,
							"u32" : 4,
							"u64" : 8,
						}.get(typName);
						if (typSize is none)
							self.err("Unknown type for inline_memcpy (must be one of u8, u16, u32 or u64)");
						self.next();
						self.skip("[");
						local count;
						try {
							count = int(self.tok);
						} catch (Error as e) {
							self.err(e.message);
						}
						self.next();
						self.skip("]");
						while (count) {
							local typeIdx = offset / typSize;
							local typeOff = offset % typSize;
							local usedDst = dstExpr;
							local usedSrc = srcExpr;
							if (typeOff != 0) {
								usedDst = f"((u8 *){usedDst} + {typeOff})";
								usedSrc = f"((u8 const *){usedSrc} + {typeOff})";
							}
							if (!isFirst)
								fp << ", ";
							fp << "((" << typName << " *)" << usedDst << ")[" << typeIdx << "] = "
								"((" << typName << " const *)" << usedSrc << ")[" << typeIdx << "]";
							isFirst = false;
							offset += typSize;
							--count;
						}
						if (self.tok in ["", ")"])
							break;
						self.skip("+");
					}
					self.skip(")");
				}	break;

				default:
					self.err(f"Unknown directive: {repr f'c:{tok}'}");
					break;
				}
				break;

			default:
				self.err(f"Unknown directive: {repr tok}");
				break;
			}
			flushStart = self.tokEnd;
			tok = self.skip("@@");
			/* Even though we  do remove  directives, we do  keep their  lines,
			 * such that #line directives over generated code remain consistent
			 * with their origins. */
			{
				local count = self.text.count("\n", skipStart, flushStart);
				if (count)
					fp << ("\n" * count);
			}
		}	goto again_handle_tok;

		default:
			if (tok.issymbol() && mode != ESCAPE_MODE_KEEP) {
				local escapedTok;
				/* Check for special control macros, such as $has_function() */
				escapedTok = keywordMacros.get(tok);
				if (escapedTok !is none) {
					if (flushStart < self.tokStart)
						fp << self.text[flushStart:self.tokStart];
					if (escapedTok is Callable) {
						flushStart = escapedTok(self, fp, mode, extendedPrefixes);
						tok        = self.tok;
					} else {
						/* Re-escape the text generated by the macro */
						escapeTextIntoFile(
							fp, escapedTok, mode, keyEscape,
							evalEnviron, forceKeyEscape);
						flushStart = self.tokEnd;
						tok = self.next();
					}
					goto again_handle_tok;
				}
				if (forceKeyEscape) {
					escapedTok = keyEscape(tok);
					if (escapedTok !is none)
						goto got_escapedTok;
				}
				if (mode != ESCAPE_MODE_FULL) {
					if (mode == ESCAPE_MODE_NONE) {
						escapedTok = tok;
						if (escapedTok.startswith("$"))
							escapedTok = tok[1:];
					} else {
						/* mode == ESCAPE_MODE_PART */
						if (tok.startswith("$"))
							goto do_escape_keyword_dollar;
						/* Do a partial escape */
						if (!forceKeyEscape) {
							escapedTok = keyEscape(tok);
							if (escapedTok !is none)
								goto got_escapedTok;
						}
						if (tok in cLanguageTwoWordTypenameKeywords) {
							tok = self.next();
							if (!tok.issymbol())
								goto again_handle_tok;
							if (forceKeyEscape) {
								escapedTok = keyEscape(tok);
								if (escapedTok !is none)
									goto got_escapedTok;
							}
							if (tok.startswith("$"))
								goto do_handle_cLanguageTwoWordTypenameKeyword_dollar;
							if (!forceKeyEscape) {
								escapedTok = keyEscape(tok);
								if (escapedTok !is none)
									goto got_escapedTok;
							}
							/* Don't escape struct/union/etc. names in PART-mode */
							continue;
						}
						escapedTok = partialKeywordEscapes.get(tok);
						if (escapedTok is none) {
							if (tok in keywordEscapes || tok in cLanguageKeywords) {
								escapedTok = tok;
							} else {
								escapedTok = escapeKeywordIfNotAlreadyEscaped(tok);
							}
						}
					}
					if (escapedTok == tok)
						continue;
				} else {
					if (tok.startswith("$")) {
do_escape_keyword_dollar:
						tok = tok[1:];
					}
					/* Escape this keyword */
					if (!forceKeyEscape) {
						escapedTok = keyEscape(tok);
						if (escapedTok !is none)
							goto got_escapedTok;
					}
					escapedTok = keywordEscapes.get(tok);
					if (escapedTok is none)
						escapedTok = partialKeywordEscapes.get(tok);
					if (escapedTok is none) {
						if (tok in cLanguageTwoWordTypenameKeywords) {
do_handle_cLanguageTwoWordTypenameKeyword:
							tok = self.next();
							if (!tok.issymbol())
								goto again_handle_tok;
							if (forceKeyEscape) {
								escapedTok = keyEscape(tok);
								if (escapedTok !is none)
									goto got_escapedTok;
							}
							if (tok.startswith("$")) {
do_handle_cLanguageTwoWordTypenameKeyword_dollar:
								tok = tok[1:];
								if (!forceKeyEscape) {
									escapedTok = keyEscape(tok);
									if (escapedTok !is none)
										goto got_escapedTok;
								}
								/* Don't escape keywords after "struct", "union", etc. by default.
								 * Only escape  them  if  an  explicit  replacement  rule  exists! */
								escapedTok = keywordEscapes.get(tok);
								if (escapedTok is none)
									escapedTok = tok;
								goto got_escapedTok;
							}
							if (!forceKeyEscape) {
								escapedTok = keyEscape(tok);
								if (escapedTok !is none)
									goto got_escapedTok;
							}
							/* Don't escape keywords after "struct", "union", etc. by default.
							 * Only escape  them  if  an  explicit  replacement  rule  exists! */
							escapedTok = keywordEscapes.get(tok);
							if (escapedTok !is none)
								goto got_escapedTok;
							if (tok in cLanguageTwoWordTypenameKeywords)
								goto do_handle_cLanguageTwoWordTypenameKeyword;
							continue;
						}
						if (tok in cLanguageKeywords)
							continue;
						escapedTok = escapeKeywordIfNotAlreadyEscaped(tok);
					}
				}
got_escapedTok:
				if (flushStart < self.tokStart)
					fp << self.text[flushStart:self.tokStart];
				fp << escapedTok;
				flushStart = self.tokEnd;
			}
			break;
		}
	}
done:
	if (flushStart < self.end)
		fp << self.text[flushStart:self.end];
	if (oldKeepNewLinesFromDeadCode !is none)
		fp.keepNewLinesFromDeadCode = oldKeepNewLinesFromDeadCode;
	if (mustFlushFp)
		fp.flush();
}

@@Helper wrapper for @escapeTextIntoFile
function escapeText(text: string | CParser | UserString, mode: int,
		keyEscape: Callable with string = none,
		evalEnviron: {string: Object} | none = none,
		forceKeyEscape: bool = false,
		extendedPrefixes: List | none = none): string | UserString {
	File.Writer result;
	escapeTextIntoFile(
		result, text, mode, keyEscape, evalEnviron,
		forceKeyEscape, extendedPrefixes);
	result = result.string;
	/* Allow for better string re-use */
	if (text is string) {
		if (result == text)
			result = text;
	} else if (text is UserString) {
		if (result == text.text)
			result = text;
	}
	return result;
}

function escapeNonRepeatingTextIntoFile(
		fp: File | CWriter, text: string | CParser | UserString,
		mode: int, keyEscape: Callable with string = none,
		evalEnviron: {string: Object} | none = none,
		forceKeyEscape: bool = false,
		extendedPrefixes: List | none = none) {
	if (fp is CWriter) {
		local newText = escapeText(
			text, mode, keyEscape, evalEnviron,
			forceKeyEscape, extendedPrefixes);
		fp.forceStartOfLine();
		fp.printPrefix(str newText);
	} else {
		escapeTextIntoFile(
			fp, text, mode, keyEscape, evalEnviron, forceKeyEscape);
	}
}


@@Scan for references to dependent functions within the given @text
@@@param: prototype: The primary function prototype.
@@                   Used to detect references to arguments, and prevent those
@@                   from ever  being considered  references to  dependencies.
function scanForNamesOfDependentFunctions(
		text: string | UserString | Callable,
		selfFunctionName: string | UserString,
		prototype: FunctionPrototype | Callable,
		forcedDependencies: {string...} = none,
		unforcedDependencies: {string...} = none,
		noAutoDependencyScanning: bool = false): Callable {
	return () -> {
		local usedPrototype = prototype;
		if (usedPrototype is Callable)
			usedPrototype = usedPrototype();
		/* Always include forced dependencies */
		for (local dep: forcedDependencies)
			yield (str(dep), dep);
		/* Check if we're supposed to do automatic dependency scanning? */
		if (noAutoDependencyScanning)
			return;
		local parser = CParser(text is Callable ? text() : text);
		local knownNonDependencies: {string...} = none;
		local prevToken;
		local tok = none;
		for (;;) {
next_token:
			prevToken = tok;
			tok = parser.next();
with_next_token:
			if (!tok)
				break;
			if (!tok.issymbol()) {
				/* Dependent functions must always have keyword names */
				switch (tok) {

				case "@":
					/* Deal with escaped keywords */
					do {
						tok = parser.next();
					} while (tok !in ["", "@"]);
					break;

				case "@@":
					/* Deal with directives (which can't contain dependent function name) */
					do {
						tok = parser.next();
					} while (tok !in ["", "@@"]);
					break;

				default:
					break;
				}
				continue;
			}
			if (tok.startswith("$"))
				continue; /* Functions cannot start with a '$', since that would interfere with escape rules */
			if (tok in cLanguageKeywords)
				continue; /* C language keywords can never be dependencies */
			if (tok in unforcedDependencies)
				continue; /* Explicitly not a dependencies of this function */
			if (tok in keywordEscapes)
				continue; /* Keywords that can be escaped further cannot refer to dependable functions */
			if (tok in forcedDependencies)
				continue; /* Already a dependency */
			if (tok in usedPrototype.argsByName)
				continue; /* Argument name -> Not a dependency */
			if (tok in knownNonDependencies)
				continue; /* Already a known non-dependency */
			if (selfFunctionName == tok)
				continue; /* No function can be its own dependency (that would cause an infinite loop!) */
			/* Check if there is a function by this name. */
			local func = allFunctionsByName.get(tok);
			if (func is none)
				continue;
			if (knownNonDependencies is none)
				knownNonDependencies = HashSet();
			if (func === DuplicateFunctionMarker) {
				/* Check for header-specific, explicit dependencies */
				for (local dep: forcedDependencies) {
					if ("." !in dep)
						continue;
					if (tok == dep.rpartition(".")[2]) {
						knownNonDependencies.insert(tok);
						prevToken = tok;
						goto next_token;
					}
				}
				/* Error, unless the function was explicitly annotated as _NOT_ being a dependency! */
				parser.err(
					"Ambiguous dependency {0!r} (consider clarifying with "
					"[dependency({0!r})] or [not_dependency({0!r})])"
					.format({ tok }));
				continue;
			}
			/* don't assume a dependency based on the next word:
			 * int error;                  // Not a dependency on error()
			 * int error = 5;              // Not a dependency on error()
			 * printf("%d, %d", error, 5); // Not a dependency on error()
			 * printf("%d", error);        // Not a dependency on error()
			 * printf("%d", &error);       // Is a dependency on error() (unless 'error' was already used in a different context)
			 * error:                      // Not a dependency on error()
			 */
			if (prevToken == "&") {
				knownNonDependencies.insert(tok);
				yield (tok, func);
				goto next_token;
			}
			prevToken = tok;
			tok = parser.next();
			if (tok in [")", ";", ",", "=", ":"]) {
				knownNonDependencies.insert(prevToken);
				goto with_next_token;
			}
			/* Yield items in pairs of @(dependencyName, dependencyFunc) */
			yield (prevToken, func);
			goto with_next_token;
		}
	};
}
