/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .parser;
import * from .globals;
import * from .writer;
import * from ..optiexpr;

#define Function         Object /* Function from .cheaders */
#define LocalFunction    Object /* LocalFunction from .cheaders */
#define SystemHeader     Object /* SystemHeader from .cheaders */

global expandPreprocessorConditionString;

@@Replace:
@@   - @"$size_t" -> "$size_t"
@@   - @"size_t"  -> "size_t"
@@   - @"foo"     -> "foo"
global final ESCAPE_MODE_KEEP = -1;

@@Replace:
@@   - @"$size_t" -> "size_t"
@@   - @"size_t"  -> "size_t"
@@   - @"foo"     -> "foo"
global final ESCAPE_MODE_NONE = 0;

@@Replace:
@@   - @"$size_t" -> "__SIZE_TYPE__"
@@   - @"size_t"  -> "size_t"
@@   - @"foo"     -> "__foo"
global final ESCAPE_MODE_PART = 1;

@@Replace:
@@   - @"$size_t" -> "__SIZE_TYPE__"
@@   - @"size_t"  -> "__SIZE_TYPE__"
@@   - @"foo"     -> "__foo"
global final ESCAPE_MODE_FULL = 2;

global cLanguageKeywords: {string...} = HashSet({
	"if", "else", "while", "for", "return", "do", "switch",
	"case", "default", "goto", "continue", "break", "sizeof",
	"alignof", "struct", "union", "extern", "void", "char",
	"int", "short", "long", "signed", "unsigned", "const",
	"__const", "__const__", "volatile", "__volatile", "__volatile__",
	"static", "_Pragma", "typedef", "float", "double", "restrict",
	"__restrict", "attribute", "__attribute", "__attribute__",
	"_declspec", "__declspec", "char16_t", "char32_t", "wchar_t",
	"inline", "__inline", "__inline__", "__extension__",
});

global cLanguageTwoWordTypenameKeywords: {string...} = HashSet({
	"struct", "union", "class", "enum"
});

@@Special replacements for certain keywords during escaping.
@@By default, all keywords are escaped by either:
@@  - Inserting 2 leading "__"
@@  - Inserting 1 leading "_", and having the following character be upper-case
@@Keywords that already appear escaped are not re-escaped
global keywordEscapes: {string: string} = Dict({
	"size_t" : "__SIZE_TYPE__",
	"ssize_t" : "__SSIZE_TYPE__",
	"intptr_t" : "__INTPTR_TYPE__",
	"longptr_t" : "__LONGPTR_TYPE__",
	"uintptr_t" : "__UINTPTR_TYPE__",
	"ulongptr_t" : "__ULONGPTR_TYPE__",
	"ptrdiff_t" : "__PTRDIFF_TYPE__",
	"intmax_t" : "__INTMAX_TYPE__",
	"uintmax_t" : "__UINTMAX_TYPE__",
	"byte_t" : "__BYTE_TYPE__",
	"int8_t" : "__INT8_TYPE__",
	"int16_t" : "__INT16_TYPE__",
	"int32_t" : "__INT32_TYPE__",
	"int64_t" : "__INT64_TYPE__",
	"uint8_t" : "__UINT8_TYPE__",
	"uint16_t" : "__UINT16_TYPE__",
	"uint32_t" : "__UINT32_TYPE__",
	"uint64_t" : "__UINT64_TYPE__",
	"wchar_t" : "__WCHAR_TYPE__",
	"char16_t" : "__CHAR16_TYPE__",
	"char32_t" : "__CHAR32_TYPE__",
	"int_least8_t" : "__INT_LEAST8_TYPE__",
	"int_least16_t" : "__INT_LEAST16_TYPE__",
	"int_least32_t" : "__INT_LEAST32_TYPE__",
	"int_least64_t" : "__INT_LEAST64_TYPE__",
	"uint_least8_t" : "__UINT_LEAST8_TYPE__",
	"uint_least16_t" : "__UINT_LEAST16_TYPE__",
	"uint_least32_t" : "__UINT_LEAST32_TYPE__",
	"uint_least64_t" : "__UINT_LEAST64_TYPE__",
	"int_fast8_t" : "__INT_FAST8_TYPE__",
	"int_fast16_t" : "__INT_FAST16_TYPE__",
	"int_fast32_t" : "__INT_FAST32_TYPE__",
	"int_fast64_t" : "__INT_FAST64_TYPE__",
	"uint_fast8_t" : "__UINT_FAST8_TYPE__",
	"uint_fast16_t" : "__UINT_FAST16_TYPE__",
	"uint_fast32_t" : "__UINT_FAST32_TYPE__",
	"uint_fast64_t" : "__UINT_FAST64_TYPE__",
	"INTMAX_MIN" : "__INTMAX_MIN__",
	"INTMAX_MAX" : "__INTMAX_MAX__",
	"UINTMAX_MAX" : "__UINTMAX_MAX__",
	"INT8_MIN" : "__INT8_MIN__",
	"INT16_MIN" : "__INT16_MIN__",
	"INT32_MIN" : "__INT32_MIN__",
	"INT8_MAX" : "__INT8_MAX__",
	"INT16_MAX" : "__INT16_MAX__",
	"INT32_MAX" : "__INT32_MAX__",
	"UINT8_MAX" : "__UINT8_MAX__",
	"UINT16_MAX" : "__UINT16_MAX__",
	"UINT32_MAX" : "__UINT32_MAX__",
	"INT64_MIN" : "__INT64_MIN__",
	"INT64_MAX" : "__INT64_MAX__",
	"UINT64_MAX" : "__UINT64_MAX__",
	"INT_LEAST8_MIN" : "__INT_LEAST8_MIN__",
	"INT_LEAST16_MIN" : "__INT_LEAST16_MIN__",
	"INT_LEAST32_MIN" : "__INT_LEAST32_MIN__",
	"INT_LEAST8_MAX" : "__INT_LEAST8_MAX__",
	"INT_LEAST16_MAX" : "__INT_LEAST16_MAX__",
	"INT_LEAST32_MAX" : "__INT_LEAST32_MAX__",
	"UINT_LEAST8_MAX" : "__UINT_LEAST8_MAX__",
	"UINT_LEAST16_MAX" : "__UINT_LEAST16_MAX__",
	"UINT_LEAST32_MAX" : "__UINT_LEAST32_MAX__",
	"INT_LEAST64_MIN" : "__INT_LEAST64_MIN__",
	"INT_LEAST64_MAX" : "__INT_LEAST64_MAX__",
	"UINT_LEAST64_MAX" : "__UINT_LEAST64_MAX__",
	"INT_FAST8_MIN" : "__INT_FAST8_MIN__",
	"INT_FAST16_MIN" : "__INT_FAST16_MIN__",
	"INT_FAST32_MIN" : "__INT_FAST32_MIN__",
	"INT_FAST8_MAX" : "__INT_FAST8_MAX__",
	"INT_FAST16_MAX" : "__INT_FAST16_MAX__",
	"INT_FAST32_MAX" : "__INT_FAST32_MAX__",
	"UINT_FAST8_MAX" : "__UINT_FAST8_MAX__",
	"UINT_FAST16_MAX" : "__UINT_FAST16_MAX__",
	"UINT_FAST32_MAX" : "__UINT_FAST32_MAX__",
	"INT_FAST64_MIN" : "__INT_FAST64_MIN__",
	"INT_FAST64_MAX" : "__INT_FAST64_MAX__",
	"UINT_FAST64_MAX" : "__UINT_FAST64_MAX__",
	"INTPTR_MIN" : "__INTPTR_MIN__",
	"INTPTR_MAX" : "__INTPTR_MAX__",
	"UINTPTR_MAX" : "__UINTPTR_MAX__",
	"SIZE_MAX" : "__SIZE_MAX__",
	"PTRDIFF_MIN" : "__PTRDIFF_MIN__",
	"PTRDIFF_MAX" : "__PTRDIFF_MAX__",
	"SIG_ATOMIC_MIN" : "__SIG_ATOMIC_MIN__",
	"SIG_ATOMIC_MAX" : "__SIG_ATOMIC_MAX__",
	"WCHAR_MIN" : "__WCHAR_MIN__",
	"WCHAR_MAX" : "__WCHAR_MAX__",
	"WINT_MIN" : "__WINT_MIN__",
	"WINT_MAX" : "__WINT_MAX__",
	"CHAR_BIT" : "__CHAR_BIT__",
	"SCHAR_MIN" : "__SCHAR_MIN__",
	"SCHAR_MAX" : "__SCHAR_MAX__",
	"UCHAR_MAX" : "__UCHAR_MAX__",
	"CHAR_MIN" : "__CHAR_MIN__",
	"CHAR_MAX" : "__CHAR_MAX__",
	"SHRT_MIN" : "__SHRT_MIN__",
	"SHRT_MAX" : "__SHRT_MAX__",
	"USHRT_MAX" : "__USHRT_MAX__",
	"INT_MIN" : "__INT_MIN__",
	"INT_MAX" : "__INT_MAX__",
	"UINT_MAX" : "__UINT_MAX__",
	"LONG_MIN" : "__LONG_MIN__",
	"LONG_MAX" : "__LONG_MAX__",
	"ULONG_MAX" : "__ULONG_MAX__",
	"LLONG_MIN" : "__LONG_LONG_MIN__",
	"LLONG_MAX" : "__LONG_LONG_MAX__",
	"ULLONG_MAX" : "__ULONG_LONG_MAX__",
	"s8" : "__INT8_TYPE__",
	"s16" : "__INT16_TYPE__",
	"s32" : "__INT32_TYPE__",
	"s64" : "__INT64_TYPE__",
	"u8" : "__UINT8_TYPE__",
	"u16" : "__UINT16_TYPE__",
	"u32" : "__UINT32_TYPE__",
	"u64" : "__UINT64_TYPE__",
	"va_list" : "__builtin_va_list",
	"va_start" : "__builtin_va_start",
	"va_copy" : "__builtin_va_copy",
	"va_end" : "__builtin_va_end",
	"va_arg" : "__builtin_va_arg",
	"bool" : "__BOOL",
	"true" : "1",
	"false" : "0",
	"NULL" : "__NULLPTR",
	"WUNUSED" : "__ATTR_WUNUSED",
	"NONNULL" : "__ATTR_NONNULL",
});



@@Construct a preprocessor expression to check if the to-be linked CRT is exporting @symbolName
function keyCrtHave(symbolName: string | UserString): string {
	/* Special case: When wishing to test for KOS-specific symbols, we
	 *               must actually look out for the DOS-variants, since
	 *               linking against KOS-symbols only works for PE applications,
	 *               however CRT feature files are written from the perspective
	 *               of an ELF program. */
	local usedSymbolName = str symbolName;
	if (usedSymbolName.startswith("KOS$")) {
		/* Technically, this should be:
		 * >> (defined(__KOS__) && defined(__PE__) && defined(__CRT_HAVE_{usedSymbolName[4:]})) */
		usedSymbolName = "DOS$" + usedSymbolName[4:];
	}
	return "defined(__CRT_HAVE_{})".format({ usedSymbolName });
}


@@Builtin macro function @"$has_function(FUNCTION_NAME)"
function builtin_has_function(
		self: CParser, fp: File | CWriter, escapeMode: int): int {
	self.next();
	local tok = self.skip("(");
	if (isCString(tok))
		tok = tok.decode("c-escape");
	else if (!tok.issymbol()) {
		self.err("Expected keyword or in after '$has_function(...)', but got {!r}"
			.format({ tok }));
	}
	local fun;
	try {
		fun = findFunctionByName(tok);
	} catch (Error as e) {
		self.err(e.message);
	}
	self.next();
	local result = self.tokEnd;
	self.skip(")");
	/* Print requires-conditions for this function */
	fun.cprintRequires(fp);
	return result;
}

@@Builtin macro function @"$crt_has_function(ASM_NAME)"
function builtin_crt_has_function(
		self: CParser, fp: File | CWriter, escapeMode: int): int {
	self.next();
	local tok = self.skip("(");
	if (isCString(tok))
		tok = tok.decode("c-escape");
	else if (!tok.issymbol()) {
		self.err("Expected keyword or in after '$crt_has_function(...)', but got {!r}"
			.format({ tok }));
	}
	self.next();
	local result = self.tokEnd;
	self.skip(")");
	/* Print the __CRT_HAVE_* expression for the given assembly name */
	fp << keyCrtHave(tok);
	return result;
}

@@Custom keyword-style macro handlers.
@@The associated values are either @(string)s that are pasted as-is, or @(Callable)s
@@that are invoked as @(Callable(self: CParser, fp: File | CWriter, escapeMode: int): int), where
@@the given @self will point to the the macro's name token, that is expected to be
@@skipped over before the callback returns.
@@Text generated by the macro can then simply be written to @fp
@@The Callable's return value is the new `flushStart`-value from which normal text
@@printing should be resumed.
global final keywordMacros: {string: string | Callable with (CParser, File | CWriter, int)} = Dict({
	"$has_function"     : builtin_has_function,
	"$crt_has_function" : builtin_crt_has_function,
});



@@Escape the given keyword if it isn't already escaped
function escapeKeywordIfNotAlreadyEscaped(
		word: string | UserString): string {
	if (word is UserString)
		word = word.text;
	if (word.startswith("__"))
		return word;
	if (word.startswith("_") && #word >= 2 && word.isupper(1))
		return word;
	return "__" + word;
}


@@Skip ahead until after the next next @"@@else", @"@@endif", @"@@elif"
@@@return: 0: Returned after @"@@else"
@@@return: 1: Returned after @"@@endif"
@@@return: 2: Returned after @"@@elif"
function skipEscapingPreproessorBlock(self: CParser): int {
	local start = self.tokStart;
	local recursion = 0;
	for (;;) {
		local tok = self.tok;
		if (tok != "@@") {
			if (!tok)
				self.errAt(start, "Unmatched conditional block");
			tok = self.next();
			continue;
		}
		tok = self.next();
		if (tok == "if")
			++recursion;
		else if (tok == "endif") {
			if (recursion == 0) {
				self.next();
				return 1; /* @@endif */
			}
			--recursion;
		} else if (recursion == 0) {
			if (tok == "elif") {
				self.next();
				return 2;
			}
			if (tok == "else") {
				self.next();
				return 0;
			}
		}
		/* Parse the remainder of the directive */
		do {
			tok = self.next();
		} while (tok !in ["", "@@"]);
		tok = self.next();
	}
}



@@Escape keywords from the given text via the given @keyEscape.
@@If the given callback returns @none for some given word, then
@@use @keywordEscapes and @escapeKeywordIfNotAlreadyEscaped instead.
@@Language keywords are not passed to @keyEscape
@@@param: mode:           One of @ESCAPE_MODE_NONE, @ESCAPE_MODE_PART, @ESCAPE_MODE_FULL
@@@param: evalEnviron:    Global variables during execution of directives
@@                        When not given, then an anonymous @Dict() is used instead.
@@@param: forceKeyEscape: When set to @true, force use of @keyEscape for _all_ keywords
@@                        before doing anything else, irregardless of what @mode is, except
@@                        for when @mode is set to @ESCAPE_MODE_KEEP
function escapeTextIntoFile(
		fp: File | CWriter, text: string | CParser | UserString,
		mode: int, keyEscape: Callable with string = none,
		evalEnviron: {string: Object} | none = none,
		forceKeyEscape: bool = false) {
	/* Check for simple case: @text is a single keyword */
	{
		local usedText = text;
		if (usedText is UserString)
			usedText = usedText.text;
		if (usedText is string) {
			if (!usedText)
				return;
			if (usedText.issymbol()) {
				if (mode == ESCAPE_MODE_KEEP) {
single_dont_escape:
					fp << usedText;
				} else {
					local escapedTok;
					if (forceKeyEscape) {
						escapedTok = keyEscape(usedText);
						if (escapedTok !is none)
							goto single_got_escapedTok;
					}
					if (mode != ESCAPE_MODE_FULL) {
						if (mode == ESCAPE_MODE_NONE) {
							escapedTok = usedText;
							if (escapedTok.startswith("$"))
								escapedTok = usedText[1:];
						} else {
							/* mode == ESCAPE_MODE_PART */
							if (usedText.startswith("$"))
								goto single_do_escape_keyword;
							/* Do a partial escape */
							if (!forceKeyEscape) {
								escapedTok = keyEscape(usedText);
								if (escapedTok !is none)
									goto got_escapedTok;
							}
							if (usedText in keywordEscapes || usedText in cLanguageKeywords)
								escapedTok = usedText;
							else {
								escapedTok = escapeKeywordIfNotAlreadyEscaped(usedText);
							}
						}
					} else {
single_do_escape_keyword:
						if (usedText.startswith("$"))
							usedText = usedText[1:];
						/* Escape this keyword */
						if (!forceKeyEscape) {
							escapedTok = keyEscape(usedText);
							if (escapedTok !is none)
								goto got_escapedTok;
						}
						escapedTok = keywordEscapes.get(usedText);
						if (escapedTok is none) {
							if (usedText in cLanguageKeywords)
								goto single_dont_escape;
							escapedTok = escapeKeywordIfNotAlreadyEscaped(usedText);
						}
					}
single_got_escapedTok:
					fp << escapedTok;
				}
				return;
			}
		}
	}

	local self = CParser(text);
	local flushStart = self.tokEnd;
	@@Stack for @@if ...@@, @@elif ...@@, @@else@@ and @@endif@@
	@@Elements are:
	@@  - @false  If no @@else@@ has been encountered, yet
	@@  - @true   If @@else@@ was encountered
	local ppStack: {bool...} = none;
	local oldKeepNewLinesFromDeadCode: bool | none = none;
	local mustFlushFp: bool = false;
	for (;;) {
		local tok = self.next();
again_handle_tok:
		switch (tok) {

		case "":
			goto done;

		case "@": {
			/* Escaped text sequence */
			if (flushStart < self.tokStart)
				fp << self.text[flushStart:self.tokStart];
			/* Find the next @-character */
			flushStart = self.tokEnd;
			local escapeEnd = self.text.find("@", flushStart);
			if (escapeEnd < 0)
				self.errAt(self.tokStart, "Unmatched @-character");
			fp << self.text[flushStart:escapeEnd];
			flushStart = escapeEnd + 1;
			self.tokEnd = flushStart;
		}	continue;

		case "@@": {
			/* Formating directive */
			if (flushStart < self.tokStart)
				fp << self.text[flushStart:self.tokStart];
			local skipStart = self.tokStart;
			tok = self.next();
			switch (tok) {

			case "exec": {
				self.next();
				local exprStart = self.tokStart;
				local exprEnd   = exprStart;
				while (self.tok !in ["", "@@"]) {
					exprEnd = self.tokEnd;
					self.next();
				}
				if (evalEnviron is none)
					evalEnviron = Dict();
				local evalExpr = self.text[exprStart:exprEnd];
				try {
					exec(evalExpr, globals: evalEnviron);
				} catch (Error as e) {
					self.errAt(exprStart, e);
					throw;
				}
			}	break;

			case "if":
			case "elif": {
				self.next();
parse_if_or_elif_condition:
				local exprStart = self.tokStart;
				local exprEnd   = exprStart;
				while (self.tok !in ["", "@@"]) {
					exprEnd = self.tokEnd;
					self.next();
				}
				if (evalEnviron is none)
					evalEnviron = Dict();
				local evalExpr = self.text[exprStart:exprEnd];
				local evalResult;
				try {
					evalResult = !!exec(evalExpr, globals: evalEnviron);
				} catch (Error as e) {
					self.errAt(exprStart, e);
					throw;
				}
				if (evalResult) {
					if (tok == "if") {
						if (ppStack is none)
							ppStack = [];
						ppStack.pushback(false);
					} else {
						if (!ppStack)
							self.errAt(exprStart, "elif without if");
						if (ppStack.last)
							self.errAt(exprStart, "elif after else");
					}
				} else {
					self.skip("@@");
					/* Skip the current block */
					local nextPart = skipEscapingPreproessorBlock(self);
					if (nextPart == 0) {
						/* @@else@@ encountered */
						if (ppStack is none)
							ppStack = [];
						ppStack.pushback(true);
					} else if (nextPart == 1) {
						/* @@endif@@ encountered */
					} else {
						/* @@elif ... encountered
						 * Act as though the skipped block didn't exist,
						 * at this elif's condition was replacing the
						 * original if/elif's condition. */
						goto parse_if_or_elif_condition;
					}
				}
			}	break;

			case "else": {
				if (!ppStack)
					self.err("else without if");
				if (ppStack.last)
					self.err("else after else");
				self.next();
				self.skip("@@");
				ppStack.last = true;
				/* Skip the current block */
				local nextPart = skipEscapingPreproessorBlock(self);
				if (nextPart == 0) {
					self.err("else after else");
				} else if (nextPart == 1) {
					/* @@endif@@ encountered */
				} else {
					self.err("elif after else");
				}
			}	break;

			case "endif": {
				if (!ppStack)
					self.err("endif without if");
				ppStack.popback();
				self.next();
			}	break;

			{
				local numLines;
				local cond;
			case "pp_if":
			case "pp_ifdef":
			case "pp_ifndef":
			case "pp_elif":
			case "pp_elifdef":
			case "pp_elifndef": {
				self.next();
				local exprStart = self.tokStart;
				local exprEnd = exprStart;
				while (self.tok !in ["", "@@"]) {
					exprEnd = self.tokEnd;
					self.next();
				}
				cond = self.text[exprStart:exprEnd];
				if (tok.endswith("ndef")) {
					cond = "!defined({})".format({ cond });
				} else if (tok.endswith("def")) {
					cond = "defined({})".format({ cond });
				}
handle_pp_if__pp_elif_cond:
				cond = expandPreprocessorConditionString(cond);
				if (tok.startswith("pp_if")) {
					if (oldKeepNewLinesFromDeadCode is none) {
						if (fp !is CWriter) {
							fp = CWriter(fp);
							mustFlushFp = true;
						}
						oldKeepNewLinesFromDeadCode = fp.keepNewLinesFromDeadCode;
						if (!fp.isDeadCode)
							fp.keepNewLinesFromDeadCode = true;
					}
					numLines = fp.ppIf(cond);
				} else {
					if (oldKeepNewLinesFromDeadCode is none)
						self.err("@@pp_elif@@ without @@pp_if@@");
					numLines = fp.ppElif(cond);
				}
handle_numLines_after_pp_directive:
				flushStart = self.tokEnd;
				tok = self.skip("@@");
				/* Even though we do remove directives, we do keep their lines,
				 * such that #line directives over generated code remain consistent
				 * with their origins. */
				local count = self.text.count("\n", skipStart, flushStart);
				if (count > numLines) {
					fp << ("\n" * (count - numLines));
				} else if (count < numLines) {
					numLines -= count;
					/* Try to skip up to @numLines lines from follow-up text
					 * -> Figure out the # of new-lines between the current flush-start,
					 *    and the next of the first token to follow after the directive */
					count = self.text.count("\n", flushStart, self.tokEnd);
					if (count) {
						if (count <= numLines) {
							/* Use the end of the last line-feed as the new flush-start */
							flushStart = self.text.rindex("\n", flushStart, self.tokEnd) + 1;
						} else {
							/* There are @count line-feeds in total, but we
							 * only need to skip the first  @numLines of them! */
							while (numLines) {
								--numLines;
								flushStart = self.text.index(
									"\n", flushStart, self.tokEnd) + 1;
							}
						}
					}
				}
			}	goto again_handle_tok;

			case "pp_else":
				if (oldKeepNewLinesFromDeadCode is none)
					self.err("@@pp_else@@ without @@pp_if@@");
				numLines = fp.ppElse();
				self.next();
				goto handle_numLines_after_pp_directive;

			case "pp_endif":
				if (oldKeepNewLinesFromDeadCode is none)
					self.err("@@pp_endif@@ without @@pp_if@@");
				numLines = fp.ppEndif();
				self.next();
				goto handle_numLines_after_pp_directive;

			/* Deprecated preprocessor functions */
			case "pp_if_has_function":           /* alias for @@pp_if $has_function({name})@@ */
			case "pp_elif_has_function":         /* alias for @@pp_elif $has_function({name})@@ */
			case "if_has_function":              /* (Deprecated alias for @@pp_if   $has_function({name})@@) */
			case "if_crt_has_function":          /* (Deprecated alias for @@pp_if   $crt_has_function({name})@@) */
			case "if_not_has_function":          /* (Deprecated alias for @@pp_if   !$has_function({name})@@) */
			case "if_not_crt_has_function":      /* (Deprecated alias for @@pp_if   !$crt_has_function({name})@@) */
			case "elif_has_function":            /* (Deprecated alias for @@pp_elif $has_function({name})@@) */
			case "elif_crt_has_function":        /* (Deprecated alias for @@pp_elif $crt_has_function({name})@@) */
			case "elif_not_has_function":        /* (Deprecated alias for @@pp_elif !$has_function({name})@@) */
			case "elif_not_crt_has_function":    /* (Deprecated alias for @@pp_elif !$crt_has_function({name})@@) */
			case "else_has_function":            /* (Deprecated alias for @@pp_else@@) */
			case "else_crt_has_function":        /* (Deprecated alias for @@pp_else@@) */
			case "else_not_has_function":        /* (Deprecated alias for @@pp_else@@) */
			case "else_not_crt_has_function":    /* (Deprecated alias for @@pp_else@@) */
			case "endif_has_function":           /* (Deprecated alias for @@pp_endif@@) */
			case "endif_crt_has_function":       /* (Deprecated alias for @@pp_endif@@) */
			case "endif_not_has_function":       /* (Deprecated alias for @@pp_endif@@) */
			case "endif_not_crt_has_function": { /* (Deprecated alias for @@pp_endif@@) */
				local functionName;
				self.next();
				self.skip("(");
				functionName = self.tok;
				if (isCString(functionName))
					functionName = functionName.decode("c-escape");
				else if (!functionName.issymbol()) {
					self.err("Expected keyword or string in '@@{}(...)@@', but got {!r}"
						.format({ tok, functionName }));
				}
				self.next();
				self.skip(")");
				if (tok in ["else_has_function", "else_crt_has_function",
				            "else_not_has_function", "else_not_crt_has_function"]) {
					if (oldKeepNewLinesFromDeadCode is none) {
						self.err("@@{}@@ without @@pp_if@@"
							.format({ tok }));
					}
					numLines = fp.ppElse();
					goto handle_numLines_after_pp_directive;
				}
				if (tok in ["endif_has_function", "endif_crt_has_function",
				            "endif_not_has_function", "endif_not_crt_has_function"]) {
					if (oldKeepNewLinesFromDeadCode is none) {
						self.err("@@{}@@ without @@pp_if@@"
							.format({ tok }));
					}
					numLines = fp.ppEndif();
					goto handle_numLines_after_pp_directive;
				}
				/* construct the condition string, and if vs. elif */
				tok, cond = {
					"pp_if_has_function"        : ("pp_if",   "$has_function({})"),
					"if_has_function"           : ("pp_if",   "$has_function({})"),
					"if_crt_has_function"       : ("pp_if",   "$crt_has_function({})"),
					"if_not_has_function"       : ("pp_if",   "!$has_function({})"),
					"if_not_crt_has_function"   : ("pp_if",   "!$crt_has_function({})"),
					"pp_elif_has_function"      : ("pp_elif", "$has_function({})"),
					"elif_has_function"         : ("pp_elif", "$has_function({})"),
					"elif_crt_has_function"     : ("pp_elif", "$crt_has_function({})"),
					"elif_not_has_function"     : ("pp_elif", "!$has_function({})"),
					"elif_not_crt_has_function" : ("pp_elif", "!$crt_has_function({})"),
				}[tok]...;
				cond = cond.format({ functionName });
				goto handle_pp_if__pp_elif_cond;
			}	break;

			}

			/* TODO: @@insert copy({basefunc}, {copymode})@@ */
			/* TODO: @@yield {expr}@@ */
			/* TODO: @@has_function({name})@@ */
			/* TODO: @@crt_has_function({name})@@ */

			default:
				self.err("Unknown directive: {!r}"
					.format({ tok }));
				break;
			}
			flushStart = self.tokEnd;
			tok = self.skip("@@");
			/* Even though we do remove directives, we do keep their lines,
			 * such that #line directives over generated code remain consistent
			 * with their origins. */
			{
				local count = self.text.count("\n", skipStart, flushStart);
				if (count)
					fp << ("\n" * count);
			}
		}	goto again_handle_tok;

		default:
			if (tok.issymbol() && mode != ESCAPE_MODE_KEEP) {
				local escapedTok;
				/* Check for special control macros, such as $has_function() */
				escapedTok = keywordMacros.get(tok);
				if (escapedTok !is none) {
					if (flushStart < self.tokStart)
						fp << self.text[flushStart:self.tokStart];
					if (escapedTok is Callable) {
						flushStart = escapedTok(self, fp, mode);
						tok        = self.tok;
					} else {
						/* Re-escape the text generated by the macro */
						escapeTextIntoFile(
							fp, escapedTok, mode, keyEscape,
							evalEnviron, forceKeyEscape);
						flushStart = self.tokStart;
						tok = self.next();
					}
					goto again_handle_tok;
				}
				if (tok.startswith("$")) {
					switch (tok) {

					/* TODO: $crt_has_function(...) */

					default:
						break;
					}
				}
				if (forceKeyEscape) {
					escapedTok = keyEscape(tok);
					if (escapedTok !is none)
						goto got_escapedTok;
				}
				if (mode != ESCAPE_MODE_FULL) {
					if (mode == ESCAPE_MODE_NONE) {
						escapedTok = tok;
						if (escapedTok.startswith("$"))
							escapedTok = tok[1:];
					} else {
						/* mode == ESCAPE_MODE_PART */
						if (tok.startswith("$"))
							goto do_escape_keyword_dollar;
						/* Do a partial escape */
						if (!forceKeyEscape) {
							escapedTok = keyEscape(tok);
							if (escapedTok !is none)
								goto got_escapedTok;
						}
						if (tok in cLanguageTwoWordTypenameKeywords)
							goto do_handle_cLanguageTwoWordTypenameKeyword;
						if (tok in keywordEscapes || tok in cLanguageKeywords)
							escapedTok = tok;
						else {
							escapedTok = escapeKeywordIfNotAlreadyEscaped(tok);
						}
					}
				} else {
					if (tok.startswith("$")) {
do_escape_keyword_dollar:
						tok = tok[1:];
					}
					/* Escape this keyword */
					if (!forceKeyEscape) {
						escapedTok = keyEscape(tok);
						if (escapedTok !is none)
							goto got_escapedTok;
					}
					escapedTok = keywordEscapes.get(tok);
					if (escapedTok is none) {
						if (tok in cLanguageTwoWordTypenameKeywords) {
do_handle_cLanguageTwoWordTypenameKeyword:
							tok = self.next();
							if (!tok.issymbol())
								goto again_handle_tok;
							if (forceKeyEscape) {
								escapedTok = keyEscape(tok);
								if (escapedTok !is none)
									goto got_escapedTok;
							}
							if (tok.startswith("$"))
								tok = tok[1:];
							if (!forceKeyEscape) {
								escapedTok = keyEscape(tok);
								if (escapedTok !is none)
									goto got_escapedTok;
							}
							/* Don't escape keywords after "struct", "union", etc. by default.
							 * Only escape them if an explicit replacement rule exists! */
							escapedTok = keywordEscapes.get(tok);
							if (escapedTok !is none)
								goto got_escapedTok;
							if (tok in cLanguageTwoWordTypenameKeywords)
								goto do_handle_cLanguageTwoWordTypenameKeyword;
							continue;
						}
						if (tok in cLanguageKeywords)
							continue;
						escapedTok = escapeKeywordIfNotAlreadyEscaped(tok);
					}
				}
got_escapedTok:
				if (flushStart < self.tokStart)
					fp << self.text[flushStart:self.tokStart];
				fp << escapedTok;
				flushStart = self.tokEnd;
			}
			break;
		}
	}
done:
	if (flushStart < self.end)
		fp << self.text[flushStart:self.end];
	if (oldKeepNewLinesFromDeadCode !is none)
		fp.keepNewLinesFromDeadCode = oldKeepNewLinesFromDeadCode;
	if (mustFlushFp)
		fp.flush();
}

@@Helper wrapper for @escapeTextIntoFile
function escapeText(text: string | CParser | UserString, mode: int,
		keyEscape: Callable with string = none,
		evalEnviron: {string: Object} | none = none,
		forceKeyEscape: bool = false): string | UserString {
	File.Writer result;
	escapeTextIntoFile(
		result, text, mode, keyEscape,
		evalEnviron, forceKeyEscape);
	result = result.string;
	/* Allow for better string re-use */
	if (text is string) {
		if (result == text)
			result = text;
	} else if (text is UserString) {
		if (result == text.text)
			result = text;
	}
	return result;
}

function escapeNonRepeatingTextIntoFile(
		fp: File | CWriter, text: string | CParser | UserString,
		mode: int, keyEscape: Callable with string = none,
		evalEnviron: {string: Object} | none = none,
		forceKeyEscape: bool = false) {
	if (fp is CWriter) {
		local newText = escapeText(
			text, mode, keyEscape, evalEnviron, forceKeyEscape);
		fp.forceStartOfLine();
		fp.printPrefix(str newText);
	} else {
		escapeTextIntoFile(
			fp, text, mode, keyEscape, evalEnviron, forceKeyEscape);
	}
}


function printPreprocessorConditionString(
		fp: File | CWriter, text: string | CParser | UserString) {
	escapeTextIntoFile(fp, text, ESCAPE_MODE_FULL, identity from functools);
}

function expandPreprocessorConditionString(
		text: string | CParser | UserString): string {
	local resultFp = File.Writer();
	escapeTextIntoFile(resultFp, text, ESCAPE_MODE_FULL, identity from functools);
	return resultFp.string;
}

