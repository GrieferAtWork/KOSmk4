/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .cheaders;
import * from .parser;
import * from .globals;
import * from .namespace;
import Function from .cheaders;

global WcharFunction;

@@Replacements for wchar-related keywords
global final wcharReplacementEscapes: {string: (string, string)} = Dict({
	"wchar_t"            : ("char16_t", "char32_t"),
	"__wchar_t"          : ("__char16_t", "__char32_t"),
	"__WCHAR_TYPE__"     : ("__CHAR16_TYPE__", "__CHAR32_TYPE__"),
	"__SIZEOF_WCHAR_T__" : ("2", "4"),
	"LIBCCALL"           : ("LIBDCALL", "LIBKCALL"),
	"VLIBCCALL"          : ("VLIBDCALL", "VLIBKCALL"),
	"__LIBCCALL"         : ("__LIBDCALL", "__LIBKCALL"),
	"__VLIBCCALL"        : ("__VLIBDCALL", "__VLIBKCALL"),
});

@@Replacements for wchar-related headers
global final wcharReplacementHeaders: {string: (string, string)} = Dict({
	"<bits/wformat-printer.h>"       : ("<bits/uformat-printer.h>",       "<bits/uformat-printer.h>"),
	"<parts/wchar/format-printer.h>" : ("<parts/uchar/format-printer.h>", "<parts/uchar/format-printer.h>"),
	"<parts/wchar/process.h>"        : ("<parts/uchar/process.h>",        "<parts/uchar/process.h>"),
	"<parts/wchar/stdio.h>"          : ("<parts/uchar/stdio.h>",          "<parts/uchar/stdio.h>"),
	"<parts/wchar/unistd.h>"         : ("<parts/uchar/unistd.h>",         "<parts/uchar/unistd.h>"),
	"<parts/wchar/utime.h>"          : ("<parts/uchar/utime.h>",          "<parts/uchar/utime.h>"),
});

global final WCHAR_REPLACEMENT_CHAR16 = 0; /* Replace with char16 */
global final WCHAR_REPLACEMENT_CHAR32 = 1; /* Replace with char32 */
global final WCHAR_REPLACEMENT_WIDTH: (int, int) = { 16, 32 };
global final WCHAR_REPLACEMENT_SIZE:  (int, int) = { 2, 4 };
global final WCHAR_REPLACEMENT_STR:   (string, string) = { "u", "U" };

@@Mapping of all local functions ever defined (by name)
@@Duplicate entires aren't allowed
global allWcharFunctionsByName: {string: WcharFunction} = Dict();

@@Replace a single, given @keyword with its wchar replacement
function replaceWcharTextKeyword(keyword: string, mode: int): string {
	/* Check for explicitly defined keyword replacements */
	local repl = wcharReplacementEscapes.get(keyword);
	if (repl !is none)
		return repl[mode];
	/* Check for references to other [[wchar]]-functions */
	repl = allWcharFunctionsByName.get(keyword);
	if (repl !is none) {
		/* Yes, this is a [[wchar]]-function! */
		repl = repl.wc_header_uchar[mode];
		if (repl !is none)
			return repl.name;
		repl = allWcharFunctionsByName[keyword];
		/* Complain if referencing a [[wchar]] function function some uchar
		 * variant, but no uchar variant exists for that referenced function. */
		throw Error("Missing %{{uchar{}}}-variant of [[wchar]] Function {!r}"
			.format({ WCHAR_REPLACEMENT_WIDTH[mode], repl.wc_func.name }));
	}
	if (keyword.startswith("$")) {
		if (#keyword >= 2 && keyword[1] != "$") {
			/* Replace without the leading "$" */
			local withoutDollar = keyword[1:];
			repl = replaceWcharTextKeyword(withoutDollar, mode);
			if (repl !== withoutDollar)
				return "$" + repl;
		}
	}

	/* Fallback: No replacement exists for this keyword */
	return keyword;
}

@@Replace some given wide character @text according to @mode
@@NOTE: The text generated by this function is _NOT_ _FINAL_!
@@      Whatever is returned by this function is still going to be passed
@@      through @escapeTextIntoFile, at which point further replacements
@@      may still take place!
@@@param: mode: Either @WCHAR_REPLACEMENT_CHAR16, or @WCHAR_REPLACEMENT_CHAR32
function replaceWcharText(
		text: string | CParser | UserString,
		mode: int): string | UserString {
	{
		/* Quick check: If @test is a single keyword, then we don't need a file writer and CParser */
		local usedText = text;
		if (usedText is UserString)
			usedText = usedText.text;
		if (usedText is string) {
			if (!usedText)
				return text; /* Special case: Empty string */
			/* Simple case: replace-single-keyword */
			if (usedText.issymbol()) {
				local result;
				try {
					result = replaceWcharTextKeyword(usedText, mode);
				} catch (Error as e) {
					if (text is UserString)
						text.err(e.message);
					throw;
				}
				if (result === usedText)
					result = text; /* Maintain the @UserString indirection if possible */
				return result;
			}
			/* Optimization for things such as "0", "1", etc...
			 * (very likely in case of preprocessor conditions) */
			if (usedText.isnumeric())
				return text;
		}
	}
	/* Expensive case: Must replace an entire text-block */
	local fp = File.Writer();
	local self = CParser(text);
	local flushStart = self.tokEnd;
	for (;;) {
		local tok = self.next();
		if (!tok)
			break;
		if (!tok.issymbol()) {
			if (tok.startswith('L"') || tok.startswith("L'")) {
				/* Wide-character string/char constant
				 * -> Convert to unicode character constant */
				if (flushStart < self.tokStart)
					fp << self.text[flushStart:self.tokStart];
				fp << WCHAR_REPLACEMENT_STR[mode];
				flushStart = self.tokStart + 1;
			}
			continue;
		}
		local repl;
		try {
			repl = replaceWcharTextKeyword(tok, mode);
		} catch (Error as e) {
			self.err(e.message);
		}
		/* Not replaced (NOTE: Use a same-object-check here, since
		 * @replaceWcharTextKeyword re-returns the given keyword if
		 * no replacement was performed, meaning that we don't actually
		 * have to compare the underlying strings (or rather: string)) */
		if (repl === tok)
			continue;
		/* Insert the keyword replacement */
		if (flushStart < self.tokStart)
			fp << self.text[flushStart:self.tokStart];
		fp << repl;
		flushStart = self.tokEnd;
	}
	if (flushStart < self.end)
		fp << self.text[flushStart:self.end];
	return fp.string;
}


function replaceWcharTextArray(
		textArray: {(string | CParser | UserString)...},
		mode: int): {(string | UserString)...} {
	if (!textArray)
		return textArray;
	local result = [];
	local changed = false;
	for (local text: textArray) {
		local repl = replaceWcharText(text, mode);
		if (repl !== text)
			changed = true;
		result.append(repl);
	}
	if (!changed)
		return textArray;
	return result;
}

function replaceWcharCType(self: CType, mode: int): CType {
	local oldBefore = self.beforeName;
	local oldAfter  = self.afterName;
	local newBefore = replaceWcharText(oldBefore, mode);
	local newAfter  = replaceWcharText(oldAfter, mode);
	if (newBefore === oldBefore && newAfter === oldAfter)
		return self;
	return CType(beforeName: newBefore, afterName: newAfter);
}

function replaceWcharArgument(self: Argument, mode: int): Argument {
	local oldType = self.ctype;
	local newType = replaceWcharCType(oldType, mode);
	if (newType === oldType)
		return self;
	return Argument(name: self.name, protoTypeName: self.protoTypeName, ctype: newType);
}

@@Construct a new wchar-replaced prototype from @self
function replaceWcharPrototype(self: FunctionPrototype, mode: int): FunctionPrototype {
	local result = FunctionPrototype(
		attributes: replaceWcharTextArray(self.attributes, mode),
		nothrow:    replaceWcharText(self.nothrow, mode),
		cc:         replaceWcharText(self.cc, mode),
		returnType: replaceWcharCType(self.returnType, mode),
		declPrefix: replaceWcharTextArray(self.declPrefix, mode));
	local argv = [];
	for (local a: self.argv)
		argv.append(replaceWcharArgument(a, mode));
	result.argv = argv;
	if (self.ellipsisArgumentTypes !is none) {
		local tsp = [];
		for (local x: self.ellipsisArgumentTypes)
			tsp.append(replaceWcharCType(x, mode));
		result.ellipsisArgumentTypes = tsp;
	}
	return result;
}

@@Construct a new wchar-replaced prototype from @self
function replaceWcharPrototypes(
		self: {(string | UserString, {FunctionPrototype...})...},
		mode: int): {(string | UserString, {FunctionPrototype...})...} {
	local newPrototypes = [];
	for (local ppCond, protos: self) {
		local newProtos = [];
		for (local proto: protos)
			newProtos.append(replaceWcharPrototype(proto, mode));
		newPrototypes.append((replaceWcharText(ppCond, mode), newProtos));
	}
	return newPrototypes;
}

function replaceWcharFunctionImplementation(
		self: FunctionImplementation, mode: int,
		functionName: string | UserString): FunctionImplementation {
	local result = FunctionImplementation(
		body:         replaceWcharText(self.body, mode),
		name:         functionName,
		implPrefix:   replaceWcharTextArray(self.implPrefix, mode),
		dependencies: ());
	local deps: {string: Function} = self.dependencyFunctions;
	if (deps) {
		local newDeps = [];
		for (local name, func: deps) {
			/* Replace wchar function dependencies with uchar variants */
			local wcs = allWcharFunctionsByName.get(func.name);
			if (wcs !is none) {
				func = wcs.wc_header_uchar[mode];
				if (func is none) {
					throw Error("Missing %{{uchar{}}}-variant of [[wchar]] Function {!r}"
						.format({ WCHAR_REPLACEMENT_WIDTH[mode], func.name }));
				}
			}
			newDeps.append((name, func));
		}
		result.dependencies = newDeps;
	}
	return result;
}


class XcharImplementation {
	this = default;
	public member loaderImpl: none | Callable | LoaderFunctionImplementation;     /* Implementation */
	public member prototype: FunctionPrototype;                                   /* Primary prototype */
	public member prototypes: {(string | UserString, {FunctionPrototype...})...}; /* Extended prototypes */
}

class WcharFunction {
	this = default;

	/* Wchar implementation features */
	public member wc_func: Function; /* The underlying wchar function */
	public member wc_loaderImpl: none | Callable | LoaderFunctionImplementation; /* Implementations */
	public member wc_prototype: FunctionPrototype | Callable; /* Primary prototype */
	public member wc_prototypes: {(string | UserString, {FunctionPrototype...})...} | Callable; /* Extended prototypes */
	/* The associated %{uchar16} and %{uchar32} functions (if any) */
	public member wc_header_uchar: (Function, Function) = [none, none];

	public property wcLoaderImpl: none | LoaderFunctionImplementation = {
		get(): none | LoaderFunctionImplementation {
			local result = wc_loaderImpl;
			if (result is Callable)
				result = wc_loaderImpl = result();
			return result;
		}
	}
	public property wcPrototype: FunctionPrototype = {
		get(): FunctionPrototype {
			local result = wc_prototype;
			if (result is Callable)
				result = wc_prototype = result();
			return result;
		}
	}
	public property wcPrototypes: {(string | UserString, {FunctionPrototype...})...} = {
		get(): {(string | UserString, {FunctionPrototype...})...} {
			local result = wc_prototypes;
			if (result is Callable)
				result = wc_prototypes = result();
			return result;
		}
	}

	private member m_cx_cache: {(string, int): XcharImplementation} = Dict();
	@@Return an approriate X-char implementation for the given @functionName and @mode
	public function getXCharImplementation(
			functionName: string | UserString, mode: int): XcharImplementation {
		local pair = (str(functionName), mode);
		local result = m_cx_cache.get(pair);
		if (result is none) {
			result = XcharImplementation();
			/* Convert prototypes */
			local wcPrototype = this.wcPrototype;
			local wcPrototypes = this.wcPrototypes;
			local wcLoaderImpl = this.wcLoaderImpl;
			result.prototype = replaceWcharPrototype(wcPrototype, mode);
			/* Optimization for the likely case of only a single
			 * (aliasing) prototype being defined for the prototype
			 * listing */
			if (#wcPrototypes == 1) {
				local p0 = wcPrototypes[0];
				if (p0[0] == "1") {
					p0 = p0[1];
					if (#p0 == 1 && p0[0] === wcPrototype) {
						result.prototypes = { ("1", { result.prototype }) };
						goto got_result_prototypes;
					}
				}
			}
			result.prototypes = replaceWcharPrototypes(wcPrototypes, mode);
got_result_prototypes:
			result.loaderImpl = wcLoaderImpl is none ? none : LoaderFunctionImplementation(
				impl:         replaceWcharFunctionImplementation(wcLoaderImpl.impl, mode, functionName),
				ppCond:       replaceWcharText(wcLoaderImpl.ppCond, mode),
				ppCondPrefix: replaceWcharTextArray(wcLoaderImpl.ppCondPrefix, mode));;
			m_cx_cache[pair] = result;
		}
		return result;
	}

}












