/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from deemon;
import * from .cparser;
import * from .ctype;
import * from .cvalue;

final class Checker: CParser {
	public member globalNamespace: CNamespace = CNamespace(name: "");
	@@Note: All elements except for the last are of type @CScope
	public member namespaceStack: {CNamespace...} = [globalNamespace];
	public member targetModule: Module;
	public member defaultStructPacking: int = 16;
	public member cxx: bool = true;

	this(targetModule: Module, fp: File, filename: string = "",
	     startLine: int = 1, startCol: int = 1, cxx: bool = true)
		: super(fp, filename, startLine, startCol)
	{
		this.targetModule = targetModule;
		this.cxx = cxx;
		this.TARGET_SIZEOF_POINTER = targetModule.POINTER_SIZE;
		this.TARGET_BIG_ENDIAN = false;
		this.TARGET_ENDIAN = "little";
		switch (targetModule.POINTER_SIZE) {
		case 4:
			TARGET_C_long       = C_long32;
			TARGET_C_ulong      = C_ulong32;
			TARGET_C_llong      = C_llong_align4;
			TARGET_C_ullong     = C_ullong_align4;
			TARGET_C_int128_t   = C_int128_t_align4;
			TARGET_C_uint128_t  = C_uint128_t_align4;
			TARGET_C_nullptr_t  = C_nullptr_t_32;
			TARGET_C_size_t     = C_uint;
			TARGET_CPointerType = CPointerType32;
			TARGET_C_nullptr    = C_nullptr_32;
			break;
		case 8:
			TARGET_C_long       = C_long64;
			TARGET_C_ulong      = C_ulong64;
			TARGET_C_llong      = C_llong_align8;
			TARGET_C_ullong     = C_ullong_align8;
			TARGET_C_int128_t   = C_int128_t_align8;
			TARGET_C_uint128_t  = C_uint128_t_align8;
			TARGET_C_nullptr_t  = C_nullptr_t_64;
			TARGET_C_size_t     = C_ulong64;
			TARGET_CPointerType = CPointerType64;
			TARGET_C_nullptr    = C_nullptr_64;
			break;
		default:
			this.err(f"Unsupported POINTER_SIZE: {repr targetModule.POINTER_SIZE}");
			break;
		}
		switch (targetModule.CPUNAME) {
		case "i686":
			TARGET_C_ldouble = C_ldouble_12;
			break;
		case "x86_64":
			TARGET_C_ldouble = C_ldouble_16;
			break;
		case "arm":
			TARGET_C_ldouble = C_double;
			break;
		default:
			this.err(f"Unknown cpu: {repr targetModule.CPUNAME}");
			break;
		}
		this.next();
	}

	/* Target-specific types */
	public member TARGET_C_long: CType;
	public member TARGET_C_ulong: CType;
	public member TARGET_C_llong: CType;
	public member TARGET_C_ullong: CType;
	public member TARGET_C_int128_t: CType;
	public member TARGET_C_uint128_t: CType;
	public member TARGET_C_nullptr_t: CType;
	public member TARGET_C_ldouble: CType;
	public member TARGET_C_size_t: CType;
	public member TARGET_CPointerType: Type;
	public member TARGET_SIZEOF_POINTER: int;
	public member TARGET_BIG_ENDIAN: bool;
	public member TARGET_ENDIAN: string;
	public member TARGET_C_nullptr: CValue;

	/* Context variables */

	@@The function whose body is currently being parsed
	public  member currentFunctionName: string | none = none;
	public  member currentFunctionTypeRef: CTypeRef | none = none;
	@@Set to @false until a return-statement is encountered
	private member currentFunctionReturnValue: Bytes | none | bool = false;

	private member isInExternC: bool = false;         /* True inside of an extern-C block */
	private member isInSwitchStatement: bool = false; /* True inside of a switch-statement */
	private member isInLoop: bool = false;            /* True inside of a loop-statement */
	public  member isUnreachable: bool = false;       /* True inside of dead code */
	private member switchIsUnreachable: bool = false; /* True inside of an unreachable switch-statement */
	private member encounteredBreak: bool = false;    /* True if `break' was encountered */
	private member switchConstantExpressionValue: Bytes | none = none;


	@@@param tab: One of:
	@@            - @"symbols": CSymbol
	@@            - @"typedefs": CTypeRef
	@@            - @"namespaces": CNamespace
	@@            - @"structSymbols": CStructType
	@@            - @"unionSymbols": CStructType
	@@            - @"enumSymbols": CEnumType
	function lookup(tab: string, name: string): Object | none {
		for (local ns: namespaceStack) {
			local result = ns.lookup(tab, name);
			if (result !is none)
				return result;
		}
		return none;
	}

	@@Lookup the symbol value override for lvalue @name
	function getSymbolValue(name: string): CValue | none {
		for (local ns: namespaceStack) {
			local symbol: CSymbol | none = ns.symbols.get(name);
			if (symbol !is none)
				return cvalueFromSymbol(symbol);
			local override: CValue | none = ns.symbolValues.get(name);
			if (override !is none)
				return override;
		}
		return none;
	}

	@@Parse a a child-namespace lookup expression chain
	@@@return @none if not found, but only when @errorIfNotFound is false.
	@@        When @none is returned, the parser is NOT rewound to the start
	@@        of the non-present symbol expression! (if needed, this has  to
	@@        be done by the caller)
	function nsLookupChildChain(ns: CNamespace, tab: string,
	                            errorIfNotFound: bool = true): Object | none {
again:
		local name = this.tok;
		if (!name.issymbol())
			this.err(f"Expected symbol in namespace symbol expression, but got {repr name}");
		if (this.next() == "::" && cxx) {
			ns = ns.lookup("namespaces", name);
			if (ns is none) {
				if (errorIfNotFound)
					return this.err(f"Unknown namespace {repr name}");
				return none;
			}
			this.next();
			goto again;
		}
		local result = ns.lookup(tab, name);
		if (result is none && errorIfNotFound)
			this.err(f"Unknown symbol in namespace {repr name}");
		return result;
	}

	@@Parse a namespace lookup expression, returning @none if nothing was parsed
	function nsLookupChain(tab: string): Object | none {
		local name = this.tok;
		if (name == "::" && cxx) {
			/* Root-namespace-relative symbol lookup */
			this.next();
			return nsLookupChildChain(globalNamespace, tab);
		}
		if (!name.issymbol())
			return none;
		local backup = this.backupCreate();
		try {
			local result;
			if (this.next() == "::" && cxx) {
				/* Lookup chain */
				local baseNs = lookup("namespaces", name);
				if (baseNs is none) {
					this.backupRestore(backup);
					return this.err(f"Unknown namespace {repr name}");
				}
				this.next();
				result = nsLookupChildChain(baseNs, tab, errorIfNotFound: false);
			} else {
				result = lookup(tab, name);
			}
			if (result is none) {
				this.backupRestore(backup);
			} else {
				this.backupDiscard(backup);
			}
			return result;
		} catch (...) {
			this.backupDiscard(backup);
			throw;
		}
	}

	function parseCTypeRefAttribute(tr: CTypeRef) {
again:
		local attributeName = this.requireSymbolName().strip("_");
		switch (attributeName) {

		case "checker":
			this.skip("::");
			goto again;

		case "packed":
			tr.flags |= CTYPEREF_FLAG_PACKED;
			this.next();
			break;

		case "force":
			tr.flags |= CTYPEREF_FLAG_FORCE;
			this.next();
			break;

		case "noreturn":
			tr.flags |= CTYPEREF_FLAG_NORETURN;
			this.next();
			break;

		case "deref":
			tr.flags = (tr.flags & ~CTYPEREF_FLAG_NODEREF) | CTYPEREF_FLAG_DEREF;
			this.next();
			break;

		case "noderef":
			if (!(tr.flags & CTYPEREF_FLAG_DEREF))
				tr.flags |= CTYPEREF_FLAG_NODEREF;
			this.next();
			break;

		case "nothrow": {
			local isStar = false;
			this.next();
			this.skip("(");
			if (this.tok == "*") {
				isStar = true;
				this.next();
			}
			local level: int = parseExprConstantInteger();
			local mode = isStar ? f"*{level}" : f"{level}";
			tr.attrib["nothrow"] = mode;
			this.skip(")");
		}	break;

		case "tag":
		case "require_caller_tag": {
			this.next();
			this.skip("(");
			tr.attrib[attributeName] = this.parseString();
			this.skip(")");
		}	break;

		case "aligned":
			this.next();
			this.skip("(");
			tr.attrib[attributeName] = parseExprConstantInteger();
			this.skip(")");
			break;

		default:
			this.err(f"Unknown attribute `{attributeName}'");
		}
	}

	function parseCTypeRefAttributes(tr: CTypeRef): bool {
		local result = false;
again:
		switch (this.tok) {

		case "alignas":
		case "_Alignas":
			if (this.tok != (cxx ? "alignas" : "_Alignas"))
				break;
			this.next();
			this.skip("(");
			tr.attrib["aligned"] = parseExprConstantInteger();
			this.skip(")");
			result = true;
			goto again;

		case "[":
			this.next();
			this.skip("[");
			while (this.tok != "]") {
				parseCTypeRefAttribute(tr);
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip("]");
			this.skip("]");
			result = true;
			goto again;

		case "__attribute":
		case "__attribute__":
			this.next();
			this.skip("(");
			this.skip("(");
			while (this.tok != ")") {
				parseCTypeRefAttribute(tr);
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip(")");
			this.skip(")");
			result = true;
			goto again;

		default: break;
		}
		return result;
	}

	function parseCTypeRefConstVolatile(tr: CTypeRef): bool {
		local result = false;
again:
		switch (this.tok) {

		case "const":
		case "__const":
		case "__const__":
		case "volatile":
		case "__volatile":
		case "__volatile__":
		case "restrict":
		case "__restrict":
		case "__restrict__":
			tr.flags |= {
				"const":    CTYPEREF_FLAG_CONST,
				"volatile": CTYPEREF_FLAG_VOLATILE,
				"restrict": CTYPEREF_FLAG_RESTRICT,
			}[this.tok.strip("_")];
			this.next();
			result = true;
			goto again;

		default: break;
		}
		if (parseCTypeRefAttributes(tr)) {
			result = true;
			goto again;
		}
		return result;
	}

	private member _anonStructMemberId: int = 0;
	function parseStructMembers(tr: CTypeRef, fields: {(CTypeRef, string)...}) {
again:
		switch (this.tok) {

		case "":
		case "}":
			break;

		case ";":
			this.next();
			goto again;

		case "public":
		case "private":
		case "protected":
			if (!cxx)
				goto default_case;
			this.next();
			this.skip(":");
			goto again;

		default: {
			local fieldType: CTypeRef;
			local fieldName: string;
default_case:
			fieldType, fieldName = parseTypeRefWithoutStorageClass()...;
			if (this.tok == ":") {
				/* Bit fields */
				this.next();
				/* XXX: Actually support? */
				parseExprConstantInteger();
			}
			if (!fieldName && fieldType.typ !is CStructType) {
				fieldName = f"__anon_struct_member_{_anonStructMemberId}";
				++_anonStructMemberId;
			}
			if (fieldName) {
				for (local none, existingName: fields) {
					if (fieldName == existingName)
						this.err(f"Duplicate field {repr fieldName} in struct type");
				}
				tr.typ.fieldsByDeclarationOrder.append((fieldType, fieldName));
			}
			fields.append((fieldType, fieldName));
			this.skip(";");
			goto again;
		}	break;

		}
	}

	function parseStruct(tr: CTypeRef, isUnion: bool): CStructType {
		local structName = "";
		if (this.tok.issymbol()) {
			structName = this.parseSymbolName();
			parseCTypeRefAttributes(tr);
		}
		local struct: CStructType;
		if (structName) {
			local tab = namespaceStack.first.operator . (isUnion ? "unionSymbols" : "structSymbols");
			struct = tab.get(structName);
			if (struct is none) {
				struct = CStructType(name: structName);
				tab[structName] = struct;

				/* C++ also requires us to put the type into the typedefs table. */
				if (cxx) {
					local typedefs = namespaceStack.first.typedefs;
					if (structName !in typedefs)
						typedefs[structName] = CTypeRef(typ: struct);
				}
			} else {
				parseCTypeRefAttributes(tr);
				if (this.tok != "{" && (!cxx || this.tok != ":")) {
					tr.typ = struct;
					return struct;
				}
				this.err(f"redeclaration of struct type {repr structName}");
			}
		} else {
			struct = CStructType(name: structName);
		}
		tr.typ = struct;
		parseCTypeRefAttributes(tr);
		if (this.tok == ":" && !isUnion && cxx) {
			/* C++ class/struct bases. */
			this.next();
			if (this.tok in ["private", "public"])
				this.next();
			local typedef = nsLookupChain("typedefs");
			if (typedef is none)
				this.err("No such struct base type");
			if (typedef.typ !is CStructType)
				this.err(f"Expected struct-type for struct base, but got {typedef}");
			struct.base = typedef.typ;
		} else {
			if (this.tok != "{")
				return struct;
		}
		this.skip("{");
		local fields: {(CTypeRef, string)...} = [];
		parseStructMembers(tr, fields);
		this.skip("}");
		parseCTypeRefAttributes(tr);

		/* Calculate struct field offsets */
		local structAlign: int | none = tr.attrib.get("aligned");
		if (structAlign is none)
			structAlign = defaultStructPacking;
		if (tr.flags & CTYPEREF_FLAG_PACKED)
			structAlign = 1;
		local fieldOffset: int = 0;
		if (struct.base !is none)
			fieldOffset = struct.base.sizeof;
		for (local fieldType, fieldName: fields) {
			if (!isUnion) {
				local fieldAlign = fieldType.attrib.get("aligned");
				if (fieldAlign is none)
					fieldAlign = fieldType.typ.alignof;
				if (structAlign !is none) {
					if (fieldAlign > structAlign)
						fieldAlign = structAlign;
				}
				if (fieldType.flags & CTYPEREF_FLAG_PACKED)
					fieldAlign = 1;
				fieldOffset = (fieldOffset + fieldAlign - 1) & -fieldAlign;
			}
			if (!fieldName && fieldType.typ is CStructType) {
				/* Anonymous union/struct */
				for (local innerFieldName, innerFieldType, innerFieldOffset: fieldType.foreachField) {
					if (innerFieldName in struct.fields)
						this.err(f"Anonymous struct field `{innerFieldName}' redeclared");
					struct.fields[innerFieldName] = (innerFieldType, innerFieldOffset + fieldOffset);
				}
			} else {
				struct.fields[fieldName] = (fieldType, fieldOffset);
			}
			if (!isUnion)
				fieldOffset += fieldType.sizeof;
		}
		if (structAlign !is none) {
			local finalStructAlign = tr.attrib.get("aligned");
			if (finalStructAlign is none)
				finalStructAlign = structAlign;
			struct._alignof = finalStructAlign;
		}
		return struct;
	}

	function parseEnumMembers(ns: CNamespace, valueType: CTypeRef) {
		local prevEnumConstantValue: int = 0;
		while (this.tok != "}") {
			local enumName = this.parseSymbolName();
			local enumValue: int;
			if (this.tok == "=") {
				enumValue = parseExprConstantInteger();
			} else {
				enumValue = prevEnumConstantValue + 1;
			}
			if (enumName in ns.symbols)
				this.err(f"Symbol `{enumName}' has already been defined");
			ns.symbols[enumName] = CSymbol(valueType, enumValue);
			prevEnumConstantValue = enumValue;
		}
	}

	function parseEnum(tr: CTypeRef, isUnion: bool): CEnumType | CEnumClassType {
		local enumType: Type = CEnumType;
		if (this.tok == "class" && cxx) {
			enumType = CEnumClassType;
			this.next();
			parseCTypeRefAttributes(tr);
		}
		local enumName: string = "";
		if (this.tok.issymbol()) {
			enumName = this.parseSymbolName();
			parseCTypeRefAttributes(tr);
		}
		local enum: CEnumType | CEnumClassType;
		if (enumName) {
			local tab = namespaceStack.first.enumSymbols;
			enum = tab.get(enumName);
			if (enum is none) {
				enum = enumType(name: enumName);
				tab[enumName] = enum;

				/* C++ also requires us to put the type into the typedefs table. */
				if (cxx) {
					local typedefs = namespaceStack.first.typedefs;
					if (enumName !in typedefs)
						typedefs[enumName] = CTypeRef(typ: enum);
					if (enumType === CEnumClassType) {
						/* Since enum classes are also namespaces, must
						 * also register the type as a child-namespace! */
						local namespaces = namespaceStack.first.namespaces;
						if (enumName !in namespaces)
							namespaces[enumName] = enumType;
					}
				}
			} else {
				parseCTypeRefAttributes(tr);
				if (this.tok != "{" && (!cxx || this.tok != ":")) {
					tr.typ = enum;
					return enum;
				}
				this.err(f"redeclaration of enum type {repr enumName}");
			}
		} else {
			enum = enumType(name: enumName);
		}
		local baseType: CTypeRef;
		if (this.tok == ":" && cxx) {
			/* C++ enum base. */
			this.next();
			baseType = parseTypeRef("-", "-").first;
			if (baseType.typ !is CCoreType)
				this.err(f"Expected core-type for enum base, but got {baseType}");
			enum.base = baseType.typ;
		} else {
			if (this.tok != "{")
				return enum;
			baseType = CTypeRef(enum.base);
		}
		this.skip("{");
		if (enumType === CEnumClassType) {
			parseEnumMembers(enum, baseType);
		} else {
			parseEnumMembers(namespaceStack.first, baseType);
		}
		this.skip("}");
		parseCTypeRefAttributes(tr);
		return enum;
	}

	function parseStorageClass(): string {
		local result = this.tok;
		if (result in ["static", "register", "auto", "extern", "typedef"]) {
			this.next();
			return result;
		}
		return "";
	}

	@@Parse a type base reference
	@@@return @none if no type was parsed, else the type itself (also stored in @tr.typ)
	function parseCTypeRefBase(tr: CTypeRef): CType | none {
		local hasCv = parseCTypeRefConstVolatile(tr);
		local intFlags = 0;
#define BASETYPE_FLAG_SIGNED    0x0001 /* FLAG: `signed' was given */
#define BASETYPE_FLAG_UNSIGNED  0x0002 /* FLAG: `unsigned' was given */
#define BASETYPE_FLAG_SIGNMASK  0x0003 /* Mask for explicit sign prefix. */
#define BASETYPE_FLAG_INT       0x0004 /* FLAG: Explicit `int' was given. */
#define BASETYPE_FLAG_CHAR      0x0010 /* FLAG: `char' was given. */
#define BASETYPE_FLAG_SHORT     0x0020 /* FLAG: `short' was given. */
#define BASETYPE_FLAG_LONG      0x0030 /* FLAG: `long' was given. */
#define BASETYPE_FLAG_LLONG     0x0040 /* FLAG: `long long' was given. */
#define BASETYPE_FLAG_INT8      0x0050 /* FLAG: `__int8' was given. */
#define BASETYPE_FLAG_INT16     0x0060 /* FLAG: `__int16' was given. */
#define BASETYPE_FLAG_INT32     0x0070 /* FLAG: `__int32' was given. */
#define BASETYPE_FLAG_INT64     0x0080 /* FLAG: `__int64' was given. */
#define BASETYPE_FLAG_INT128    0x0090 /* FLAG: `__int128' was given. */
#define BASETYPE_FLAG_WIDTHMASK 0x00f0 /* MASK: Explicit width was given. */
again:
		switch (this.tok) {

		case "signed":
		case "__signed":
		case "__signed__":
		case "unsigned":
		case "__unsigned":
		case "__unsigned__":
			if (intFlags & BASETYPE_FLAG_SIGNMASK)
				this.err("Duplicate 'signed' or 'unsigned' in type-expression");
			intFlags |= "unsigned" in this.tok ? BASETYPE_FLAG_UNSIGNED : BASETYPE_FLAG_SIGNED;
			this.next();
			goto again;

		case "int":
			if (intFlags & BASETYPE_FLAG_INT)
				this.err("Duplicate 'int' in type-expression");
			intFlags |= BASETYPE_FLAG_INT;
			this.next();
			goto again;

		case "char":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK)
				this.err("Duplicate width-keyword in type-expression");
			intFlags |= BASETYPE_FLAG_CHAR;
			this.next();
			goto again;

		case "short":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK)
				this.err("Duplicate width-keyword in type-expression");
			intFlags |= BASETYPE_FLAG_SHORT;
			this.next();
			goto again;

		case "long":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK) {
				if ((intFlags & BASETYPE_FLAG_WIDTHMASK) != BASETYPE_FLAG_LONG)
					this.err("Duplicate width-keyword in type-expression");
				intFlags &= ~BASETYPE_FLAG_WIDTHMASK;
				intFlags |= BASETYPE_FLAG_LLONG;
			} else {
				intFlags |= BASETYPE_FLAG_LONG;
			}
			this.next();
			goto again;

		case "__int8":
		case "__int16":
		case "__int32":
		case "__int64":
		case "__int128":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK)
				this.err("Duplicate width-keyword in type-expression");
			intFlags |= {
				"__int8"   : BASETYPE_FLAG_INT8,
				"__int16"  : BASETYPE_FLAG_INT16,
				"__int32"  : BASETYPE_FLAG_INT32,
				"__int64"  : BASETYPE_FLAG_INT64,
				"__int128" : BASETYPE_FLAG_INT128,
			}[this.tok];
			this.next();
			goto again;

		case "class":
			if (!cxx)
				goto default_case;
			/* FALLTHRU */
		case "struct":
		case "union": {
			local isUnion = this.tok == "union";
			if (intFlags)
				this.err("struct/union/class with integer keyword");
			this.next();
			parseCTypeRefAttributes(tr);
			parseStruct(tr, isUnion);
		}	break;

		case "enum": {
			if (intFlags)
				this.err("enum with integer keyword");
			this.next();
			parseCTypeRefAttributes(tr);
			parseEnum(tr);
		}	break;

		case "double":
			if (intFlags) {
				if (intFlags != BASETYPE_FLAG_LONG)
					this.err("double with integer keyword");
				tr.typ = TARGET_C_ldouble;
				this.next();
			} else {
				this.next();
				if (this.tok == "long") {
					this.next();
					tr.typ = TARGET_C_ldouble;
				} else {
					tr.typ = C_double;
				}
			}
			break;

		case "decltype":
			if (!cxx)
				goto default_case;
			/* FALLTHRU */
		case "typeof":
		case "__typeof":
		case "__typeof__":
			this.next();
			this.skip("(");
			tr.typ = parseTypeOrExpressionType().typ;
			this.skip(")");
			break;

		default: {
default_case:
			if (intFlags) {
				/* Integer core type */
				local typ;
				switch (intFlags & BASETYPE_FLAG_WIDTHMASK) {
				case BASETYPE_FLAG_CHAR:   typ = C_char; break;
				case BASETYPE_FLAG_SHORT:  typ = C_short; break;
				case BASETYPE_FLAG_LONG:   typ = TARGET_C_long; break;
				case BASETYPE_FLAG_LLONG:  typ = TARGET_C_llong; break;
				case BASETYPE_FLAG_INT8:   typ = C_schar; break;
				case BASETYPE_FLAG_INT16:  typ = C_short; break;
				case BASETYPE_FLAG_INT32:  typ = C_int; break;
				case BASETYPE_FLAG_INT64:  typ = TARGET_C_llong; break;
				case BASETYPE_FLAG_INT128: typ = TARGET_C_int128_t; break;
				default: typ = C_int; break;
				}
				switch (intFlags & BASETYPE_FLAG_SIGNMASK) {
				case BASETYPE_FLAG_SIGNED:
					if (typ === C_char)
						typ = C_schar;
					break;
				case BASETYPE_FLAG_UNSIGNED:
					typ = C_UNSIGNED[typ];
					break;
				default: break;
				}
				tr.typ = typ;
				break;
			}

			/* Single-keyword integer core types */
			local typ = SINGLE_KEYWORD_CORE_TYPES.get(this.tok);
			if (typ !is none) {
				this.next();
				tr.typ = typ;
				break;
			}

			/* Lookup a typedef */
			local typedef = nsLookupChain("typedefs");
			if (typedef is none) {
				if (hasCv)
					this.err("Unable to parse type after const/volatile");
				return none;
			}
			tr.importFrom(typedef);
		}	break;

		}
		parseCTypeRefConstVolatile(tr);
		return tr.typ;
	}

	function parseTypeRefWithoutStorageClass(): (CTypeRef, string) {
		local tr, nam, sc = parseTypeRef(storageClass: "-")...;
		if (sc != "-")
			this.err(f"Storage class {repr sc} is invalid in this context");
		return (tr, nam);
	}

	function parseTypeRefInnerSuffix(tr: CTypeRef) {
suffixAgain:
		switch (this.tok) {

		case "(": {
			this.next();
			local func = CFunctionType(returnType: tr.typ);
			while (this.tok != ")") {
				if (this.tok == "...") {
					func.isVarArgs = true;
					this.next();
					break;
				}
				local typ, nam = parseTypeRefWithoutStorageClass()...;
				if (typ.typ === C_void && !nam)
					break;
				func.args.append((typ, nam));
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip(")");
			tr.typ = func;
			goto suffixAgain;
		}

		case "[": {
			this.next();
			local dim: int | none;
			if (this.tok == "]") {
				dim = none;
			} else if (currentFunctionName is none) {
				dim = parseExprConstantInteger();
			} else {
				/* Outside the global namespace, the dimension expression may
				 * be  non-constant to indicate a VLA array. In order to keep
				 * things simple, we treat these kinds of arrays as  flexible
				 * arrays. */
				local dimExpr: CValue = parseExprRValue();
				if (dimExpr.isConstExpr) {
					dim = dimExpr.constExprValue;
				} else {
					dim = none;
				}
			}
			local baseType: CType = tr.typ;
			local itemAlign: int = tr.attrib.get("aligned", baseType.alignof);
			if (tr.flags & CTYPEREF_FLAG_PACKED)
				itemAlign = 1;
			local stride: int = (baseType.sizeof + itemAlign) & -itemAlign;
			tr.typ = CArrayType(baseType, dim, stride);
			this.skip("]");
			goto suffixAgain;
		}

		default: break;
		}
	}

	@@Parse everything after the base-expression of a C-type
	function parseTypeRefInner(tr: CTypeRef, name: string = ""): (CTypeRef, string) {
		/* Parse the inner type-ref prefix (iow: pointer types) */
prefixAgain:
		if (this.tok == "*") {
			this.next();
			local pt: CPointerType;
			switch (this.tok) {
			case "__ptr32":
				this.next();
				pt = CPointerType32(base: tr);
				break;
			case "__ptr64":
				this.next();
				pt = CPointerType64(base: tr);
				break;
			default:
				pt = TARGET_CPointerType(base: tr);
				break;
			}
			tr = CTypeRef(typ: pt);
			parseCTypeRefConstVolatile(tr);
			goto prefixAgain;
		}
		parseCTypeRefAttributes(tr);

		local result;
		if (this.tok == "(") {
			this.next();
			result = parseTypeRefInner(tr, name);
			this.skip(")");
		} else {
			/* Parse variable name */
			if (!name && this.tok.issymbol()) {
				name = this.tok;
				this.next();
			}
			result = (tr, name);
		}

		/* Parse type suffix expressions */
		do {
			parseTypeRefInnerSuffix(tr);
		} while (parseCTypeRefAttributes(tr));
		return result;
	}

	@@Parse a type reference and return (type, name, storage-class)
	function parseTypeRef(name: string = "",
	                      storageClass: string = "",
	                      tryParse: bool = false)
			: (CTypeRef, string, string) | none {
		if (!storageClass)
			storageClass = parseStorageClass();
		local tr = CTypeRef();
		if (parseCTypeRefBase(tr) is none) {
			if (tryParse && !storageClass)
				return none;
			this.err(f"Cannot parse type from {repr this.tok}");
		}
		if (!storageClass)
			storageClass = parseStorageClass();
		tr, name = parseTypeRefInner(tr, name)...;
		return (tr, name, storageClass);
	}

	function parseDeclaration(storageClass: string = "", tryParse: bool = false): bool {
		local typeref, name;
		typeref, name, storageClass = parseTypeRef("", storageClass, tryParse)...;
		if (typeref is none)
			return false;
		if (!name)
			return true;
		//print "parse: ", repr storageClass, typeref.tostr(name);

		/* Create a typedef/symbol for the parsed declaration. */
		if (storageClass == "typedef") {
			local tab: {string: CTypeRef} = namespaceStack.first.typedefs;
			local existingDecl: CTypeRef = tab.get(name);
			if (existingDecl is none) {
				tab[name] = typeref;
			} else {
				if (typeref == existingDecl) {
					/* Ignore typedef re-declaration where the new type matches the old */
				} else {
					this.err(f"redeclaration of {tab[:-1]} {repr name}");
				}
			}
			this.skip(";");
			return true;
		}

		/* Handle symbol assembly names. */
		if (this.tok in ["asm", "__asm", "__asm__"]) {
			this.next();
			this.skip("(");
			this.parseString();
			this.skip(")");
		}

		local tab: {string: CSymbol} = namespaceStack.first.symbols;
		local decl: CSymbol | none = tab.get(name);
		if (decl !is none) {
			/* Special case for function overloads. */
			if (typeref.typ is CFunctionType && this.tok != ";" && !isInExternC && cxx) {
				local overload: CSymbol;
				if (decl is COverloadedFunctionSymbol) {
					overload = decl.getOrCreateOverload(typeref);
				} else if (decl.typeref.equalsForRedeclaration(typeref)) {
					overload = decl;
				} else {
					/* Initial overload given */
					local overloadsDecl: COverloadedFunctionSymbol = COverloadedFunctionSymbol();
					overloadsDecl.overloads.append(decl);
					decl = CSymbol(typeref);
					overloadsDecl.overloads.append(decl);
					namespaceStack.first.symbols[name] = overloadsDecl;
				}
				this.skip("{");
				decl.val = parseFunctionBody(typeref, name);
				this.skip("}");
				return true;
			}
			if (decl.typeref.equalsForRedeclaration(typeref) &&
			    namespaceStack.first === globalNamespace) {
				/* Ignore re-declaration where the new type matches the old */
				decl.typeref.importFrom(typeref);
			} else {
				this.err(f"redeclaration of `{decl.typeref.tostr(name)}' "
				         f"as `{typeref.tostr(name)}'");
			}
			if (decl.val is bound) {
				/* Symbol already had a value assigned. */
				this.skip(";");
				return true;
			}
		} else {
			decl = CSymbol(typeref: typeref);
			tab[name] = decl;
		}

		if (this.tok == ";") {
			this.next();
			return true;
		}

		/* Must parse an initializer/function-body for the declaration. */
		if (typeref.typ is CFunctionType) {
			this.skip("{");
			decl.val = parseFunctionBody(typeref, name);
			this.skip("}");
		} else {
			this.skip("=");
			local val = parseTypedExpr(typeref);
			if (!isUnreachable) {
				/* Override the declaration's type so pointer attributes are inherited
				 * >> void foo(USER CHECKED void *p) {
				 * >>     void *x = p; // Here, `x' automatically inherits pointer attributes from `p'
				 * >> } */
				decl.typeref = val.typeref;
				decl.val     = val;
			}
			this.skip(";");
		}
		return true;
	}

	@@Returns the function's return value
	function parseFunctionBody(funTypRef: CTypeRef, name: string): Bytes | none {
		/* Push a namespace for the function's body. */
		local fnScope: CScope = CScope();
		fnScope.name = name;

		/* Define local symbols for each of the function's arguments. */
		for (local argTypeRef, argName: funTypRef.typ.args) {
			if (!argName)
				continue;
			fnScope.symbols[argName] = CSymbol(argTypeRef, none);
		}

		/* Setup the context for evaluation of the function body */
		namespaceStack.pushfront(fnScope);
		local savedCurrentFunctionName        = currentFunctionName;
		local savedCurrentFunctionTypeRef     = currentFunctionTypeRef;
		local savedCurrentFunctionReturnValue = currentFunctionReturnValue;
		currentFunctionName        = name;
		currentFunctionTypeRef     = funTypRef;
		currentFunctionReturnValue = false;

		/* Parse the function body. */
		parseStatements();

		/* Eval a constant return value */
		local result = currentFunctionReturnValue;
		if (result === false)
			result = none;

		/* Restore context */
		currentFunctionName        = savedCurrentFunctionName;
		currentFunctionTypeRef     = savedCurrentFunctionTypeRef;
		currentFunctionReturnValue = savedCurrentFunctionReturnValue;
		namespaceStack.popfront();
		return result;
	}

	function parseGCCAssemblyArgument() {
		if (this.tok == "[") {
			this.next();
			this.parseSymbolName();
			this.skip("]");
		}
		this.parseString();
		this.skip("(");
		parseExpr();
		this.skip(")");
	}

	function parseGCCAssemblyArguments() {
		if (!this.tok.startswith(":")) {
			for (;;) {
				parseGCCAssemblyArgument();
				if (this.tok != ",")
					break;
				this.next();
			}
		}
	}

	function parseGCCAssemblyStatement() {
		/* Local assembly */
		if (this.next() in ["volatile", "__volatile", "__volatile__"])
			this.next();
		local hasGoto = this.tok == "goto";
		if (hasGoto)
			this.next();
		this.skip("(");
		this.parseString();
		if (this.tok.startswith(":")) {
			this.makeSingleCharacterToken();
			this.next();
			/* output arguments */
			parseGCCAssemblyArguments();
			if (this.tok.startswith(":")) {
				this.makeSingleCharacterToken();
				this.next();
				/* input arguments */
				parseGCCAssemblyArguments();
				if (this.tok.startswith(":")) {
					this.makeSingleCharacterToken();
					this.next();
					/* Clobber list */
					if (this.tok.startswith('"')) {
						for (;;) {
							this.parseString();
							if (this.tok != ",")
								break;
							this.next();
						}
					}
					if (hasGoto && this.tok.startswith(":")) {
						this.makeSingleCharacterToken();
						this.next();
						/* Label list */
						if (this.tok.issymbol()) {
							for (;;) {
								this.next();
								if (this.tok != ",")
									break;
								this.next();
								if (!this.tok.issymbol())
									this.err(f"Expected label in asm goto, but got {repr this.tok}");
							}
						}
					}
				}
			}
		}
		this.skip(")");
		this.skip(";");
	}

	function parseStatement() {
again:
		switch (this.tok) {

		case "":
		case "}":
			break;

		case ";":
			this.next();
			break;

		case "{":
			this.next();
			namespaceStack.pushfront(CScope(
					/* Can just re-use the parent scope's symbol value overrides */
					symbolValues: namespaceStack.first.symbolValues));
			parseStatements();
			namespaceStack.popfront();
			this.skip("}");
			break;

		case "case":
		case "default":
			if (!isInSwitchStatement)
				this.err("`case' or `default' outside of switch-statement");
			this.next();
			if (this.tok == "case") {
				local caseValue: CValue = parseExprConstant();
				if (switchConstantExpressionValue !is none && !switchIsUnreachable) {
					/* When the switch-expression is constant, only
					 * disable unreachable if  case matches  switch */
					if (switchConstantExpressionValue == caseValue.constExprValue(this)) {
						isUnreachable = false;
					}
					this.skip(":");
					goto again;
				}
			}
			this.skip(":");
			if (!switchIsUnreachable)
				isUnreachable = false;
			goto again;

		case "goto":
			this.next();
			if (this.tok == "*") {
				/* For addressable labels. */
				this.next();
				this.parseExpr();
			} else {
				this.parseSymbolName();
			}
			this.skip(";");
			isUnreachable = true;
			break;

		case "break":
			if (isInLoop) {
				if (!isUnreachable)
					encounteredBreak = true;
			} else if (!isInSwitchStatement) {
				this.err("`break' outside of loop or switch");
			}
			this.next();
			this.skip(";");
			isUnreachable = true;
			break;

		case "continue":
			if (!isInLoop)
				this.err("`continue' outside of loop");
			this.next();
			this.skip(";");
			isUnreachable = true;
			break;

		case "asm":
		case "__asm":
		case "__asm__":
			parseGCCAssemblyStatement();
			break;

		case "switch": {
			this.next();
			this.skip("(");
			local savedSwitchConstantExpressionValue = switchConstantExpressionValue;
			local switchExpr = parseExprRValue();
			switchConstantExpressionValue = none;
			switchConstantExpressionValue = switchExpr.data;
			this.skip(")");
			this.require("{");

			local savedIsInSwitchStatement = isInSwitchStatement;
			local savedSwitchIsUnreachable = switchIsUnreachable;
			isInSwitchStatement = true;
			switchIsUnreachable = isUnreachable;
			if (isUnreachable) {
				parseStatement();
			} else {
				/* Switch statement contents are unreachable until a case/default label is hit. */
				isUnreachable = true;
				parseStatement();
				isUnreachable = false;
			}

			isInSwitchStatement = savedIsInSwitchStatement;
			switchIsUnreachable = savedSwitchIsUnreachable;
			switchConstantExpressionValue = savedSwitchConstantExpressionValue;
		}	break;

		case "if": {
			this.next();
			this.skip("(");
			local ifVal: CValue = parseExprRValue();
			this.skip(")");
			if (isUnreachable) {
				parseStatement();
				if (this.tok == "else") {
					this.next();
					parseStatement();
				}
			} else if (ifVal.isConstExpr) {
				if (ifVal.constExprValue) {
					parseStatement();
					if (this.tok == "else") {
						this.next();
						local savedIsUnreachable = isUnreachable;
						isUnreachable = true;
						parseStatement();
						isUnreachable = savedIsUnreachable;
					}
				} else {
					isUnreachable = true;
					parseStatement();
					isUnreachable = false;
					if (this.tok == "else") {
						this.next();
						parseStatement();
					}
				}
			} else {
				/* Configure the expression value engine such that
				 * it  maintains identical values from both sides. */
				local ttScope = CScope();
				namespaceStack.pushfront(ttScope);
				parseStatement();
				namespaceStack.popfront();
				if (this.tok == "else") {
					local ttIsNoReturn = isUnreachable;
					this.next();
					local ffScope = CScope();
					namespaceStack.pushfront(ffScope);
					isUnreachable = false;
					parseStatement();
					namespaceStack.popfront();
					if (!ttIsNoReturn)
						isUnreachable = false;
					local parentScope: CScope = namespaceStack.first;
					local ttOverrides: {string: CValue} = ttScope.symbolValues;
					local ffOverrides: {string: CValue} = ffScope.symbolValues;
					local allNames: {string...} = HashSet(ttOverrides);
					allNames.insertall(ffOverrides);
					for (local name: allNames) {
						local ttValue = ttOverrides.get(name);
						local ffValue = ffOverrides.get(name);
						if (ttValue is none)
							ttValue = getSymbolValue(name);
						if (ffValue is none)
							ffValue = getSymbolValue(name);
						if (ttValue is none || ffValue is none) {
							ttValue = none;
						} else if (ttValue != ffValue) {
							ttValue = none;
						}
						parentScope.setSymbolValue(name, ttValue);
					}
				}
			}
		}	break;

		case "while": {
			this.next();
			this.skip("(");
			local whileVal: CValue = parseExprRValue();
			this.skip(")");
			local savedIsInLoop         = isInLoop;
			local savedEncounteredBreak = encounteredBreak;
			isInLoop         = true;
			encounteredBreak = false;
			if (isUnreachable) {
				parseStatement();
			} else if (whileVal.isConstExpr && !whileVal.constExprValue) {
				/* Loop condition is never true -> loop body is dead */
				isUnreachable = true;
				parseStatement();
				isUnreachable = false;
			} else {
				/* Must eval the loop in a sub-scope. Since it's  conditionally
				 * executed, we mustn't inherit symbol value overrides from it. */
				namespaceStack.pushfront(CScope());
				parseStatement();
				namespaceStack.popfront();
				if (encounteredBreak) {
					isUnreachable = false; /* There is a reachable break, so the loop can be exited */
				} else if (whileVal.isConstExpr && whileVal.constExprValue) {
					isUnreachable = true; /* For-ever loop without break */
				}
			}
			isInLoop         = savedIsInLoop;
			encounteredBreak = savedEncounteredBreak;
		}	break;

		case "do": {
			this.next();
			local savedIsInLoop         = isInLoop;
			local savedEncounteredBreak = encounteredBreak;
			isInLoop         = true;
			encounteredBreak = false;

			local loopBodyLoc = this.backupCreate();
			local loopScope = CScope();
			namespaceStack.pushfront(loopScope);
			parseStatement();
			namespaceStack.popfront();
			this.skip("while");
			this.skip("(");
			local whileVal: CValue = parseExprRValue();
			if (isUnreachable) {
				/* End of loop isn't reachable */
				if (encounteredBreak)
					isUnreachable = false; /* Loop contains a reachable break -> loop can be exited */
			} else if (!whileVal.isConstExpr) {
				/* The while-body is executed [1-n] times. In this case, we can only
				 * inherit those its symbol value overrides if they remain unchanged
				 * after a second iteration. */
				if (!loopScope.symbolValues) {
					/* No value overrides -> don't need to check if we can inherit them! */
				} else {
					this.backupRestore(loopBodyLoc);
					loopBodyLoc = none;
					local pass1SymbolValues = loopScope.symbolValues;
					loopScope.symbolValues = Dict();
					namespaceStack.pushfront(loopScope);
					parseStatement();
					namespaceStack.popfront();
					this.skip("while");
					this.skip("(");
					local secondPassWhileCond = parseExprRValue();
					if (secondPassWhileCond !is none && whileVal == secondPassWhileCond) {
						if (loopScope.symbolValues == pass1SymbolValues) {
							/* Everything ended up the same -> can inherit */
							namespaceStack.first.setSymbolValues(pass1SymbolValues);
						}
					}
				}
			} else if (whileVal.constExprValue) {
				/* For-ever loop without break never returns */
				if (!encounteredBreak)
					isUnreachable = true;
			} else {
				/* Special   case   for  `do { } while (0)'-loops   without  `break'.
				 * Here, we can always inherit the contained scope's value overrides. */
				if (!encounteredBreak)
					namespaceStack.first.setSymbolValues(loopScope.symbolValues);
			}

			this.skip(")");
			this.skip(";");
			if (loopBodyLoc !is none)
				this.backupDiscard(loopBodyLoc);
			isInLoop         = savedIsInLoop;
			encounteredBreak = savedEncounteredBreak;
		}	break;

		case "for": {
			namespaceStack.pushfront(CScope());
			this.next();
			this.skip("(");
			if (!parseDeclaration(tryParse: true))
				parseExprComma();
			this.skip(";");
			local savedIsInLoop         = isInLoop;
			local savedEncounteredBreak = encounteredBreak;
			isInLoop         = true;
			encounteredBreak = false;

			local condVal: CValue = C_true;
			if (this.tok != ";")
				condVal = parseExprRValue();
			this.skip(";");
			if (isUnreachable) {
				if (this.tok != ")")
					parseExprComma();
				this.skip(")");
				parseStatement();
			} else if (condVal.isConstExpr && !condVal.constExprValue) {
				/* Loop condition is never true -> loop body is dead */
				isUnreachable = true;
				if (this.tok != ")")
					parseExprComma();
				this.skip(")");
				parseStatement();
				isUnreachable = false;
			} else {
				/* Must eval the loop in a sub-scope. Since it's  conditionally
				 * executed, we mustn't inherit symbol value overrides from it. */
				namespaceStack.pushfront(CScope());
				if (this.tok != ")")
					parseExprComma();
				this.skip(")");
				namespaceStack.pushfront(CScope());
				parseStatement();
				namespaceStack.popfront();
				namespaceStack.popfront();
				if (encounteredBreak) {
					isUnreachable = false; /* There is a reachable break, so the loop can be exited */
				} else if (condVal.isConstExpr && condVal.constExprValue) {
					isUnreachable = true; /* For-ever loop without break */
				}
			}

			isInLoop         = savedIsInLoop;
			encounteredBreak = savedEncounteredBreak;
			namespaceStack.popfront();
		}	break;

		case "return": {
			this.next();
			local returnValue: CValue;
			local returnType: CTypeRef = CTypeRef(currentFunctionTypeRef.typ.returnType);
			for (;;) {
				returnValue = parseTypedExpr(returnType);
				if (this.tok != ",")
					break;
				this.next();
			}
			if (isUnreachable) {
				/* Unreachable code */
			} else if (!returnValue.isConstExpr) {
				currentFunctionReturnValue = none;
			} else if (currentFunctionReturnValue === false) {
				currentFunctionReturnValue = returnValue.data;
			} else if (currentFunctionReturnValue !is none) {
				if (currentFunctionReturnValue != returnValue.data)
					currentFunctionReturnValue = none;
			}
			isUnreachable = true;
		}	break;

		default:
			if (this.tok.issymbol() && this.nextTokIsSingleColon()) {
				/* Special case: labels. */
				this.next();
				this.skip(":");
				isUnreachable = false;

				/* Must clear all symbol value overrides */
				for (local ns: namespaceStack)
					ns.symbolValues.clear();

				goto again;
			}
			if (!parseDeclaration(tryParse: true)) {
				parseExprComma();
			}
			break;
		}
	}

	function parseStatements() {
		do {
			parseStatement();
		} while (this.tok !in ["", "}"]);
	}

	function parseArrayInitializer(typ: CArrayType): CValue {
		if (isUnreachable) {
			parseArrayInitializerInto(typ, none, 0);
return_void_value:
			return CValue(kind: CVALUE_RVOID, typeref: CTypeRef(typ));
		}
		local data: Bytes = Bytes(typ.sizeof);
		local finalData: Bytes | none = parseArrayInitializerInto(typ, data, 0);
		if (finalData is none)
			goto return_void_value;
		return CValue(
				kind:    CVALUE_RCONST,
				typeref: CTypeRef(typ),
				data:    finalData,
				offset:  0);
	}
	function parseArrayInitializerInto(typ: CArrayType, result: Bytes | none, offset: int): Bytes | none {
		this.skip("{");
		local nextIndex: int = 0;
		local stride: int = typ.stride;
		while (this.tok != "}") {
			local loIndex: int = nextIndex;
			local hiIndex: int = nextIndex;
			if (this.tok == "[") {
				local loIndexValue: CValue = parseExprRValue();
				local hiIndexValue: CValue = loIndexValue;
				if (this.tok == "...") {
					this.next();
					hiIndexValue = parseExprRValue();
				}
				if (loIndexValue.isConstExpr && hiIndexValue.isConstExpr) {
					loIndex = loIndexValue.constExprValue(this);
					hiIndex = hiIndexValue.constExprValue(this);
					if (loIndex > hiIndex)
						this.err(f"Bad array initializer bounds: `[{loIndex} ... {hiIndex}]'");
				} else {
					result = none;
				}
				this.skip("]");
				this.skip("=");
			}
			local startOffset: int = offset + loIndex * stride;
			local endOffset: int   = offset + hiIndex * stride;
			if (result !is none && endOffset > #result)
				result = result.resized(endOffset);
			result = parseTypedExprInto(typ.base, result, startOffset);
			if (endOffset > startOffset && result !is none) {
				/* Copy initializers into all other fields. */
				local src: Bytes = result[startOffset:startOffset + stride];
				for (local i: [:endOffset - startOffset]) {
					local destOffset: int = startOffset + (i + 1) * stride;
					result[destOffset:destOffset + stride] = src;
				}
			}
			if (this.tok != ",")
				break;
			this.next();
			nextIndex = hiIndex + 1;
		}
		this.skip("}");
		return result;
	}

	function parseStructInitializer(typ: CStructType): CValue {
		if (isUnreachable) {
			parseStructInitializerInto(typ, none, 0);
return_void_value:
			return CValue(kind: CVALUE_RVOID, typeref: CTypeRef(typ));
		}
		local data: Bytes = Bytes(typ.sizeof);
		local finalData: Bytes | none = parseStructInitializerInto(typ, data, 0);
		if (finalData is none)
			goto return_void_value;
		return CValue(
				kind:    CVALUE_RCONST,
				typeref: CTypeRef(typ),
				data:    finalData,
				offset:  0);
	}
	function parseStructInitializerInto(typ: CStructType, result: Bytes | none, offset: int): Bytes | none {
		this.skip("{");
		@@Index of the next field to be initialized, or @none if not calculated, in
		@@which case the index of @fieldsByDeclarationLastField+1 needs to be used.
		local fieldsByDeclarationOrderNextIndex: int | none = 0;
		@@Name of the last-written field, or @none if none have been written, yet
		local fieldsByDeclarationLastField: string | none = none;
		while (this.tok != "}") {
			@@Name of the field to initialize
			local fieldName: string;
			local fieldType: CTypeRef;
			local fieldOffset: int;
			if (this.tok == ".") {
				this.next();
				fieldName = this.parseSymbolName();
				fieldsByDeclarationOrderNextIndex = none;
				this.skip("=");
			} else if (this.tok.issymbol() && this.nextTokIsSingleColon()) {
				fieldName = this.parseSymbolName();
				fieldsByDeclarationOrderNextIndex = none;
				this.skip(":");
			} else {
				/* Initialize the field that follows after the last-parsed field. */
				if (fieldsByDeclarationOrderNextIndex is none) {
					fieldsByDeclarationOrderNextIndex = 0;
					for (;;) {
						if (typ.fieldsByDeclarationOrder[fieldsByDeclarationOrderNextIndex].last == fieldsByDeclarationLastField)
							break;
						++fieldsByDeclarationOrderNextIndex;
					}
				} else {
					if (fieldsByDeclarationOrderNextIndex >= #typ.fieldsByDeclarationOrder)
						this.err(f"More field initializers after end of `{typ}'");
				}
				fieldName = typ.fieldsByDeclarationOrder[fieldsByDeclarationOrderNextIndex].last;
				++fieldsByDeclarationOrderNextIndex;
				if (!fieldName) {
					/* Initialize transparent struct/union */
					local innerStruct: CStructType = fieldType.typ;
					local firstFieldOffset: int;
					if (innerStruct.fieldsByDeclarationOrder) {
						local firstFieldName: string = innerStruct.fieldsByDeclarationOrder.first.first;
						firstFieldOffset = innerStruct.fields[firstFieldName].last;
					} else {
						firstFieldOffset = offset;
					}
					result = parseStructInitializerInto(fieldType.typ, result, firstFieldOffset);
					goto after_field_init;
				}
			}

			/* Lookup the field to initialize and parse its initializer. */
			fieldType, fieldOffset = typ.fields.get(fieldName)...;
			if (fieldType is none)
				this.err(f"Cannot initialize field `{fieldName}' which does not exists in `{typ}'");
			if (offset)
				fieldOffset += offset;
			result = parseTypedExprInto(fieldType, result, fieldOffset);
			fieldsByDeclarationLastField = fieldName;
after_field_init:
			if (this.tok != ",")
				break;
			this.next();
		}
		this.skip("}");
		return result;
	}

	@@Parse stuff from the global scope
	function parseGlobal() {
again:
		switch (this.tok) {

		case "":
		case "}":
			break;

		case ";":
			this.next();
			goto again;

		case "asm":
		case "__asm":
		case "__asm__":
			/* Global assembly (ignore) */
			this.next();
			this.skip("(");
			this.parseString();
			this.skip(")");
			this.skip(";");
			goto again;

		case "static_assert":
		case "_Static_assert": {
			if (this.tok != (cxx ? "static_assert" : "_Static_assert"))
				goto default_case;
			this.next();
			this.skip("(");
			local exprStart = this.warnBackupCreate();
			if (!parseExprConstantInteger()) {
				local message: string;
				if (this.tok == ",") {
					this.next();
					message = this.parseString();
				} else {
					message = this.parseString();
				}
				this.errAt(exprStart, "Static assertion failed");
				this.warnBackupDiscard(exprStart);
			} else {
				this.warnBackupDiscard(exprStart);
			}
			if (this.tok == ",") {
				this.next();
				this.parseString();
			}
			this.skip(")");
			this.skip(";");
		}	break;

		case "namespace": {
			if (!cxx)
				goto default_case;
			this.next();
			local ns = namespaceStack.first;
			do {
				ns = ns.childNamespace(this.parseSymbolName());
			} while (this.trySkip("::"));
			namespaceStack.pushfront(ns);
			this.skip("{");
			do {
				parseGlobal();
			} while (this.tok !in ["", "}"]);
			this.skip("}");
			namespaceStack.popfront();
		}	break;

		case "extern":
			if (!cxx)
				goto default_case;
			this.next();
			if (this.tok.startswith('"')) {
				local externMode = this.parseString();
				local savedIsInExternC = isInExternC;
				isInExternC = externMode == "C";
				this.skip("{");
				do {
					parseGlobal();
				} while (this.tok !in ["", "}"]);
				this.skip("}");
				isInExternC = savedIsInExternC;
				return;
			}
			parseDeclaration("extern");
			break;

		default:
default_case:
			parseDeclaration();
			break;
		}
	}


	/* Expression parser */
	// function parseExprUnaryPrefix(): CValue;
	// function parseExprUnarySuffix(value: CValue): CValue;
	// function parseExprUnary(): CValue;
#define parseExprUnarySuffixCheck(tok) ((tok) in ["[", "(", ".", "@", "->", "++", "--"])
#define parseExprUnarySuffix_CASE \
	case "[":                     \
	case "(":                     \
	case ".":                     \
	case "@":                     \
	case "->":                    \
	case "++":                    \
	case "--"

	// function parseExprProdSuffix(value: CValue): CValue;
	// function parseExprProd(): CValue;
#define parseExprProdSuffixCheck(tok) ((tok) in "*/%")
#define parseExprProdSuffix_CASE \
	case "*":                    \
	case "/":                    \
	case "%"

	// function parseExprSumSuffix(value: CValue): CValue;
	// function parseExprSum(): CValue;
#define parseExprSumSuffixCheck(tok) ((tok) in "+-")
#define parseExprSumSuffix_CASE \
	case "+":                   \
	case "-"

	// function parseExprShiftSuffix(value: CValue): CValue;
	// function parseExprShift(): CValue;
#define parseExprShiftSuffixCheck(tok) ((tok) in ["<<", ">>"])
#define parseExprShiftSuffix_CASE \
	case "<<":                    \
	case ">>"

	// function parseExprCmpSuffix(value: CValue): CValue;
	// function parseExprCmp(): CValue;
#define parseExprCmpSuffixCheck(tok) ((tok) in ["<", ">", "<=", ">="])
#define parseExprCmpSuffix_CASE \
	case "<":                   \
	case ">":                   \
	case "<=":                  \
	case ">="

	// function parseExprCmpEqSuffix(value: CValue): CValue;
	// function parseExprCmpEq(): CValue;
#define parseExprCmpEqSuffixCheck(tok) ((tok) in ["==", "!="])
#define parseExprCmpEqSuffix_CASE \
	case "==":                    \
	case "!="

	// function parseExprBitAndSuffix(value: CValue): CValue;
	// function parseExprBitAnd(): CValue;
#define parseExprBitAndSuffixCheck(tok) ((tok) == "&")
#define parseExprBitAndSuffix_CASE case "&"

	// function parseExprBitXorSuffix(value: CValue): CValue;
	// function parseExprBitXor(): CValue;
#define parseExprBitXorSuffixCheck(tok) ((tok) == "^")
#define parseExprBitXorSuffix_CASE case "^"

	// function parseExprBitOrSuffix(value: CValue): CValue;
	// function parseExprBitOr(): CValue;
#define parseExprBitOrSuffixCheck(tok) ((tok) == "|")
#define parseExprBitOrSuffix_CASE case "|"

	// function parseExprLAndSuffix(value: CValue): CValue;
	// function parseExprLAnd(): CValue;
#define parseExprLAndSuffixCheck(tok) ((tok) == "&&")
#define parseExprLAndSuffix_CASE case "&&"

	// function parseExprLOrSuffix(value: CValue): CValue;
	// function parseExprLOr(): CValue;
#define parseExprLOrSuffixCheck(tok) ((tok) == "||")
#define parseExprLOrSuffix_CASE case "||"

	// function parseExprCondSuffix(value: CValue): CValue;
	// function parseExprCond(): CValue;
#define parseExprCondSuffixCheck(tok) ((tok) == "?")
#define parseExprCondSuffix_CASE case "?"

	// function parseExprAssignSuffix(value: CValue): CValue;
	// function parseExpr(): CValue;
#define parseExprAssignSuffixCheck(tok) \
	((tok) in ["=", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "<<=", ">>=", "^="])
#define parseExprAssignSuffix_CASE \
	case "=":                      \
	case "+=":                     \
	case "-=":                     \
	case "*=":                     \
	case "/=":                     \
	case "%=":                     \
	case "|=":                     \
	case "&=":                     \
	case "<<=":                    \
	case ">>=":                    \
	case "^="

	/*****************************************************************************
	** Core parsers                                                             **
	*****************************************************************************/
	function parseExprUnaryPrefix(): CValue {
		local tok = this.tok;
		switch (tok) {

		case "nullptr":
			this.next();
			return copy TARGET_C_nullptr;

		case "true":
			this.next();
			return copy C_true;

		case "false":
			this.next();
			return copy C_false;

		case "__func__":
			if (currentFunctionName is none)
				goto default_case;
			this.next();
			return cvalueFromString(currentFunctionName);

		case "&&": /* For addressable labels. */
			this.next();
			this.parseSymbolName();
return_unknown_void_pointer:
			return CValue(kind: CVALUE_AVOID,
				typeref: CTypeRef(TARGET_CPointerType(C_void)));

		case "__builtin_alloca":
			this.next();
			this.skip("(");
			parseExpr();
			this.skip(")");
			goto return_unknown_void_pointer;

		case "__builtin_bswap16":
		case "__builtin_bswap32":
		case "__builtin_bswap64":
		case "__builtin_bswap128": {
			local typ: CType;
			switch (tok) {
			case "__builtin_bswap16":  typ = C_ushort; break;
			case "__builtin_bswap32":  typ = C_uint; break;
			case "__builtin_bswap64":  typ = TARGET_C_ullong; break;
			case "__builtin_bswap128": typ = TARGET_C_uint128_t; break;
			}
			this.next();
			this.skip("(");
			local result = parseExpr().inplaceCast(this, CTypeRef(typ));
			this.skip(")");
			if (result.isConstExpr) {
				local val = result.constExprValue;
				switch (tok) {
				case "__builtin_bswap16":  val = val.swap16; break;
				case "__builtin_bswap32":  val = val.swap32; break;
				case "__builtin_bswap64":  val = val.swap64; break;
				case "__builtin_bswap128": val = val.swap128; break;
				}
				result.data = result.typeref.typ.bytes(this, val);
			}
			return result;
		}	break;

		case "sizeof":
		case "alignof":
		case "_Alignof":
		case "__alignof":
		case "__alignof__":
		case "__builtin_alignof": {
			this.next();
			local typ: CType;
			if (this.tok == "(") {
				this.next();
				typ = parseTypeOrExpressionType().typ;
				this.skip(")");
			} else {
				typ = parseTypeOrExpressionType().typ;
			}
			return CValue(CTypeRef(TARGET_C_size_t), typ.operator . (
					tok == "sizeof" ? "sizeof" : "alignof"));
		}	break;

		case "__builtin_expect":
		case "__builtin_expect_with_probability": {
			this.next();
			this.skip("(");
			local result: CValue = parseExpr();
			this.skip(",");
			parseExpr();
			if ("probability" in tok) {
				this.skip(",");
				parseExpr();
			}
			this.skip(")");
			return result;
		}	break;

		case "__builtin_unreachable": {
			this.next();
			this.skip("(");
			this.skip(")");
			isUnreachable = true;
		}	break;

		case "__builtin_constant_p": {
			this.next();
			this.skip("(");
			local expr: CValue = parseExprRValue();
			this.skip(")");
			return CValue(CTypeRef(C_int), expr.isConstExpr ? 1 : 0);
		}	break;

		case "__builtin_has_attribute": {
			this.next();
			this.skip("(");
			local check: CTypeRef = parseExpr().typeref;
			this.skip(",");
			local template: CTypeRef = CTypeRef();
			parseCTypeRefAttribute(template);
			this.skip(")");
			/* Verify that by merging attributes, we get `(check & template) == template' */
			return CValue(CTypeRef(C_int), check.hasAllAttributesFrom(template) ? 1 : 0);
		}	break;

		case "(": {
			this.next();
			local castInfo = parseTypeRef("-", "", tryParse: true);
			if (castInfo !is none) {
				local typeref, storageClass;
				typeref, none, storageClass = castInfo...;
				if (storageClass != "")
					this.err(f"Storage class {repr storageClass} cannot appear in expressions");
				this.skip(")");
				return parseTypedExpr(typeref, explicit: true);
			}
			local result: CValue = parseExprComma();
			this.skip(")");
			return result;
		}	break;

			/* Unary operators. */
		case "*":
		case "&":
		case "+":
		case "-":
		case "!":
		case "~": {
			this.startWarnHere();
			this.next();
			local result: CValue = parseExprUnary().inplaceOp1(this, tok);
			this.endWarnHere();
			return result;
		}	break;

		default:
default_case:
			if (tok.issymbol()) {
		case "::":
				local ctorInfo = parseTypeRef("-", "", tryParse: true)...;
				if (ctorInfo !is none) {
					/* C++ function-style cast expression */
					local typeref, storageClass;
					typeref, none, storageClass = ctorInfo...;
					if (storageClass != "")
						this.err(f"Storage class {repr storageClass} cannot appear in expressions");
					this.skip("(");
					local result: CValue = parseTypedExpr(typeref, explicit: true);
					this.skip(")");
					return result;
				} else {
					/* Not a type -> check for a normal symbol */
					/* TODO: Check for `symbolValues' */
					local symbol: CSymbol | none = nsLookupChain("symbols");
					if (symbol is none)
						this.err(f"No such symbol `{tok}'");
					return cvalueFromSymbol(symbol);
				}
			} else if (tok.startswith('"')) {
				/* String literal. */
				return cvalueFromString(this.parseString());
			} else if (tok.startswith("'")) {
				/* Character literal. */
				local chr = this.parseString();
				local ord = 0;
				for (local ch: chr.ordinals) {
					ord = (ord << 8) | ch;
				}
				return CValue(CTypeRef(C_int), ord & 0xffffffff);
			} else {
				local constVal: int | float;
				local suffixEnd = #tok;
				while (suffixEnd && tok[suffixEnd - 1] in "ulUL")
					--suffixEnd;
				local integerType: CType;
				local integerSuffix = tok[suffixEnd:];
				switch (integerSuffix.lower()) {
				case "":
					integerType = C_int;
					break;
				case "u":
					integerType = C_uint;
					break;
				case "l":
					integerType = TARGET_C_long;
					break;
				case "ul":
				case "lu":
					integerType = TARGET_C_ulong;
					break;
				case "ll":
					integerType = TARGET_C_llong;
					break;
				case "ull":
				case "lul":
				case "llu":
					integerType = TARGET_C_ullong;
					break;
				default:
					this.err(f"Invalid integer suffix {repr integerSuffix}");
					break;
				}
				try {
					constVal = int(tok[:suffixEnd]);
				} catch (...) {
					suffixEnd = #tok;
					while (suffixEnd && tok[suffixEnd - 1] in "fFlL")
						--suffixEnd;
					integerSuffix = tok[suffixEnd:];
					switch (integerSuffix.lower()) {
					case "":  integerType = C_double; break;
					case "f": integerType = C_float; break;
					case "l": integerType = TARGET_C_ldouble; break;
					default:
						this.err(f"Invalid floating-point suffix {repr integerSuffix}");
						break;
					}
					try {
						constVal = float(tok);
					} catch (...) {
						this.err(f"Unable to parse expression from {repr tok}");
					}
				}
				this.next();
				return cvalueFromValue(this, CTypeRef(integerType), constVal);
			}
		}
	}

	function parseExprUnarySuffix(value: CValue): CValue {
		assert parseExprUnarySuffixCheck(this.tok);
		this.err(f"TODO: parseExprUnarySuffix({repr value})");
	}

#define DEFINE_SIMPLE_SUFFIX_PARSER(name, parseExprOperand)       \
	function parseExpr##name##Suffix(value: CValue): CValue {     \
		do {                                                      \
			local op = this.tok;                                  \
			assert parseExpr##name##SuffixCheck(op);              \
			this.next();                                          \
			value = value.inplaceOp2(this, op, parseExprOperand); \
		} while (parseExpr##name##SuffixCheck(this.tok));         \
		return value;                                             \
	}
	DEFINE_SIMPLE_SUFFIX_PARSER(Prod, parseExprUnary())
	DEFINE_SIMPLE_SUFFIX_PARSER(Sum, parseExprProd())
	DEFINE_SIMPLE_SUFFIX_PARSER(Shift, parseExprSum())
	DEFINE_SIMPLE_SUFFIX_PARSER(Cmp, parseExprShift())
	DEFINE_SIMPLE_SUFFIX_PARSER(CmpEq, parseExprCmp())
	DEFINE_SIMPLE_SUFFIX_PARSER(BitAnd, parseExprCmpEq())
	DEFINE_SIMPLE_SUFFIX_PARSER(BitXor, parseExprBitAnd())
	DEFINE_SIMPLE_SUFFIX_PARSER(BitOr, parseExprBitXor())
#undef DEFINE_SIMPLE_SUFFIX_PARSER

	function parseExprLAndSuffix(value: CValue): CValue {
		assert parseExprLAndSuffixCheck(this.tok);
		this.err(f"TODO: parseExprLAndSuffix({repr value})");
	}

	function parseExprLOrSuffix(value: CValue): CValue {
		assert parseExprLOrSuffixCheck(this.tok);
		this.err(f"TODO: parseExprLOrSuffix({repr value})");
	}

	function parseExprCondSuffix(value: CValue): CValue {
		assert parseExprCondSuffixCheck(this.tok);
		this.err(f"TODO: parseExprCondSuffix({repr value})");
	}

	function parseExprAssignSuffix(value: CValue): CValue {
		assert parseExprAssignSuffixCheck(this.tok);
		this.err(f"TODO: parseExprAssignSuffix({repr value})");
	}


	/*****************************************************************************
	** Inter-pos expression parsers                                             **
	*****************************************************************************/
#define DEFINE_INTERPOS_PARSER(name, innerName)        \
	function parseExpr##name(): CValue {               \
		local result: CValue = parseExpr##innerName(); \
		if (parseExpr##name##SuffixCheck(this.tok))    \
			return parseExpr##name##Suffix(result);    \
		return result;                                 \
	}
	DEFINE_INTERPOS_PARSER(Unary, UnaryPrefix)
	DEFINE_INTERPOS_PARSER(Prod, Unary)
	DEFINE_INTERPOS_PARSER(Sum, Prod)
	DEFINE_INTERPOS_PARSER(Shift, Sum)
	DEFINE_INTERPOS_PARSER(Cmp, Shift)
	DEFINE_INTERPOS_PARSER(CmpEq, Cmp)
	DEFINE_INTERPOS_PARSER(BitAnd, CmpEq)
	DEFINE_INTERPOS_PARSER(BitXor, BitAnd)
	DEFINE_INTERPOS_PARSER(BitOr, BitXor)
	DEFINE_INTERPOS_PARSER(LAnd, BitOr)
	DEFINE_INTERPOS_PARSER(LOr, LAnd)
	DEFINE_INTERPOS_PARSER(Cond, LOr)
	/*DEFINE_INTERPOS_PARSER(, Cond)*/
#undef DEFINE_INTERPOS_PARSER

	/* This one could also be defined as an inter-pos parser, but we don't do that so minimize stack-usage */
	function parseExpr(): CValue {
		local result: CValue = parseExprUnaryPrefix();
		switch (this.tok) {

		parseExprUnarySuffix_CASE:
			result = parseExprUnarySuffix(result);
#define PARSE_CASE_CHECK(name)                              \
			if (parseExpr##name##SuffixCheck(this.tok)) {   \
		parseExpr##name##Suffix_CASE:                       \
				result = parseExpr##name##Suffix(result);   \
			}
			PARSE_CASE_CHECK(Prod)
			PARSE_CASE_CHECK(Sum)
			PARSE_CASE_CHECK(Shift)
			PARSE_CASE_CHECK(Cmp)
			PARSE_CASE_CHECK(CmpEq)
			PARSE_CASE_CHECK(BitAnd)
			PARSE_CASE_CHECK(BitXor)
			PARSE_CASE_CHECK(BitOr)
			PARSE_CASE_CHECK(LAnd)
			PARSE_CASE_CHECK(LOr)
			PARSE_CASE_CHECK(Cond)
			PARSE_CASE_CHECK(Assign)
#undef PARSE_CASE_CHECK
			break;

		default:
			break;
		}
		return result;
	}

	@@High-level function to parse an expression (may return none if inside of dead code)
	function parseExprComma(): CValue {
again:
		local result: CValue = parseExpr();
		if (this.tok == ",") {
			this.next();
			goto again;
		}
		return result;
	}

	@@Same as @parseExpr, but special handling for when @typeref
	@@is a  struct/array type,  and the  current token  is  @"{"
	@@
	@@Also: even when the current token isn't @"{", still  do
	@@      an implicit cast of the expression into @typeref.
	function parseTypedExpr(typeref: CTypeRef, explicit: bool = false): CValue {
		if (this.tok == "{") {
			local typ: CType = typeref.typ;
			if (typ is CArrayType)
				return parseArrayInitializer(typ);
			if (typ is CStructType)
				return parseStructInitializer(typ);
		}
		if (isUnreachable) {
			return parseExpr();
		} else {
			return parseExprRValue().inplaceCast(this, typeref, explicit);
		}
	}

	function parseTypedExprInto(typeref: CTypeRef, result: Bytes | none,
	                            offset: int, explicit: bool = false): Bytes | none {
		if (this.tok == "{") {
			local typ: CType = typeref.typ;
			if (typ is CArrayType)
				return parseArrayInitializerInto(typ, result, offset);
			if (typ is CStructType)
				return parseStructInitializerInto(typ, result, offset);
		}
		local value = parseExprRValue()
			.inplaceCast(this, typeref, explicit);
		if (result !is none) {
			if (value.isConstExpr) {
				local valueData: Bytes = value.data;
				assert valueData is Bytes;
				local endOffset: int = offset + #valueData;
				if (#result < endOffset)
					result = result.resized(endOffset);
				result[offset:endOffset] = valueData;
			} else {
				result = none;
			}
		}
		return result;
	}

	@@Parse an expression and convert it into an R-Value
	function parseExprRValue(): CValue {
		return parseExpr().inplaceRValue(this);
	}

	function parseExprConstant(): CValue | none {
		local expr: CValue = parseExprRValue();
		if (!expr.isConstExpr) {
			if (!isUnreachable)
				this.err("Expected a compile-time constant expression");
			return none;
		}
		return expr;
	}

	function parseExprConstantInteger(): int | none {
		local result = parseExprConstant().constExprValue(this);
		if (result !is int && result !is none)
			this.err(f"Expected integer constant expression, but got `{repr result}'");
		return result;
	}

	@@Parse a type-expression, or parse a normal expression and return its type
	function parseTypeOrExpressionType(): CTypeRef {
		local tr: CTypeRef = CTypeRef();
		if (parseCTypeRefBase(tr) is none)
			return parseExpr().typeref;
		return parseTypeRefInner(tr, "-").first;
	}


	@@Main parser function
	function main() {
		try {
			do {
				parseGlobal();
			} while (this.tok);
		} catch (e...) {
			if (e !is ParserError)
				this.errMsg(f"Parser error: {e}");
			throw;
		}
	}
}

@@Main function to run the checker on an already-preprocessed C/C++ source file
@@@param: language: Either "c" or "c++"
function runChecker(filename: string, targetModule: Module, language: string = "c++") {
	local fp = File.open(filename, "rb");
	local checker = Checker(
			targetModule: targetModule, fp: fp, filename: filename,
			cxx: { "c": false, "c++": true }[language]);
#if 0
	do {
		print repr checker.filename, repr checker.lc, repr checker.this.tok;
	} while (checker.this.next());
#elif defined(__MAIN__)
	checker.main();
#else
	try {
		checker.main();
	} catch (e...) {
		print repr e;
		print Traceback.current;
	}
#endif
}

#ifdef __MAIN__
runChecker(
	"build/i386-kos-nOD/mod.dbx/kos.src.kernel.moddbx.cmodule.c.chk.E",
	import("...targets.i386"));
#endif
