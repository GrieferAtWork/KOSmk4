/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from deemon;
import * from .cparser;
import * from .ctype;
import * from .cvalue;
import UniqueSet from collections;

/* TODO: Add an attribute  `function_abi("foo")` that  allows for  user-defined
 *       strings to be set on function pointers. Then, a warning is issued when
 *       trying to assign a function that doesn't have the same ABI-tag.
 * -> This  way, we can  assert calling conventions  even where those would
 *    normally be identical on certain arches (e.g. assert correct usage of
 *    LIBCCALL / LIBDCALL not just on x86_64, but also i386)
 */

/* Dump top-level declarations as they are parsed. */
#undef DUMP_TOP_LEVEL_DECLS
#if 0
#define DUMP_TOP_LEVEL_DECLS
#endif

#define TemplateParamValue (CTypeRef | Bytes)

#define IDENTICAL(a, b) (type(a) === type(b) && ((a) == (b)))

final class Checker: CParser {
	public member globalNamespace: CNamespace = CNamespace(name: "");
	@@Note: All elements except for the last are of type @CScope
	public member namespaceStack: {CNamespace...} = [globalNamespace];
	public member targetModule: Module;
	public member defaultStructPacking: int;
	public member cxx: bool = true;

	this(targetModule: Module, fp: File, filename: string = "",
	     startLine: int = 1, startCol: int = 1, cxx: bool = true)
		: super(fp, filename, startLine, startCol)
	{
		this.targetModule = targetModule;
		this.cxx = cxx;
		this.defaultStructPacking = targetModule.POINTER_SIZE;
		this.TARGET_SIZEOF_POINTER = targetModule.POINTER_SIZE;
		this.TARGET_BIG_ENDIAN = false;
		this.TARGET_ENDIAN = "little";
		switch (targetModule.POINTER_SIZE) {
		case 4:
			TARGET_C_long       = C_long32;
			TARGET_C_ulong      = C_ulong32;
			TARGET_C_llong      = C_llong_align4;
			TARGET_C_ullong     = C_ullong_align4;
			TARGET_C_int128_t   = C_int128_t_align4;
			TARGET_C_uint128_t  = C_uint128_t_align4;
			TARGET_C_nullptr_t  = C_nullptr_t_32;
			TARGET_C_size_t     = C_uint;
			TARGET_CPointerType = CPointerType32;
			TARGET_C_nullptr    = C_nullptr_32;
			break;
		case 8:
			TARGET_C_long       = C_long64;
			TARGET_C_ulong      = C_ulong64;
			TARGET_C_llong      = C_llong_align8;
			TARGET_C_ullong     = C_ullong_align8;
			TARGET_C_int128_t   = C_int128_t_align8;
			TARGET_C_uint128_t  = C_uint128_t_align8;
			TARGET_C_nullptr_t  = C_nullptr_t_64;
			TARGET_C_size_t     = C_ulong64;
			TARGET_CPointerType = CPointerType64;
			TARGET_C_nullptr    = C_nullptr_64;
			break;
		default:
			this.err(f"Unsupported POINTER_SIZE: {repr targetModule.POINTER_SIZE}");
			break;
		}
		switch (targetModule.CPUNAME) {
		case "i686":
			TARGET_C_ldouble = C_ldouble_12;
			break;
		case "x86_64":
			TARGET_C_ldouble = C_ldouble_16;
			break;
		case "arm":
			TARGET_C_ldouble = C_double;
			break;
		default:
			this.err(f"Unknown cpu: {repr targetModule.CPUNAME}");
			break;
		}
		this.next();
	}

	/* Target-specific types */
	public member TARGET_C_long: CType;
	public member TARGET_C_ulong: CType;
	public member TARGET_C_llong: CType;
	public member TARGET_C_ullong: CType;
	public member TARGET_C_int128_t: CType;
	public member TARGET_C_uint128_t: CType;
	public member TARGET_C_nullptr_t: CType;
	public member TARGET_C_ldouble: CType;
	public member TARGET_C_size_t: CType;
	public member TARGET_CPointerType: Type;
	public member TARGET_SIZEOF_POINTER: int;
	public member TARGET_BIG_ENDIAN: bool;
	public member TARGET_ENDIAN: string;
	public member TARGET_C_nullptr: CValue;

	/* Context variables */

	@@The function whose body is currently being parsed
	public member currentFunctionName: string | none = none;
	public member currentFunctionTypeRef: CTypeRef | none = none;
	@@Set to @false until a return-statement is encountered
	private member currentFunctionReturnValue: Bytes | none | bool = false;
	@@The greatest nothrow level of a function called by the current function,
	@@as well as pointers dereferenced by the function
	@@Set to @-1 if nothing like that has yet to have happened.
	public member currentTryBlockGreatestNothrowLevel: int = -1;

	@@Set of exceptions that were seen as throwable within the current context
	public member currentTryBlockExceptions: {int...} | none = none;

	@@Value of @currentTryBlockExceptions, but only gets assigned while inside of `catch`
	public member currentCatchBlockExceptions: {int...} | none = none;

	private member isInExternC: bool = false;         /* True inside of an extern-C block */
	private member isInSwitchStatement: bool = false; /* True inside of a switch-statement */
	private member isInLoop: bool = false;            /* True inside of a loop-statement */
	public  member isUnreachable: bool = false;       /* True inside of dead code */
	public  member isInTryBlock: bool = false;        /* True inside of a try-block */
	private member switchIsUnreachable: bool = false; /* True inside of an unreachable switch-statement */
	private member encounteredBreak: bool = false;    /* True if `break' was encountered */
	private member encounteredAsm: bool = false;      /* True if `__asm__' was encountered */
	private member switchConstantExpressionValue: Bytes | none = none;
	private member switchExpressionType: CTypeRef | none = none;

	@@Mapping of  `new ->  old`  or `DEFINE_PUBLIC_ALIAS()`  and  friends.
	@@At the end of the parsing process, these are checked against symbols
	@@from the global namespace to see if
	private member asmSymbolAliasDefinitions: {string: string} = Dict();

	@@@param tab: One of:
	@@            - @"symbols": @CSymbol or @CSymbolTemplate
	@@            - @"typedefs": @CTypeRef or @CTypeRefTemplate
	@@            - @"namespaces": @CNamespace
	@@            - @"structSymbols": @CStructType
	@@            - @"unionSymbols": @CStructType
	@@            - @"enumSymbols": @CEnumType
	function lookup(tab: string, name: string): Object | none {
		for (local ns: namespaceStack) {
			local result = ns.lookup(tab, name);
			if (result !is none)
				return result;
			/* When looking for typedefs, don't keep searching if a symbol of the same name also exists */
			if (tab == "typedefs") {
				result = ns.lookup("symbols", name);
				if (result !is none)
					return none;
			}
		}
		return none;
	}

	function lookupEx(tab: string, name: string, check: Callable): Object | none {
		for (local ns: namespaceStack) {
			local result = ns.lookup(tab, name);
			if (result !is none && check(result))
				return result;
		}
		return none;
	}

	@@Lookup the symbol value override for lvalue @name
	@@@return: @none: The value of @symbol is unknown
	function getSymbolValue(symbol: CSymbol): Bytes | none {
		for (local ns: namespaceStack) {
			local override: CValue | bool | none = ns.symbolValues.get(symbol, false);
			if (override !== false)
				return override;
		}
		return none;
	}

	@@Return the prefix for the current namespace (e.g. @"std::")
	@@When inside of the global namespace, return an empty string
	property currentNamespacePrefix: string = {
		get(): string {
			local result = "";
			for (local ns: namespaceStack) {
				if (ns is CScope)
					continue;
				if (ns === globalNamespace)
					break;
				result = f"{ns.name}::{result}";
			}
			return result;
		}
	}

	function exceptCodeName(code: int): string {
		if (code == THROWS_ANY)
			return "...";
		if (code == THROWS_CB)
			return "*";
		local result: string | none = this.exceptByCode.get(code);
		if (result !is none)
			return result;
		return code.hex();
	}

	function exceptCodeNames(codes: {int...}): {string...} {
		local hasCb = false;
		local hasAny = false;
		for (local code: codes.sorted()) {
			if (code == THROWS_ANY) {
				hasAny = true;
			} else if (code == THROWS_CB) {
				hasCb = true;
			} else {
				local result: string | none = this.exceptByCode.get(code);
				if (result is none)
					result = code.hex();
				yield result;
			}
		}
		if (hasCb)
			yield "*";
		if (hasAny)
			yield "...";
	}


	@@The name of the final symbol in @nsLookupChildChain and @nsLookupChain
	private member _nsLookupChildChainSymbolName: string;

	@@Parse a a child-namespace lookup expression chain
	@@@return @none if not found, but only when @errorIfNotFound is false.
	@@        When @none is returned, the parser is NOT rewound to the start
	@@        of the non-present symbol expression! (if needed, this has  to
	@@        be done by the caller)
	function nsLookupChildChain(ns: CNamespace, tab: string,
	                            errorIfNotFound: bool = true): Object | none {
again:
		local name: string = this.tok;
		if (!name.issymbol())
			this.err(f"Expected symbol in namespace symbol expression, but got {repr name}");
		if (this.next() == "::" && cxx) {
			ns = ns.lookup("namespaces", name);
			if (ns is none) {
				if (errorIfNotFound)
					return this.err(f"Unknown namespace {repr name}");
				return none;
			}
			this.next();
			goto again;
		}
		_nsLookupChildChainSymbolName = name;
		local result: Object | none = ns.lookup(tab, name);
		if (result is none && errorIfNotFound)
			this.err(f"Unknown symbol `{name}' in namespace `{ns.name}' [tab: {repr tab}]");
		return result;
	}

	@@Parse a namespace lookup expression, returning @none if nothing was parsed
	function nsLookupChain(tab: string): Object | none {
		local name = this.tok;
		local backup;
		local baseNs;
		if (name == "::" && cxx) {
			/* Root-namespace-relative symbol lookup */
			backup = this.backupCreate();
			baseNs = globalNamespace;
			goto next_and_lookup_in_baseNs;
		}
		if (!name.issymbol())
			return none;
		backup = this.backupCreate();
		try {
			local result;
			if (this.next() == "::" && cxx) {
				/* Lookup chain */
				baseNs = lookup("namespaces", name);
				if (baseNs is none) {
					this.backupRestore(backup);
					return this.err(f"Unknown namespace {repr name}");
				}
next_and_lookup_in_baseNs:
				this.next();
				result = nsLookupChildChain(baseNs, tab, errorIfNotFound: false);
			} else {
				if (tab == "typedefs" && cxx && this.tok == "<") {
					result = lookupEx(tab, name, x -> x is CTypeRefTemplate);
					if (result is none)
						result = lookup(tab, name);
				} else {
					result = lookup(tab, name);
				}
				_nsLookupChildChainSymbolName = name;
			}
			if (result is none) {
				this.backupRestore(backup);
			} else {
				this.backupDiscard(backup);
			}
			return result;
		} catch (...) {
			this.backupDiscard(backup);
			throw;
		}
	}

	@@Parse an exception ID for a `__attribute__((throws(...)))` annotation
	@@Exceptions can appear a any of the following:
	@@+------------------------+---------------------------------------+
	@@| `...`                  | Indicator for throws-any (@0)         |
	@@| `*`                    | Indicator for throws-cb (@-1)         |
	@@| `"E_INVALID_ARGUMENT"` | Raw keyword as string                 |
	@@| `E_INVALID_ARGUMENT`   | Raw keyword                           |
	@@| `(0x0002)`             | Preprocessor expanded class           |
	@@| `(0x0002, 0x0001)`     | Preprocessor expanded sub-class       |
	@@| `(0x00010002)`         | Fully evaluated sub-class             |
	@@| `0x0002`               | Preprocessor expanded class w/o paren |
	@@| `0x00010002`           | Fully evaluated sub-class w/o paren   |
	@@+------------------------+---------------------------------------+
	function parseExceptionId(): int {
		local tok = this.tok;
		if (tok == "...") {
			this.next();
			return THROWS_ANY;
		}
		if (tok == "*") {
			this.next();
			return THROWS_CB;
		}
		if (tok == "(") {
			this.next();
			local id: int = this.parseInt();
			if (this.tok == ",") {
				this.next();
				id = (this.parseInt() << 16) | id;
			}
			this.skip(")");
			return id;
		}
		local exceptName: string;
		if (tok.startswith('"')) {
			exceptName = this.parseString();
		} else if (tok.issymbol()) {
			exceptName = tok;
			this.next();
		} else {
			return this.parseInt();
		}
		local result: int | none = this.exceptByName.get(exceptName);
		if (result is none)
			this.err(f"Unknown exception `{exceptName}'");
		return result;
	}

	function parseCTypeRefAttribute(tr: CTypeRef) {
again:
		local attributeName = this.requireSymbolName().strip("_");
		switch (attributeName) {

		case "checker":
		case "gnu":
			this.skip("::");
			goto again;

			/* Ignored attributes */
		case "regparm":
		case "warning":
		case "error":
		case "section":
		case "weakref":
		case "alias":
		case "visibility":
		case "format":
		case "format_arg":
		case "alloc_size":
		case "optimize":
		case "assume_aligned":
		case "alloc_align":
			this.next();
			this.skip("(");
			parseSkipUntil(")");
			this.skip(")");
			break;

		case "deprecated":
		case "sentinel":
			this.next();
			if (this.tok == "(") {
				this.next();
				parseSkipUntil(")");
				this.skip(")");
			}
			break;

		case "cdecl":
		case "stdcall":
		case "fastcall":
		case "thiscall":
		case "sysvabi":
		case "msabi":
		case "dllimport":
		case "dllexport":
		case "weak":
		case "returns_twice":
		case "externally_visible":
		case "returns_nonnull":
		case "const":
		case "pure":
		case "leaf":
		case "unused":
		case "no_instrument_function":
		case "malloc":
		case "noinline":
		case "used":
		case "warn_unused_result":
		case "may_alias":
		case "artificial":
		case "cold":
		case "hot":
		case "noclone":
		case "fallthrough":
		case "gnu_inline":
			this.next();
			break;

		case "packed":
			tr.flags |= CTYPEREF_FLAG_PACKED;
			this.next();
			break;

		case "force":
			tr.flags |= CTYPEREF_FLAG_FORCE;
			this.next();
			break;

		case "noreturn":
			tr.flags |= CTYPEREF_FLAG_NORETURN;
			this.next();
			break;

		case "deref":
			tr.flags = (tr.flags & ~CTYPEREF_FLAG_NODEREF) | CTYPEREF_FLAG_DEREF;
			this.next();
			break;

		case "noderef":
			if (!(tr.flags & CTYPEREF_FLAG_DEREF))
				tr.flags |= CTYPEREF_FLAG_NODEREF;
			this.next();
			break;

		case "throws": {
			this.next();
			this.skip("(");
			local throws: {int...} = tr.attribThrows;
			if (throws !is HashSet)
				tr.attribThrows = throws = HashSet(throws);
			while (this.tok != ")") {
				local id: int = parseExceptionId();
				throws.insert(id);
				if (id > 0xffff)
					throws.insert(id & 0xffff); /* Implied super-class */
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip(")");
		}	break;

		case "nothrow": {
			local isStar = false;
			local level: int;
			this.next();
			if (this.tok == "(") {
				this.next();
				if (this.tok == "*") {
					isStar = true;
					this.next();
				}
				level = parseExprConstantInteger();
				this.skip(")");
			} else {
				level = 0;
			}
			tr.attribNothrow = f"{isStar ? "*" : ""}{level}";
		}	break;

		case "nonnull":
			this.next();
			if (this.tok == "(") {
				this.next();
				local nonnull: Set with int = tr.requireAttrib.nonnull;
				if (nonnull !is HashSet)
					tr.attrib.nonnull = nonnull = HashSet(nonnull);
				while (this.tok != ")") {
					nonnull.insert(parseExprConstantInteger());
					if (this.tok != ",")
						break;
					this.next();
				}
				this.skip(")");
			} else {
				tr.flags |= CTYPEREF_FLAG_NONNULL;
			}
			break;

		case "tag":
		case "require_caller_tag": {
			this.next();
			this.skip("(");
			local attribName: string = {
				"tag" : "attribTags",
				"require_caller_tag" : "attribRequireCallerTags",
			}[attributeName];
			local tags: Set with string = tr.operator . (attribName);
			if (tags !is HashSet)
				tr.operator . (attribName) = tags = HashSet(tags);
			for (;;) {
				tags.insert(this.parseString());
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip(")");
		}	break;

		case "aligned":
			this.next();
			this.skip("(");
			tr.attribAligned = parseExprConstantInteger();
			this.skip(")");
			break;

		default:
			this.err(f"Unknown attribute `{attributeName}'");
		}
	}

	function parseCTypeRefAttributes(tr: CTypeRef): bool {
		local result = false;
again:
		switch (this.tok) {

		case "alignas":
		case "_Alignas":
			if (this.tok != (cxx ? "alignas" : "_Alignas"))
				break;
			this.next();
			this.skip("(");
			tr.attribAligned = parseExprConstantInteger();
			this.skip(")");
			result = true;
			goto again;

		case "__extension__":
			/* In GCC, this suppresses warnings about use of extensions. */
			this.next();
			result = true;
			goto again;

		case "[":
			/* Be careful not to parse as attribute in case of array type. */
			if (this.firstCharOfNextTok() != "[")
				break;
			this.next();
			this.skip("[");
			while (this.tok != "]") {
				parseCTypeRefAttribute(tr);
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip("]");
			this.skip("]");
			result = true;
			goto again;

		case "__attribute":
		case "__attribute__":
			this.next();
			this.skip("(");
			this.skip("(");
			while (this.tok != ")") {
				parseCTypeRefAttribute(tr);
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip(")");
			this.skip(")");
			result = true;
			goto again;

		default: break;
		}
		return result;
	}

	function parseCTypeRefConstVolatile(tr: CTypeRef): bool {
		local result = false;
again:
		switch (this.tok) {

		case "const":
		case "__const":
		case "__const__":
		case "volatile":
		case "__volatile":
		case "__volatile__":
		case "restrict":
		case "__restrict":
		case "__restrict__":
			tr.flags |= {
				"const":    CTYPEREF_FLAG_CONST,
				"volatile": CTYPEREF_FLAG_VOLATILE,
				"restrict": CTYPEREF_FLAG_RESTRICT,
			}[this.tok.strip("_")];
			this.next();
			result = true;
			goto again;

		default: break;
		}
		if (parseCTypeRefAttributes(tr)) {
			result = true;
			goto again;
		}
		return result;
	}

	private member _anonStructMemberId: int = 0;
	function parseStructMembers(tr: CTypeRef, structType: CStructType,
	                            fields: {(CTypeRef, string)...}) {
again:
		switch (this.tok) {

		case "":
		case "}":
			break;

		case ";":
			this.next();
			goto again;

		case "public":
		case "private":
		case "protected":
			if (!cxx)
				goto default_case;
			this.next();
			this.skip(":");
			goto again;

		default: {
			local fieldType: CTypeRef;
			local fieldName: string;
default_case:
			for (fieldType, fieldName, none: parseTypeRefs("-")) {
				if (this.tok == ":") {
					/* Bit fields */
					this.next();
					/* XXX: Actually support? */
					parseExprConstantInteger();
				}
				if (!fieldName && fieldType.typ !is CStructType) {
					this.warn("-Wtypedef", f"Unnamed struct field of type `{fieldType}'");
					fieldName = f"__anon_struct_member_{_anonStructMemberId}";
					++_anonStructMemberId;
				}
				if (fieldName) {
					for (local none, existingName: fields) {
						if (fieldName == existingName)
							this.err(f"Duplicate field {repr fieldName} in struct type");
					}
					tr.typ.fieldsByDeclarationOrder.append((fieldType, fieldName));
				}
				/* Use a WeakRef to prevent a reference loop */
				if (gc.isreferring(fieldType.typ, structType))
					fieldType.typ = WeakRef(fieldType.typ);
				fields.append((fieldType, fieldName));
			}
			this.skip(";");
			goto again;
		}	break;

		}
	}

	function parseStruct(structName: string, tr: CTypeRef, isUnion: bool): CStructType {
		local struct: CStructType;
		if (structName) {
			local tabName: string = isUnion ? "unionSymbols" : "structSymbols";
			/* Check if the struct was already defined somewhere */
			struct = lookup(tabName, structName);
			if (struct is none) {
				struct = CStructType(name: structName);
				local tab = namespaceStack.first.operator . (tabName);
				if (tab is none)
					namespaceStack.first.operator . (tabName) = tab = Dict();
				tab[structName] = struct;

				/* C++ also requires us to put the type into the typedefs table. */
				if (cxx) {
					local typedefs = namespaceStack.first.typedefs;
					if (structName !in typedefs) {
						if (typedefs is none)
							namespaceStack.first.typedefs = typedefs = Dict();
						typedefs[structName] = CTypeRef(typ: struct);
					}
				}
			} else {
				parseCTypeRefAttributes(tr);
				if (this.tok != "{" && (!cxx || this.tok != ":")) {
					tr.typ = struct;
					return struct;
				}
				if (struct.fields) {
					this.err(f"redeclaration of {isUnion ? "union" : "struct"} "
					         f"type {repr structName}");
				}
			}
		} else {
			struct = CStructType(name: structName);
		}
		tr.typ = struct;
		parseCTypeRefAttributes(tr);
		if (this.tok == ":" && !isUnion && cxx) {
			/* C++ class/struct bases. */
			this.next();
			if (this.tok in ["private", "public"])
				this.next();
			local baseTypeRef: CTypeRef = CTypeRef();
			parseCTypeRefBase(baseTypeRef);
			if (baseTypeRef.typ !is CStructType)
				this.err(f"Expected struct-type for struct base, but got {baseTypeRef}");
			struct.base = baseTypeRef.typ;
		} else {
			if (this.tok != "{")
				return struct;
		}
		this.skip("{");
		local fields: {(CTypeRef, string)...} = [];
		parseStructMembers(tr, struct, fields);
		this.skip("}");
		parseCTypeRefAttributes(tr);

		/* Calculate struct field offsets */
		local structAlign: int | none = tr.attribAligned;
		if (structAlign is none)
			structAlign = defaultStructPacking;
		if (tr.flags & CTYPEREF_FLAG_PACKED)
			structAlign = 1;
		local fieldOffset: int = 0;
		if (struct.base !is none)
			fieldOffset = struct.base.sizeof;
		for (local fieldType, fieldName: fields) {
			if (!isUnion) {
				local fieldAlign = fieldType.attribAligned;
				if (fieldAlign is none)
					fieldAlign = fieldType.typ.alignof;
				if (structAlign !is none) {
					if (fieldAlign > structAlign)
						fieldAlign = structAlign;
				}
				if (fieldType.flags & CTYPEREF_FLAG_PACKED)
					fieldAlign = 1;
				fieldOffset = (fieldOffset + fieldAlign - 1) & -fieldAlign;
			}
			if (!fieldName && fieldType.typ is CStructType) {
				/* Anonymous union/struct */
				for (local innerFieldName, innerFieldType, innerFieldOffset: fieldType.typ.foreachField) {
					if (innerFieldName in struct.fields)
						this.err(f"Anonymous struct field `{innerFieldName}' redeclared");
					struct.fields[innerFieldName] = (innerFieldType, innerFieldOffset + fieldOffset);
				}
			} else {
				struct.fields[fieldName] = (fieldType, fieldOffset);
			}
			if (!isUnion)
				fieldOffset += fieldType.sizeof;
		}
		if (structAlign !is none) {
			local finalStructAlign: int | none = tr.attribAligned;
			if (finalStructAlign is none)
				finalStructAlign = structAlign;
			struct._alignof = finalStructAlign;
		}
		return struct;
	}

	function parseEnumMembers(ns: CNamespace, enumTypeRef: CTypeRef) {
		local prevEnumConstantValue: int = 0;
		local enumBase: CType = enumTypeRef.typ.base;
		while (this.tok != "}") {
			local enumDecl = this.flc;
			local enumName = this.parseSymbolName();
			local enumValue: int;
			if (this.tok == "=") {
				this.next();
				enumValue = parseExprConstantInteger();
			} else {
				enumValue = prevEnumConstantValue + 1;
			}
			if (enumName in ns.symbols)
				this.err(f"Symbol `{enumName}' has already been defined");
			if (ns.symbols is none)
				ns.symbols = Dict();
			ns.symbols[enumName] = CSymbol(enumName, enumDecl,
				enumTypeRef, enumBase.bytes(this, enumValue));
			prevEnumConstantValue = enumValue;
			if (this.tok != ",")
				break;
			this.next();
		}
	}

	function parseEnum(tr: CTypeRef): CEnumType | CEnumClassType {
		local enumType: Type = CEnumType;
		if (this.tok == "class" && cxx) {
			enumType = CEnumClassType;
			this.next();
			parseCTypeRefAttributes(tr);
		}
		local enumName: string = "";
		if (this.tok.issymbol()) {
			enumName = this.parseSymbolName();
			parseCTypeRefAttributes(tr);
		}
		local enum: CEnumType | CEnumClassType;
		if (enumName) {
			if (enumType === CEnumClassType) {
				enum = CEnumClassType(name: enumName);
				goto skip_normal_enum_namespace;
			}
			local tab = namespaceStack.first.enumSymbols;
			enum = tab.get(enumName);
			if (enum is none) {
				enum = enumType(name: enumName);
				if (tab is none)
					namespaceStack.first.enumSymbols = tab = Dict();
				tab[enumName] = enum;

				/* C++ also requires us to put the type into the typedefs table. */
skip_normal_enum_namespace:
				if (cxx) {
					local typedefs = namespaceStack.first.typedefs;
					if (enumName !in typedefs) {
						if (typedefs is none)
							namespaceStack.first.typedefs = typedefs = Dict();
						typedefs[enumName] = CTypeRef(typ: enum);
					}
					if (enumType === CEnumClassType) {
						/* Since enum classes are also namespaces, must
						 * also register the type as a child-namespace! */
						local namespaces = namespaceStack.first.namespaces;
						if (enumName !in namespaces) {
							if (namespaces is none)
								namespaceStack.first.namespaces = namespaces = Dict();
							namespaces[enumName] = enumType;
						}
					}
				}
			} else {
				parseCTypeRefAttributes(tr);
				if (this.tok != "{" && (!cxx || this.tok != ":")) {
					tr.typ = enum;
					return enum;
				}
				this.err(f"redeclaration of enum type {repr enumName}");
			}
		} else {
			enum = enumType(name: enumName);
		}
		tr.typ = enum;
		local baseType: CTypeRef;
		if (this.tok == ":" && cxx) {
			/* C++ enum base. */
			this.next();
			baseType = parseTypeRef("-", "-").first;
			if (baseType.typ !is CCoreType)
				this.err(f"Expected core-type for enum base, but got {baseType}");
			enum.base = baseType.typ;
		} else {
			if (this.tok != "{")
				return enum;
			baseType = CTypeRef(enum.base);
		}
		this.skip("{");
		local enumTypeRef: CTypeRef = CTypeRef(enum, CTYPEREF_FLAG_CONST);
		if (enumType === CEnumClassType) {
			parseEnumMembers(enum, enumTypeRef);
		} else {
			parseEnumMembers(namespaceStack.first, enumTypeRef);
		}
		this.skip("}");
		parseCTypeRefAttributes(tr);
		return enum;
	}

	function parseStorageClass(): string {
		local result = this.tok;
		if (result in ["static", "register", "auto", "extern", "typedef"]) {
			this.next();
			return result;
		}
		return "";
	}

	@@Return the common type between @a and @b
	@@@return: none: Only when @tryCommon is set to @true, and the types have no common type
	function commonType(a: CTypeRef, b: CTypeRef, tryCommon: bool = false): CTypeRef | none {
		local aTyp: CType = a.typ;
		local bTyp: CType = b.typ;
		if (aTyp in C_NUMERIC && bTyp in C_NUMERIC) {
			/* Special case: return the larger of 2  */

			/* Return the larger of the two types. */
			if (aTyp.sizeof > bTyp.sizeof)
				goto return_a;
			if (aTyp.sizeof < bTyp.sizeof)
				goto return_b;

			/* Return whichever isn't a boolean. */
			if (aTyp in C_BOOLEAN)
				goto return_b;
			if (bTyp in C_BOOLEAN)
				goto return_a;

			/* Same type sizes. -> Return the signed of the two types. */
			if (aTyp in C_SIGNED && bTyp !in C_SIGNED)
				goto return_a;
			if (bTyp in C_SIGNED && aTyp !in C_SIGNED)
				goto return_b;

			/* Both types are integers, and have the same size and sign.
			 * Prefer `long long' over `long', `long' over `int', and `int' over `short' */
			if (aTyp in C_LLONG)
				goto return_a;
			if (bTyp in C_LLONG)
				goto return_b;
			if (aTyp in C_LONG)
				goto return_a;
			if (bTyp in C_LONG)
				goto return_b;
			if (aTyp in C_INT)
				goto return_a;
			if (bTyp in C_INT)
				goto return_b;

			/* Fallback: The 2 types seem to be identical, so just return `a' over `b' */
			goto return_a;
		}

		/* Check if the types are identical. */
		if (IDENTICAL(aTyp, bTyp))
			goto return_a;

		if (aTyp is CPointerType) {
			/* Special case: if one of the types is a nullptr, return the other type */
			if (bTyp is CCoreNullptrType)
				goto return_a;
			if (bTyp is CPointerType) {
				/* Return the common type of 2 pointer types.
				 *
				 * For this purpose,  the greatest nothrow  level is  used,
				 * and all type flags are or'd, except CTYPEREF_FLAG_FORCE,
				 * which is and-ed. */
				local aBaseTypeRef: CTypeRef = aTyp.base;
				local bBaseTypeRef: CTypeRef = bTyp.base;
				local aBaseType: CType = aBaseTypeRef.typ;
				local bBaseType: CType = bBaseTypeRef.typ;
				local rBaseType: CType;
				if (IDENTICAL(aBaseType, bBaseType)) {
					rBaseType = aBaseType;
				} else {
					/* When one of the base types is void, use the other! */
					if (aBaseType === C_void) {
						rBaseType = bBaseType;
					} else if (bBaseType === C_void) {
						rBaseType = aBaseType;
					} else {
						goto after_pointer;
					}
				}

				/* Merge pointer types and their attributes */
				local rBaseTypeRef: CTypeRef = cTypeRefWithCommonAttrib(aBaseTypeRef, aBaseTypeRef);
				rBaseTypeRef.typ = rBaseType;
				local rTypeRef: CTypeRef = cTypeRefWithCommonAttrib(a, b);
				local rPointerType: Type = type aBaseType;
				if (rPointerType !== type bBaseType && bBaseType.sizeof > aBaseType.sizeof)
					rPointerType = type bBaseType;
				rTypeRef.typ = rPointerType(rBaseTypeRef);
				return rTypeRef;
			}
		} else if (bTyp is CPointerType) {
			/* Special case: if one of the types is a nullptr, return the other type */
			if (aTyp is CCoreNullptrType)
				goto return_b;
		}
after_pointer:

		if (!tryCommon)
			this.err(f"Types `{a}' and `{b}' don't have a common type");
		return none;
return_a:
		return cTypeRefWithCommonAttrib(a, b);
return_b:
		return cTypeRefWithCommonAttrib(b, a);
	}

	@@Parse a type base reference
	@@@return @none if no type was parsed, else the type itself (also stored in @tr.typ)
	function parseCTypeRefBase(tr: CTypeRef): CType | none {
		local hasCv: bool = parseCTypeRefConstVolatile(tr);
		local typedef: CTypeRef | CTypeRefTemplate;
		local intFlags: int = 0;
#define BASETYPE_FLAG_SIGNED    0x0001 /* FLAG: `signed' was given */
#define BASETYPE_FLAG_UNSIGNED  0x0002 /* FLAG: `unsigned' was given */
#define BASETYPE_FLAG_SIGNMASK  0x0003 /* Mask for explicit sign prefix. */
#define BASETYPE_FLAG_INT       0x0004 /* FLAG: Explicit `int' was given. */
#define BASETYPE_FLAG_CHAR      0x0010 /* FLAG: `char' was given. */
#define BASETYPE_FLAG_SHORT     0x0020 /* FLAG: `short' was given. */
#define BASETYPE_FLAG_LONG      0x0030 /* FLAG: `long' was given. */
#define BASETYPE_FLAG_LLONG     0x0040 /* FLAG: `long long' was given. */
#define BASETYPE_FLAG_INT8      0x0050 /* FLAG: `__int8' was given. */
#define BASETYPE_FLAG_INT16     0x0060 /* FLAG: `__int16' was given. */
#define BASETYPE_FLAG_INT32     0x0070 /* FLAG: `__int32' was given. */
#define BASETYPE_FLAG_INT64     0x0080 /* FLAG: `__int64' was given. */
#define BASETYPE_FLAG_INT128    0x0090 /* FLAG: `__int128' was given. */
#define BASETYPE_FLAG_WIDTHMASK 0x00f0 /* MASK: Explicit width was given. */
again:
		switch (this.tok) {

		case "signed":
		case "__signed":
		case "__signed__":
		case "unsigned":
		case "__unsigned":
		case "__unsigned__":
			if (intFlags & BASETYPE_FLAG_SIGNMASK)
				this.err("Duplicate 'signed' or 'unsigned' in type-expression");
			intFlags |= "unsigned" in this.tok ? BASETYPE_FLAG_UNSIGNED : BASETYPE_FLAG_SIGNED;
			this.next();
			goto again;

		case "int":
			if (intFlags & BASETYPE_FLAG_INT)
				this.err("Duplicate 'int' in type-expression");
			intFlags |= BASETYPE_FLAG_INT;
			this.next();
			goto again;

		case "char":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK)
				this.err("Duplicate width-keyword in type-expression");
			intFlags |= BASETYPE_FLAG_CHAR;
			this.next();
			goto again;

		case "short":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK)
				this.err("Duplicate width-keyword in type-expression");
			intFlags |= BASETYPE_FLAG_SHORT;
			this.next();
			goto again;

		case "long":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK) {
				if ((intFlags & BASETYPE_FLAG_WIDTHMASK) != BASETYPE_FLAG_LONG)
					this.err("Duplicate width-keyword in type-expression");
				intFlags &= ~BASETYPE_FLAG_WIDTHMASK;
				intFlags |= BASETYPE_FLAG_LLONG;
			} else {
				intFlags |= BASETYPE_FLAG_LONG;
			}
			this.next();
			goto again;

		case "__int8":
		case "__int16":
		case "__int32":
		case "__int64":
		case "__int128":
			if (intFlags & BASETYPE_FLAG_WIDTHMASK)
				this.err("Duplicate width-keyword in type-expression");
			intFlags |= {
				"__int8"   : BASETYPE_FLAG_INT8,
				"__int16"  : BASETYPE_FLAG_INT16,
				"__int32"  : BASETYPE_FLAG_INT32,
				"__int64"  : BASETYPE_FLAG_INT64,
				"__int128" : BASETYPE_FLAG_INT128,
			}[this.tok];
			this.next();
			goto again;

		case "class":
			if (!cxx)
				goto default_case;
			/* FALLTHRU */
		case "struct":
		case "union": {
			local isUnion = this.tok == "union";
			if (intFlags)
				this.err("struct/union/class with integer keyword");
			this.next();
			parseCTypeRefAttributes(tr);
			local structName: string = "";
			if (this.tok.issymbol()) {
				structName = this.parseSymbolName();
				parseCTypeRefAttributes(tr);
				if (this.tok == "<") {
					typedef = lookupEx("typedefs", structName, x -> x is CTypeRefTemplate);
					if (typedef is none)
						return this.err(f"No such struct/union/class template-typedef `{structName}'");
					goto resolve_template_typedef;
				}
			}
			parseStruct(structName, tr, isUnion);
		}	break;

		case "enum": {
			if (intFlags)
				this.err("enum with integer keyword");
			this.next();
			parseCTypeRefAttributes(tr);
			parseEnum(tr);
		}	break;

		case "double":
			if (intFlags) {
				if (intFlags != BASETYPE_FLAG_LONG)
					this.err("double with integer keyword");
				tr.typ = TARGET_C_ldouble;
				this.next();
			} else {
				this.next();
				if (this.tok == "long") {
					this.next();
					tr.typ = TARGET_C_ldouble;
				} else {
					tr.typ = C_double;
				}
			}
			break;

		case "decltype":
			if (!cxx)
				goto default_case;
			/* FALLTHRU */
		case "typeof":
		case "__typeof":
		case "__typeof__":
			this.next();
			this.skip("(");
			tr.typ = parseTypeOrExpressionType().typ;
			this.skip(")");
			break;

		default: {
default_case:
			if (intFlags) {
				/* Integer core type */
				local typ;
				switch (intFlags & BASETYPE_FLAG_WIDTHMASK) {
				case BASETYPE_FLAG_CHAR:   typ = C_char; break;
				case BASETYPE_FLAG_SHORT:  typ = C_short; break;
				case BASETYPE_FLAG_LONG:   typ = TARGET_C_long; break;
				case BASETYPE_FLAG_LLONG:  typ = TARGET_C_llong; break;
				case BASETYPE_FLAG_INT8:   typ = C_schar; break;
				case BASETYPE_FLAG_INT16:  typ = C_short; break;
				case BASETYPE_FLAG_INT32:  typ = C_int; break;
				case BASETYPE_FLAG_INT64:  typ = TARGET_C_llong; break;
				case BASETYPE_FLAG_INT128: typ = TARGET_C_int128_t; break;
				default: typ = C_int; break;
				}
				switch (intFlags & BASETYPE_FLAG_SIGNMASK) {
				case BASETYPE_FLAG_SIGNED:
					if (typ === C_char)
						typ = C_schar;
					break;
				case BASETYPE_FLAG_UNSIGNED:
					typ = C_UNSIGNED[typ];
					break;
				default: break;
				}
				tr.typ = typ;
				break;
			}

			local typ: CType;
			switch (this.tok) {

				/* Single-keyword integer core types */
			case "void":
				typ = C_void;
				break;

			case "float":
				typ = C_float;
				break;

			case "wchar_t":
			case "__wchar_t":
				typ = C_wchar_t;
				break;

			case "_Bool":
				if (cxx)
					goto lookup_typedef;
				typ = C_bool;
				break;

			case "bool":
			case "char8_t":
			case "char16_t":
			case "char32_t":
				if (!cxx)
					goto lookup_typedef;
				typ = {
					"bool":     C_bool,
					"char8_t":  C_char8_t,
					"char16_t": C_char16_t,
					"char32_t": C_char32_t,
				}[this.tok];
				break;

			default: {
				/* Lookup a typedef */
lookup_typedef:
				typedef = nsLookupChain("typedefs");
				if (typedef is none) {
					if (hasCv)
						this.err("Unable to parse type after const/volatile");
					return none;
				}
				if (typedef is CTypeRefTemplate) {
resolve_template_typedef:
					local templateParamValues: {TemplateParamValue...} = [];
					this.skip("<");
					while (!this.tok.startswith(">") && #templateParamValues < #typedef.params) {
						local param: TemplateParam = typedef.params[#templateParamValues];
						templateParamValues.append(parseTemplateParamValue(param));
						if (this.tok != ",")
							break;
						this.next();
					}
					typedef = instantiateTemplate(typedef, templateParamValues);
					this.skip(">");
				}
				tr.importTypedef(typedef);
				goto done;
			}	break;

			}
			if (typ !is none) {
				this.next();
				tr.typ = typ;
				break;
			}
		}	break;

		}
done:
		parseCTypeRefConstVolatile(tr);
		return tr.typ;
	}

	function parseTemplateParamValue(param: TemplateParam): TemplateParamValue {
		local typeref: CTypeRef | none = param.typeref;
		if (typeref !is none) {
			if (this.tok == "{") {
				local result: Bytes;
				param.typeref, result = parseTypedExprConstant(typeref)...; /* Parse a constant */
				return result;
			}
			/* Can only parse unary expressions here since everything else would
			 * result in ambiguity when it comes  to ">", ">>", ">=" and  ">>="!
			 * If you want full expressions here, you just need to use parens! */
			local cvalue: CValue = parseExprUnary()
				.inplaceCast(this, typeref);
			if (!cvalue.isConstExpr) {
				if (!isUnreachable)
					this.err("Expected a compile-time constant expression");
				return none;
			}
			param.typeref = cvalue.typeref;
			return cvalue.constExprBytes;
		}
		return parseTypeRefWithoutStorageClassOrName();
	}

	function parseTypeRefWithoutStorageClass(): (CTypeRef, string) {
		local tr, nam, sc = parseTypeRef(storageClass: "-")...;
		if (sc != "-")
			this.err(f"Storage class {repr sc} is invalid in this context");
		return (tr, nam);
	}

	function parseTypeRefWithoutStorageClassOrName(): CTypeRef {
		local tr, nam, sc = parseTypeRef("-", "-")...;
		if (sc != "-")
			this.err(f"Storage class {repr sc} is invalid in this context");
		return tr;
	}

	function parseTypeRefInnerSuffix(tr: CTypeRef) {
		switch (this.tok) {

		case "(": {
			this.next();
			local func = CFunctionType();
			while (this.tok != ")") {
				if (this.tok == "...") {
					func.isVarArgs = true;
					this.next();
					break;
				}
				local argTypeRef: CTypeRef;
				local argName: string;
				argTypeRef, argName = parseTypeRefWithoutStorageClass()...;
				if (argTypeRef.typ === C_void && !argName)
					break;
				if (this.tok == "=") {
					this.next();
					local argDefault: Bytes | none;
					argTypeRef, argDefault = parseTypedExprConstant(argTypeRef)...;
					if (argDefault is none)
						argDefault = Bytes();
					func.defaults.append(argDefault);
				}
				if (argTypeRef.typ is CArrayType) {
					/* Top-level array  arguments in  function
					 * types are actually treated as pointers. */
					local argType: CType = argTypeRef.typ;
					argTypeRef.typ = argType.base;
					argType = TARGET_CPointerType(argTypeRef);
					argTypeRef = CTypeRef(argType);
				}
				func.args.append((argTypeRef, argName));
				if (this.tok != ",")
					break;
				this.next();
			}
			this.skip(")");
			parseCTypeRefAttributes(tr);
			if (this.tok == "noexcept" && cxx) {
				/* c++ noexcept attribute -> parse like `__attribute__((nothrow(0)))` */
				tr.requireAttrib.nothrow = 0;
				this.next();
				parseCTypeRefAttributes(tr);
			}
			parseTypeRefInnerSuffix(tr);
			func.returnType = tr.typ;
			tr.typ = func;
		}	break;

		case "[": {
			this.next();
			local dim: int | none;
			if (this.tok == "]") {
				dim = none;
			} else if (currentFunctionName is none) {
				dim = parseExprConstantInteger();
			} else {
				/* Outside the global namespace, the dimension expression may
				 * be  non-constant to indicate a VLA array. In order to keep
				 * things simple, we treat these kinds of arrays as  flexible
				 * arrays. */
				local dimExpr: CValue = parseExprRValue();
				if (dimExpr.isConstExpr) {
					dim = dimExpr.constExprValue(this);
				} else {
					dim = none;
				}
			}
			this.skip("]");
			parseCTypeRefAttributes(tr);
			parseTypeRefInnerSuffix(tr);
			local baseType: CType = tr.typ;
			local itemAlign: int | none = tr.attribAligned;
			if (itemAlign is none)
				itemAlign = baseType.alignof;
			if (tr.flags & CTYPEREF_FLAG_PACKED)
				itemAlign = 1;
			local stride: int = (baseType.sizeof + itemAlign - 1) & -itemAlign;
			if (dim !is none && dim < 0)
				this.err(f"Negative array dimension in `{baseType}[{dim}]'");
			tr.typ = CArrayType(baseType, dim, stride);
		}	break;

		default: break;
		}
	}

	@@Parse everything after the base-expression of a C-type
	function parseTypeRefInner(tr: CTypeRef, name: string = ""): (CTypeRef, string) {
		/* Warn about use of nonsensical attributes (e.g. `__attribute((noreturn)) int i;') */
		local result = parseTypeRefInnerImpl(tr, name);
		result.first.fixNonsensicalAttributes(this);
		return result;
	}

	function parseTypeRefInnerImpl(tr: CTypeRef, name: string = ""): (CTypeRef, string) {
		/* Parse the inner type-ref prefix (iow: pointer types) */
		parseCTypeRefAttributes(tr);
prefixAgain:
		if (this.tok == "*") {
			this.next();
			local pointerType: Type;
			switch (this.tok) {
			case "__ptr32":
				this.next();
				pointerType = CPointerType32;
				break;
			case "__ptr64":
				this.next();
				pointerType = CPointerType64;
				break;
			default:
				pointerType = TARGET_CPointerType;
				break;
			}

			tr = CTypeRef(pointerType(tr));
			parseCTypeRefConstVolatile(tr);
			goto prefixAgain;
		}

		local result;
		if (this.tok == "(") {
			this.next();
			result = parseTypeRefInnerImpl(tr, name);
			this.skip(")");
			parseCTypeRefAttributes(tr);
		} else {
			/* Parse variable name */
			if (!name && this.tok.issymbol()) {
				name = this.tok;
				this.next();
				parseCTypeRefAttributes(tr);
			}
			result = (tr, name);
		}

		/* Parse type suffix expressions */
		parseTypeRefInnerSuffix(tr);
		parseCTypeRefAttributes(tr);

		return result;
	}

	@@Parse a type reference and return (type, name, storage-class)
	function parseTypeRef(name: string = "",
	                      storageClass: string = "",
	                      tryParse: bool = false)
			: (CTypeRef, string, string) | none {
		if (!storageClass)
			storageClass = parseStorageClass();
		local tr = CTypeRef();
		if (parseCTypeRefBase(tr) is none) {
			if (tryParse && !storageClass)
				return none;
			this.err(f"Cannot parse type from {repr this.tok}");
		}
		if (!storageClass)
			storageClass = parseStorageClass();
		tr, name = parseTypeRefInner(tr, name)...;
		return (tr, name, storageClass);
	}

	function parseTypeRefs(storageClass: string = "",
	                       tryParse: bool = false)
			: {(CTypeRef, string, string)...} {
		if (!storageClass)
			storageClass = parseStorageClass();
		local tr = CTypeRef();
		if (parseCTypeRefBase(tr) is none) {
			if (tryParse && !storageClass)
				return;
			this.err(f"Cannot parse type from {repr this.tok}");
		}
		if (!storageClass)
			storageClass = parseStorageClass();
		for (;;) {
			local itemTr: CTypeRef;
			local itemName: string;
			itemTr, itemName = parseTypeRefInner(copy tr)...;
			yield (itemTr, itemName, storageClass);
			if (this.tok != ",")
				break;
			this.next();
		}
	}

	function parseDeclaration(storageClass: string = "",
	                          tryParse: bool = false,
	                          withSemiColon: bool = true): bool {
		local typeref: CTypeRef;
		local name: string;
		local result: bool = false;
		for (typeref, name, storageClass: parseTypeRefs(storageClass, tryParse)) {
			result = true;
#ifdef DUMP_TOP_LEVEL_DECLS
#define LOG_DECL(typeref)                                             \
	({                                                                \
		if (currentFunctionName is none) {                            \
			print("decl: ", storageClass, storageClass ? " " : "",    \
				(typeref).tostr(currentNamespacePrefix + name), ";"); \
		}                                                             \
	})
#else /* DUMP_TOP_LEVEL_DECLS */
#define LOG_DECL(typeref) /* nothing */
#endif /* !DUMP_TOP_LEVEL_DECLS */

			/* Create a typedef/symbol for the parsed declaration. */
			if (storageClass == "typedef") {
				if (!name) {
					this.warn("-Wtypedef", f"Unnamed typedef declaration with `{typeref}'");
				} else {
					local tab: {string: CTypeRef | CTypeRefTemplate} | none = namespaceStack.first.typedefs;
					local existingDecl: CTypeRef | CTypeRefTemplate | none = tab.get(name);
					if (existingDecl is none) {
						if (tab is none)
							namespaceStack.first.typedefs = tab = Dict();
						tab[name] = typeref;
						LOG_DECL(typeref);
					} else if (existingDecl is CTypeRefTemplate) {
						this.err(
							f"Redefinition of template typedef `{name}' as non-template"
							f"{this.formatMessageAddend(existingDecl.decl, "See definition of template")}");
					} else {
						if (existingDecl.redeclarationEquals(typeref)) {
							/* Ignore typedef re-declaration where the new type matches the old */
							existingDecl.redeclarationImport(this, typeref, name, name);
						} else {
							this.err(
								f"redeclaration of typedef `{typeref.tostr(name)}' "
								f"previously declared as `{existingDecl.tostr(name)}'");
						}
						LOG_DECL(existingDecl);
					}
				}
				continue;
			}

			/* Handle symbol assembly names. */
			if (this.tok in ["asm", "__asm", "__asm__"]) {
				this.next();
				this.skip("(");
				this.parseString();
				this.skip(")");
			}

			if (!name) {
				/* Need a name to have an initializer or a symbol! */
				LOG_DECL(typeref);
				continue;
			}

			local tab: {string: CSymbol | CSymbolTemplate} | none = namespaceStack.first.symbols;
			local decl: CSymbol | CSymbolTemplate | none = tab.get(name);
			if (decl !is none) {
				if (decl is CSymbolTemplate) {
					this.err(
						f"Redefinition of template symbol `{name}' as non-template"
						f"{this.formatMessageAddend(decl.decl, "See definition of template")}");
				}

				/* Special case for function overloads. */
				if (typeref.typ is CFunctionType && !isInExternC && cxx) {
					if (decl is COverloadedFunctionSymbol) {
						decl = decl.getOrCreateOverload(this, typeref);
					} else if (decl.typeref.redeclarationEquals(typeref)) {
						/* Still the same symbol */
						decl.typeref.redeclarationImport(this, typeref, name, name, decl.decl);
					} else {
						/* Initial overload given */
						local overloadsDecl = COverloadedFunctionSymbol();
						overloadsDecl.name = name;
						overloadsDecl.decl = decl.decl;
						overloadsDecl.typeref = none;
						overloadsDecl.overloads.append(decl);
						decl = CSymbol(name, this.flc, typeref);
						overloadsDecl.overloads.append(decl);
						namespaceStack.first.symbols[name] = overloadsDecl;
					}
					LOG_DECL(typeref);
					if (this.tok == "{") {
						this.skip("{");
						decl.val = parseFunctionBody(typeref, name);
						this.skip("}");
						/* Don't allow extra definitions here, and don't require a ';' */
						return true;
					}
					continue;
				}
				if (decl.typeref.redeclarationEquals(typeref) &&
					namespaceStack.first !is CScope) {
					/* Ignore re-declaration where the new type matches the old */
					decl.typeref.redeclarationImport(this,typeref, name, name, decl.decl);
					typeref = decl.typeref;
				} else {
					this.err(f"redeclaration of `{typeref.tostr(name)}'{
						this.formatMessageAddend(decl.decl,
							f'previously declared as `{decl.typeref.tostr(name)}\'')
					}");
				}
				if (decl.val is bound) {
					LOG_DECL(typeref);
					continue; /* Symbol already had a value assigned. */
				}
			} else {
				if (tab is none)
					namespaceStack.first.symbols = tab = Dict();
				decl = CSymbol(name, this.flc, typeref);
				tab[name] = decl;
			}

			/* Must parse an initializer/function-body for the declaration. */
			if (typeref.typ is CFunctionType) {
				LOG_DECL(typeref);
				if (this.tok != "{")
					continue;
				this.skip("{");
				decl.val = parseFunctionBody(typeref, name);
				this.skip("}");
				/* Don't allow extra definitions here, and don't require a ';' */
				return true;
			}
			if (this.tok != "=") {
				LOG_DECL(typeref);
				continue;
			}
			this.next();
			local val: CValue;
			local savedIsUnreachable: bool = isUnreachable;
			isUnreachable = false;
			val = parseTypedExpr(typeref);
			isUnreachable = savedIsUnreachable;
			/* Override the declaration's type so pointer attributes are inherited
			 * >> void foo(USER CHECKED void *p) {
			 * >>     void *x = p; // Here, `x' automatically inherits pointer attributes from `p'
			 * >> } */
			decl.typeref = val.typeref;
			if (!isUnreachable) {
				if (val.isConstExpr) {
					decl.val = val.constExprBytes;
				} else {
					decl.val = none;
#if 0 /* FIXME: This doesn't work because `static int x = 0, *y = &x;' isn't known at compile-time,
       *        but is still OK  when it comes  to static initialization  (rather than have  simple
       *        Bytes blobs, we need something more sophisticated to keep track of embedded symbols
       *        in the form of virtual relocations) */
					if (namespaceStack.first !is CScope ||
					    storageClass in ["static", "extern"]) {
						this.warn("-Wconst", f"Non-constant static initializer for `{decl}'");
					}
#endif
				}
			}
			LOG_DECL(decl.typeref);
		}
		if (result && withSemiColon)
			this.skip(";");
		return result;
	}

	function verifyRethrow() {
		if (!isUnreachable && currentCatchBlockExceptions) {
			currentTryBlockExceptions.insertall(currentCatchBlockExceptions);
			if (!isInTryBlock) {
				verifyTopLevelThrows(currentCatchBlockExceptions,
					getReason: _ -> "it `RETHROW()`s them here");
			}
		}
	}

	@@Verify that it's OK that exceptions @codes are thrown at the top-level of the current function
	function verifyTopLevelThrows(codes: {int...}, getReason: Callable) {
		local callerThrows: {int...} = currentFunctionTypeRef.attribThrows;
		local missingThrows: {int...} = codes - callerThrows;
		if (missingThrows) {
			local simplifiedMissingThrows = HashSet();

			/* Remove sub-classes where `callerThrows' specifies the base-class */
			for (local code: missingThrows) {
				if (code > 0xffff && (code & 0xffff) in callerThrows)
					continue;
				simplifiedMissingThrows.insert(code);
			}

			/* Remove some exceptions if the calling function has
			 * a nothrow attribute  with a  "*" or a  level >  0. */
			local callerNothrow: string | none = currentFunctionTypeRef.attribNothrow;
			if (callerNothrow !is none) {
				if (callerNothrow.startswith("*") || int(callerNothrow) > 0) {
					simplifiedMissingThrows.remove(this.exceptByName["E_SEGFAULT"]);
					simplifiedMissingThrows.remove(this.exceptByName["E_BADALLOC"]);
					simplifiedMissingThrows.remove(this.exceptByName["E_WOULDBLOCK"]);
				}
			}
			missingThrows = simplifiedMissingThrows;
		}
		if (missingThrows && (THROWS_ANY !in callerThrows)) {
			this.warn("-Wthrows",
				f"Function `{currentFunctionName}' is missing annotations "
				f"`THROWS({", ".join(exceptCodeNames(simplifyThrowsSet(missingThrows)))})', "
				f"because {getReason(missingThrows)}");
		}
	}

	@@Returns the function's return value
	function parseFunctionBody(funTypRef: CTypeRef, name: string): Bytes | none {
		/* Push a namespace for the function's body. */
		local fnScope: CScope = CScope();
		fnScope.symbols = Dict();
		fnScope.name = name;

		/* Define local symbols for each of the function's arguments. */
		for (local argTypeRef, argName: funTypRef.typ.args) {
			if (!argName)
				continue;
			fnScope.symbols[argName] = CSymbol(argName, this.flc, argTypeRef, none);
		}

		/* Setup the context for evaluation of the function body */
		namespaceStack.pushfront(fnScope);
		local savedCurrentFunctionName                 = currentFunctionName;
		local savedCurrentFunctionTypeRef              = currentFunctionTypeRef;
		local savedCurrentFunctionReturnValue          = currentFunctionReturnValue;
		local savedCurrentTryBlockGreatestNothrowLevel = currentTryBlockGreatestNothrowLevel;
		local savedCurrentTryBlockExceptions           = currentTryBlockExceptions;
		local savedIsUnreachable                       = isUnreachable;
		local savedIsInTryBlock                        = isInTryBlock;
		local savedEncounteredAsm                      = encounteredAsm;
		currentFunctionName                 = name;
		currentFunctionTypeRef              = funTypRef;
		currentFunctionReturnValue          = false;
		currentTryBlockGreatestNothrowLevel = -1;
		currentTryBlockExceptions           = HashSet();
		isUnreachable                       = false;
		isInTryBlock                        = false;
		encounteredAsm                      = false;

		/* Parse the function body. */
		parseStatements();

		/* Eval a constant return value */
		local result = currentFunctionReturnValue;
		if (result === false)
			result = none;

		/* Warn if the end of a non-void function is reached without a return-statement. */
		if (!isUnreachable && funTypRef.typ.returnType !== C_void)
			this.warn("-Wreturn", "End of non-void function reached (missing return?)");

		/* Compare the function's annotations to what happens within the function. */
		local functionThrows: Set with int = funTypRef.attribThrows;
		local functionNothrow: string | none = funTypRef.attribNothrow;
		local bodyThrows: Set with int = currentTryBlockExceptions;
		local bodyNothrow: int = currentTryBlockGreatestNothrowLevel;
		if (bodyNothrow < 0 && (THROWS_OOB !in bodyThrows && THROWS_NCX !in bodyThrows))
			bodyNothrow = 0; /* Function doesn't do anything dangerous */
		if (functionThrows && !encounteredAsm) {
			if (THROWS_ANY in functionThrows && THROWS_ANY !in bodyThrows) {
				local thrownButNotAnnotated: Set with int = HashSet(bodyThrows - functionThrows);
				thrownButNotAnnotated.remove(THROWS_CB);
				this.warn("-Wnothrow",
					f"`THROWS(...)' is more broad than it needs to be. "
					f"Use `THROWS({", ".join(
						exceptCodeNames(simplifyThrowsSet(thrownButNotAnnotated))
					)})' instead");
			}
			local neverThrownExceptions: Set with int = HashSet(functionThrows - bodyThrows);
			neverThrownExceptions.remove(THROWS_ANY);
			neverThrownExceptions.remove(THROWS_CB);
			if (functionNothrow.startswith("*") || int(functionNothrow) > 0) {
				neverThrownExceptions.remove(this.exceptByName["E_SEGFAULT"]);
				neverThrownExceptions.remove(this.exceptByName["E_BADALLOC"]);
				neverThrownExceptions.remove(this.exceptByName["E_WOULDBLOCK"]);
			}
			if (neverThrownExceptions) {
				/* Remove exception base classes if sub-classes are also part of the set. */

				this.warn("-Wnothrow",
					f"Exceptions `THROWS({", ".join(
						exceptCodeNames(simplifyThrowsSet(neverThrownExceptions))
					)})' are never thrown");
			}
		}

		if (functionNothrow is none) {
			/* Figure out which annotation the function should have (if any) */
			local expectedAnnotation: string;
			if (bodyThrows.remove(THROWS_OOB)) {
				expectedAnnotation = "";
			} else if (bodyThrows || encounteredAsm) {
				expectedAnnotation = "";
			} else {
				local bodyHasNcx = bodyThrows.remove(THROWS_NCX);
				local bodyHasCb = bodyThrows.remove(THROWS_CB);
				if (bodyHasNcx && bodyHasCb) {
					expectedAnnotation = "NOTHROW_CB_NCX";
				} else if (bodyHasCb) {
					expectedAnnotation = "NOTHROW_CB";
				} else if (bodyHasNcx) {
					expectedAnnotation = "NOTHROW_NCX";
				} else if (bodyNothrow <= 0) {
					/* If the function takes pointer arguments that are not  __restrict
					 * and don't appear in nonnull((n)), suggest NOTHROW or NOTHROW_NCX
					 * instead */
					if (funTypRef.typ.hasNotRestrictNotNonnullPointerArguments) {
						expectedAnnotation = "NOTHROW_NCX' or `NOTHROW";
					} else {
						expectedAnnotation = "NOTHROW";
					}
				} else {
					expectedAnnotation = getPrettyNothrowLevelName(bodyNothrow);
				}
			}
			if (expectedAnnotation) {
				this.warn("-Wnothrow",
					f"Function `{currentFunctionName}' should "
					f"be annotated as `{expectedAnnotation}', "
					f"as no explicit exceptions are thrown");
			}
		} else if (!functionNothrow.startswith("*")) {
			local functionNothrowLevel: int = int(functionNothrow);
			if (bodyNothrow >= 0 && functionNothrowLevel > bodyNothrow) {
				this.warn("-Wnothrow",
					f"Function `{currentFunctionName}' can be annotated as "
					f"`{getPrettyNothrowLevelName(bodyNothrow)}' instead of "
					f"`{getPrettyNothrowLevelName(functionNothrowLevel)}'");
			}
		}

		/* Restore context */
		currentFunctionName                 = savedCurrentFunctionName;
		currentFunctionTypeRef              = savedCurrentFunctionTypeRef;
		currentFunctionReturnValue          = savedCurrentFunctionReturnValue;
		currentTryBlockGreatestNothrowLevel = savedCurrentTryBlockGreatestNothrowLevel;
		currentTryBlockExceptions           = savedCurrentTryBlockExceptions;
		isUnreachable                       = savedIsUnreachable;
		isInTryBlock                        = savedIsInTryBlock;
		encounteredAsm                      = savedEncounteredAsm;
		namespaceStack.popfront();
		return result;
	}

	function parseGCCAssemblyArgument() {
		if (this.tok == "[") {
			this.next();
			this.parseSymbolName();
			this.skip("]");
		}
		this.parseString();
		this.skip("(");
		parseExpr();
		this.skip(")");
	}

	function parseGCCAssemblyArguments() {
		if (!this.tok.startswith(":") && this.tok != ")") {
			for (;;) {
				parseGCCAssemblyArgument();
				if (this.tok != ",")
					break;
				this.next();
			}
		}
	}

	function parseGCCAssemblyStatement() {
		/* Local assembly */
		if (this.next() in ["volatile", "__volatile", "__volatile__"])
			this.next();
		local hasGoto = this.tok == "goto";
		if (hasGoto)
			this.next();
		this.skip("(");
		this.parseString();
		if (this.tok.startswith(":")) {
			this.makeSingleCharacterToken();
			this.next();
			/* output arguments */
			parseGCCAssemblyArguments();
			if (this.tok.startswith(":")) {
				this.makeSingleCharacterToken();
				this.next();
				/* input arguments */
				parseGCCAssemblyArguments();
				if (this.tok.startswith(":")) {
					this.makeSingleCharacterToken();
					this.next();
					/* Clobber list */
					if (this.tok.startswith('"')) {
						for (;;) {
							this.parseString();
							if (this.tok != ",")
								break;
							this.next();
						}
					}
					if (hasGoto && this.tok.startswith(":")) {
						this.makeSingleCharacterToken();
						this.next();
						/* Label list */
						if (this.tok.issymbol()) {
							for (;;) {
								this.next();
								if (this.tok != ",")
									break;
								this.next();
								if (!this.tok.issymbol())
									this.err(f"Expected label in asm goto, but got {repr this.tok}");
							}
						}
					}
				}
			}
		}
		this.skip(")");
		this.skip(";");
	}

	@@Parse the `__builtin_define_alias` statement
	function parseBuiltinDefineAlias() {
		this.next();
		this.skip("(");
		local newName: string = this.parseString();
		this.skip(",");
		local oldName: string = this.parseString();
		this.skip(")");
		this.asmSymbolAliasDefinitions[newName] = oldName;
		this.skip(";");
	}

	function parseStatement(): CValue | none {
again:
		switch (this.tok) {

		case "":
		case "}":
			break;

		case ";":
			this.next();
			break;

		case "template":
			if (!cxx)
				goto default_case;
			parseTemplate();
			break;

		case "static_assert":
		case "_Static_assert":
			if (this.tok != (cxx ? "static_assert" : "_Static_assert"))
				goto default_case;
			parseStaticAssert();
			break;

		case "{": {
			this.next();
			local innerScope: CScope = CScope();
			/* Can just re-use the parent scope's symbol value hints */
			innerScope.symbolValues = namespaceStack.first.symbolValues;
			namespaceStack.pushfront(innerScope);
			parseStatements();
			namespaceStack.popfront();
			this.skip("}");
		}	break;

		case "case":
		case "default":
			if (!isInSwitchStatement)
				this.err("`case' or `default' outside of switch-statement");
			if (this.tok == "case") {
				this.next();
				local savedIsUnreachable = isUnreachable;
				isUnreachable = switchIsUnreachable;
				local caseValueLo: Bytes | none = parseTypedExprConstant(
					switchExpressionType, canRetainNothrow: false).last;
				local caseValueHi: Bytes | none = caseValueLo;
				if (this.tok == "...") {
					isUnreachable = switchIsUnreachable;
					this.next();
					caseValueHi = parseTypedExprConstant(
						switchExpressionType, canRetainNothrow: false).last;
				}
				isUnreachable = savedIsUnreachable;
				if (switchConstantExpressionValue !is none &&
				    caseValueLo !is none && caseValueHi !is none &&
				    !switchIsUnreachable) {
					/* When the switch-expression is constant, only
					 * disable unreachable if  case matches  switch */
					if (caseValueLo === caseValueHi || caseValueLo == caseValueHi) {
						if (switchConstantExpressionValue == caseValueLo)
							isUnreachable = false;
					} else {
						local switchType: CType = switchExpressionType.typ;
						local caseIntLo = switchType.peek(this, caseValueLo, 0);
						local caseIntHi = switchType.peek(this, caseValueHi, 0);
						local switchInt = switchType.peek(this, switchConstantExpressionValue, 0);
						if (switchInt >= caseIntLo && switchInt <= caseIntHi)
							isUnreachable = false;
					}
					this.skip(":");
					goto again;
				}
			} else {
				this.next();
			}
			this.skip(":");
			if (!switchIsUnreachable)
				isUnreachable = false;
			goto again;

		case "goto":
			this.next();
			if (this.tok == "*") {
				/* For addressable labels. */
				this.next();
				this.parseExpr();
			} else {
				this.parseSymbolName();
			}
			this.skip(";");
			isUnreachable = true;
			break;

		case "break":
			if (!isUnreachable)
				encounteredBreak = true;
			if (!isInLoop && !isInSwitchStatement)
				this.err("`break' outside of loop or switch");
			this.next();
			this.skip(";");
			isUnreachable = true;
			break;

		case "continue":
			if (!isInLoop)
				this.err("`continue' outside of loop");
			this.next();
			this.skip(";");
			isUnreachable = true;
			break;

		case "__builtin_define_alias":
			parseBuiltinDefineAlias();
			break;

		case "asm":
		case "__asm":
		case "__asm__":
			if (!isUnreachable)
				encounteredAsm = true;
			parseGCCAssemblyStatement();
			break;

		case "throw":
			if (!cxx)
				goto default_case;
			verifyRethrow();
			this.next();
			this.skip(";");
			break;

		case "try": {
			if (!cxx)
				goto default_case;
			local savedIsInTryBlock                        = isInTryBlock;
			local savedCurrentTryBlockExceptions           = currentTryBlockExceptions;
			local savedCurrentTryBlockGreatestNothrowLevel = currentTryBlockGreatestNothrowLevel;
			local savedEncounteredAsm                      = encounteredAsm;
			currentTryBlockExceptions           = HashSet();
			currentTryBlockGreatestNothrowLevel = -1;
			encounteredAsm                      = false;
			this.next();

			isInTryBlock = true;
			local tryIsUnreachable: bool = isUnreachable;
			this.require("{");
			this.parseStatement();
			isInTryBlock = savedCurrentTryBlockExceptions;

			local tryBlockGreatestNothrowLevel = currentTryBlockGreatestNothrowLevel;
			currentTryBlockGreatestNothrowLevel = savedCurrentTryBlockGreatestNothrowLevel;
			if (!currentTryBlockExceptions && !encounteredAsm &&
			    tryBlockGreatestNothrowLevel <= 0 && !isUnreachable) {
				this.warn("-Wthrows", "Guarded code never throws any exceptions");
			}
			if (tryIsUnreachable) {
				encounteredAsm = savedEncounteredAsm;
			} else if (savedEncounteredAsm) {
				encounteredAsm = true;
			}
			this.skip("catch");
			this.skip("(");
			this.skip("...");
			this.skip(")");

			local savedCurrentCatchBlockExceptions = currentCatchBlockExceptions;
			currentCatchBlockExceptions = currentTryBlockExceptions;
			currentTryBlockExceptions   = savedCurrentTryBlockExceptions;

			this.require("{");
			if (tryIsUnreachable) {
				isUnreachable = true;
				this.parseStatement();
				isUnreachable = true;
			} else {
				local tryEndIsUnreachable: bool = isUnreachable;
				isUnreachable = false;
				if (!currentCatchBlockExceptions)
					isUnreachable = true; /* Without exceptions, catch is unreachable */
				this.parseStatement();
				if (!tryEndIsUnreachable)
					isUnreachable = false;
			}
			currentCatchBlockExceptions = savedCurrentCatchBlockExceptions;
		}	break;

		case "switch": {
			this.next();
			this.skip("(");
			local switchExpr: CValue = parseExprRValue();
			local savedSwitchExpressionType          = switchExpressionType;
			local savedSwitchConstantExpressionValue = switchConstantExpressionValue;
			switchExpressionType = switchExpr.typeref;
			switchConstantExpressionValue = switchExpr.isConstExpr
				? switchExpr.constExprBytes
				: none;
			this.skip(")");
			this.require("{");

			local savedEncounteredBreak    = encounteredBreak;
			local savedIsInSwitchStatement = isInSwitchStatement;
			local savedSwitchIsUnreachable = switchIsUnreachable;
			encounteredBreak    = false;
			isInSwitchStatement = true;
			switchIsUnreachable = isUnreachable;
			if (isUnreachable) {
				parseStatement();
			} else {
				/* Switch statement contents are unreachable until a case/default label is hit. */
				isUnreachable = true;
				parseStatement();
			}

			/* If a reachable break-statement is hit, the end of the switch is reachable. */
			if (encounteredBreak)
				isUnreachable = false;

			encounteredBreak              = savedEncounteredBreak;
			isInSwitchStatement           = savedIsInSwitchStatement;
			switchIsUnreachable           = savedSwitchIsUnreachable;
			switchConstantExpressionValue = savedSwitchConstantExpressionValue;
			switchExpressionType          = savedSwitchExpressionType;
		}	break;

		case "if": {
			this.next();
			this.skip("(");
			local ifVal: CValue = parseExprRValue();
			this.skip(")");
			if (isUnreachable) {
				parseStatement();
				if (this.tok == "else") {
					this.next();
					parseStatement();
				}
			} else if (ifVal.isConstExpr) {
				if (ifVal.constExprValue(this)) {
					parseStatement();
					if (this.tok == "else") {
						this.next();
						local savedIsUnreachable = isUnreachable;
						isUnreachable = true;
						parseStatement();
						isUnreachable = savedIsUnreachable;
					}
				} else {
					isUnreachable = true;
					parseStatement();
					isUnreachable = false;
					if (this.tok == "else") {
						this.next();
						parseStatement();
					}
				}
			} else {
				/* Configure the expression value engine such that
				 * it  maintains identical values from both sides. */
				local ttScope = CScope();
				namespaceStack.pushfront(ttScope);
				parseStatement();
				namespaceStack.popfront();
				if (this.tok != "else") {
					/* The true-branch is conditional,  so
					 * it being noreturn doesn't propagate */
					isUnreachable = false;

					/* Value assumptions made  by the conditional  branch must  be
					 * inherited as unknowns because they might not always happen. */
					inheritAllSymbolValuesAsUnknowns(ttScope);
				} else {
					local ttIsNoReturn = isUnreachable;
					this.next();
					local ffScope = CScope();
					namespaceStack.pushfront(ffScope);
					isUnreachable = false;
					parseStatement();
					namespaceStack.popfront();
					if (!ttIsNoReturn)
						isUnreachable = false;
					local parentScope: CScope = namespaceStack.first;
					local ttOverrides: {CSymbol: Bytes | none} = ttScope.symbolValues;
					local ffOverrides: {CSymbol: Bytes | none} = ffScope.symbolValues;
					for (local symbol: ttOverrides.keys | ffOverrides.keys) {
						local ttValue: Bytes | bool | none = ttOverrides.get(symbol, false);
						local ffValue: Bytes | bool | none = ffOverrides.get(symbol, false);
						if (ttValue === false)
							ttValue = getSymbolValue(symbol);
						if (ffValue === false)
							ffValue = getSymbolValue(symbol);
						if (ttValue is none || ffValue is none) {
							ttValue = none;
						} else if (ttValue != ffValue) {
							ttValue = none;
						}
						parentScope.symbolValues[symbol] = ttValue;
					}
				}
			}
		}	break;

		case "while": {
			this.next();
			this.skip("(");
			local whileVal: CValue = parseExprRValue();
			this.skip(")");
			local savedIsInLoop         = isInLoop;
			local savedEncounteredBreak = encounteredBreak;
			isInLoop         = true;
			encounteredBreak = false;
			if (isUnreachable) {
				parseStatement();
			} else if (whileVal.isConstExpr && !whileVal.constExprValue(this)) {
				/* Loop condition is never true -> loop body is dead */
				isUnreachable = true;
				parseStatement();
				isUnreachable = false;
			} else {
				/* Must eval the loop in a sub-scope. Since it's  conditionally
				 * executed, we mustn't inherit symbol value overrides from it. */
				namespaceStack.pushfront(CScope());
				parseStatement();
				namespaceStack.popfront();
				if (encounteredBreak) {
					isUnreachable = false; /* There is a reachable break, so the loop can be exited */
				} else if (whileVal.isConstExpr && whileVal.constExprValue(this)) {
					isUnreachable = true; /* For-ever loop without break */
				}
			}
			isInLoop         = savedIsInLoop;
			encounteredBreak = savedEncounteredBreak;
		}	break;

		case "do": {
			this.next();
			local savedIsInLoop         = isInLoop;
			local savedEncounteredBreak = encounteredBreak;
			isInLoop         = true;
			encounteredBreak = false;

			local loopBodyLoc = this.backupCreate();
			local loopScope = CScope();
			namespaceStack.pushfront(loopScope);
			parseStatement();
			namespaceStack.popfront();
			this.skip("while");
			this.skip("(");
			local whileVal: CValue = parseExprRValue();
			if (isUnreachable) {
				/* End of loop isn't reachable */
				if (encounteredBreak)
					isUnreachable = false; /* Loop contains a reachable break -> loop can be exited */
			} else if (!whileVal.isConstExpr) {
				/* The while-body is executed [1-n] times. In this case, we can only
				 * inherit those its symbol value overrides if they remain unchanged
				 * after a second iteration. */
				if (!loopScope.symbolValues) {
					/* No value overrides -> don't need to check if we can inherit them! */
				} else {
					this.backupRestore(loopBodyLoc);
					loopBodyLoc = none;
					local pass1SymbolValues = loopScope.symbolValues;
					loopScope.symbolValues = Dict();
					namespaceStack.pushfront(loopScope);
					parseStatement();
					namespaceStack.popfront();
					this.skip("while");
					this.skip("(");
					local secondPassWhileCond = parseExprRValue();
					if (secondPassWhileCond !is none && whileVal == secondPassWhileCond) {
						if (pass1SymbolValues == loopScope.symbolValues) {
							/* Everything ended up the same -> can inherit */
							namespaceStack.first.symbolValues.update(pass1SymbolValues);
						}
					}
				}
			} else if (whileVal.constExprValue(this)) {
				/* For-ever loop without break never returns */
				if (!encounteredBreak)
					isUnreachable = true;
			} else {
				/* Special   case   for  `do { } while (0)'-loops   without  `break'.
				 * Here, we can always inherit the contained scope's value overrides. */
				if (!encounteredBreak)
					namespaceStack.first.symbolValues.update(loopScope.symbolValues);
			}

			this.skip(")");
			this.skip(";");
			if (loopBodyLoc !is none)
				this.backupDiscard(loopBodyLoc);
			isInLoop         = savedIsInLoop;
			encounteredBreak = savedEncounteredBreak;
		}	break;

		case "for": {
			namespaceStack.pushfront(CScope());
			this.next();
			this.skip("(");
			if (this.tok != ";") {
				if (!parseDeclaration(tryParse: true, withSemiColon: false))
					parseExprComma();
			}
			this.skip(";");
			local savedIsInLoop         = isInLoop;
			local savedEncounteredBreak = encounteredBreak;
			isInLoop         = true;
			encounteredBreak = false;

			local condVal: CValue = C_true;
			if (this.tok != ";")
				condVal = parseExprComma().inplaceRValue(this);
			this.skip(";");
			if (isUnreachable) {
				if (this.tok != ")")
					parseExprComma();
				this.skip(")");
				parseStatement();
			} else if (condVal.isConstExpr && !condVal.constExprValue(this)) {
				/* Loop condition is never true -> loop body is dead */
				isUnreachable = true;
				if (this.tok != ")")
					parseExprComma();
				this.skip(")");
				parseStatement();
				isUnreachable = false;
			} else {
				/* Must eval the loop in a sub-scope. Since it's  conditionally
				 * executed, we mustn't inherit symbol value overrides from it. */
				namespaceStack.pushfront(CScope());
				if (this.tok != ")")
					parseExprComma();
				this.skip(")");
				namespaceStack.pushfront(CScope());
				parseStatement();
				namespaceStack.popfront();
				namespaceStack.popfront();
				if (encounteredBreak) {
					isUnreachable = false; /* There is a reachable break, so the loop can be exited */
				} else if (condVal.isConstExpr && condVal.constExprValue(this)) {
					isUnreachable = true; /* For-ever loop without break */
				}
			}

			isInLoop         = savedIsInLoop;
			encounteredBreak = savedEncounteredBreak;
			namespaceStack.popfront();
		}	break;

		case "return": {
			this.next();
			local returnType: CType = currentFunctionTypeRef.typ.returnType;
			if (returnType === C_void) {
				if (this.tok != ";") {
					this.warn("-Wreturn",
						f"Non-empty return expression in function `{currentFunctionName}'"
						f"expected to return `void'");
					parseExprComma();
				}
			} else if (this.tok == ";") {
				this.warn("-Wreturn",
					f"Missing return expression in function `{currentFunctionName}' "
					f"expected to return `{returnType}'");
			} else {
				local returnTypeRef: CTypeRef = CTypeRef(returnType);
				local returnValue: CValue;
				for (;;) {
					returnValue = parseTypedExpr(returnTypeRef, canRetainNothrow: false,
						getExtraCannotRetainInfo: () ->
							f" (return type `{returnType}' of function "
							f"`{currentFunctionName}' appears incorrectly annotated)");
					if (this.tok != ",")
						break;
					this.next();
				}
				if (isUnreachable) {
					/* Unreachable code */
				} else if (!returnValue.isConstExpr) {
					currentFunctionReturnValue = none;
				} else if (currentFunctionReturnValue === false) {
					currentFunctionReturnValue = returnValue.constExprBytes;
				} else if (currentFunctionReturnValue !is none) {
					if (currentFunctionReturnValue != returnValue.constExprBytes)
						currentFunctionReturnValue = none;
				}
			}
			isUnreachable = true;
			this.skip(";");
		}	break;

		default:
default_case:
			if (this.tok.issymbol() && this.nextTokIsSingleColon()) {
				/* Special case: labels. */
				this.next();
				this.skip(":");
				isUnreachable = false;

				/* Must clear all symbol value overrides */
				for (local ns: namespaceStack)
					ns.symbolValues.clear();

				goto again;
			}
			if (!parseDeclaration(tryParse: true)) {
				local result: CValue = parseExprComma();
				this.skip(";");
				return result;
			}
			break;
		}
	}

	function parseStatements() {
		do {
			parseStatement();
		} while (this.tok !in ["", "}"]);
	}

	function parseArrayInitializer(typeref: CTypeRef): CValue {
		local typ: CArrayType = typeref.typ;
		if (isUnreachable) {
			parseArrayInitializerInto(typ, none, 0);
return_void_value:
			return CValue(CVALUE_RVOID, typeref);
		}
		local data: Bytes = Bytes(typ.sizeof);
		local finalLength: int;
		local finalData: Bytes | none;
		finalLength, finalData = parseArrayInitializerInto(typ, data, 0)...;
		if (typ.dim is none) {
			typ = copy typ;
			typ.dim = finalLength;
			typeref = copy typeref;
			typeref.typ = typ;
		}
		if (finalData is none)
			goto return_void_value;
		return CValue(
				kind:    CVALUE_RCONST,
				typeref: typeref,
				data:    finalData,
				offset:  0);
	}
	function parseArrayInitializerInto(typ: CArrayType, result: Bytes | none,
	                                   offset: int): (int, Bytes | none) {
		this.skip("{");
		local arrayLength: int = 0;
		local nextIndex: int = 0;
		local stride: int = typ.stride;
		while (this.tok != "}") {
			local loIndex: int = nextIndex;
			local hiIndex: int = nextIndex;
			if (this.tok == "[") {
				this.next();
				local loIndexValue: CValue = parseExprRValue();
				local hiIndexValue: CValue = loIndexValue;
				if (this.tok == "...") {
					this.next();
					hiIndexValue = parseExprRValue();
				}
				if (loIndexValue.isConstExpr && hiIndexValue.isConstExpr) {
					loIndex = loIndexValue.constExprValue(this);
					hiIndex = hiIndexValue.constExprValue(this);
					if (loIndex > hiIndex)
						this.err(f"Bad array initializer bounds: `[{loIndex} ... {hiIndex}]'");
				} else {
					result = none;
				}
				this.skip("]");
				this.skip("=");
			}
			local startOffset: int = offset + loIndex * stride;
			local endOffset: int   = offset + hiIndex * stride;
			if (result !is none && endOffset > #result)
				result = result.resized(endOffset);
			result = parseTypedExprInto(CTypeRef(typ.base), result, startOffset);
			if (endOffset > startOffset && result !is none) {
				/* Copy initializers into all other fields. */
				local src: Bytes = result[startOffset:startOffset + stride];
				for (local i: [:endOffset - startOffset]) {
					local destOffset: int = startOffset + (i + 1) * stride;
					result[destOffset:destOffset + stride] = src;
				}
			}
			nextIndex = hiIndex + 1;
			if (arrayLength < nextIndex)
				arrayLength = nextIndex;
			if (this.tok != ",")
				break;
			this.next();
		}
		this.skip("}");
		return (arrayLength, result);
	}

	function parseStructInitializer(typeref: CTypeRef): CValue {
		local typ: CStructType = typeref.typ;
		if (isUnreachable) {
			parseStructInitializerInto(typ, none, 0);
return_void_value:
			return CValue(CVALUE_RVOID, typeref);
		}
		local data: Bytes = Bytes(typ.sizeof);
		local finalData: Bytes | none = parseStructInitializerInto(typ, data, 0);
		if (finalData is none)
			goto return_void_value;
		return CValue(
				kind:    CVALUE_RCONST,
				typeref: typeref,
				data:    finalData,
				offset:  0);
	}
	function parseStructInitializerInto(typ: CStructType, result: Bytes | none, offset: int): Bytes | none {
		this.skip("{");
		@@Index of the next field to be initialized, or @none if not calculated, in
		@@which case the index of @fieldsByDeclarationLastField+1 needs to be used.
		local fieldsByDeclarationOrderNextIndex: int | none = 0;
		@@Name of the last-written field, or @none if none have been written, yet
		local fieldsByDeclarationLastField: string | none = none;
		while (this.tok != "}") {
			@@Name of the field to initialize
			local fieldName: string;
			local fieldType: CTypeRef;
			local fieldOffset: int;
			if (this.tok == ".") {
				this.next();
				fieldName = this.parseSymbolName();
				fieldsByDeclarationOrderNextIndex = none;
				this.skip("=");
			} else if (this.tok.issymbol() && this.nextTokIsSingleColon()) {
				fieldName = this.parseSymbolName();
				fieldsByDeclarationOrderNextIndex = none;
				this.skip(":");
			} else {
				/* Initialize the field that follows after the last-parsed field. */
				if (fieldsByDeclarationOrderNextIndex is none) {
					fieldsByDeclarationOrderNextIndex = 0;
					for (;;) {
						if (typ.fieldsByDeclarationOrder[fieldsByDeclarationOrderNextIndex].last == fieldsByDeclarationLastField)
							break;
						++fieldsByDeclarationOrderNextIndex;
					}
				} else {
					if (fieldsByDeclarationOrderNextIndex >= #typ.fieldsByDeclarationOrder)
						this.err(f"More field initializers after end of `{typ}'");
				}
				fieldName = typ.fieldsByDeclarationOrder[fieldsByDeclarationOrderNextIndex].last;
				++fieldsByDeclarationOrderNextIndex;
				if (!fieldName) {
					/* Initialize transparent struct/union */
					local innerStruct: CStructType = fieldType.typ;
					local firstFieldOffset: int;
					if (innerStruct.fieldsByDeclarationOrder) {
						local firstFieldName: string = innerStruct.fieldsByDeclarationOrder.first.last;
						firstFieldOffset = innerStruct.fields[firstFieldName].last;
					} else {
						firstFieldOffset = offset;
					}
					result = parseStructInitializerInto(fieldType.typ, result, firstFieldOffset);
					goto after_field_init;
				}
			}

			/* Lookup the field to initialize and parse its initializer. */
			fieldType, fieldOffset = typ.fields.get(fieldName)...;
			if (fieldType is none)
				this.err(f"Cannot initialize field `{fieldName}' which does not exists in `{typ}'");
			if (offset)
				fieldOffset += offset;
			result = parseTypedExprInto(fieldType, result, fieldOffset);
			fieldsByDeclarationLastField = fieldName;
after_field_init:
			if (this.tok != ",")
				break;
			this.next();
		}
		this.skip("}");
		return result;
	}

	function parseSkipUntil(oneOfTheseTokens: {string...}) {
		local recursionStack: {string...} = [];
		for (;;) {
			if (!recursionStack && (this.tok in oneOfTheseTokens))
				break;
			switch (this.tok) {
			case "(": case "<":
			case "[": case "{":
				recursionStack.append({
					"(": ")",
					"<": ">",
					"[": "]",
					"{": "}",
				}[this.tok]);
				break;
			case ")": case ">":
			case "]": case "}":
				if (recursionStack && recursionStack.last == this.tok)
					recursionStack.popback();
				break;
			default:
				break;
			}
			this.next();
		}
	}

	@@Skip over `__attribute__((...))` and `[[...]]`
	function parseSkipCTypeRefAttributes(): bool {
		local result: bool = false;
again:
		switch (this.tok) {

		case "[":
			/* Be careful not to parse as attribute in case of array type. */
			if (this.firstCharOfNextTok() != "[")
				break;
			this.next();
			this.skip("[");
			parseSkipUntil({ "]" });
			this.skip("]");
			this.skip("]");
			result = true;
			goto again;

		case "__attribute":
		case "__attribute__":
			this.next();
			this.skip("(");
			this.skip("(");
			parseSkipUntil({ ")" });
			this.skip(")");
			this.skip(")");
			result = true;
			goto again;

		case "alignas":
			this.next();
			this.skip("(");
			parseSkipUntil(")");
			this.skip(")");
			result = true;
			goto again;

		case "__extension__":
			/* In GCC, this suppresses warnings about use of extensions. */
			this.next();
			result = true;
			goto again;

		default:
			break;
		}
		return result;
	}

	function parseSkipCTypeRefConstVolatile() {
again:
		switch (this.tok) {
		case "const":
		case "__const":
		case "__const__":
		case "volatile":
		case "__volatile":
		case "__volatile__":
		case "restrict":
		case "__restrict":
		case "__restrict__":
			this.next();
			goto again;
		case "[":
		case "__attribute":
		case "__attribute__":
		case "alignas":
		case "__extension__":
			if (!parseSkipCTypeRefAttributes())
				break;
			goto again;
		default: break;
		}
	}

	@@Skip over the base-portion of a typeref expression
	@@s.a. @parseCTypeRefBase
	function parseSkipCTypeRefBase(): bool {
		local hasIntFlags: bool = false;
		local result: bool = false;
again:
		switch (this.tok) {

		case "[":
		case "__attribute":
		case "__attribute__":
		case "alignas":
		case "__extension__":
			if (!parseSkipCTypeRefAttributes())
				break;
			result = true;
			goto again;

		case "const":
		case "__const":
		case "__const__":
		case "volatile":
		case "__volatile":
		case "__volatile__":
		case "restrict":
		case "__restrict":
		case "__restrict__":
			goto next;

		case "signed":
		case "__signed":
		case "__signed__":
		case "unsigned":
		case "__unsigned":
		case "__unsigned__":
		case "int":
		case "char":
		case "short":
		case "long":
		case "__int8":
		case "__int16":
		case "__int32":
		case "__int64":
		case "__int128":
		case "double":
		case "void":
		case "float":
		case "wchar_t":
		case "__wchar_t":
		case "_Bool":
		case "bool":
		case "char8_t":
		case "char16_t":
		case "char32_t":
			hasIntFlags = true;
			goto next;

		case "class":
		case "struct":
		case "union":
		case "enum":
			this.next();
			parseSkipCTypeRefAttributes();
			if (this.tok.issymbol())
				this.next();
			if (this.tok == ":")
				parseSkipUntil("{");
			if (this.tok == "{") {
				this.next();
				parseSkipUntil("}");
				this.skip("}");
			}
			result = true;
			break;

		case "decltype":
		case "typeof":
		case "__typeof":
		case "__typeof__":
			this.next();
			this.skip("(");
			parseSkipUntil(")");
			this.skip(")");
			break;

		default:
			if (hasIntFlags) {
				parseSkipCTypeRefConstVolatile();
				break;
			}
			if (this.tok.issymbol()) {
				result = true;
				this.next();
				while (this.tok == "::") {
		case "::":
					this.next();
					this.requireSymbolName();
					this.next();
				}
				if (this.tok == "<") {
					this.next();
					parseSkipUntil({ ">" });
					this.skip(">");
				}
				result = true;
				parseSkipCTypeRefConstVolatile();
				break;
			}
			break;

		}
		return result;
next:
		result = true;
		this.next();
		goto again;
	}

	@@Skip over the inner-portion of a typeref expression
	@@s.a. @parseTypeRefInner
	@@@return: * : The name of the typeref expression (or an empty string if unnamed)
	function parseSkipTypeRefInner(): string {
		/* Parse the inner type-ref prefix (iow: pointer types) */
prefixAgain:
		if (this.tok == "*") {
			this.next();
			if (this.tok in ["__ptr32", "__ptr64"])
				this.next();
			parseSkipCTypeRefConstVolatile();
			goto prefixAgain;
		}
		parseSkipCTypeRefAttributes();

		local result: string;
		if (this.tok == "(") {
			this.next();
			result = parseSkipTypeRefInner();
			this.skip(")");
		} else {
			/* Parse variable name */
			if (this.tok.issymbol()) {
				result = this.tok;
				this.next();
			} else {
				result = "";
			}
		}
		return result;
	}


	function parseTemplateParam(): TemplateParam {
		local result: TemplateParam = TemplateParam();
		if (this.tok in ["class", "typename"]) {
			this.next();
			result.typeref = none;
			result.decl = this.flc;
			result.name = this.parseSymbolName();
		} else {
			result.decl = this.flc;
			result.typeref, result.name = parseTypeRefWithoutStorageClass()...;
			result.typeref.flags |= CTYPEREF_FLAG_CONST; /* Needed so constants are inlined */
		}
		if (this.tok == "=") {
			local backup = this.subChunkBegin();
			parseSkipUntil({ ",", ">", ">>", ">=", ">>=" });
			result.defaultInit, result.defaultDecl = this.subChunkEnd(backup)...;
		}
		return result;
	}

	function instantiateTemplate(template: CTypeRefTemplate | CSymbolTemplate,
	                             args: {TemplateParamValue...}): CTypeRef | CSymbol {
		local templateParams: {TemplateParam...} = template.params;
		local templateScope: CScope | none = none;
		assert #args <= #templateParams;
		local hasAllTemplateArgs = #args >= #templateParams;

		/* Check if another instance already exists for this set of parameters. */
		local result: CTypeRef | CSymbol | none;
		if (hasAllTemplateArgs) {
			if (args !is Tuple)
				args = Tuple(args);
			result = template.instances.get(args);
			if (result !is none)
				return result;
		}

		local templateScope = CScope();
		namespaceStack.pushfront(templateScope);
		for (local i: [:#args]) {
			local argValue: TemplateParamValue = args[i];
			local argParam: TemplateParam = templateParams[i];
			assert (argValue is Bytes) == (argParam.typeref !is none);
			templateScope.defineTemplateParamValue(argParam, argValue);
		}

		/* Load default template arguments for missing arguments. */
		if (!hasAllTemplateArgs) {
			args = List(args);
			for (local argParam: templateParams[#args:]) {
				if (argParam.defaultInit is none)
					this.err(f"Template argument `{argParam.name}' is missing and has no default");
				local backup = this.subChunkPush(argParam.defaultInit, argParam.defaultDecl);
				local argValue: TemplateParamValue;
				if (argParam.typeref is none) {
					argValue = parseTypeRefWithoutStorageClassOrName();
				} else {
					argValue = parseTypedExprConstant(argParam.typeref, canRetainNothrow: false).last;
				}
				if (this.tok) {
					this.err(
						f"Unrecognized token `{this.tok}' after default value "
						f"of template `{template.name}' argument `{argParam.name}'");
				}
				this.subChunkPop(backup);
				templateScope.defineTemplateParamValue(argParam, argValue);
				args.append(argValue);
			}
			args = Tuple(args);
			/* Check if another instance already exists for this set of parameters. */
			result = template.instances.get(args);
			if (result !is none) {
				namespaceStack.popfront();
				return result;
			}
		} else {
			if (args !is Tuple)
				args = Tuple(args);
		}

		/* At this point, all template parameters have been loaded.
		 * -> Time to parse the template's type initializer. */
		local backup = this.subChunkPush(template.typeInit, template.typeDecl);
		/* Remember this template instantiation */
		if (template is CSymbolTemplate) {
			result = CSymbol(template.name, template.decl);
			template.instances[args] = result;
			local typeref: CTypeRef;
			try {
				typeref = parseTypeRefWithoutStorageClass().first;
			} catch (e...) {
				this.errMsg(f"In symbol-template type-instantiation "
				            f"`{template.instantiationRepr(this, args)}'");
				this.subChunkPop(backup);
				throw;
			}
			if (this.tok) {
				this.err(f"Unrecognized token `{this.tok}' after "
				         f"symbol-template `{template.name}' type-block");
			}
			this.subChunkPop(backup);

			/* We're actually parsing a symbol initializer, so we must also parse the symbol! */
			backup = this.subChunkPush(template.valInit, template.valDecl);
			local symValue: CValue;
			try {
				symValue = parseTypedExpr(typeref);
			} catch (e...) {
				this.errMsg(f"In symbol-template init-instantiation "
				            f"`{template.instantiationRepr(this, args)}'");
				this.subChunkPop(backup);
				throw;
			}
			if (this.tok) {
				this.err(f"Unrecognized token `{this.tok}' after "
				         f"symbol-template `{template.name}' init-block");
			}
			this.subChunkPop(backup);
			local symValueConstant = symValue.isConstExpr ? symValue.constExprBytes : none;
			assert result is CSymbol;
			result.typeref = symValue.typeref;
			result.val = symValueConstant;
		} else {
			result = CTypeRef();
			template.instances[args] = result;
			try {
				if (parseCTypeRefBase(result) is none)
					this.err(f"Cannot parse type from {repr this.tok}");
				local finalTypeRef = parseTypeRefInner(result, "").first;
				if (finalTypeRef !== result)
					template.instances[args] = result = finalTypeRef;
			} catch (e...) {
				this.errMsg(f"In typedef-template instantiation "
				            f"`{template.instantiationRepr(this, args)}'");
				this.subChunkPop(backup);
				throw;
			}
			if (this.tok) {
				this.err(f"Unrecognized token `{this.tok}' after "
				         f"template `{template.name}' type-block");
			}
			this.subChunkPop(backup);
		}

		/* Cleanup the scope that was used during the template instantiation. */
		namespaceStack.popfront();
		return result;
	}

	function parseTemplate(): CTypeRefTemplate | CSymbolTemplate {
		assert this.tok == "template";
		this.next();
		this.skip("<");
		local templateParams: {TemplateParam...} = [];
		while (!this.tok.startswith(">")) {
			templateParams.append(parseTemplateParam());
			if (this.tok != ",")
				break;
			this.next();
		}
		this.skip(">");

		/* Simple case: `template using':
		 * >> template<class T> using Foo = Bar<T>; */
		local result: CTypeRefTemplate | CSymbolTemplate;
		if (this.tok == "using") {
			this.next();
			result = CTypeRefTemplate();
			result.decl = this.flc;
			result.name = this.requireSymbolName();
			local tab: {string: CTypeRef | CTypeRefTemplate} | none = namespaceStack.first.typedefs;
			if (tab is none)
				namespaceStack.first.typedefs = tab = Dict();
			if (result.name in tab)
				this.err(f"Redefinition of typedef `{result.name}' with template using");
			this.next();
			result.params = templateParams;
			this.skip("=");
			local usingInitBackup = this.subChunkBegin();
			parseSkipUntil({ ";" });
			result.typeInit, result.typeDecl = this.subChunkEnd(usingInitBackup)...;
			this.skip(";");
			tab[result.name] = result;
			goto done;
		}

		/* Must  support   the   following   cases:
		 * >> template<class T> struct Foo { T x };
		 * >> template<class T> union Foo { T x };
		 * >> template<class T> Foo<T> foo;
		 * >> template<class T> Foo<T> foo = 42;
		 * >> template<class T> Foo<T> foo();
		 * >> template<class T> Foo<T> foo() { return 42; }
		 */
		local typeDeclChunkBackup = this.subChunkBegin();
		parseSkipCTypeRefAttributes();

		/* Check  if  it's a  struct/union/class template  (as  opposed to  a normal
		 * template that just so happens to return/be-typed-as a struct/union/class) */
		switch (this.tok) {

		case "struct":
		case "union":
		case "class": {
			this.next();
			parseSkipCTypeRefAttributes();
			local structName: string = this.tok;
			local structDecl: (string, int, int) = this.flc;
			if (structName.issymbol()) {
				this.next();
				parseSkipCTypeRefAttributes();
			} else {
				structName = "";
			}
			if (this.tok == ":")
				parseSkipUntil({ "{" });
			if (this.tok == "{") {
				this.next();
				parseSkipUntil({ "}" });
				this.skip("}");
				if (this.tok == ";") {
update_or_create_struct_template:
					if (!structName)
						this.err("Unnamed struct/union/class templates are not allowed");
					/* Yup! it's a struct/union/class template! */
					local tab: {string: CTypeRef | CTypeRefTemplate} | none = namespaceStack.first.typedefs;
					if (tab is none)
						namespaceStack.first.typedefs = tab = Dict();
					local oldDecl: CTypeRef | CTypeRefTemplate | none = tab.get(structName);
					if (oldDecl !is none) {
						if (oldDecl is CTypeRefTemplate && oldDecl.typeInit !is bound) {
							/* Uninitialized (forward-declared) template */
						} else {
							this.err(f"Redefinition of typedef `{structName}' "
							         f"with template struct/union/class");
						}
						result = oldDecl;
					} else {
						result = CTypeRefTemplate();
						tab[structName] = result;
					}
					result.name = structName;
					result.decl = structDecl;
					result.params = templateParams;
					if (typeDeclChunkBackup !is none)
						result.typeInit, result.typeDecl = this.subChunkEnd(typeDeclChunkBackup)...;
					this.next();
					goto done;
				}
			} else if (this.tok == ";") {
				this.subChunkEnd(typeDeclChunkBackup);
				typeDeclChunkBackup = none;
				goto update_or_create_struct_template;
			}
		}	break;

		default:
			/* Skip type keywords. */
			if (!parseSkipCTypeRefBase())
				this.err(f"Expected type-base-expression base `template', but got `{this.tok}'");
			break;
		}

		/* At this point, we've parsed an abstract typeref prefix:
		 * >> int (*foo)(int, int, int) = 42;
		 *        ^--- We are here
		 * This also means that we know that it's going to be a
		 * symbol template  (rather than  a typedef  template).
		 *
		 * We must now figure out the template name (above:  "foo"),
		 * and then skip ahead until the "=" (which can also be ";") */
		local templateDecl: (string, int, int) = this.flc;
		local templateName: string = parseSkipTypeRefInner();
		if (!templateName)
			this.err("Unnamed symbol templates are not allowed");

		/* Skip until the template symbol/function initializer (or the end-of-declaration marker) */
		this.parseSkipUntil({ "=", "{", ";" });

		/* All right! At this point we've got the symbol name and the parser
		 * should be located at the body/initialize of the  symbol/function.
		 *
		 * Time to create the template object and fill in its fields. */
		local tab: {string: CSymbol | CSymbolTemplate} | none = namespaceStack.first.symbols;
		if (tab is none)
			namespaceStack.first.typedefs = tab = Dict();
		result = tab.get(templateName);
		local typeInit: Bytes;
		local typeDecl: (string, int, int);
		typeInit, typeDecl = this.subChunkEnd(typeDeclChunkBackup)...;
		if (result is none) {
			result = CSymbolTemplate();
		} else if (result !is CSymbolTemplate) {
			if (this.tok in ["{", ";"]) {
				if (result is COverloadedFunctionSymbol) {
create_for_overloaded_function_symbol:
					result = result.getOrCreateTemplateOverload(typeInit);
					goto fill_template;
				} else if (result.typeref.typ is CFunctionType) {
					/* Turn into an overloaded function */
					local overloadsDecl = COverloadedFunctionSymbol();
					overloadsDecl.name = templateName;
					overloadsDecl.decl = result.decl;
					overloadsDecl.typeref = none;
					overloadsDecl.overloads.append(result);
					tab[templateName] = result = overloadsDecl;
					goto create_for_overloaded_function_symbol;
				}
			}
			this.err(f"Redefinition of non-template symbol `{templateName}' with template");
		}
fill_template:
		result.name = templateName;
		result.decl = templateDecl;
		result.params = templateParams;
		result.typeInit = typeInit;
		result.typeDecl = typeDecl;
		if (this.tok == "=") {
			if (result.valInit is bound)
				this.err(f"Redefinition of template-symbol `{templateName}'");
			result.isFunction = false;
			parseSkipUntil({ ";" });
			this.skip(";");
		} else if (this.tok == "{") {
			if (result.valInit is bound)
				this.err(f"Redefinition of template-function `{templateName}'");
			result.isFunction = true;
			this.next();
			parseSkipUntil({ "}" });
			this.skip("}");
		}
done:
#ifdef DUMP_TOP_LEVEL_DECLS
		if (currentFunctionName is none) {
			print("template: ", result.name, ": ", result,  ";");
		}
#endif /* DUMP_TOP_LEVEL_DECLS */
		return result;
	}

	function parseStaticAssert() {
		this.next();
		this.skip("(");
		local value: int | none = parseExprConstantInteger();
		if (value is none) {
			/* Inside unreachable block */
		} else if (!value) {
			local message: string;
			if (this.tok == ",") {
				this.next();
				message = this.parseString();
			} else {
				message = this.parseString();
			}
			this.err("Static assertion failed");
		}
		if (this.tok == ",") {
			this.next();
			this.parseString();
		}
		this.skip(")");
		this.skip(";");
	}

	@@Parse stuff from the global scope
	function parseGlobal() {
again:
		switch (this.tok) {

		case "":
		case "}":
			break;

		case ";":
			this.next();
			goto again;

		case "template":
			if (!cxx && !isInExternC)
				goto default_case;
			parseTemplate();
			goto again;

		case "__builtin_define_alias":
			parseBuiltinDefineAlias();
			break;

		case "asm":
		case "__asm":
		case "__asm__":
			/* Global assembly (ignore) */
			this.next();
			this.skip("(");
			this.parseString();
			this.skip(")");
			this.skip(";");
			goto again;

		case "static_assert":
		case "_Static_assert":
			if (this.tok != (cxx ? "static_assert" : "_Static_assert"))
				goto default_case;
			parseStaticAssert();
			break;

		case "namespace": {
			if (!cxx)
				goto default_case;
			this.next();
			local ns = namespaceStack.first;
			do {
				ns = ns.childNamespace(this.parseSymbolName());
			} while (this.trySkip("::"));
			namespaceStack.pushfront(ns);
			this.skip("{");
			do {
				parseGlobal();
			} while (this.tok !in ["", "}"]);
			this.skip("}");
			namespaceStack.popfront();
		}	break;

		case "using": {
			if (!cxx)
				goto default_case;
			this.next();
			if (this.tok == "namespace") {
				this.next();
				local ns: CNamespace | none = nsLookupChain("namespace");
				if (ns is none)
					this.err(f"No such namespace `{this.tok}'");
				local imports = namespaceStack.first.importedNamespaces;
				if (ns !in imports) {
					if (imports is none)
						namespaceStack.first.importedNamespaces = imports = List();
					imports.append(ns);
				}
			} else {
				if (this.tok.issymbol() && this.nextTokIsEquals()) {
					/* using foo = bar; */
					local name: string = this.parseSymbolName();
					this.skip("=");
					local newTypeRef: CTypeRef | none = nsLookupChain("typedefs");
					if (newTypeRef is none)
						this.err(f"No such symbol/typedef `{this.tok}'");
					local tab: {string: CTypeRef} | none = namespaceStack.first.typedefs;
					local existingTypeRef: CTypeRef | none = tab.get(name);
					if (existingTypeRef !is none && existingTypeRef != newTypeRef)
						this.err(f"Duplicate declaration of {name}");
					if (tab is none)
						namespaceStack.first.typedefs = tab = Dict();
					tab[name] = newTypeRef;
				} else {
					local tabName: string;
					local element: Object | none;
					for (tabName: ["symbols", "typedefs"]) {
						element = nsLookupChain(tabName);
						if (element !is none)
							break;
					}
					if (element is none)
						this.err(f"No such symbol/typedef `{this.tok}'");
					local name: string = _nsLookupChildChainSymbolName;
					local tab: {string: Object} | none = namespaceStack.first.operator . (tabName);
					local existingElement: Object | none = tab.get(name);
					if (existingElement !is none && existingElement != element)
						this.err(f"Duplicate declaration of {name}");
					if (tab is none)
						namespaceStack.first.operator . (tabName) = tab = Dict();
					tab[name] = element;
				}
			}
			this.skip(";");
		}	break;

		case "extern":
			if (!cxx)
				goto default_case;
			this.next();
			if (this.tok.startswith('"')) {
				local externMode = this.parseString();
				local savedIsInExternC = isInExternC;
				isInExternC = externMode == "C";
				this.skip("{");
				do {
					parseGlobal();
				} while (this.tok !in ["", "}"]);
				this.skip("}");
				isInExternC = savedIsInExternC;
				return;
			}
			parseDeclaration("extern");
			break;

		default:
default_case:
			parseDeclaration();
			break;
		}
	}


	/* Expression parser */
	// function parseExprUnaryPrefix(): CValue;
	// function parseExprUnarySuffix(value: CValue): CValue;
	// function parseExprUnary(): CValue;
#define parseExprUnarySuffixCheck(tok) ((tok) in ["[", "(", ".", "->", "++", "--"])
#define parseExprUnarySuffix_CASE \
	case "[":                     \
	case "(":                     \
	case ".":                     \
	case "->":                    \
	case "++":                    \
	case "--"

	// function parseExprProdSuffix(value: CValue): CValue;
	// function parseExprProd(): CValue;
#define parseExprProdSuffixCheck(tok) ((tok) in "*/%")
#define parseExprProdSuffix_CASE \
	case "*":                    \
	case "/":                    \
	case "%"

	// function parseExprSumSuffix(value: CValue): CValue;
	// function parseExprSum(): CValue;
#define parseExprSumSuffixCheck(tok) ((tok) in "+-")
#define parseExprSumSuffix_CASE \
	case "+":                   \
	case "-"

	// function parseExprShiftSuffix(value: CValue): CValue;
	// function parseExprShift(): CValue;
#define parseExprShiftSuffixCheck(tok) ((tok) in ["<<", ">>"])
#define parseExprShiftSuffix_CASE \
	case "<<":                    \
	case ">>"

	// function parseExprCmpSuffix(value: CValue): CValue;
	// function parseExprCmp(): CValue;
#define parseExprCmpSuffixCheck(tok) ((tok) in ["<", ">", "<=", ">="])
#define parseExprCmpSuffix_CASE \
	case "<":                   \
	case ">":                   \
	case "<=":                  \
	case ">="

	// function parseExprCmpEqSuffix(value: CValue): CValue;
	// function parseExprCmpEq(): CValue;
#define parseExprCmpEqSuffixCheck(tok) ((tok) in ["==", "!="])
#define parseExprCmpEqSuffix_CASE \
	case "==":                    \
	case "!="

	// function parseExprBitAndSuffix(value: CValue): CValue;
	// function parseExprBitAnd(): CValue;
#define parseExprBitAndSuffixCheck(tok) ((tok) == "&")
#define parseExprBitAndSuffix_CASE case "&"

	// function parseExprBitXorSuffix(value: CValue): CValue;
	// function parseExprBitXor(): CValue;
#define parseExprBitXorSuffixCheck(tok) ((tok) == "^")
#define parseExprBitXorSuffix_CASE case "^"

	// function parseExprBitOrSuffix(value: CValue): CValue;
	// function parseExprBitOr(): CValue;
#define parseExprBitOrSuffixCheck(tok) ((tok) == "|")
#define parseExprBitOrSuffix_CASE case "|"

	// function parseExprLAndSuffix(value: CValue): CValue;
	// function parseExprLAnd(): CValue;
#define parseExprLAndSuffixCheck(tok) ((tok) == "&&")
#define parseExprLAndSuffix_CASE case "&&"

	// function parseExprLOrSuffix(value: CValue): CValue;
	// function parseExprLOr(): CValue;
#define parseExprLOrSuffixCheck(tok) ((tok) == "||")
#define parseExprLOrSuffix_CASE case "||"

	// function parseExprCondSuffix(value: CValue): CValue;
	// function parseExprCond(): CValue;
#define parseExprCondSuffixCheck(tok) ((tok) == "?")
#define parseExprCondSuffix_CASE case "?"

	// function parseExprAssignSuffix(value: CValue): CValue;
	// function parseExpr(): CValue;
#define parseExprAssignSuffixCheck(tok) \
	((tok) in ["=", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "<<=", ">>=", "^="])
#define parseExprAssignSuffix_CASE \
	case "=":                      \
	case "+=":                     \
	case "-=":                     \
	case "*=":                     \
	case "/=":                     \
	case "%=":                     \
	case "|=":                     \
	case "&=":                     \
	case "<<=":                    \
	case ">>=":                    \
	case "^="

	/*****************************************************************************
	** Core parsers                                                             **
	*****************************************************************************/
	function parseExprUnaryPrefix(): CValue {
		local tok = this.tok;
		switch (tok) {

		case "nullptr":
			this.next();
			return copy TARGET_C_nullptr;

		case "true":
			this.next();
			return copy C_true;

		case "false":
			this.next();
			return copy C_false;

		case "__func__":
			if (currentFunctionName is none)
				goto default_case;
			this.next();
			return cvalueFromString(currentFunctionName);

		case "&&": /* For addressable labels. */
			this.next();
			this.parseSymbolName();
return_unknown_void_pointer:
			return CValue(kind: CVALUE_AVOID,
				typeref: CTypeRef(TARGET_CPointerType(CTypeRef(C_void))));

		case "__builtin_alloca":
			this.next();
			this.skip("(");
			parseExpr().inplaceCast(this, CTypeRef(TARGET_C_size_t));
			this.skip(")");
			goto return_unknown_void_pointer;

		case "__builtin_return_address":
		case "__builtin_frame_address":
			this.next();
			this.skip("(");
			parseExpr().inplaceCast(this, C_uint_typeref);
			this.skip(")");
			goto return_unknown_void_pointer;

		case "__builtin_extract_return_addr":
		case "__builtin_frob_return_addr":
			this.next();
			this.skip("(");
			parseExpr().inplaceCast(this, CTypeRef(TARGET_CPointerType(CTypeRef(C_void))));
			this.skip(")");
			goto return_unknown_void_pointer;

		case "__builtin_stack_restore":
			this.next();
			this.skip("(");
			parseExpr();
			this.skip(")");
			goto return_C_voidval;

		case "__builtin_stack_save":
			this.next();
			this.skip("(");
			this.skip(")");
			goto return_unknown_void_pointer;

		case "__builtin_void": {
			this.next();
			this.skip("(");
			local result: CValue = parseExpr().inplaceVoid;
			this.skip(")");
			return result;
		}	break;

		case "__builtin_rvoid": {
			this.next();
			this.skip("(");
			local result: CValue = parseExpr()
					.inplaceVoid
					.inplaceRValue(this);
			this.skip(")");
			return result;
		}	break;

		case "__builtin_bswap16":
		case "__builtin_bswap32":
		case "__builtin_bswap64":
		case "__builtin_bswap128": {
			local typ: CType;
			switch (tok) {
			case "__builtin_bswap16":  typ = C_ushort; break;
			case "__builtin_bswap32":  typ = C_uint; break;
			case "__builtin_bswap64":  typ = TARGET_C_ullong; break;
			case "__builtin_bswap128": typ = TARGET_C_uint128_t; break;
			}
			this.next();
			this.skip("(");
			local result = parseExpr().inplaceCast(this, CTypeRef(typ));
			this.skip(")");
			if (result.isConstExpr) {
				local val = result.constExprValue(this);
				switch (tok) {
				case "__builtin_bswap16":  val = val.swap16; break;
				case "__builtin_bswap32":  val = val.swap32; break;
				case "__builtin_bswap64":  val = val.swap64; break;
				case "__builtin_bswap128": val = val.swap128; break;
				}
				result.data = result.typeref.typ.bytes(this, val);
				result.offset = 0;
			}
			return result;
		}	break;

		case "__builtin_rethrow": {
			verifyRethrow();
			this.next();
			this.skip("(");
			this.skip(")");
			isUnreachable = true;
return_C_voidval:
			return copy C_voidval;
		}	break;

		case "__builtin_throw": {
			this.next();
			this.skip("(");
			local exceptCodeValue: CValue = parseExprRValue();
			local exceptCode: int = exceptCodeValue.isConstExpr
				? exceptCodeValue.constExprValue(this)
				: 0;
			if (!isUnreachable) {
				currentTryBlockExceptions.insert(exceptCode);
				if (!isInTryBlock) {
					/* Assert that `exceptCode' is part of the caller's throws-attribute */
					verifyTopLevelThrows({exceptCode},
						getReason: _ -> "it `THROW()`s it here");
				}
			}
			while (this.tok == ",") {
				this.next();
				this.parseExpr();
			}
			this.skip(")");
			isUnreachable = true;
			goto return_C_voidval;
		}	break;

		case "alignof":
		case "_Alignof":
			if (this.tok != (cxx ? "alignof" : "_Alignof"))
				goto default_case;
			/* FALLTHRU */
		case "sizeof":
		case "__alignof":
		case "__alignof__":
		case "__builtin_alignof": {
			this.next();
			local typ: CType;
			if (this.tok == "(") {
				this.next();
				typ = parseTypeOrExpressionType().typ;
				this.skip(")");
			} else {
				typ = parseTypeOrExpressionType().typ;
			}
			return cvalueFromValue(this, CTypeRef(TARGET_C_size_t), typ.operator . (
					tok == "sizeof" ? "sizeof" : "alignof"));
		}	break;

		case "__builtin_expect":
		case "__builtin_expect_with_probability": {
			this.next();
			this.skip("(");
			local result: CValue = parseExpr();
			this.skip(",");
			parseExpr();
			if ("probability" in tok) {
				this.skip(",");
				parseExpr();
			}
			this.skip(")");
			return result;
		}	break;

		case "__builtin_unreachable": {
			this.next();
			this.skip("(");
			this.skip(")");
			isUnreachable = true;
			goto return_C_voidval;
		}	break;

		case "__builtin_constant_p": {
			this.next();
			this.skip("(");
			local expr: CValue = parseExprRValue();
			this.skip(")");
			return cvalueFromValue(this, C_int_typeref, expr.isConstExpr ? 1 : 0);
		}	break;

		case "__builtin_types_compatible_p": {
			this.next();
			this.skip("(");
			local a: CTypeRef = parseTypeOrExpressionType();
			this.skip(",");
			local b: CTypeRef = parseTypeOrExpressionType();
			this.skip(")");
			local r: CTypeRef | none = commonType(a, b, true);
			return cvalueFromValue(this, C_int_typeref, r !is none ? 1 : 0);
		}	break;

		case "__builtin_has_attribute": {
			this.next();
			this.skip("(");
			local check: CTypeRef = parseExpr().typeref;
			this.skip(",");
			local template: CTypeRef = CTypeRef();
			parseCTypeRefAttribute(template);
			this.skip(")");
			/* Verify that by merging attributes, we get `(check & template) == template' */
			return cvalueFromValue(this, C_int_typeref,
				check.hasAllAttributesFrom(template) ? 1 : 0);
		}	break;

		case "__builtin_speculation_safe_value":
		case "__builtin_assoc_barrier": {
			this.next();
			this.skip("(");
			local result = parseExpr();
			if (this.tok == "," && tok == "__builtin_speculation_safe_value") {
				this.next();
				parseExpr();
			}
			this.skip(")");
			return result;
		}	break;

		case "__builtin_offsetof":
		case "__builtin_offsetafter": {
			this.next();
			this.skip("(");
			local typ: CTypeRef = parseTypeRefWithoutStorageClassOrName();
			this.skip(",");
			local val: CValue = CValue(CVALUE_LADDR, typ, offset: 0)
				.inplaceField(this, this.parseSymbolName());
again_builtin_offsetof_suffix:
			switch (this.tok) {
			case ".":
				this.next();
				val.inplaceField(this, this.parseSymbolName());
				goto again_builtin_offsetof_suffix;
			case "[":
				this.next();
				val.inplaceOp2(this, "+", parseExprConstant()).inplaceInd(this);
				this.skip("]");
				goto again_builtin_offsetof_suffix;
			default:
				break;
			}
			this.skip(")");
			val.inplaceRef(this);
			if (tok == "__builtin_offsetafter")
				val.inplaceOp2(this, "+", cvalueFromValue(this, C_int_typeref, 1));
			return val.inplaceCast(this, CTypeRef(TARGET_C_size_t), true);
		}	break;

		case "__builtin_container_of": {
			this.next();
			this.skip("(");
			local ptr: CValue = parseExprRValue();
			if (ptr.typeref.typ !is CPointerType) {
				this.err(f"First argument o `__builtin_container_of' "
				         f"must be a pointer, but is `{ptr.typeref}'");
			}
			this.skip(",");
			local typ: CTypeRef = parseTypeRefWithoutStorageClassOrName();
			this.skip(",");
			local val: CValue = CValue(CVALUE_LADDR, typ, offset: 0)
				.inplaceField(this, this.parseSymbolName());
again_builtin_container_of_suffix:
			switch (this.tok) {
			case ".":
				this.next();
				val.inplaceField(this, this.parseSymbolName());
				goto again_builtin_container_of_suffix;
			case "[":
				this.next();
				val.inplaceOp2(this, "+", parseExprConstant()).inplaceInd(this);
				this.skip("]");
				goto again_builtin_container_of_suffix;
			default:
				break;
			}
			this.skip(")");
			val.inplaceRef(this);
			if (commonType(ptr.typeref, val.typeref, true) is none) {
				this.warn("-Wcast",
					f"`__builtin_container_of' pointer argument `{ptr.typeref}' "
					f"differs from field type `{val.typeref.typ.base}'");
			}
			val.inplaceCast(this, CTypeRef(TARGET_C_size_t), true);
			return ptr /* NOTE: We cast to a char-pointer so that pointer attributes can be retained */
				.inplaceCast(this, CTypeRef(TARGET_CPointerType(CTypeRef(C_char))), true)
				.inplaceOp2(this, "-", val)
				.inplaceCast(this, CTypeRef(TARGET_CPointerType(typ)), true);
		}	break;

		case "__builtin_LINE":
		case "__builtin_FILE":
		case "__builtin_FUNCTION": {
			this.next();
			this.skip("(");
			this.skip(")");
			if (tok == "__builtin_FUNCTION")
				return cvalueFromString(currentFunctionName);
			if (tok == "__builtin_FILE")
				return cvalueFromString(this.filename);
			return cvalueFromValue(this, C_int_typeref, this.lc.first);
		}	break;

		case "__builtin_ffs":
		case "__builtin_ffsl":
		case "__builtin_ffsll":
		case "__builtin_clz":
		case "__builtin_clzl":
		case "__builtin_clzll":
		case "__builtin_ctz":
		case "__builtin_ctzl":
		case "__builtin_ctzll":
		case "__builtin_clrsb":
		case "__builtin_clrsbl":
		case "__builtin_clrsbll":
		case "__builtin_popcount":
		case "__builtin_popcountl":
		case "__builtin_popcountll":
		case "__builtin_parity":
		case "__builtin_parityl":
		case "__builtin_parityll": {
			this.next();
			this.skip("(");
			local result: CValue = this.parseExpr();
			this.skip(")");
			tok = tok[#"__builtin_":];
			local typ: CType = C_int;
			if (tok.endswith("ll")) {
				tok = tok[:-2];
				typ = TARGET_C_llong;
			} else if (tok.endswith("l")) {
				tok = tok[:-1];
				typ = TARGET_C_long;
			}
			if (tok !in ["ffs", "clrsb"])
				typ = C_UNSIGNED[typ];
			result.inplaceCast(this, CTypeRef(typ));
			if (result.isConstExpr) {
				local val = result.constExprValue(this);
				local bits: int = result.typeref.sizeof * 8;
				switch (tok) {
				case "ffs":
					val = val.ffs;
					break;
				case "clz":
					val = bits - val.fls;
					break;
				case "ctz":
					val = val.ctz;
					break;
				case "clrsb": {
					local ret: int = 0;
					local mask: int = (1 << (bits - 1));
					local flag: int = val & mask;
					while (mask) {
						mask >>= 1;
						flag >>= 1;
						if ((val & mask) != flag)
							break;
						++ret;
					}
					val = ret;
				}	break;
				case "popcount":
					val = val.popcount;
					break;
				case "parity":
					val = val.parity;
					break;
				default:
					break;
				}
				result = cvalueFromValue(this, C_int_typeref, val);
			} else {
				result = CValue(
					kind:    CVALUE_AVOID,
					typeref: C_int_typeref);
			}
			return result;
		}	break;

		case "__builtin_add_overflow":
		case "__builtin_add_overflow_p":
		case "__builtin_sadd_overflow":
		case "__builtin_saddl_overflow":
		case "__builtin_saddll_overflow":
		case "__builtin_uadd_overflow":
		case "__builtin_uaddl_overflow":
		case "__builtin_uaddll_overflow":
		case "__builtin_sub_overflow":
		case "__builtin_sub_overflow_p":
		case "__builtin_ssub_overflow":
		case "__builtin_ssubl_overflow":
		case "__builtin_ssubll_overflow":
		case "__builtin_usub_overflow":
		case "__builtin_usubl_overflow":
		case "__builtin_usubll_overflow":
		case "__builtin_mul_overflow":
		case "__builtin_mul_overflow_p":
		case "__builtin_smul_overflow":
		case "__builtin_smull_overflow":
		case "__builtin_smulll_overflow":
		case "__builtin_umul_overflow":
		case "__builtin_umull_overflow":
		case "__builtin_umulll_overflow": {
			local isP: bool = tok.endswith("_p");
			if (isP)
				tok = tok[:-2];
			tok = tok[#"__builtin_":-#"_overflow"];
			this.next();
			this.skip("(");
			local a: CValue = parseExprRValue();
			this.skip(",");
			local b: CValue = parseExprRValue();
			this.skip(",");
			local resPtr: CValue = parseExprRValue();
			this.skip(")");
			local typ: CType | none = none;
			if (tok.endswith("ll") && tok !in ["smull", "umull"]) {
				typ = TARGET_C_llong;
				tok = tok[:-2];
			} else if (tok.endswith("l") && tok !in ["smul", "umul", "mul"]) {
				typ = TARGET_C_long;
				tok = tok[:-1];
			}
			if (tok.startswith("s") && !tok.startswith("sub")) {
				tok = tok[1:];
				if (typ is none)
					typ = C_int;
			} else if (tok.startswith("u")) {
				tok = tok[1:];
				if (typ is none) {
					typ = C_uint;
				} else {
					typ = C_UNSIGNED[typ];
				}
			}
			assert tok in ["add", "sub", "mul"];
			if (typ !is none) {
				local typeref: CTypeRef = CTypeRef(typ);
				a.inplaceCast(this, typeref);
				b.inplaceCast(this, typeref);
				assert !isP;
				resPtr.inplaceCast(this, CTypeRef(TARGET_CPointerType(typeref)));
			}
			if (!isP)
				resPtr.inplaceInd(this);
			local resTyp: CType = resPtr.typeref.typ;
			if (resTyp !in C_INTEGER) {
				this.err(f"Result type of `__builtin_{tok}_overload' "
				         f"is `{resTyp}', which is not an integer type");
			}
			if (a.isConstExpr && b.isConstExpr) {
				local aValue = a.constExprValue(this);
				local bValue = b.constExprValue(this);
				local rValue;
				switch (tok) {
				case "add":
					rValue = aValue + bValue;
					break;
				case "sub":
					rValue = aValue - bValue;
					break;
				case "mul":
					rValue = aValue * bValue;
					break;
				}
				local resBytes: Bytes = resTyp.bytes(this, rValue);
				local resValue = resTyp.peek(this, resBytes, 0);
				if (!isP) {
					/* Emulate the assignment to `resPtr' */
					resPtr.inplaceAssign(this, CValue(
						kind:    CVALUE_RCONST,
						typeref: resPtr.typeref,
						data:    resBytes,
						offset:  0));
				}
				return cvalueFromValue(this, C_bool_typeref, rValue == resValue ? 1 : 0);
			}
			return CValue(
				kind:    CVALUE_AVOID,
				typeref: C_bool_typeref);
		}	break;

		// TODO: double __builtin_huge_val(void);
		// TODO: float __builtin_huge_valf(void);
		// TODO: long double __builtin_huge_vall(void);
		// TODO: double __builtin_inf(void);
		// TODO: float __builtin_inff(void);
		// TODO: long double __builtin_infl(void);
		// TODO: double __builtin_nan(char const *str);
		// TODO: float __builtin_nanf(char const *str);
		// TODO: long double __builtin_nanl(char const *str);

		case "(": {
			this.next();
			if (this.tok == "{") {
				/* Statements-in-expression */
				this.next();
				local result: CValue | none = none;
				if (this.tok != "}") {
					local innerScope: CScope = CScope();
					/* Can just re-use the parent scope's symbol value hints */
					innerScope.symbolValues = namespaceStack.first.symbolValues;
					namespaceStack.pushfront(innerScope);
					do {
						result = parseStatement();
					} while (this.tok != "}");
					namespaceStack.popfront();
				}
				this.skip("}");
				this.skip(")");
				if (result is none)
					result = copy C_voidval;
				return result;
			}
			local castInfo = parseTypeRef("-", "", tryParse: true);
			if (castInfo !is none) {
				local typeref: CTypeRef;
				local storageClass: string;
				typeref, none, storageClass = castInfo...;
				if (storageClass != "")
					this.err(f"Storage class {repr storageClass} cannot appear in expressions");
				this.skip(")");
				return parseTypedExprUnary(typeref, explicit: true);
			}
			local result: CValue = parseExprComma();
			this.skip(")");
			return result;
		}	break;

			/* Unary operators. */
		case "*":
		case "&":
		case "+":
		case "-":
		case "!":
		case "~": {
			this.next();
			local result: CValue = parseExprUnary().inplaceOp1(this, tok);
			return result;
		}	break;

		case "++":
		case "--": {
			this.next();
			local result: CValue = parseExprUnary();
			local one: CValue = cvalueFromValue(this, C_int_typeref, 1);
			local newValue: CValue = result.op2(this, tok[0], one);
			result = result.inplaceAssign(this, newValue);
			return result;
		}	break;

		default:
default_case:
			if (tok.issymbol()) {
		case "::":
				local symbol: CSymbol | none = nsLookupChain("symbols");
				if (symbol is none) {
					/* Not a symbol -> check for a typedef and see if it's a c++-style construct call */
					if (cxx) {
						local ctorInfo = parseTypeRef("-", "", tryParse: true);
						if (ctorInfo !is none) {
							/* C++ function-style cast expression */
							local typeref, storageClass;
							typeref, none, storageClass = ctorInfo...;
							if (storageClass != "")
								this.err(f"Storage class {repr storageClass} cannot appear in expressions");
							local result: CValue;
							if (this.tok == "{") {
								result = parseTypedExpr(typeref, explicit: true);
							} else {
								this.skip("(");
								result = parseTypedExpr(typeref, explicit: true);
								this.skip(")");
							}
							return result;
						}
					}
					this.err(f"No such symbol `{tok}'");
				}
				return cvalueFromSymbol(symbol);
			} else if (tok.startswith('"')) {
				/* String literal. */
				return cvalueFromString(this.parseString());
			} else if (tok.startswith("'")) {
				/* Character literal. */
				local chr: string = this.parseString();
				local ord: int = 0;
				for (local ch: chr.ordinals)
					ord = (ord << 8) | ch;
				return cvalueFromValue(this, C_int_typeref, ord);
			} else {
				local constVal: int | float;
				local suffixEnd: int = #tok;
				while (suffixEnd && tok[suffixEnd - 1] in "ulUL")
					--suffixEnd;
				local integerType: CType;
				local integerSuffix: string = tok[suffixEnd:];
				switch (integerSuffix.lower()) {
				case "":
					integerType = C_int;
					break;
				case "u":
					integerType = C_uint;
					break;
				case "l":
					integerType = TARGET_C_long;
					break;
				case "ul":
				case "lu":
					integerType = TARGET_C_ulong;
					break;
				case "ll":
					integerType = TARGET_C_llong;
					break;
				case "ull":
				case "lul":
				case "llu":
					integerType = TARGET_C_ullong;
					break;
				default:
					this.err(f"Invalid integer suffix {repr integerSuffix}");
					break;
				}
				try {
					constVal = int(tok[:suffixEnd]);
				} catch (...) {
					suffixEnd = #tok;
					while (suffixEnd && tok[suffixEnd - 1] in "fFlL")
						--suffixEnd;
					integerSuffix = tok[suffixEnd:];
					switch (integerSuffix.lower()) {
					case "":  integerType = C_double; break;
					case "f": integerType = C_float; break;
					case "l": integerType = TARGET_C_ldouble; break;
					default:
						this.err(f"Invalid floating-point suffix {repr integerSuffix}");
						break;
					}
					try {
						constVal = float(tok[:suffixEnd]);
					} catch (...) {
						this.err(f"Unable to parse expression from {repr tok}");
					}
				}
				this.next();
				return cvalueFromValue(this, CTypeRef(integerType), constVal);
			}
		}
	}

	function parseExprUnarySuffix(value: CValue): CValue {
		assert parseExprUnarySuffixCheck(this.tok);
again:
		switch (this.tok) {

		case "++":
		case "--": {
			local oldValue: CValue = value.rValue(this);
			local one: CValue = cvalueFromValue(this, C_int_typeref, 1);
			local newValue: CValue = value.op2(this, this.tok[0], one);
			value.inplaceAssign(this, newValue);
			value = oldValue;
			this.next();
			goto again;
		}	break;

		case "[": {
			this.next();
			local rhs: CValue = parseExprComma();
			this.skip("]");
			value = value
				.inplaceOp2(this, "+", rhs)
				.inplaceInd(this);
			goto again;
		}	break;

		case "->":
			value = value.inplaceInd(this);
			/* FALLTHRU */
		case ".":
			this.next();
			value = value.inplaceField(this, this.parseSymbolName());
			goto again;

		case "(": {
			this.next();
			/* Automatically dereference function pointers. */
			while (value.typeref.typ is CPointerType)
				value = value.inplaceInd(this);
			local funTyp: CType | none = value.typeref.typ;
			local args: {CValue...} = [];
			local argTypesAndNames: {(CTypeRef, string)...} = ();
			local canRetainNothrow: bool = false;
			if (funTyp is CFunctionType) {
				argTypesAndNames = funTyp.args;
				/* When the function is annotated as `nothrow(*...)', then  nothrow
				 * specifications of arguments passed to the function are retained. */
				local calleeNothrow: string | none = value.typeref.attribNothrow;
				if (calleeNothrow !is none && calleeNothrow.startswith("*"))
					canRetainNothrow = true;
			}

			/* Parse function arguments. */
			while (this.tok != ")") {
				local arg: CValue;
				if (#args < #argTypesAndNames) {
					arg = parseTypedExpr(argTypesAndNames[#args].first,
						canRetainNothrow: canRetainNothrow,
						getExtraCannotRetainInfo: canRetainNothrow ? none : () ->
							f" (argument `{argTypesAndNames[#args].last}' of function "
							f"`{value.kind in [CVALUE_LSYMBOL, CVALUE_RSYMBOL, CVALUE_ASYMBOL]
								? value.data.name
								: "<unnamed>"
							}' appears incorrectly annotated)");
				} else {
					arg = parseExpr();
				}
				arg.inplaceRValue(this);
				args.append(arg);
				if (this.tok != ",")
					break;
				this.next();
			}
			value = value.inplaceCall(this, args, mustCastArgs: #args != #argTypesAndNames);
			this.skip(")");
			goto again;
		}	break;

		default:
			break;
		}
		return value;
	}

#define DEFINE_SIMPLE_SUFFIX_PARSER(name, parseExprOperand)       \
	function parseExpr##name##Suffix(value: CValue): CValue {     \
		do {                                                      \
			local op = this.tok;                                  \
			assert parseExpr##name##SuffixCheck(op);              \
			this.next();                                          \
			value = value.inplaceOp2(this, op, parseExprOperand); \
		} while (parseExpr##name##SuffixCheck(this.tok));         \
		return value;                                             \
	}
	DEFINE_SIMPLE_SUFFIX_PARSER(Prod, parseExprUnary())
	DEFINE_SIMPLE_SUFFIX_PARSER(Sum, parseExprProd())
	DEFINE_SIMPLE_SUFFIX_PARSER(Shift, parseExprSum())
	DEFINE_SIMPLE_SUFFIX_PARSER(Cmp, parseExprShift())
	DEFINE_SIMPLE_SUFFIX_PARSER(CmpEq, parseExprCmp())
	DEFINE_SIMPLE_SUFFIX_PARSER(BitAnd, parseExprCmpEq())
	DEFINE_SIMPLE_SUFFIX_PARSER(BitXor, parseExprBitAnd())
	DEFINE_SIMPLE_SUFFIX_PARSER(BitOr, parseExprBitXor())
#undef DEFINE_SIMPLE_SUFFIX_PARSER

	function parseExprLAndSuffix(value: CValue): CValue {
		/* NOTE: `A && B' is the same as `A ? !!B : false' */
		value = value.inplaceOp1(this, "bool");
again:
		assert parseExprLAndSuffixCheck(this.tok);
		this.next(); /* Consume "&&" */
		if (isUnreachable) {
			parseExprBitOr();
			value.inplaceVoid;
		} else if (value.isConstExpr) {
			if (value.constExprValue(this)) {
				value = parseExprBitOr().inplaceOp1(this, "bool");
			} else {
				isUnreachable = true;
				parseExprBitOr();
				isUnreachable = false;
			}
		} else {
			/* Value assumptions made  by the conditional  branch must  be
			 * inherited as unknowns because they might not always happen. */
			local condScope: CScope = CScope();
			namespaceStack.pushfront(condScope);
			parseExprBitOr();
			namespaceStack.popfront();
			inheritAllSymbolValuesAsUnknowns(condScope);
			/* The true-branch is conditional, so it being noreturn doesn't propagate */
			isUnreachable = false;
			value.inplaceVoid;
		}
		if (parseExprLAndSuffixCheck(this.tok))
			goto again;
		return value;
	}

	function parseExprLOrSuffix(value: CValue): CValue {
		/* NOTE: `A || B' is the same as `A ? true : !!B' */
		value = value.inplaceOp1(this, "bool");
again:
		assert parseExprLOrSuffixCheck(this.tok);
		this.next(); /* Consume "||" */
		if (isUnreachable) {
			parseExprLAnd();
			value.inplaceVoid;
		} else if (value.isConstExpr) {
			if (value.constExprValue(this)) {
				isUnreachable = true;
				parseExprLAnd();
				isUnreachable = false;
			} else {
				value = parseExprLAnd().inplaceOp1(this, "bool");
			}
		} else {
			/* Value assumptions made  by the conditional  branch must  be
			 * inherited as unknowns because they might not always happen. */
			local condScope: CScope = CScope();
			namespaceStack.pushfront(condScope);
			parseExprLAnd();
			namespaceStack.popfront();
			inheritAllSymbolValuesAsUnknowns(condScope);
			/* The false-branch is conditional, so it being noreturn doesn't propagate */
			isUnreachable = false;
			value.inplaceVoid;
		}
		if (parseExprLOrSuffixCheck(this.tok))
			goto again;
		return value;
	}

	function inheritAllSymbolValuesAsUnknowns(scope: CScope) {
		local parentScope: CScope = namespaceStack.first;
		for (local symbol: scope.symbolValues.keys) {
			parentScope.symbolValues[symbol] = none;
		}
	}

	function parseExprCondSuffix(value: CValue): CValue {
		assert parseExprCondSuffixCheck(this.tok);
		this.next();
		if (isUnreachable) {
			local ttVal: CValue = value;
			if (this.tok != ":")
				ttVal = parseExprLOr().inplaceRValue(this);
			this.skip(":");
			local ffVal: CValue = parseExprCond().inplaceRValue(this);
			value = CValue(kind: CVALUE_AVOID, typeref: commonType(ttVal.typeref, ffVal.typeref));
		} else if (value.isConstExpr) {
			if (value.constExprValue(this)) {
				if (this.tok != ":")
					value = parseExprLOr().inplaceRValue(this);
				this.skip(":");
				local savedIsUnreachable = isUnreachable;
				isUnreachable = true;
				local ffVal: CValue = parseExprCond().inplaceRValue(this);
				isUnreachable = savedIsUnreachable;
				value = value.inplaceCast(this, commonType(value.typeref, ffVal.typeref));
			} else {
				if (this.tok != ":") {
					isUnreachable = true;
					value = parseExprLOr().inplaceRValue(this);
					isUnreachable = false;
				}
				this.skip(":");
				local ffVal: CValue = parseExprCond().inplaceRValue(this);
				value = ffVal.inplaceCast(this, commonType(value.typeref, ffVal.typeref));
			}
		} else {
			/* Configure the expression value engine such that
			 * it  maintains identical values from both sides. */
			local ttScope: CScope = CScope();
			if (this.tok != ":") {
				namespaceStack.pushfront(ttScope);
				value = parseExprLOr().inplaceRValue(this);
				namespaceStack.popfront();
			}
			local ttIsNoReturn: bool = isUnreachable;
			this.next();
			local ffScope: CScope = CScope();
			namespaceStack.pushfront(ffScope);
			isUnreachable = false;
			local ffVal: CValue = parseExprCond().inplaceRValue(this);
			namespaceStack.popfront();
			if (!ttIsNoReturn)
				isUnreachable = false;
			local parentScope: CScope = namespaceStack.first;
			local ttOverrides: {CSymbol: Bytes | none} = ttScope.symbolValues;
			local ffOverrides: {CSymbol: Bytes | none} = ffScope.symbolValues;
			for (local symbol: ttOverrides.keys | ffOverrides.keys) {
				local ttValue: Bytes | bool | none = ttOverrides.get(symbol, false);
				local ffValue: Bytes | bool | none = ffOverrides.get(symbol, false);
				if (ttValue === false)
					ttValue = getSymbolValue(symbol);
				if (ffValue === false)
					ffValue = getSymbolValue(symbol);
				if (ttValue is none || ffValue is none) {
					ttValue = none;
				} else if (ttValue != ffValue) {
					ttValue = none;
				}
				parentScope.symbolValues[symbol] = ttValue;
			}
			value = value.inplaceVoid
				.inplaceCast(this, commonType(value.typeref, ffVal.typeref));
		}
		return value;
	}

	function parseExprAssignSuffix(value: CValue): CValue {
		assert parseExprAssignSuffixCheck(this.tok);
		do {
			local op: string = this.tok[:-1]; /* Remove trailing "=" */
			this.next();
			local rhs: CValue = parseExprCond();
			if (op) /* Perform inplace operation. */
				rhs = value.op2(this, op, rhs);
			value = value.inplaceAssign(this, rhs);
		} while (parseExprAssignSuffixCheck(this.tok));
		return value;
	}


	/*****************************************************************************
	** Inter-pos expression parsers                                             **
	*****************************************************************************/
#define DEFINE_INTERPOS_PARSER(name, innerName)        \
	function parseExpr##name(): CValue {               \
		local result: CValue = parseExpr##innerName(); \
		if (parseExpr##name##SuffixCheck(this.tok))    \
			return parseExpr##name##Suffix(result);    \
		return result;                                 \
	}
	DEFINE_INTERPOS_PARSER(Unary, UnaryPrefix)
	DEFINE_INTERPOS_PARSER(Prod, Unary)
	DEFINE_INTERPOS_PARSER(Sum, Prod)
	DEFINE_INTERPOS_PARSER(Shift, Sum)
	DEFINE_INTERPOS_PARSER(Cmp, Shift)
	DEFINE_INTERPOS_PARSER(CmpEq, Cmp)
	DEFINE_INTERPOS_PARSER(BitAnd, CmpEq)
	DEFINE_INTERPOS_PARSER(BitXor, BitAnd)
	DEFINE_INTERPOS_PARSER(BitOr, BitXor)
	DEFINE_INTERPOS_PARSER(LAnd, BitOr)
	DEFINE_INTERPOS_PARSER(LOr, LAnd)
	DEFINE_INTERPOS_PARSER(Cond, LOr)
	/*DEFINE_INTERPOS_PARSER(, Cond)*/
#undef DEFINE_INTERPOS_PARSER

	/* This one could also be defined as an inter-pos parser, but we don't do that so minimize stack-usage */
	function parseExpr(): CValue {
		local result: CValue = parseExprUnaryPrefix();
		switch (this.tok) {

		parseExprUnarySuffix_CASE:
			result = parseExprUnarySuffix(result);
#define PARSE_CASE_CHECK(name)                              \
			if (parseExpr##name##SuffixCheck(this.tok)) {   \
		parseExpr##name##Suffix_CASE:                       \
				result = parseExpr##name##Suffix(result);   \
			}
			PARSE_CASE_CHECK(Prod)
			PARSE_CASE_CHECK(Sum)
			PARSE_CASE_CHECK(Shift)
			PARSE_CASE_CHECK(Cmp)
			PARSE_CASE_CHECK(CmpEq)
			PARSE_CASE_CHECK(BitAnd)
			PARSE_CASE_CHECK(BitXor)
			PARSE_CASE_CHECK(BitOr)
			PARSE_CASE_CHECK(LAnd)
			PARSE_CASE_CHECK(LOr)
			PARSE_CASE_CHECK(Cond)
			PARSE_CASE_CHECK(Assign)
#undef PARSE_CASE_CHECK
			break;

		default:
			break;
		}
		return result;
	}

	@@High-level function to parse an expression (may return none if inside of dead code)
	function parseExprComma(): CValue {
again:
		local result: CValue = parseExpr();
		if (this.tok == ",") {
			this.next();
			goto again;
		}
		return result;
	}

	@@Same as @parseExpr, but special handling for when @typeref
	@@is a  struct/array type,  and the  current token  is  @"{"
	@@
	@@Also: even when the current token isn't @"{", still  do
	@@      an implicit cast of the expression into @typeref.
	function parseTypedExpr(typeref: CTypeRef, explicit: bool = false, canRetainNothrow: bool = true,
	                        getExtraCannotRetainInfo: Callable | none = none): CValue {
		if (this.tok == "{") {
			local typ: CType = typeref.typ;
			if (typ is CArrayType)
				return parseArrayInitializer(typeref);
			if (typ is CStructType)
				return parseStructInitializer(typeref);
		}
		return parseExpr().inplaceCast(this, typeref, explicit, canRetainNothrow, getExtraCannotRetainInfo);
	}

	function parseTypedExprUnary(typeref: CTypeRef, explicit: bool = false, canRetainNothrow: bool = true,
	                             getExtraCannotRetainInfo: Callable | none = none): CValue {
		if (this.tok == "{") {
			local typ: CType = typeref.typ;
			if (typ is CArrayType)
				return parseArrayInitializer(typeref);
			if (typ is CStructType)
				return parseStructInitializer(typeref);
		}
		return parseExprUnary().inplaceCast(this, typeref, explicit, canRetainNothrow, getExtraCannotRetainInfo);
	}

	function parseTypedExprInto(typeref: CTypeRef, result: Bytes | none, offset: int,
	                            explicit: bool = false, canRetainNothrow: bool = true,
	                            getExtraCannotRetainInfo: Callable | none = none): Bytes | none {
		if (this.tok == "{") {
			local typ: CType = typeref.typ;
			if (typ is CArrayType)
				return parseArrayInitializerInto(typ, result, offset).last;
			if (typ is CStructType)
				return parseStructInitializerInto(typ, result, offset);
		}
		local value = parseExpr().inplaceCast(this, typeref, explicit, canRetainNothrow, getExtraCannotRetainInfo);
		if (result !is none) {
			if (value.isConstExpr) {
				local valueData: Bytes = value.constExprBytes;
				local endOffset: int = offset + #valueData;
				if (#result < endOffset)
					result = result.resized(endOffset);
				result[offset:endOffset] = valueData;
			} else {
				result = none;
			}
		}
		return result;
	}

	@@Parse an expression and convert it into an R-Value
	function parseExprRValue(): CValue {
		return parseExpr().inplaceRValue(this);
	}

	function parseTypedExprConstant(typeref: CTypeRef, explicit: bool = false, canRetainNothrow: bool = true,
	                                getExtraCannotRetainInfo: Callable | none = none): (CTypeRef, Bytes | none) {
		local result: CValue = parseTypedExpr(typeref, explicit, canRetainNothrow, getExtraCannotRetainInfo);
		if (!result.isConstExpr) {
			if (!isUnreachable)
				this.err("Expected a compile-time constant expression");
			return (result.typeref, none);
		}
		return (result.typeref, result.constExprBytes);
	}

	function parseExprConstant(): CValue | none {
		local expr: CValue = parseExprRValue();
		if (!expr.isConstExpr) {
			if (!isUnreachable)
				this.err("Expected a compile-time constant expression");
			return none;
		}
		return expr;
	}

	function parseExprConstantInteger(): int | none {
		local value: CValue | none = parseExprConstant();
		if (value.typeref.typ !in C_NUMERIC) /* So we will generate warnings/errors. */
			value.inplaceCast(this, CTypeRef(TARGET_C_size_t));
		local result: int | none = value.constExprValue(this);
		if (result !is int && result !is none)
			this.err(f"Expected integer constant expression, but got `{repr result}'");
		return result;
	}

	@@Parse a type-expression, or parse a normal expression and return its type
	function parseTypeOrExpressionType(): CTypeRef {
		local tr: CTypeRef = CTypeRef();
		if (parseCTypeRefBase(tr) is none)
			return parseExpr().typeref;
		return parseTypeRefInner(tr, "-").first;
	}

	@@When set to true, @CFunctionType.redeclarationImport will ignore duplicate default arguments
	public member ignoreDuplicateDefaultArgumentDeclarations: bool = false;

	function checkAsmSymbolAliasDefinitions() {
		local savedIgnoreDuplicateDefaultArgumentDeclarations = ignoreDuplicateDefaultArgumentDeclarations;
		ignoreDuplicateDefaultArgumentDeclarations = savedIgnoreDuplicateDefaultArgumentDeclarations;
		ignoreDuplicateDefaultArgumentDeclarations = true;
		for (local newSymbolName: asmSymbolAliasDefinitions.keys.sorted()) {
			local oldSymbolName: string = asmSymbolAliasDefinitions[newSymbolName];
			local oldSymbol: CSymbol | CSymbolTemplate | none = globalNamespace.symbols.get(oldSymbolName);
			local newSymbol: CSymbol | CSymbolTemplate | none = globalNamespace.symbols.get(newSymbolName);
			if (oldSymbol is CSymbol && newSymbol is CSymbol) {
				local oldSymbolTypeRef: CTypeRef = oldSymbol.typeref;
				local newSymbolTypeRef: CTypeRef = newSymbol.typeref;
				this.pushWarnLocationOverride(newSymbol.decl);
				deepcopy(oldSymbolTypeRef).redeclarationImport(this, newSymbolTypeRef,
					newSymbolName, oldSymbolName, oldSymbol.decl);
				this.popWarnLocationOverride();
			}
		}
	}

	@@Main parser function
	function main() {
		try {
			do {
				parseGlobal();
			} while (this.tok);
		} catch (e...) {
			if (e !is ParserError)
				this.errMsg(f"Parser error: {e}");
			throw;
		}
		checkAsmSymbolAliasDefinitions();
	}
}

@@Main function to run the checker on an already-preprocessed C/C++ source file
@@@param: language: Either "c" or "c++"
function runChecker(filename: string, targetModule: Module, language: string = "c++") {
	local fp = File.open(filename, "rb");
	local checker = Checker(
		targetModule: targetModule, fp: fp, filename: filename,
		cxx: { "c": false, "c++": true }[language]);
#if 0
	do {
		print repr checker.filename, repr checker.lc, repr checker.this.tok;
	} while (checker.this.next());
#elif defined(__MAIN__) || 0
	checker.main();
#else
	try {
		checker.main();
	} catch (e...) {
		print repr e;
		print Traceback.current;
	}
#endif
}

#ifdef __MAIN__
local args = [...][1:];
if (!args)
	args = [r"E:\c\kls\kos\build\i386-kos-nOD\mod.dbx\kos.src.kernel.moddbx.cexpr.c.chk.E"];
for (local arg: args)
	runChecker(arg, import("...targets.i386"));
#endif
