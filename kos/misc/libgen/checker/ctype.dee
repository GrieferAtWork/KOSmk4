/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from deemon;
import * from errors;
#define Checker Object

class CType {
	// function tostr(varname: string = ""): string;

	operator str() -> this.tostr();
	// property sizeof: int;
	property alignof: int = { get(): int -> this.sizeof; };
}

global final CTYPEREF_FLAG_CONST    = 0x0001;
global final CTYPEREF_FLAG_VOLATILE = 0x0002;
global final CTYPEREF_FLAG_RESTRICT = 0x0004;
global final CTYPEREF_FLAG_DEREF    = 0x0010;
global final CTYPEREF_FLAG_NODEREF  = 0x0020;
global final CTYPEREF_FLAG_CV = CTYPEREF_FLAG_CONST | CTYPEREF_FLAG_VOLATILE;

@@A function that never returns. When the function is invoked,
global final CTYPEREF_FLAG_NORETURN = 0x0040;

@@Do no inherit pointer attributes during casts:
@@```c
@@__attribute__((noderef)) void *p = get_pointer();
@@int x = *(int *)p;                        // Error
@@int y = *(__attribute__((force)) int *)p; // OK
@@```
global final CTYPEREF_FLAG_FORCE = 0x4000;

@@Used during creation of struct objects.
global final CTYPEREF_FLAG_PACKED = 0x8000;

final class CTypeRef {
	this = default;
	public member typ: CType;

	@@Type flags. Set of `CTYPEREF_FLAG_*`
	public member flags: int = 0;

	@@Type attributes. Map of:
	@@ - @"nothrow"               -> @string   (nothrow level, as string-coded decimal, possible prefixed by @"*")
	@@ - @"tag"                   -> @string   (function tag)
	@@ - @"require_caller_tag"    -> @string   (function caller tag requirements)
	@@ - @"aligned"               -> @int      (alignment)
	public member attrib: {string: string | int} = Dict();

	/* Helpers */
	operator str(): string -> tostr();
	public property sizeof: int = { get(): int -> typ.sizeof; };
	public property alignof: int = { get(): int -> typ.alignof; };

	@@Check if @this @CTypeRef is identical to @other in such
	@@a way  that  no  re-declaration error  show  be  thrown
	function equalsForRedeclaration(other: CTypeRef): bool {
		return typ == other.typ;
	}

	function tostr(varname: string = ""): string {
		if (flags & CTYPEREF_FLAG_RESTRICT)
			varname = f"restrict {varname}";
		if (flags & CTYPEREF_FLAG_VOLATILE)
			varname = f"volatile {varname}";
		if (flags & CTYPEREF_FLAG_CONST)
			varname = f"const {varname}";
		if (flags & CTYPEREF_FLAG_NODEREF)
			varname = f"__attribute__((noderef)) {varname}";
		for (local attrName, attrVal: attrib) {
			if (attrName in ["tag", "require_caller_tag"])
				attrVal = repr attrVal;
			varname = f"__attribute__(({attrName}({attrVal}))) {varname}";
		}
		return typ.tostr(varname);
	}

	@@Used to implement the `__builtin_has_attribute' function
	@@Note however that @this @CTypeRef is allowed to have *more* attributes!
	function hasAllAttributesFrom(other: CTypeRef): bool {
		if ((flags & other.flags) != other.flags)
			return false;
		for (local attrName, attrVal: other) {
			local myVal = attrib.get(attrName);
			if (myVal is none)
				return false;
			if (myVal != attrVal)
				return false;
		}
		return true;
	}

	function importFrom(other: CTypeRef) {
		flags |= other.flags;
		attrib.update(other.attrib);
		typ = other.typ;
	}
}

class CCoreType: CType {
	this = default;
	public member name: string;
	public member sizeof: int;
	public member alignof: int;
	function tostr(varname: string = ""): string {
		return varname ? f"{name} {varname}" : name;
	}
}

final class CCoreIntType: CCoreType {
	public member signed: bool;
	this(name: string, sizeof: int, alignof: int, signed: bool)
		: super(name, sizeof, alignof)
	{
		this.signed = signed;
	}
	operator repr(): string ->
			f"CCoreIntType(name: {repr this.name}, "
			f"sizeof: {repr this.sizeof}, "
			f"alignof: {repr this.alignof}, "
			f"signed: {repr signed})";
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + this.sizeof], checker.TARGET_ENDIAN, signed);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + this.sizeof] = value.tobytes(this.sizeof, checker.TARGET_ENDIAN, signed);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return value.tobytes(this.sizeof, checker.TARGET_ENDIAN, signed);
	}
}

global final C_void = CCoreType("void", 0, 1);
global final C_bool = CCoreIntType("bool", 1, 1, false);
global final C_char = CCoreIntType("char", 1, 1, true);
global final C_schar = CCoreIntType("signed char", 1, 1, true);
global final C_uchar = CCoreIntType("unsigned char", 1, 1, false);
global final C_short = CCoreIntType("short", 2, 2, true);
global final C_ushort = CCoreIntType("unsigned short", 2, 2, false);
global final C_int = CCoreIntType("int", 4, 4, true);
global final C_uint = CCoreIntType("unsigned int", 4, 4, false);
global final C_long32 = CCoreIntType("long", 4, 4, true);
global final C_long64 = CCoreIntType("long", 8, 8, true);
global final C_ulong32 = CCoreIntType("unsigned long", 4, 4, false);
global final C_ulong64 = CCoreIntType("unsigned long", 8, 8, false);
global final C_llong_align4 = CCoreIntType("long long", 8, 4, true);
global final C_llong_align8 = CCoreIntType("long long", 8, 8, true);
global final C_ullong_align4 = CCoreIntType("unsigned long long", 8, 4, false);
global final C_ullong_align8 = CCoreIntType("unsigned long long", 8, 8, false);
global final C_int128_t_align4 = CCoreIntType("__int128", 16, 4, true);
global final C_int128_t_align8 = CCoreIntType("__int128", 16, 8, true);
global final C_uint128_t_align4 = CCoreIntType("unsigned __int128", 16, 4, false);
global final C_uint128_t_align8 = CCoreIntType("unsigned __int128", 16, 8, false);
global final C_wchar_t = CCoreIntType("wchar_t", 4, 4, false);
global final C_char16_t = CCoreIntType("char16_t", 2, 2, false);
global final C_char32_t = CCoreIntType("char32_t", 4, 4, false);
global final C_float = CCoreType("float", 4, 4);
global final C_double = CCoreType("double", 8, 8);
global final C_ldouble_12 = CCoreType("long double", 12, 8);
global final C_ldouble_16 = CCoreType("long double", 16, 16);
global final C_nullptr_t_32 = CCoreType("nullptr_t", 4, 4);
global final C_nullptr_t_64 = CCoreType("nullptr_t", 8, 8);

global final SINGLE_KEYWORD_CORE_TYPES: {string: CCoreType} = {
	"void" : C_void,
	"float" : C_float,
	"wchar_t" : C_wchar_t,
	"bool" : C_bool,
	"_Bool" : C_bool,
	"char16_t" : C_char16_t,
	"char32_t" : C_char32_t,
};

global final C_PROMOTE: {CCoreType...} = HashSet({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
}).frozen;
global final C_NUMERIC: {CCoreType...} = HashSet({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_int,
	C_uint,
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
	C_int128_t_align4,
	C_int128_t_align8,
	C_uint128_t_align4,
	C_uint128_t_align8,
	C_wchar_t,
	C_char16_t,
	C_char32_t,
	C_float,
	C_double,
	C_ldouble_12,
	C_ldouble_16,
}).frozen;

global final C_NULLPTR: {CCoreType...} = HashSet({
	C_nullptr_t_32,
	C_nullptr_t_64,
}).frozen;
global final C_INTEGER: {CCoreType...} = HashSet({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_int,
	C_uint,
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
	C_int128_t_align4,
	C_int128_t_align8,
	C_uint128_t_align4,
	C_uint128_t_align8,
	C_wchar_t,
	C_char16_t,
	C_char32_t,
}).frozen;

global final C_FLOATING: {CCoreType...} = HashSet({
	C_float,
	C_double,
	C_ldouble_12,
	C_ldouble_16,
}).frozen;

global final C_SIGNED: {CCoreType: CCoreType} = {
	C_char:             C_schar,
	C_uchar:            C_schar,
	C_ushort:           C_short,
	C_uint:             C_int,
	C_ulong32:          C_long32,
	C_ulong64:          C_long64,
	C_ullong_align4:    C_llong_align4,
	C_ullong_align8:    C_llong_align8,
	C_uint128_t_align4: C_int128_t_align4,
	C_uint128_t_align8: C_int128_t_align8,
};
global final C_UNSIGNED: {CCoreType: CCoreType} = {
	C_char:            C_uchar,
	C_schar:           C_uchar,
	C_short:           C_ushort,
	C_int:             C_uint,
	C_long32:          C_ulong32,
	C_long64:          C_ulong64,
	C_llong_align4:    C_ullong_align4,
	C_llong_align8:    C_ullong_align8,
	C_int128_t_align4: C_uint128_t_align4,
	C_int128_t_align8: C_uint128_t_align8,
};

class CPointerType: CType {
	this = default;
	public member base: CTypeRef;
	function tostr(varname: string = ""): string {
		return base.tostr("*" + varname);
	}
}

final class CPointerType32: CPointerType {
	this = super;
	public property sizeof: int = { get() -> 4; };
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + 4], checker.TARGET_ENDIAN, false);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + 4] = value.tobytes(4, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return value.tobytes(4, checker.TARGET_ENDIAN, false);
	}
}

final class CPointerType64: CPointerType {
	this = super;
	public property sizeof: int = { get() -> 8; };
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + 8], checker.TARGET_ENDIAN, false);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + 8] = value.tobytes(8, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return value.tobytes(8, checker.TARGET_ENDIAN, false);
	}
}

final class CStructType: CType {
	this = default;
	public member name: string;
	public member base: CStructType | none = none;
	public member fields: {string: (CTypeRef, int)} = Dict();
	public member fieldsByDeclarationOrder: {(string, CTypeRef)...} = [];

	function tostr(varname: string = ""): string {
		return varname ? f"struct {name} {varname}" : f"struct {name}";
	}

	function getField(name: string): (CTypeRef, int) | none {
		local result = fields.get(name);
		if (result is none && base !is none)
			result = base.getField(name);
		return result;
	}

	public property foreachField: {(string, CTypeRef, int)...} = {
		get(): {(string, CTypeRef, int)...} {
			if (base !is none)
				yield base.foreachField...;
			for (local name, typAndOffset: fields) {
				yield (name, typAndOffset...);
			}
		}
	}

	function fieldByOffset(offset: int): (string, int) | none {
		local result: (string, int) | none = none;
		for (local fieldName, none, fieldOffset: foreachField) {
			if (fieldOffset <= offset) {
				local subOffset = offset - fieldOffset;
				if (result is none || subOffset < result.last)
					result = (fieldName, subOffset);
				if (subOffset == 0)
					break;
			}
		}
		return none;
	}

	private member _sizeof: int;
	public property sizeof: int = {
		get() {
			if (_sizeof !is bound) {
				local result = 0;
				for (local none, fieldType, fieldOffset: foreachField) {
					local offsetAfter = fieldOffset + fieldType.typ.sizeof;
					if (result < offsetAfter)
						result = offsetAfter;
				}
				_sizeof = result;
			}
			return _sizeof;
		}
	}

	public member _alignof: int;
	public property alignof: int = {
		get() {
			if (_alignof !is bound) {
				local result = 1;
				for (local none, fieldType, none: foreachField) {
					local temp = fieldType.typ.alignof;
					if (result < temp)
						result = temp;
				}
				_alignof = result;
			}
			return _alignof;
		}
	}
}

final class CEnumType: CType {
	this = default;
	public member name: string;
	public member base: CType = C_int;
	public property sizeof: int = { get(): int -> base.sizeof; };
	public property alignof: int = { get(): int -> base.alignof; };
	function tostr(varname: string = ""): string {
		return varname ? f"enum {name} {varname}" : f"enum {name}";
	}
}

final class CFunctionType: CType {
	this = default;
	public member returnType: CType;
	public member args: {(CTypeRef, string)...} = [];
	public member isVarArgs: bool = false;
	public property sizeof: int = { get(): int -> 0; };
	public property alignof: int = { get(): int -> 1; };
	function tostr(varname: string = ""): string {
		if (varname.startswith("*") || " " in varname) {
			varname = f"({varname})";
		}
		if (args) {
			varname = f"{varname}({
				", ".join(for (local typ, name: args) typ.tostr(name))
			})";
		} else {
			varname += "(void)";
		}
		return returnType.tostr(varname);
	}
}

final class CArrayType: CType {
	this = default;
	public member base: CType;
	@@Set to @none for flexible arrays
	public member dim: int | none;
	public member stride: int;
	public property sizeof: int = { get(): int -> dim is none ? 0 : base.sizeof * dim; };
	public property alignof: int = { get(): int -> base.alignof; };
	function tostr(varname: string = ""): string {
		if (varname.startswith("*") || " " in varname)
			varname = f"({varname})";
		return base.tostr(f"{varname}[{dim is none ? "" : dim}]");
	}

	function indexByOffset(offset: int): (int, int) | none {
		local stride = base.alignof;
		if (stride <= 0)
			return none;
		local index, subOffset = offset.divmod(stride)...;
		if (index < 0 || (dim !is none && index >= dim))
			return none;
		return (index, subOffset);
	}

}


class CSymbol {
	this = default;
	@@Type of the symbol
	public member typeref: CTypeRef;
	@@Constant value of the symbol, or unbound if never assigned, or @none if unknown
	public member val: Bytes | none;
	public property valOrNone: Bytes | none = {
		get(): Bytes | none {
			try {
				return val;
			} catch (UnboundAttribute) {
				return none;
			}
		}
	}
}

@@Sub-class for overloaded function-like symbols (needed for overloads)
@@NOTE: The primary symbol element should not be used, and its fields are unbound!
final class COverloadedFunctionSymbol: CSymbol {
	this = default;
	@@The overloads of this function
	public member overloads: {CSymbol...} = [];

	@@Get or create an overload for the given @typeref c-function-type
	function getOrCreateOverload(typeref: CTypeRef): CSymbol {
		for (local overload: overloads) {
			if (overload.typeref.equalsForRedeclaration(typeref)) {
				overload.typeref.importFrom(typeref);
				return overload;
			}
		}
		local result = CSymbol(typeref: typeref);
		overloads.append(result);
		return result;
	}
}

global CEnumClassType;
class CNamespace {
	this = default;
	public final member name: string;
	public final member symbols: {string: CSymbol} = Dict();
	public final member typedefs: {string: CTypeRef} = Dict();
	public final member namespaces: {string: CNamespace} = Dict();
	public final member structSymbols: {string: CStructType} = Dict();
	public final member unionSymbols: {string: CStructType} = Dict();
	public final member enumSymbols: {string: CEnumType | CEnumClassType} = Dict();
	public final member importedNamespaces: {CNamespace...} = [];

	@@Only here so we don't need special handling when used as a @CScope
	public property symbolValues = { get() -> none; };

	@@@param tab: One of:
	@@            - @"symbols": CSymbol
	@@            - @"typedefs": CTypeRef
	@@            - @"namespaces": CNamespace
	@@            - @"structSymbols": CStructType
	@@            - @"unionSymbols": CStructType
	@@            - @"enumSymbols": CEnumType
	public final function lookup(tab: string, name: string): Object | none {
		local result = this.operator . (tab).get(name);
		if (result !is none)
			return result;
		for (local importedNamespace: importedNamespaces) {
			result = importedNamespace.lookup(tab, name);
			if (result !is none)
				return result;
		}
		return none;
	}

	function childNamespace(name: string): CNamespace {
		local result = lookup("namespaces", name);
		if (result is none) {
			result = CNamespace(name: name);
			namespaces[name] = result;
		}
		return result;
	}
}


final class CEnumClassType: CNamespace, CType {
	this = super;
	public member name: string;
	public member base: CTypeRef = C_int;
	public property sizeof: int = { get(): int -> base.sizeof; };
	public property alignof: int = { get(): int -> base.alignof; };
	function tostr(varname: string = ""): string {
		return varname ? f"enum class {this.name} {varname}" : f"enum class {this.name}";
	}
}
