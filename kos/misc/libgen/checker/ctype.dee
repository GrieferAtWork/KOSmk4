/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from deemon;
import * from errors;
import util;
import UniqueSet, UniqueDict from collections;
import ctypes;
#define Checker Object

#define IDENTICAL(a, b) (type(a) === type(b) && ((a) == (b)))

global CPointerType;
global CPointerType32;
global CPointerType64;
global CLValueType;
global CFunctionType;
global CCoreType;
global CStructType;
global CArrayType;
global CEnumType;
global CCoreFloatType;
global CSymbol;
global CSymbolTemplate;

global C_INT;
global C_LONG;
global C_LLONG;
global C_UNSIGNED;
global C_NUMERIC;

global C_void;
global C_int;


class CType: WeakRefAble {
	operator == (other) { return other is CType; }
	operator != (other) { return other !is CType; }
	operator str() -> this.tostr();

	// function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string;
	// function tostr(varname: string = ""): string;
	// property sizeof: int;
	property alignof: int = { get(): int -> this.sizeof; };
	property unwindWeakRef: CType = { get(): CType -> this; };

	@@Check if this type can be converted to @other
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return IDENTICAL(this, other);
	}

	@@Fix nonsensical attributes an warn where their presence is a user-error.
	function fixNonsensicalAttributes(checker: Checker) {
	}

	@@Import added attributes/annotations during a re-declaration, and warn about this
	function redeclarationImport(checker: Checker, other: CType,
	                             newName: string = "", oldName: string = "",
	                             oldDeclFlc: (string, int, int) | none = none) {
	}
}

global final CTYPEREF_FLAG_CONST    = 0x0001;
global final CTYPEREF_FLAG_VOLATILE = 0x0002;
global final CTYPEREF_FLAG_RESTRICT = 0x0004;
global final CTYPEREF_FLAG_DEREF    = 0x0010;
global final CTYPEREF_FLAG_NODEREF  = 0x0020;
global final CTYPEREF_FLAG_NONNULL  = 0x0040;
global final CTYPEREF_FLAG_CV = CTYPEREF_FLAG_CONST | CTYPEREF_FLAG_VOLATILE;

@@A function that never returns. When the function is invoked,
global final CTYPEREF_FLAG_NORETURN = 0x0080;

@@Do no inherit pointer attributes during casts:
@@```c
@@__attribute__((noderef)) void *p = get_pointer();
@@int x = *(int *)p;                        // Error
@@int y = *(__attribute__((force)) int *)p; // OK
@@```
global final CTYPEREF_FLAG_FORCE = 0x4000;

@@Used during creation of struct objects.
global final CTYPEREF_FLAG_PACKED = 0x8000;

@@Flags that are relevant for 2 types to be considered equal
global final CTYPEREF_FLAG_RELEVANT_FOR_EQUALITY =
	CTYPEREF_FLAG_CONST | CTYPEREF_FLAG_VOLATILE |
	CTYPEREF_FLAG_RESTRICT;

global final CTYPEREF_FLAGNAMES_KEYWORD: {int: string} = {
	CTYPEREF_FLAG_CONST    : "const",
	CTYPEREF_FLAG_VOLATILE : "volatile",
	CTYPEREF_FLAG_RESTRICT : "restrict",
};

global final CTYPEREF_FLAGNAMES_ATTRIB: {int: string} = {
	CTYPEREF_FLAG_DEREF    : "deref",
	CTYPEREF_FLAG_NODEREF  : "noderef",
	CTYPEREF_FLAG_NONNULL  : "nonnull",
	CTYPEREF_FLAG_NORETURN : "noreturn",
	CTYPEREF_FLAG_FORCE    : "force",
	CTYPEREF_FLAG_PACKED   : "packed",
};

function CTYPEREF_FLAGNAMES_TOSTR(tab: {int: string}, flags: int): {string...} {
	local mask = 1;
	while (mask <= flags) {
		if (flags & mask) {
			local res: string | none = tab.get(mask);
			if (res !is none)
				yield res;
		}
		mask <<= 1;
	}
}

/* Special THROWS error codes. */
@@Explicit anything-may-be-thrown: `THROWS(...)`
global final THROWS_ANY = -1;
@@Explicit throws-from-callback: `THROWS(*)`
global final THROWS_CB = -2;
@@Used internally: NonCallExceptions:
@@Implicit throws due to access of pointers with nothrow>0, or calls to functions with nothrow>0.
global final THROWS_NCX = -3;
@@Used internally: OutOfBad:
@@Implicit throws due to calls to functions with neither nothrow, nor throws annotation
global final THROWS_OOB = -4;

@@Remove base classes of explicitly specified sub-classes from @throws
function simplifyThrowsSet(throws: Set with int): Set with int {
	local result: Set with int = HashSet();
	local subClassBases: Set with int = HashSet();
	for (local code: throws) {
		result.insert(code);
		if (code > 0xffff)
			subClassBases.insert(code & 0xffff);
	}
	for (local code: subClassBases)
		result.remove(code);
	return result;
}


/* Attributes that are nonsensical for:
 * CTYPEATTRIBUTES_NONSENSE_PTRBASE_FUNCTION: int __attribute__((...)) (*foo)(...);
 * CTYPEATTRIBUTES_NONSENSE_PTRBASE_REGULAR:  int __attribute__((...)) *foo;
 * CTYPEATTRIBUTES_NONSENSE_FUNCTION:         int __attribute__((...)) foo(...);
 * CTYPEATTRIBUTES_NONSENSE_REGULAR:          int __attribute__((...)) foo;
 */
global final CTYPEATTRIBUTES_NONSENSE_PTRBASE_FUNCTION: {string...} = { "aligned" };
global final CTYPEATTRIBUTES_NONSENSE_PTRBASE_REGULAR: {string...} = { "tags", "requireCallerTags", "throws", "nonnull" };
global final CTYPEATTRIBUTES_NONSENSE_FUNCTION: {string...} = { "aligned" };
global final CTYPEATTRIBUTES_NONSENSE_REGULAR: {string...} = { "nothrow", "tags", "requireCallerTags", "throws", "nonnull" };

global final CTYPEREF_FLAG_NONSENSE_FUNCTION =
	CTYPEREF_FLAG_CONST | CTYPEREF_FLAG_VOLATILE | CTYPEREF_FLAG_DEREF |
	CTYPEREF_FLAG_NODEREF | CTYPEREF_FLAG_NONNULL | CTYPEREF_FLAG_FORCE |
	CTYPEREF_FLAG_PACKED;
global final CTYPEREF_FLAG_NONSENSE_POINTER =
	CTYPEREF_FLAG_DEREF | CTYPEREF_FLAG_NODEREF | CTYPEREF_FLAG_NONNULL |
	CTYPEREF_FLAG_FORCE | CTYPEREF_FLAG_NORETURN;
global final CTYPEREF_FLAG_NONSENSE_REGULAR =
	CTYPEREF_FLAG_DEREF | CTYPEREF_FLAG_NODEREF | CTYPEREF_FLAG_NONNULL |
	CTYPEREF_FLAG_FORCE | CTYPEREF_FLAG_NORETURN | CTYPEREF_FLAG_RESTRICT;
global final CTYPEREF_FLAG_NONSENSE_PTRBASE_FUNCTION = CTYPEREF_FLAG_PACKED;
global final CTYPEREF_FLAG_NONSENSE_PTRBASE_REGULAR = CTYPEREF_FLAG_NORETURN | CTYPEREF_FLAG_PACKED;


global final PRETTY_NOTHROW_LEVEL_NAME: {int: string} = {
	0 : "NOTHROW",
	1 : "NCX",
	2 : "BLOCKING",
};
function getPrettyNothrowLevelName(level: int | string): string {
	if (level !is int) {
		if (level.startswith("*")) {
			if (level == "*0")
				return "NOTHROW_NCX";
			goto fallback;
		}
		level = int(level);
	}
	local result = PRETTY_NOTHROW_LEVEL_NAME.get(level);
	if (result !is none)
		return result;
fallback:
	return f"__attribute__((nothrow({level})))";
}


final class CTypeAttributes {
	this = default;

	public member nothrow: string | none = none;
	public member tags: Set with string | none = none;
	public member requireCallerTags: Set with string | none = none;
	public member aligned: int | none = none;
	public member throws: Set with int | none = none;
	@@Only ever set during parsing: function arguments that are non-null
	public member nonnull: Set with int | none = none;

	// TODO: "format": Verify KOS-extended printf-format string argument types
	// NOTE: Based on this, dynamically create varargs function parameter types (including annotations):
	//       >> printf("foo = %s", p); // int printf(char const *, char const *);
	//       >> printf("foo = %p", p); // int printf(char const *, void [[noderef]] const volatile *);

	function fixNonsensicalFunctionAttributes(checker: Checker) {
		if (nothrow !is none && throws) {
			/* It only makes sense to have both of these
			 * attributes when `throws' is `{THROWS_CB}' */
			if (throws != {THROWS_CB}) {
				checker.warn("-Wattribute",
					f"Function type annotated as both `{getPrettyNothrowLevelName(nothrow)}' "
					f"and `THROWS({", ".join(checker.simpleExceptCodeNames(throws))})'");
				throws = none;
			}
		}
	}

	public function enumerateAttributsNotPresentIn(
			checker: Checker | none = none,
			other: CTypeAttributes | none = none,
			includeAllAttributes: bool = true
		): {string...} {
		if (!IDENTICAL(nothrow, other.nothrow) && nothrow !is none)
			yield f"nothrow({nothrow})";
		if (!IDENTICAL(tags, other.tags) && tags !is none) {
			local missingTags: {string...} = (other is none ? tags : (tags - other.tags)).sorted();
			if (missingTags)
				yield f"tag({", ".join(for (local x: missingTags) repr x)})";
		}
		if (!IDENTICAL(requireCallerTags, other.requireCallerTags) && requireCallerTags !is none) {
			local missingTags: {string...} = (requireCallerTags - other.requireCallerTags).sorted();
			if (missingTags)
				yield f"require_caller_tag({", ".join(for (local x: missingTags) repr x)})";
		}
		if (!IDENTICAL(aligned, other.aligned) && aligned !is none && includeAllAttributes)
			yield f"aligned({aligned})";
		if (!IDENTICAL(throws, other.throws) && throws !is none) {
			local missingThrows: {int...} = other is none ? throws : throws - other.throws;
			if (missingThrows) {
				yield f"throws({', '.join(
					checker is none
					? for (local id: missingThrows) { -1 : '*', 0 : '...' }.get(id, id.hex())
					: checker.simpleExceptCodeNames(missingThrows)
				)})";
			}
		}
	}

	public function importFrom(other: CTypeAttributes) {
		if (nothrow is none) {
			nothrow = other.nothrow;
		} else if (other.nothrow !is none) {
			local hasStar: bool = nothrow.startswith("*") || other.nothrow.startswith("*");
			local myNothrowLevel: int = int(nothrow.lstrip("*"));
			local otNothrowLevel: int = int(other.nothrow.lstrip("*"));
			if (myNothrowLevel < otNothrowLevel)
				myNothrowLevel = otNothrowLevel;
			nothrow = f"{hasStar ? "*" : ""}{myNothrowLevel}";
		}
		if (other.tags) {
			if (tags is none)
				tags = HashSet();
			tags.insertall(other.tags);
		}
		if (other.requireCallerTags) {
			if (requireCallerTags is none)
				requireCallerTags = HashSet();
			requireCallerTags.insertall(other.requireCallerTags);
		}
		if (aligned is none) {
			aligned = other.aligned;
		} else if (other.aligned !is none) {
			if (aligned < other.aligned)
				aligned = other.aligned;
		}
		if (!throws) {
			throws = other.throws;
		} else if (other.throws) {
			if (throws !is HashSet)
				throws = HashSet(throws);
			throws.insertall(other.throws);
		}
		if (!nonnull) {
			nonnull = other.nonnull;
		} else if (other.nonnull) {
			if (nonnull !is HashSet)
				nonnull = HashSet(nonnull);
			nonnull.insertall(other.nonnull);
		}
	}

	function hasAllAttributesFrom(other: CTypeAttributes): bool {
		for (local attrib: {
			"nothrow",
			"nothrowInheritable",
			"throws",
			"throwsInheritable",
			"tags",
			"requireCallerTags",
			"aligned",
			"nonnull",
		}) {
			local myVal = this.operator . (attrib);
			local otVal = other.operator . (attrib);
			if (myVal is none) {
				if (otVal !is none)
					return false;
			} else {
				if (otVal is none)
					return false;
				if (myVal != otVal)
					return false;
			}
		}
		return true;
	}
}

function simplifyType(checker: Checker, typ: CType): CType {
	if (typ is CEnumType)
		return typ.base;
	if (typ is CPointerType32)
		return C_int;
	if (typ is CPointerType64)
		return checker.TARGET_C_llong;
	return typ;
}

function ceilAlign(x: int, a: int): int {
	return (x + a - 1) & -a;
}

@@Check if @this @CTypeRef is binary-compatible with @newTypeRef
function binaryConvertibleTo(checker: Checker, oldType: CType, newType: CType, localAlign: int = 1): bool {
	oldType = simplifyType(checker, oldType);
	newType = simplifyType(checker, newType);
	if (oldType === newType)
		return true;
	if ((oldType is CArrayType || oldType is CStructType || oldType is CCoreType) &&
		(newType is CArrayType || newType is CStructType || newType is CCoreType)) {
		return ceilAlign(oldType.sizeof, localAlign) >= ceilAlign(newType.sizeof, localAlign) &&
			   ceilAlign(oldType.alignof, localAlign) >= ceilAlign(newType.alignof, localAlign);
	}
	if (oldType is CFunctionType && newType is CFunctionType)
		return oldType.binaryCompatibleWith(checker, newType);
	return false;
}


final class CTypeRef {
	this = default;
	@@NOTE: Might point  to a  weakref in  order to  prevent
	@@      reference loops in self-referencing struct types
	public member typ: CType | WeakRef with CType;

	@@Type flags. Set of `CTYPEREF_FLAG_*`
	public member flags: int = 0;

	@@Type attributes.
	public member attrib: CTypeAttributes | none = none;

	/* Copy constructor (that also copies attributes, if present) */
	operator copy(other: CTypeRef) {
		typ = other.typ;
		flags = other.flags;
		attrib = copy other.attrib;
	}

	/* Operator integration */
	public operator str(): string -> tostr();
	public operator hash(): int ->
		hash(typ, flags & CTYPEREF_FLAG_RELEVANT_FOR_EQUALITY);
	public operator == (other: CTypeRef): bool ->
		((flags & CTYPEREF_FLAG_RELEVANT_FOR_EQUALITY) ==
		 (other.flags & CTYPEREF_FLAG_RELEVANT_FOR_EQUALITY)) &&
		IDENTICAL(typ, other.typ);
	public operator != (other: CTypeRef): bool ->
		((flags & CTYPEREF_FLAG_RELEVANT_FOR_EQUALITY) !=
		 (other.flags & CTYPEREF_FLAG_RELEVANT_FOR_EQUALITY)) ||
		!IDENTICAL(typ, other.typ);

	/* Helper proxies for the underlying CType */
	public property sizeof: int = { get(): int -> typ.sizeof; };
	public property alignof: int = { get(): int -> typ.alignof; };

	@@Unwind a @CTypeRef that's pointing to a @WeakRef
	public property unwindWeakRef: CTypeRef = {
		get(): CTypeRef {
			if (typ is WeakRef) {
				local result = copy this;
				result.typ = typ.value.unwindWeakRef;
				return result;
			}
			local newTyp = typ.unwindWeakRef;
			if (typ !== newTyp) {
				local result = copy this;
				result.typ = newTyp;
				return result;
			}
			return this;
		}
	}

	@@Ensure that @attrib has been allocated
	public property requireAttrib: CTypeAttributes = {
		get(): CTypeAttributes {
			if (attrib is none)
				attrib = CTypeAttributes();
			return attrib;
		}
	};

	/* Helpers for accessing attributes */
	public property attribNothrow: string | none = {
		get(): string | none -> attrib.nothrow;
		set(v: string | none) { (v is none ? attrib : requireAttrib).nothrow = v; }
	};
	public property attribThrows: Set with int = {
		get(): Set with int {
			local result: Set with int | none = attrib.throws;
			if (result is none)
				result = Set();
			return result;
		}
		set(v: Set with int) {
			requireAttrib.throws = v;
		}
	};
	public property attribTags: Set with string = {
		get(): Set with string {
			local result: Set with string | none = attrib.tags;
			if (result is none)
				result = Set();
			return result;
		}
		set(v: Set with string) {
			requireAttrib.tags = v;
		}
	};
	public property attribRequireCallerTags: Set with string = {
		get(): Set with string {
			local result: Set with string | none = attrib.requireCallerTags;
			if (result is none)
				result = Set();
			return result;
		}
		set(v: Set with string) {
			requireAttrib.requireCallerTags = v;
		}
	};
	public property attribAligned: int | none = {
		get(): int | none -> attrib.aligned;
		set(v: int | none) { (v is none ? attrib : requireAttrib).aligned = v; }
	};

	@@Check if @this @CTypeRef is identical to @other in such
	@@a way  that  no  re-declaration error  show  be  thrown
	function redeclarationEquals(other: CTypeRef): bool {
		return IDENTICAL(typ, other.typ);
	}

	@@Import extra annotations/attributes during a second re-declaration
	@@```c
	@@extern int *x;
	@@extern __attribute__((noderef)) int *x; // Extra attributes are imported here!
	@@```
	function redeclarationImport(checker: Checker, other: CTypeRef,
	                             newName: string = "", oldName: string = "",
	                             oldDeclFlc: (string, int, int) | none = none) {
		/* Check for changed flags. */
		local flagsRemoved: int = 0;
		local flagsAdded: int = 0;
		if (flags != other.flags) {
			flagsRemoved = flags & ~other.flags;
			flagsAdded   = other.flags & ~flags;
			flags |= other.flags;
		}

		/* Check for changed attributes. */
		local attribRemoved: {string...} = ();
		local attribAdded: {string...} = ();
		if (attrib !is none) {
			if (other.attrib is none) {
				attribRemoved = List(attrib.enumerateAttributsNotPresentIn(
						checker, includeAllAttributes: false));
			} else {
				attribRemoved = List(attrib.enumerateAttributsNotPresentIn(
						checker, other.attrib, includeAllAttributes: false));
				attribAdded   = List(other.attrib.enumerateAttributsNotPresentIn(
						checker, attrib, includeAllAttributes: false));
				if (attribAdded)
					attrib.importFrom(other.attrib);
			}
		} else if (other.attrib !is none) {
			attribAdded = List(other.attrib.enumerateAttributsNotPresentIn(
					checker, includeAllAttributes: false));
			if (attribAdded) {
				attrib = CTypeAttributes();
				attrib.importFrom(other.attrib);
			}
		}

		/* Warnings for attributes that weren't present during the initial declaration. */
		if (flagsRemoved || flagsAdded || attribRemoved || attribAdded) {
			local addedKeywords: string = "";
			local removedKeywords: string = "";
			if (flagsAdded) {
				if (attribAdded !is List)
					attribAdded = List(attribAdded);
				addedKeywords = " ".join(CTYPEREF_FLAGNAMES_TOSTR(CTYPEREF_FLAGNAMES_KEYWORD, flagsAdded));
				attribAdded.extend(CTYPEREF_FLAGNAMES_TOSTR(CTYPEREF_FLAGNAMES_ATTRIB, flagsAdded));
			}
			if (flagsRemoved) {
				if (attribRemoved !is List)
					attribRemoved = List(attribRemoved);
				removedKeywords = " ".join(CTYPEREF_FLAGNAMES_TOSTR(CTYPEREF_FLAGNAMES_KEYWORD, flagsRemoved));
				attribRemoved.extend(CTYPEREF_FLAGNAMES_TOSTR(CTYPEREF_FLAGNAMES_ATTRIB, flagsRemoved));
			}
			if (attribAdded)
				addedKeywords = f"__attribute__(({', '.join(attribAdded)})) {addedKeywords}".rstrip();
			if (attribRemoved)
				removedKeywords = f"__attribute__(({', '.join(attribRemoved)})) {removedKeywords}".rstrip();
			local message = f"redeclaration of `{newName}' with different attributes: ";
			if (addedKeywords && removedKeywords) {
				message += f"added `{addedKeywords}' & removed `{removedKeywords}'";
			} else if (addedKeywords) {
				message += f"added `{addedKeywords}'";
			} else {
				message += f"removed `{removedKeywords}'";
			}
			if (oldDeclFlc !is none) {
				message += checker.forceFormatMessageAddend(
					oldDeclFlc, f"See previous declaration of `{oldName}'");
			}
			checker.warn("-Wdecl", message);
		}
		if (type(typ) === type(other.typ))
			typ.redeclarationImport(checker, other.typ, newName, oldName, oldDeclFlc);
	}

	@@Import specifications from a fixed @typedef into @this
	@@This merges attributes/flags in:
	@@```c
	@@typedef int FOO;
	@@const FOO x = 42; // "FOO" is inherited/merged-into "const"
	@@```
	function importTypedef(checker: Checker, typedef: CTypeRef) {
		flags |= typedef.flags;
		if (typedef.attrib !is none)
			requireAttrib.importFrom(typedef.attrib);
		local newType: CType = typedef.typ;
		if (newType in checker.incompleteStructTypes)
			newType = WeakRef(newType);
		typ = newType;
	}

	@@Move attributes that have no meaning for pointers to @dst
	function moveNonPointerAttributes(dst: CTypeRef) {
		if (flags & CTYPEREF_FLAG_NONSENSE_PTRBASE_REGULAR) {
			dst.flags |= flags & CTYPEREF_FLAG_NONSENSE_PTRBASE_REGULAR;
			flags &= ~CTYPEREF_FLAG_NONSENSE_PTRBASE_REGULAR;
		}
		local myAttrib: CTypeAttributes | none = attrib;
		if (myAttrib !is none) {
			for (local moveAttrib: CTYPEATTRIBUTES_NONSENSE_PTRBASE_REGULAR) {
				local value = myAttrib.operator . (moveAttrib);
				if (value !is none) {
					dst.requireAttrib.operator . (moveAttrib) = value;
					myAttrib.operator . (moveAttrib) = none;
				}
			}
		}
	}

	@@Warn about the presence of nonsensical attributes being present based on @typ
	@@e.g. `__attribute((noreturn)) int i;`
	function fixNonsensicalAttributes(checker: Checker) {
		local typ: CType = this.typ;
		local attrib: CTypeAttributes | none = this.attrib;
		local shouldWarn: CTypeRef | none = none;
		if (typ is CFunctionType) {
			/* If the function returns a pointer, the function attributes may
			 * have been parsed in the  context of that pointer's base  type:
			 * >> __attribute__((tag("MyTag"))) void *foo(void);
			 *
			 * By default, this is parsed as:
			 * >> void __attribute__((tag("MyTag"))) *(foo)(void);
			 *
			 * But we want to change this to become:
			 * >> void *(__attribute__((tag("MyTag"))) foo)(void);
			 */
			local functionReturnType: CType = typ.returnType;
			if (functionReturnType is CPointerType || functionReturnType is CLValueType) {
				local innerMostReturnPointerBaseTypeRef: CTypeRef;
				innerMostReturnPointerBaseTypeRef = functionReturnType.base;
				while (innerMostReturnPointerBaseTypeRef.typ is CPointerType ||
				       innerMostReturnPointerBaseTypeRef.typ is CLValueType)
					innerMostReturnPointerBaseTypeRef = innerMostReturnPointerBaseTypeRef.typ.base;
				innerMostReturnPointerBaseTypeRef.moveNonPointerAttributes(this);
				attrib = this.attrib;
			}
			if (flags & CTYPEREF_FLAG_NONSENSE_FUNCTION) {
				if (flags & CTYPEREF_FLAG_NONNULL) {
					if (!typ.setNonnullArgumentsAllPointers(checker)) {
						checker.warn("-Wattribute",
							f"Function type `{this}' with `__attribute__((nonnull))' "
							f"does not have any pointer-type arguments");
					}
					flags &= ~CTYPEREF_FLAG_NONNULL;
				}
				if (flags & CTYPEREF_FLAG_NONSENSE_FUNCTION) {
					shouldWarn = copy this;
					flags &= ~CTYPEREF_FLAG_NONSENSE_FUNCTION;
				}
			}
			if (attrib !is none) {
				if (attrib.nonnull !is none) {
					typ.setNonnullArguments(checker, attrib.nonnull);
					attrib.nonnull = none;
				}
				for (local nonSenseAttrib: CTYPEATTRIBUTES_NONSENSE_FUNCTION) {
					if (attrib.operator . (nonSenseAttrib) !is none) {
						if (shouldWarn is none)
							shouldWarn = copy this;
						attrib.operator . (nonSenseAttrib) = none;
					}
				}
				attrib.fixNonsensicalFunctionAttributes(checker);
			}
		} else {
			if (typ is CPointerType || typ is CLValueType) {
				if (flags & CTYPEREF_FLAG_NONSENSE_POINTER) {
					shouldWarn = copy this;
					flags &= ~CTYPEREF_FLAG_NONSENSE_POINTER;
				}
			} else {
				if (flags & CTYPEREF_FLAG_NONSENSE_REGULAR) {
					shouldWarn = copy this;
					flags &= ~CTYPEREF_FLAG_NONSENSE_REGULAR;
				}
			}
			if (attrib !is none) {
				for (local nonSenseAttrib: CTYPEATTRIBUTES_NONSENSE_REGULAR) {
					if (attrib.operator . (nonSenseAttrib) !is none) {
						if (shouldWarn is none)
							shouldWarn = copy this;
						attrib.operator . (nonSenseAttrib) = none;
					}
				}
			}
		}
		if (shouldWarn !is none) {
			checker.warn("-Wattribute",
				f"Nonsensical attributes in `{shouldWarn}'");
		}
		typ.fixNonsensicalAttributes(checker);
	}

	@@Same as @fixNonsensicalAttributes, but called when @this @CTypeRef is the base of a @CPointerType
	function fixNonsensicalPointerBaseAttributes(checker: Checker) {
		local typ: CType = this.typ;
		local attrib: CTypeAttributes | none = this.attrib;
		local shouldWarn: CTypeRef | none = none;

		if (typ is CFunctionType) {
			/* If the function returns a pointer, the function attributes may
			 * have been parsed in the  context of that pointer's base  type:
			 * >> __attribute__((tag("MyTag"))) void *foo(void);
			 *
			 * By default, this is parsed as:
			 * >> void __attribute__((tag("MyTag"))) *(foo)(void);
			 *
			 * But we want to change this to become:
			 * >> void *(__attribute__((tag("MyTag"))) foo)(void);
			 */
			local functionReturnType: CType = typ.returnType;
			if (functionReturnType is CPointerType || functionReturnType is CLValueType) {
				local innerMostReturnPointerBaseTypeRef: CTypeRef;
				innerMostReturnPointerBaseTypeRef = functionReturnType.base;
				while (innerMostReturnPointerBaseTypeRef.typ is CPointerType ||
				       innerMostReturnPointerBaseTypeRef.typ is CLValueType)
					innerMostReturnPointerBaseTypeRef = innerMostReturnPointerBaseTypeRef.typ.base;
				innerMostReturnPointerBaseTypeRef.moveNonPointerAttributes(this);
				attrib = this.attrib;
			}
			if (flags & CTYPEREF_FLAG_NONSENSE_PTRBASE_FUNCTION) {
				if (flags & CTYPEREF_FLAG_NONNULL) {
					if (typ.setNonnullArgumentsAllPointers(checker))
						flags &= ~CTYPEREF_FLAG_NONNULL;
				}
				if (flags & CTYPEREF_FLAG_NONSENSE_PTRBASE_FUNCTION) {
					shouldWarn = copy this;
					flags &= ~CTYPEREF_FLAG_NONSENSE_PTRBASE_FUNCTION;
				}
			}
			if (attrib !is none) {
				if (attrib.nonnull !is none) {
					typ.setNonnullArguments(checker, attrib.nonnull);
					attrib.nonnull = none;
				}
				for (local nonSenseAttrib: CTYPEATTRIBUTES_NONSENSE_PTRBASE_FUNCTION) {
					if (attrib.operator . (nonSenseAttrib) !is none) {
						if (shouldWarn is none)
							shouldWarn = copy this;
						attrib.operator . (nonSenseAttrib) = none;
					}
				}
				attrib.fixNonsensicalFunctionAttributes(checker);
			}
		} else {
			if (flags & CTYPEREF_FLAG_NONSENSE_PTRBASE_REGULAR) {
				shouldWarn = copy this;
				flags &= ~CTYPEREF_FLAG_NONSENSE_PTRBASE_REGULAR;
			}
			if (attrib !is none) {
				for (local nonSenseAttrib: CTYPEATTRIBUTES_NONSENSE_PTRBASE_REGULAR) {
					if (attrib.operator . (nonSenseAttrib) !is none) {
						if (shouldWarn is none)
							shouldWarn = copy this;
						attrib.operator . (nonSenseAttrib) = none;
					}
				}
				local nothrow: string | none = attrib.nothrow;
				if (nothrow.startswith("*")) {
					/* Inheriting nothrow attributes are not allowed on regular pointer types. */
					checker.warn("-Wattribute",
						f"`__attribute__((nothrow(*)))' cannot be "
						f"used on pointer-to-non-function `{this}'");
					attrib.nothrow = nothrow.lstrip("*");
				}
			}
		}

		/* Warn if `nonnull' is used alongside a non-zero `nothrow' tag.
		 * s.a. `setNonnullFlagForFunctionArgument()' */
		if (flags & CTYPEREF_FLAG_NONNULL) {
			local nothrow: string | none = attrib.nothrow;
			if (nothrow !is none && (nothrow.startswith("*") || int(nothrow) > 0)) {
				if (typ is CFunctionType) {
					/* Function pointers are allowed to have a nothrow attribute *and* be nonnull! */
				} else {
					checker.warn("-Wattribute",
						f"Use of `__attribute__((nonnull))' together "
						f"with `__attribute__((nothrow({nothrow})))' "
						f"in `{this}'");
				}
			}
		}

		if (shouldWarn !is none) {
			checker.warn("-Wattribute",
				f"Nonsensical attributes in `{CPointerType(shouldWarn)}'");
		}
		typ.fixNonsensicalAttributes(checker);
	}

	@@Set the @CTYPEREF_FLAG_NONNULL flag, and warn if its use is inappropriate
	function setNonnullFlagForFunctionArgument(checker: Checker, varname: string) {
		/* Warn if `nonnull' is used  alongside a non-zero `nothrow'  tag.
		 * Reason is that a pointer with a non-zero nothrow annotation can
		 * implicitly result in E_SEGFAULT when accessed, which also means
		 * that there'd be no point  in disallowing NULL, since  accessing
		 * NULL also results in E_SEGFAULT! */
		if (!(flags & CTYPEREF_FLAG_NONNULL)) {
			local nothrow: string | none = attrib.nothrow;
			if (nothrow !is none && (nothrow.startswith("*") || int(nothrow) > 0)) {
				if (typ is CFunctionType) {
					/* Function pointers are allowed to have a nothrow attribute *and* be nonnull! */
				} else {
					checker.warn("-Wattribute",
						f"`__attribute__((nonnull))' applied to argument `{varname}' "
						f"which is annotated as `{getPrettyNothrowLevelName(nothrow)}'");
				}
			}
			flags |= CTYPEREF_FLAG_NONNULL;
		}
	}

	function isConvertibleTo(other: CTypeRef, explicit: bool = false): bool {
		local otherTyp: CType = other.typ;
		if (otherTyp === C_void)
			return true; /* Always able to convert anything to void */
		return typ.isConvertibleTo(otherTyp, explicit);
	}

	function isConvertibleToWithFlags(other: CTypeRef, explicit: bool = false): bool {
		if (!explicit) {
			/* Not allowed to cast away const/volatile */
			local myCV = flags & CTYPEREF_FLAG_CV;
			local otCV = other.flags & CTYPEREF_FLAG_CV;
			if ((myCV & otCV) != myCV)
				return false;
		}
		return isConvertibleTo(other, explicit);
	}

	function tostr(varname: string = ""): string {
		for (local keyword: CTYPEREF_FLAGNAMES_TOSTR(CTYPEREF_FLAGNAMES_KEYWORD, flags))
			varname = f"{keyword} {varname}";
		local attributeValues: {string...} = List(
			CTYPEREF_FLAGNAMES_TOSTR(CTYPEREF_FLAGNAMES_ATTRIB, flags));
		if (attrib !is none)
			attributeValues.extend(attrib.enumerateAttributsNotPresentIn());
		if (attributeValues)
			varname = f"__attribute__(({', '.join(attributeValues)})) {varname}";
		return typ.tostr(varname.rstrip());
	}

	@@Used to implement the `__builtin_has_attribute' function
	@@Note however that @this @CTypeRef is allowed to have *more* attributes!
	function hasAllAttributesFrom(other: CTypeRef): bool {
		if ((flags & other.flags) != other.flags)
			return false;
		if (attrib is none && other.attrib is none) {
			/* OK: no custom attributes anywhere */
		} else {
			if (!requireAttrib.hasAllAttributesFrom(other.requireAttrib))
				return false;
		}
		return true;
	}
}

function commonTypeRefFlags(a: int, b: int): int {
	return ((a | b) & ~CTYPEREF_FLAG_FORCE) |
	       ((a & b) & (CTYPEREF_FLAG_FORCE));
}

function cTypeRefWithCommonAttrib(self: CTypeRef, other: CTypeRef): CTypeRef {
	if (self.flags == other.flags && IDENTICAL(self.attrib, other.attrib))
		return self;
	local result = CTypeRef(typ: self.typ, flags: commonTypeRefFlags(self.flags, other.flags));
	if (self.attrib is none) {
		result.attrib = copy other.attrib;
	} else if (other.attrib is none) {
		result.attrib = copy self.attrib;
	} else {
		result.attrib = copy self.attrib;
		result.attrib.importFrom(other.attrib);
	}
	return result;
}



class CCoreType: CType {
	this = default;
	public member name: string;
	public member sizeof: int;
	public member alignof: int;
	public operator hash(): int -> Object.id(this);
	public operator == (other: CCoreType): bool -> this === other;
	public operator != (other: CCoreType): bool -> this !== other;

	function tostr(varname: string = ""): string {
		return varname ? f"{name} {varname}" : name;
	}
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return this in C_NUMERIC && other in C_NUMERIC;
	}

	// public  function  peek(checker:  Checker, data:  Bytes,  offset: int):  int  | float;
	// public function poke(checker: Checker, data: Bytes, offset: int, value: int | float);
	// public function bytes(checker: Checker, value: int | float): Bytes;
}

final class CCoreIntType: CCoreType {
	public member signed: bool;
	public member mask: int;
	this(name: string, sizeof: int, alignof: int, signed: bool)
		: super(name, sizeof, alignof)
	{
		this.signed = signed;
		this.mask = (1 << (sizeof * 8)) - 1;
	}
	operator repr(): string ->
			f"CCoreIntType(name: {repr this.name}, "
			f"sizeof: {repr this.sizeof}, "
			f"alignof: {repr this.alignof}, "
			f"signed: {repr signed})";
	public function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other is CEnumType)
			other = other.base;
		return (other in C_NUMERIC) ||
		       (other is CPointerType);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		local intVal: int = peek(checker, data, offset);
		local suffix: string = "";
		if (this in C_LLONG) {
			suffix = this in C_UNSIGNED ? "ull" : "ll";
		} else if (this in C_LONG) {
			suffix = this in C_UNSIGNED ? "ul" : "l";
		}
		return f"{intVal}{suffix}";
	}
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + this.sizeof], checker.TARGET_ENDIAN, signed);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + this.sizeof] = (value & mask).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return (value & mask).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
}

final class CCoreBoolType: CCoreType {
	this = super;
	public function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other is CEnumType)
			other = other.base;
		return (other in C_NUMERIC) ||
		       (other is CPointerType);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return str !!peek(checker, data, offset);
	}
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + this.sizeof]) ? 1 : 0;
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + this.sizeof] = (value ? 1 : 0).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return (value ? 1 : 0).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
}

final class CCoreNullptrType: CCoreType {
	this = super;
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return (other is CPointerType) ||
		       (other is CCoreNullptrType) ||
		       (explicit && (other in C_NUMERIC));
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return "nullptr";
	}
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return 0;
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + this.sizeof] = Bytes(this.sizeof);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return Bytes(this.sizeof);
	}
}

final class CCoreVoidType: CCoreType {
	this(): super("void", 0, 1) {}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return "(void)0";
	}
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return other is CCoreVoidType;
	}
}

global final CTYPES_FLOAT_TYPES: {int: ctypes.StructuredType} = {
	ctypes.float.sizeof : ctypes.float,
	ctypes.double.sizeof : ctypes.double,
	ctypes.ldouble.sizeof : ctypes.ldouble,
};

function ctypesGetFloatTypeBySize(sizeof: int): ctypes.StructuredType {
	for (;;) {
		local result: ctypes.StructuredType | none;
		result = CTYPES_FLOAT_TYPES.get(sizeof);
		if (result !is none)
			return result;
		--sizeof;
		if (sizeof <= 0)
			throw Error("No floating point type known for this size");
	}
}

global final FLOAT_TYPES_SUFFIX: {Type: string};
final class CCoreFloatType: CCoreType {
	public member ctypesType: ctypes.StructuredType;
	this(name: string, sizeof: int, alignof: int)
		: super(name, sizeof, alignof)
	{
		ctypesType = ctypesGetFloatTypeBySize(sizeof);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return f"{ctypesType.frombytes(data, offset)}{FLOAT_TYPES_SUFFIX[type this]}";
	}
	public function peek(checker: Checker, data: Bytes, offset: int): float {
		return (float)ctypesType.frombytes(data, offset);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: float) {
		ctypesType.tobytes((ctypesType)value, data, offset);
	}
	public function bytes(checker: Checker, value: float): Bytes {
		return ctypesType.tobytes((ctypesType)value);
	}
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return other in C_NUMERIC;
	}
}


global final C_void = CCoreVoidType();
global final C_bool = CCoreBoolType("bool", 1, 1);
global final C_char = CCoreIntType("char", 1, 1, true);
global final C_schar = CCoreIntType("signed char", 1, 1, true);
global final C_uchar = CCoreIntType("unsigned char", 1, 1, false);
global final C_short = CCoreIntType("short", 2, 2, true);
global final C_ushort = CCoreIntType("unsigned short", 2, 2, false);
global final C_int = CCoreIntType("int", 4, 4, true);
global final C_uint = CCoreIntType("unsigned int", 4, 4, false);
global final C_long32 = CCoreIntType("long", 4, 4, true);
global final C_long64 = CCoreIntType("long", 8, 8, true);
global final C_ulong32 = CCoreIntType("unsigned long", 4, 4, false);
global final C_ulong64 = CCoreIntType("unsigned long", 8, 8, false);
global final C_llong_align4 = CCoreIntType("long long", 8, 4, true);
global final C_llong_align8 = CCoreIntType("long long", 8, 8, true);
global final C_ullong_align4 = CCoreIntType("unsigned long long", 8, 4, false);
global final C_ullong_align8 = CCoreIntType("unsigned long long", 8, 8, false);
global final C_int128_t_align4 = CCoreIntType("__int128", 16, 4, true);
global final C_int128_t_align8 = CCoreIntType("__int128", 16, 8, true);
global final C_uint128_t_align4 = CCoreIntType("unsigned __int128", 16, 4, false);
global final C_uint128_t_align8 = CCoreIntType("unsigned __int128", 16, 8, false);
global final C_wchar_t = CCoreIntType("wchar_t", 4, 4, false);
global final C_char8_t = CCoreIntType("char8_t", 1, 1, false);
global final C_char16_t = CCoreIntType("char16_t", 2, 2, false);
global final C_char32_t = CCoreIntType("char32_t", 4, 4, false);
global final C_float = CCoreFloatType("float", 4, 4);
global final C_double = CCoreFloatType("double", 8, 8);
global final C_ldouble_12 = CCoreFloatType("long double", 12, 8);
global final C_ldouble_16 = CCoreFloatType("long double", 16, 16);
global final C_nullptr_t_32 = CCoreNullptrType("nullptr_t", 4, 4);
global final C_nullptr_t_64 = CCoreNullptrType("nullptr_t", 8, 8);

global final C_int_typeref: CTypeRef = CTypeRef(C_int);
global final C_uint_typeref: CTypeRef = CTypeRef(C_uint);
global final C_double_typeref: CTypeRef = CTypeRef(C_double);

global final FLOAT_TYPES_SUFFIX: {Type: string} = UniqueDict.Frozen({
	C_float : "F",
	C_double : "",
	C_ldouble_12 : "L",
	C_ldouble_16 : "L",
});


global final C_PROMOTE: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_char8_t,
	C_char16_t,
});
global final C_NUMERIC: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_int,
	C_uint,
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
	C_int128_t_align4,
	C_int128_t_align8,
	C_uint128_t_align4,
	C_uint128_t_align8,
	C_wchar_t,
	C_char8_t,
	C_char16_t,
	C_char32_t,
	C_float,
	C_double,
	C_ldouble_12,
	C_ldouble_16,
});

global final C_BOOLEAN: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
});

global final C_NULLPTR: {CCoreType...} = UniqueSet.Frozen({
	C_nullptr_t_32,
	C_nullptr_t_64,
});

global final C_INT: {CCoreType...} = UniqueSet.Frozen({
	C_int,
	C_uint,
});

global final C_LONG: {CCoreType...} = UniqueSet.Frozen({
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
});

global final C_LLONG: {CCoreType...} = UniqueSet.Frozen({
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
});

global final C_INTEGER: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_int,
	C_uint,
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
	C_int128_t_align4,
	C_int128_t_align8,
	C_uint128_t_align4,
	C_uint128_t_align8,
	C_wchar_t,
	C_char8_t,
	C_char16_t,
	C_char32_t,
});

global final C_FLOATING: {CCoreType...} = UniqueSet.Frozen({
	C_float,
	C_double,
	C_ldouble_12,
	C_ldouble_16,
});

global final C_SIGNED: {CCoreType: CCoreType} = UniqueDict.Frozen({
	C_char:             C_schar,
	C_uchar:            C_schar,
	C_ushort:           C_short,
	C_uint:             C_int,
	C_ulong32:          C_long32,
	C_ulong64:          C_long64,
	C_ullong_align4:    C_llong_align4,
	C_ullong_align8:    C_llong_align8,
	C_uint128_t_align4: C_int128_t_align4,
	C_uint128_t_align8: C_int128_t_align8,
});
global final C_UNSIGNED: {CCoreType: CCoreType} = UniqueDict.Frozen({
	C_char:            C_uchar,
	C_schar:           C_uchar,
	C_short:           C_ushort,
	C_int:             C_uint,
	C_long32:          C_ulong32,
	C_long64:          C_ulong64,
	C_llong_align4:    C_ullong_align4,
	C_llong_align8:    C_ullong_align8,
	C_int128_t_align4: C_uint128_t_align4,
	C_int128_t_align8: C_uint128_t_align8,
});

class CPointerType: CType {
	this = default;

	@@Pointer base type.
	public member base: CTypeRef;
	public function fixNonsensicalAttributes(checker: Checker)
		-> base.fixNonsensicalPointerBaseAttributes(checker);

	public property unwindWeakRef: CType = {
		get(): CType {
			local resBase = base.unwindWeakRef;
			if (resBase === base)
				return this;
			local res = copy this;
			res.base = resBase;
			return res;
		}
	}

	function redeclarationImport(checker: Checker, other: CType,
	                             newName: string = "", oldName: string = "",
	                             oldDeclFlc: (string, int, int) | none = none)
		-> base.redeclarationImport(checker, other.base, newName, oldName, oldDeclFlc);

	function tostr(varname: string = ""): string {
		return base.tostr("*" + varname);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		local intVal: int = this.peek(checker, data, offset);
		return intVal ? f"({this}){intVal.hex()}ul" : "0";
	}
	public operator hash(): int -> hash(type(this), base);
	public operator == (other: CPointerType): bool -> type(this) === type(other) && base == other.base;
	public operator != (other: CPointerType): bool -> type(this) !== type(other) || base != other.base;
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other !is CPointerType)
			return false;
		if (explicit)
			return true;
		return base.isConvertibleToWithFlags(other.base, explicit);
	}
}

final class CPointerType32: CPointerType {
	this = super;
	public property sizeof: int = { get() -> 4; };
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + 4], checker.TARGET_ENDIAN, false);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + 4] = value.tobytes(4, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return value.tobytes(4, checker.TARGET_ENDIAN, false);
	}
}

final class CPointerType64: CPointerType {
	this = super;
	public property sizeof: int = { get() -> 8; };
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + 8], checker.TARGET_ENDIAN, false);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + 8] = value.tobytes(8, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return value.tobytes(8, checker.TARGET_ENDIAN, false);
	}
}

class CLValueType: CType {
	this = default;

	@@LValue base type.
	public member base: CTypeRef;
	function fixNonsensicalAttributes(checker: Checker)
		-> base.fixNonsensicalPointerBaseAttributes(checker);

	public property unwindWeakRef: CType = {
		get(): CType {
			local resBase = base.unwindWeakRef;
			if (resBase === base)
				return this;
			local res = copy this;
			res.base = resBase;
			return res;
		}
	}

	function redeclarationImport(checker: Checker, other: CType,
	                             newName: string = "", oldName: string = "",
	                             oldDeclFlc: (string, int, int) | none = none)
		-> base.redeclarationImport(checker, other.base, newName, oldName, oldDeclFlc);

	function tostr(varname: string = ""): string {
		return base.tostr("&" + varname);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		local intVal: int = this.peek(checker, data, offset);
		return intVal ? f"*({base.tostr("*")}){intVal.hex()}ul" : "0";
	}
	public operator hash(): int -> hash(base);
	public operator == (other: CLValueType): bool -> base == other.base;
	public operator != (other: CLValueType): bool -> base != other.base;
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other !is CLValueType)
			return base.isConvertibleTo(other, explicit);
		if (explicit)
			return true;
		return base.isConvertibleToWithFlags(other.base, explicit);
	}
}

final class CStructType: CType {
	this = default;
	public member name: string;
	public member isUnion: bool;
	public member base: CStructType | none = none;
	@@Struct fields and C++ member functions
	public member fields: {string: (CTypeRef, int) | CSymbol} = Dict();
	public member fieldsByDeclarationOrder: {(CTypeRef, string)...} = [];

	public operator hash(): int -> Object.id(this);
	public operator == (other: CStructType) -> this === other;
	public operator != (other: CStructType) -> this !== other;

	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		local writer = File.Writer();
		writer << "{";
		local prefix: string = "";
		local nextIndent: int = indent;
		if (indent >= 0) {
			writer << "\n";
			prefix = "\t" * indent;
			++nextIndent;
		}
		local isFirst = true;
		if (base !is none) {
			writer << prefix << "[" << base << "]: ";
			base.dumpValue(checker, data, offset, nextIndent);
			isFirst = false;
		}
		for (local fieldType, fieldName: fieldsByDeclarationOrder) {
			if (!isFirst) {
				writer << ",";
				if (indent >= 0)
					writer << "\n";
			}
			isFirst = false;
			writer << prefix;
			local fieldOffset: int;
			if (fieldName) {
				fieldOffset = fields[fieldName].last;
				writer << fieldName << ": ";
			} else {
				fieldOffset = 0;
				local innerStruct = fieldType.typ;
				if (innerStruct is CStructType) {
					local firstFieldName: string = innerStruct.fieldsByDeclarationOrder.first.last;
					fieldOffset = innerStruct.fields[firstFieldName].last;
				}
			}
			writer << fieldType.dumpValue(checker, data, offset + fieldOffset, nextIndent);
		}
		writer << "}";
		return writer.string;
	}

	public function isConvertibleTo(other: CType, explicit: bool = false): bool {
		local iter: CStructType | none = this;
		do {
			if (other === iter)
				return true;
			iter = iter.base;
		} while (iter !is none);
		return false;
	}

	public property structRepr: string = {
		get(): string {
			if (name)
				return f"struct {name}";
			local result = File.Writer();
			result << "struct {";
			for (local fieldType, fieldName: fieldsByDeclarationOrder)
				result << " " << fieldType.unwindWeakRef.tostr(fieldName) << ";";
			result << " }";
			return result.string;
		}
	}

	public function tostr(varname: string = ""): string {
		return varname ? f"{structRepr} {varname}" : structRepr;
	}

	public function getField(name: string): (CTypeRef, int) | CSymbol | none {
		local result = fields.get(name);
		if (result is none && base !is none)
			result = base.getField(name);
		if (result !is none && result !is CSymbol)
			result = (result.first.unwindWeakRef, result.last);
		return result;
	}

	public property foreachField: {(string, CTypeRef, int)...} = {
		get(): {(string, CTypeRef, int)...} {
			if (base !is none)
				yield base.foreachField...;
			for (local name, typAndOffset: fields) {
				if (typAndOffset is CSymbol)
					continue;
				local typ, offset = typAndOffset...;
				yield (name, typ.unwindWeakRef, offset);
			}
		}
	}

	public function fieldByOffset(offset: int): (string, int) | none {
		local result: (string, int) | none = none;
		for (local fieldName, none, fieldOffset: foreachField) {
			if (fieldOffset <= offset) {
				local subOffset = offset - fieldOffset;
				if (result is none || subOffset < result.last)
					result = (fieldName, subOffset);
				if (subOffset == 0)
					break;
			}
		}
		return none;
	}

	private member _sizeof: int;
	public property sizeof: int = {
		get() {
			if (_sizeof !is bound) {
				local result = 0;
				for (local none, fieldType, fieldOffset: foreachField) {
					local offsetAfter = fieldOffset + fieldType.typ.sizeof;
					if (result < offsetAfter)
						result = offsetAfter;
				}
				_sizeof = result;
			}
			return _sizeof;
		}
	}

	public member _alignof: int; /* Must be public! */
	public property alignof: int = {
		get() {
			if (_alignof !is bound) {
				local result = 1;
				for (local none, fieldType, none: foreachField) {
					local temp = fieldType.typ.alignof;
					if (result < temp)
						result = temp;
				}
				_alignof = result;
			}
			return _alignof;
		}
	}
}

final class CEnumType: CType {
	this = default;
	public member name: string;
	public member base: CType = C_int;
	public property sizeof: int = { get(): int -> base.sizeof; };
	public property alignof: int = { get(): int -> base.alignof; };
	public operator hash(): int -> Object.id(this);
	public operator == (other: CStructType) -> this === other;
	public operator != (other: CStructType) -> this !== other;
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other is CEnumType) {
			if (this === other)
				return true;
			if (!explicit)
				return false;
			return base.isConvertibleTo(other.base, true);
		}
		return base.isConvertibleTo(other, explicit);
	}
	function tostr(varname: string = ""): string {
		return varname ? f"enum {name} {varname}" : f"enum {name}";
	}
}

final class CFunctionType: CType {
	this = default;
	public member returnType: CType;
	public member args: {(CTypeRef, string)...} = [];
	@@Defaults for the last N arguments of the function
	public member defaults: {Bytes...} = [];
	public member isVarArgs: bool = false;
	public property sizeof: int = { get(): int -> 0; };
	public property alignof: int = { get(): int -> 1; };

	public property unwindWeakRef: CType = {
		get(): CType {
			local resReturnType = returnType.unwindWeakRef;
			if (resReturnType !== this) {
				local result = copy this;
				result.returnType = resReturnType;
				result.args = List(
					for (local argTypeRef, argName: args)
						(argTypeRef.unwindWeakRef, argName)
				);
				return result;
			}
			for (local i: [:#args]) {
				local argTypeRef = args[i].first;
				local resArgTypeRef = argTypeRef.unwindWeakRef;
				if (argTypeRef !== resArgTypeRef) {
					local result = copy this;
					result.returnType = resReturnType;
					result.args = copy result.args;
					result.args[i] = (resArgTypeRef, args[i].last);
					for (++i; i < #args; ++i) {
						local argName;
						argTypeRef, argName = args[i]...;
						result.args[i] = (argTypeRef.unwindWeakRef, argName);
					}
					return result;
				}
			}
			return this;
		}
	}

	@@Evaluations to @true if there are pointer-arguments that are neither `restrict`, not `[[nonnull]]`
	public property hasNotRestrictNotNonnullPointerArguments: bool = {
		get(): bool {
			for (local argTypeRef, none: args) {
				local argType: CType = argTypeRef.typ;
				if ((argType is CPointerType) &&
				    !(argTypeRef.flags & CTYPEREF_FLAG_RESTRICT) &&
				    !(argType.base.flags & CTYPEREF_FLAG_NONNULL)) {
					return true;
				}
			}
			return false;
		}
	}

	function redeclarationImport(checker: Checker, other: CType,
	                             newName: string = "", oldName: string = "",
	                             oldDeclFlc: (string, int, int) | none = none) {
		returnType.redeclarationImport(checker, other.returnType, newName, oldName, oldDeclFlc);
		assert #args == #other.args;
		if (other.defaults) {
			/* Default arguments can only be declared *once* */
			if (checker.ignoreDuplicateDefaultArgumentDeclarations) {
				/* Special mode for `__builtin_define_alias()` */
			} else if (!defaults) {
				defaults = other.defaults;
			} else {
				checker.warn("-Wdecl",
					f"Function default arguments were already "
					f"present in previous declaration of `{newName}'");
			}
		}
		for (local i: [:#args]) {
			local argTypeRef: CTypeRef;
			local argName: string;
			argTypeRef, argName = args[i]...;
			local otherArgName = other.args[i].last;
			if (!argName) {
				/* Lazily import argument names when not already defined. */
				argName = otherArgName;
				args[i] = (argTypeRef, argName);
			}
			if (!otherArgName)
				otherArgName = argName;
			argTypeRef.redeclarationImport(checker, other.args[i].first,
					f"{newName}.{argName}",
					f"{oldName}.{otherArgName}",
					oldDeclFlc);
		}
	}

	function binaryArgsSize(checker: Checker): int {
		local result = 0;
		local sizeofPointer = checker.TARGET_SIZEOF_POINTER;
		if (returnType is CStructType)
			result += sizeofPointer; /* Struct return is done with an implicit pointer argument inserted at the front */
		for (local typeref, none: args) {
			result = ceilAlign(result, typeref.alignof);
			result += ceilAlign(typeref.sizeof, sizeofPointer);
		}
		return result;
	}

	function binaryCompatibleWith(checker: Checker, newType: CFunctionType): bool {
		/* TODO: Assert compatible calling conventions */
		local sizeofPointer = checker.TARGET_SIZEOF_POINTER;
		if (!binaryConvertibleTo(checker, returnType, newType.returnType, sizeofPointer))
			return false;
		local oldArgsSize = binaryArgsSize(checker);
		local newArgsSize = newType.binaryArgsSize(checker);
		/* TODO: For STDCALL, this check needs to be `oldArgsSize == newArgsSize' */
		return oldArgsSize <= newArgsSize;
	}

	public operator hash(): int -> hash(returnType, isVarArgs, args.each.first);
	public operator == (other: CFunctionType) ->
		other is CFunctionType &&
		IDENTICAL(returnType, other.returnType) &&
		isVarArgs == other.isVarArgs &&
		(args.each.first as Sequence) == other.args.each.first;
	public operator != (other: CFunctionType) ->
		other !is CFunctionType ||
		!IDENTICAL(returnType, other.returnType) ||
		isVarArgs != other.isVarArgs ||
		(args.each.first as Sequence) != other.args.each.first;

	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other !is CFunctionType)
			return false;
		if (explicit)
			return true;
		if (isVarArgs != other.isVarArgs)
			return false;
		if (#args != #other.args)
			return false;
		for (local myArg, otArg: util.zip(args, other.args)) {
			if (!myArg.first.isConvertibleTo(otArg.first))
				return false;
		}
		return returnType.isConvertibleTo(other.returnType);
	}

	function tostr(varname: string = ""): string {
		if (!varname.replace(":", "").issymbol())
			varname = f"({varname})";
		if (args) {
			varname = f"{varname}({
				", ".join(for (local typ, name: args) typ.tostr(name))
			})";
		} else {
			varname += "(void)";
		}
		return returnType.tostr(varname);
	}

	function fixNonsensicalAttributes(checker: Checker)
		-> returnType.fixNonsensicalAttributes(checker);

	@@Mark all pointer arguments as non-null
	function setNonnullArgumentsAllPointers(checker: Checker): bool {
		local result: bool = false;
		for (local argTypeRef, argName: args) {
			local typ: CType = argTypeRef.typ;
			if (typ is CPointerType) {
				typ.base.setNonnullFlagForFunctionArgument(checker, argName);
				result = true;
			}
		}
		return true;
	}

	@@Mark all arguments that are part of @nonnull as non-null
	function setNonnullArguments(checker: Checker, nonnull: Set with int) {
		for (local index: nonnull) {
			if (index <= 0 || index > #args) {
				checker.warn("-Wattribute",
					f"`__attribute__((nonnull({index})))': Argument index does not exist");
				continue;
			}
			--index;
			local argTypeRef: CTypeRef;
			local argName: string;
			argTypeRef, argName = args[index]...;
			local argType: CType = argTypeRef.typ;
			if (argType !is CPointerType) {
				checker.warn("-Wattribute",
					f"`__attribute__((nonnull({index + 1})))': "
					f"Argument `{argTypeRef.tostr(argName)}' "
					f"does not have pointer-typing");
				continue;
			}
			argType.base.setNonnullFlagForFunctionArgument(checker, argName);
		}
	}

#define ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE      0 /* isConvertibleTo */
#define ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE_STDC 1 /* isConvertibleTo (but `char **' is not convertible to `char const **') */
#define ACCEPTS_CONFORMANCE_LEVEL_EXACT            2 /* Do types match exactly? */
#define ACCEPTS_CONFORMANCE_LEVEL_COUNT            3
	function acceptsArgumentTypes(types: {CType...},
	                              conformanceLevel: int = ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE): bool {
		local myTypes = args;
		if (#types != #myTypes) {
			if (#types > #myTypes) {
				if (!isVarArgs)
					return false;
				types = types[:#myTypes];
			} else {
				local myMinArgc: int = #myTypes - #defaults;
				if (#types < myMinArgc)
					return false;
				myTypes = myTypes[:#types];
			}
		}
		assert #types == #myTypes;
		/*print("acceptsArgumentTypes([", ", ".join(
			for (local typ, nam: myTypes) typ.tostr(nam)
		), "], [", ", ".join(types), "]) [conformanceLevel: ", conformanceLevel, "]");*/
		myTypes = myTypes.each.first.typ; /* {CType...} */
		for (local myTyp, rqTyp: util.zip(myTypes, types)) {
			switch (conformanceLevel) {
			case ACCEPTS_CONFORMANCE_LEVEL_EXACT:
				if (!IDENTICAL(myTyp, rqTyp))
					return false;
				break;
			case ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE_STDC: {
				if (rqTyp is CPointerType && myTyp is CPointerType) {
					local rqTypBase: CType = rqTyp.base.typ;
					local myTypBase: CType = myTyp.base.typ;
					if (!IDENTICAL(rqTypBase, myTypBase))
						return false;
					local rqTypCV = rqTyp.base.flags & CTYPEREF_FLAG_CV;
					local myTypCV = myTyp.base.flags & CTYPEREF_FLAG_CV;
					if ((rqTypCV & myTypCV) != rqTypCV)
						return false;
				} else {
					if (!rqTyp.isConvertibleTo(myTyp))
						return false;
				}
			}	break;
			default:
				if (!rqTyp.isConvertibleTo(myTyp))
					return false;
				break;
			}
		}
		return true;
	}
}

final class CArrayType: CType {
	this = default;
	public member base: CType;
	@@Set to @none for flexible arrays
	public member dim: int | none;
	public member stride: int;
	public property sizeof: int = { get(): int -> dim is none ? 0 : base.sizeof * dim; };
	public property alignof: int = { get(): int -> base.alignof; };

	function fixNonsensicalAttributes(checker: Checker)
		-> base.fixNonsensicalAttributes(checker);

	function tostr(varname: string = ""): string {
		if (varname.startswith("*") || " " in varname)
			varname = f"({varname})";
		return base.tostr(f"{varname}[{dim is none ? "" : dim}]");
	}

	public operator hash(): int -> hash(base, dim, stride);
	public operator == (other: CArrayType) ->
		other is CArrayType ||
		IDENTICAL(base, other.base) &&
		IDENTICAL(dim, other.dim) &&
		stride == other.stride;
	public operator != (other: CFunctionType) ->
		other !is CArrayType ||
		!IDENTICAL(base, other.base) ||
		!IDENTICAL(dim, other.dim) ||
		stride != other.stride;

	function indexByOffset(offset: int): (int, int) | none {
		local stride = base.alignof;
		if (stride <= 0)
			return none;
		local index, subOffset = offset.divmod(stride)...;
		if (index < 0 || (dim !is none && index >= dim))
			return none;
		return (index, subOffset);
	}

}


class CSymbol {
	this = default;
	@@Name of the symbol
	public member name: string;
	@@Declaration location `filename, line, column`
	public member decl: (string, int, int);
	@@Type of the symbol (@none for @COverloadedFunctionSymbol)
	public member typeref: CTypeRef | none;
	@@Constant value of the symbol, or unbound if never assigned, or @none if unknown
	public member val: Bytes | none;

	operator str(): string -> str typeref.tostr(name);
	public property valOrNone: Bytes | none = {
		get(): Bytes | none {
			try {
				return val;
			} catch (UnboundAttribute) {
				return none;
			}
		}
	}
}

@@Sub-class for overloaded function-like symbols (needed for overloads)
@@NOTE: The primary symbol element should not be used, and its fields are unbound!
final class COverloadedFunctionSymbol: CSymbol {
	this = default;
	@@The overloads of this function
	public member overloads: {CSymbol | CSymbolTemplate...} = [];

	@@Get or create an overload for the given @typeref c-function-type
	function getOrCreateOverload(checker: Checker, typeref: CTypeRef): CSymbol {
		for (local overload: overloads) {
			if (overload is CSymbolTemplate)
				continue;
			if (overload.typeref.redeclarationEquals(typeref)) {
				local symbolName = this.name;
				overload.typeref.redeclarationImport(
					checker, typeref, symbolName, symbolName, overload.decl);
				return overload;
			}
		}
		local result = CSymbol(this.name, this.decl, typeref);
		overloads.append(result);
		return result;
	}

	function getOrCreateTemplateOverload(typeInit: Bytes): CSymbolTemplate {
		for (local overload: overloads) {
			if (overload !is CSymbolTemplate)
				continue;
			if (overload.typeInit == typeInit)
				return overload;
		}
		local result = CSymbolTemplate();
		overloads.append(result);
		return result;
	}

	function getOverloadsForTypes(checker: Checker, argTypes: {CType...}): {CSymbol...} {
		local result: {CSymbol...} = [];
		for (local overload: overloads) {
			if (overload is CSymbolTemplate) {
				/* TODO: Instantiate template */
			} else {
				local symType: CType = overload.typeref.typ;
				if (symType is CFunctionType && symType.acceptsArgumentTypes(argTypes))
					result.append(overload);
			}
		}
		if (#result > 1) {
			for (local level: [1:ACCEPTS_CONFORMANCE_LEVEL_COUNT]) {
				local newResult: {CSymbol...} = [];
				for (local overload: result) {
					local symType: CType = overload.typeref.typ;
					if (symType.acceptsArgumentTypes(argTypes, level))
						newResult.append(overload);
				}
				if (newResult) {
					result = newResult;
					if (#result == 1)
						break;
				} else {
					break;
				}
			}
		}
		return result;
	}

}


#define TemplateParamValue (CTypeRef | Bytes)
class TemplateParam {
	this = default;
	@@Name of this template parameter
	@@ - `FOO` in `template<class FOO = int>`
	@@ - `N` in `template<size_t N = 4>`
	public member name: string;
	@@Declaration location of @name
	public member decl: (string, int, int);
	@@Parameter type, or @none if it's a type-parameter
	public member typeref: CTypeRef | none;
	@@Default initializer for this parameter
	@@ - `int` in `template<class FOO = int>`
	@@ - `4` in `template<size_t N = 4>`
	public member defaultInit: Bytes | none = none;
	@@Declaration location of @defaultInit
	public member defaultDecl: (string, int, int) | none = none;
	operator str(): string {
		if (defaultInit is none) {
			if (typeref is none)
				return f"class {name}";
			return typeref.tostr(name);
		} else {
			if (typeref is none)
				return f"class {name} = {defaultInit}";
			return f"{typeref.tostr(name)} = {defaultInit}";
		}
	}
}

class CTypeRefTemplate {
	this = default;
	@@Name of the typedef/symbol
	@@ - `Name` in `template<class T> using Name = T;`
	@@ - `bar` in `template<class T> T bar = (T)0;`
	@@ - `foo` in `template<class T> struct foo { T x; };`
	@@ - `foo` in `template<class T> void foo(T x) { callMe(); }`
	public member name: string;
	@@Declaration location of @name
	public member decl: (string, int, int);
	@@Template parameters
	public member params: {TemplateParam...};
	@@Raw source-code that represents the initializer for the template type
	@@ - `T` in `template<class T> using Name = T;`
	@@ - `struct foo { T x; }` in `template<class T> struct foo { T x; };`
	@@For @CSymbolTemplate:
	@@ - `T bar` in `template<class T> T bar = (T)0;`
	@@ - `void foo(T x)` in `template<class T> void foo(T x) { callMe(); }`
	@@NOTE: Unbound in case of an uninitialized struct/union/class template
	public member typeInit: Bytes;
	@@Declaration location of @typeInit
	public member typeDecl: (string, int, int);
	@@Instantiated instances of this template.
	@@ - For @CTypeRefTemplate, elements are @CTypeRef
	@@ - For @CSymbolTemplate, elements are @CSymbol
	public member instances: {{TemplateParamValue...} : CTypeRef | CSymbol} = Dict();

	function instantiationRepr(checker: Checker, args: {TemplateParamValue...}): string {
		local writer = File.Writer();
		writer << name << "<";
		local isFirst = true;
		for (local param, arg: util.zip(params, args)) {
			if (!isFirst)
				writer << ", ";
			isFirst = false;
			if (arg is CTypeRef) {
				writer << arg;
			} else {
				writer << param.typeref.typ.peek(checker, arg);
			}
		}
		writer << ">";
		return writer.string;
	}

	operator str(): string {
		if (typeInit is bound)
			return f"template<{", ".join(params)}> {typeInit.replace("\n", " ")}";
		return f"template<{", ".join(params)}> <uninitialized> {name}";
	}
}

class CSymbolTemplate: CTypeRefTemplate {
	@@Raw source-code that represents the initializer for this symbol template
	@@ - `(T)0` in `template<class T> T bar = (T)0;`
	@@ - `{ callMe(); }` in `template<class T> void foo(T x) { callMe(); }`
	@@NOTE: Unbound in case of an uninitialized symbol template
	public member valInit: Bytes;
	@@Declaration location of @valInit
	public member valDecl: (string, int, int);
	@@Set to @true if this is a function-template (i.e. *no* `=` exists before @valInit)
	public member isFunction: bool;
}


global CEnumClassType;
class CNamespace {
	this = default;
	public final member name: string;
	public final member symbols: {string: CSymbol | CSymbolTemplate} | none = none;
	public final member typedefs: {string: CTypeRef | CTypeRefTemplate} | none = none;
	public final member namespaces: {string: CNamespace} | none = none;
	public final member structSymbols: {string: CStructType} | none = none;
	public final member unionSymbols: {string: CStructType} | none = none;
	public final member enumSymbols: {string: CEnumType} | none = none;
	public final member importedNamespaces: {CNamespace...} | none = none;

	@@Only here so we don't need special handling when used as a @CScope
	public property symbolValues = { get() -> none; };

	@@@param tab: One of:
	@@            - @"symbols": @CSymbol or @CSymbolTemplate
	@@            - @"typedefs": @CTypeRef or @CTypeRefTemplate
	@@            - @"namespaces": @CNamespace
	@@            - @"structSymbols": @CStructType
	@@            - @"unionSymbols": @CStructType
	@@            - @"enumSymbols": @CEnumType
	public final function lookup(tab: string, name: string): Object | none {
		local result = this.operator . (tab).get(name);
		if (result !is none)
			return result;
		for (local importedNamespace: importedNamespaces) {
			result = importedNamespace.lookup(tab, name);
			if (result !is none)
				return result;
		}
		return none;
	}

	public final function defineTemplateParamValue(param: TemplateParam, value: TemplateParamValue) {
		local tabName: string = "typedefs";
		if (value is Bytes) {
			tabName = "symbols";
			assert param.typeref !is none;
			value = CSymbol(param.name, param.decl, param.typeref, value);
		}
		local tab: {string: Object} | none = this.operator . (tabName);
		if (tab is none)
			this.operator . (tabName) = tab = Dict();
		tab[param.name] = value;
	}

	public final function childNamespace(name: string): CNamespace {
		local result = lookup("namespaces", name);
		if (result is none) {
			result = CNamespace(name: name);
			if (namespaces is none)
				namespaces = Dict();
			namespaces[name] = result;
		}
		return result;
	}
}


final class CEnumClassType: CNamespace, CType {
	this = super;
	public member name: string;
	public member base: CTypeRef = C_int;
	public property sizeof: int = { get(): int -> base.sizeof; };
	public property alignof: int = { get(): int -> base.alignof; };
	function tostr(varname: string = ""): string {
		return varname ? f"enum class {this.name} {varname}" : f"enum class {this.name}";
	}
}
