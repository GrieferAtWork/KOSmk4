/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from deemon;
import * from errors;
import util;
import UniqueSet, UniqueDict from collections;
import ctypes;
#define Checker Object

#define IDENTICAL(a, b) (type(a) === type(b) && ((a) == (b)))

global CTypeRef;
class CType: WeakRefAble {
	operator == (other) { return other is CType; }
	operator != (other) { return other !is CType; }
	operator str() -> this.tostr();

	// function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string;
	// function tostr(varname: string = ""): string;
	// property sizeof: int;
	property alignof: int = { get(): int -> this.sizeof; };

	@@Check if this type can be converted to @other
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return IDENTICAL(this, other);
	}
}

global final CTYPEREF_FLAG_CONST    = 0x0001;
global final CTYPEREF_FLAG_VOLATILE = 0x0002;
global final CTYPEREF_FLAG_RESTRICT = 0x0004;
global final CTYPEREF_FLAG_DEREF    = 0x0010;
global final CTYPEREF_FLAG_NODEREF  = 0x0020;
global final CTYPEREF_FLAG_CV = CTYPEREF_FLAG_CONST | CTYPEREF_FLAG_VOLATILE;

@@A function that never returns. When the function is invoked,
global final CTYPEREF_FLAG_NORETURN = 0x0040;

@@Do no inherit pointer attributes during casts:
@@```c
@@__attribute__((noderef)) void *p = get_pointer();
@@int x = *(int *)p;                        // Error
@@int y = *(__attribute__((force)) int *)p; // OK
@@```
global final CTYPEREF_FLAG_FORCE = 0x4000;

@@Used during creation of struct objects.
global final CTYPEREF_FLAG_PACKED = 0x8000;

@@Attribute flags that have no meaning for pointers and should be moved when encountered on one
global final CTYPEREF_FLAG_NON_POINTER = CTYPEREF_FLAG_NORETURN | CTYPEREF_FLAG_PACKED;


/* Special THROWS error codes. */
@@Explicit anything-may-be-thrown: `THROWS(...)`
global final THROWS_ANY = -1;
@@Explicit throws-from-callback: `THROWS(*)`
global final THROWS_CB = -2;
@@Used internally: NonCallExceptions:
@@Implicit throws due to access of pointers with nothrow>0, or calls to functions with nothrow>0.
global final THROWS_NCX = -3;
@@Used internally: OutOfBad:
@@Implicit throws due to calls to functions with neither nothrow, nor throws annotation
global final THROWS_OOB = -4;

@@Remove base classes of explicitly specified sub-classes from @throws
function simplifyThrowsSet(throws: Set with int): Set with int {
	local result: Set with int = HashSet();
	local subClassBases: Set with int = HashSet();
	for (local code: throws) {
		result.insert(code);
		if (code > 0xffff)
			subClassBases.insert(code & 0xffff);
	}
	for (local code: subClassBases)
		result.remove(code);
	return result;
}


final class CTypeAttributes {
	this = default;
	public member nothrow: string | none = none;
	public member tags: Set with string | none = none;
	public member requireCallerTags: Set with string | none = none;
	public member aligned: int | none = none;
	public member throws: Set with int | none = none;

	// TODO: "format": Verify KOS-extended printf-format string argument types

	public function importFrom(other: CTypeAttributes) {
		if (nothrow is none) {
			nothrow = other.nothrow;
		} else if (other.nothrow !is none) {
			local hasStar: bool = nothrow.startswith("*") || other.nothrow.startswith("*");
			local myNothrowLevel: int = int(nothrow.lstrip("*"));
			local otNothrowLevel: int = int(other.nothrow.lstrip("*"));
			if (myNothrowLevel < otNothrowLevel)
				myNothrowLevel = otNothrowLevel;
			nothrow = f"{hasStar ? "*" : ""}{myNothrowLevel}";
		}
		if (other.tags) {
			if (tags is none)
				tags = HashSet();
			tags.insertall(other.tags);
		}
		if (other.requireCallerTags) {
			if (requireCallerTags is none)
				requireCallerTags = HashSet();
			requireCallerTags.insertall(other.requireCallerTags);
		}
		if (aligned is none) {
			aligned = other.aligned;
		} else if (other.aligned !is none) {
			if (aligned < other.aligned)
				aligned = other.aligned;
		}
		if (!throws) {
			throws = other.throws;
		} else if (other.throws) {
			if (throws !is HashSet)
				throws = HashSet(throws);
			throws.insertall(other.throws);
		}
	}

	function hasAllAttributesFrom(other: CTypeAttributes): bool {
		for (local attrib: {
			"nothrow",
			"nothrowInheritable",
			"throws",
			"throwsInheritable",
			"tag",
			"requireCallerTag",
			"aligned",
		}) {
			local myVal = this.operator . (attrib);
			local otVal = other.operator . (attrib);
			if (myVal is none) {
				if (otVal !is none)
					return false;
			} else {
				if (otVal is none)
					return false;
				if (myVal != otVal)
					return false;
			}
		}
		return true;
	}
}


global C_void;
final class CTypeRef {
	this = default;
	@@NOTE: Might point  to a  weakref in  order to  prevent
	@@      reference loops in self-referencing struct types
	public member typ: CType | WeakRef with CType;

	@@Type flags. Set of `CTYPEREF_FLAG_*`
	public member flags: int = 0;

	@@Type attributes.
	public member attrib: CTypeAttributes | none = none;

	operator copy(other: CTypeRef) {
		typ = other.typ;
		flags = other.flags;
		attrib = copy other.attrib;
	}

	/* Helpers */
	operator str(): string -> tostr();
	public property sizeof: int = { get(): int -> typ.sizeof; };
	public property alignof: int = { get(): int -> typ.alignof; };

	@@Unwind a @CTypeRef that's pointing to a @WeakRef
	public property unwindWeakRef: CTypeRef = {
		get(): CTypeRef {
			if (typ is WeakRef) {
				local result = copy this;
				result.typ = typ.value;
				return result;
			}
			return this;
		}
	}

	@@Ensure that @attrib has been allocated
	public property requireAttrib: CTypeAttributes = {
		get(): CTypeAttributes {
			if (attrib is none)
				attrib = CTypeAttributes();
			return attrib;
		}
	};

	/* Helpers for accessing attributes */
	public property attribNothrow: string | none = {
		get(): string | none -> attrib.nothrow;
		set(v: string | none) { (v is none ? attrib : requireAttrib).nothrow = v; }
	};
	public property attribThrows: Set with int = {
		get(): Set with int {
			local result: Set with int | none = attrib.throws;
			if (result is none)
				result = Set();
			return result;
		}
		set(v: Set with int) {
			requireAttrib.throws = v;
		}
	};
	public property attribTags: Set with string = {
		get(): Set with string {
			local result: Set with string | none = attrib.tags;
			if (result is none)
				result = Set();
			return result;
		}
		set(v: Set with string) {
			requireAttrib.tags = v;
		}
	};
	public property attribRequireCallerTags: Set with string = {
		get(): Set with string {
			local result: Set with string | none = attrib.requireCallerTags;
			if (result is none)
				result = Set();
			return result;
		}
		set(v: Set with string) {
			requireAttrib.requireCallerTags = v;
		}
	};
	public property attribAligned: int | none = {
		get(): int | none -> attrib.aligned;
		set(v: int | none) { (v is none ? attrib : requireAttrib).aligned = v; }
	};

	@@Check if @this @CTypeRef is identical to @other in such
	@@a way  that  no  re-declaration error  show  be  thrown
	function redeclarationEquals(other: CTypeRef): bool {
		return IDENTICAL(typ, other.typ);
	}

	@@Import extra annotations/attributes during a second re-declaration
	@@```c
	@@extern int *x;
	@@extern __attribute__((noderef)) int *x; // Extra attributes are imported here!
	@@```
	function redeclarationImport(checker: Checker, other: CTypeRef) {
		/* TODO: Warnings for attributes that weren't present during the initial declaration. */
		flags |= other.flags;
		if (other.attrib !is none)
			requireAttrib.importFrom(other.attrib);
		typ = other.typ;
	}

	@@Import specifications from a fixed @typedef into @this
	@@This merges attributes/flags in:
	@@```c
	@@typedef int FOO;
	@@const FOO x = 42; // "FOO" is inherited/merged-into "const"
	@@```
	function importTypedef(typedef: CTypeRef) {
		flags |= typedef.flags;
		if (typedef.attrib !is none)
			requireAttrib.importFrom(typedef.attrib);
		typ = typedef.typ;
	}

	@@Move attributes that have no meaning for pointers to @dst
	function moveNonPointerAttributes(dst: CTypeRef) {
		if (flags & CTYPEREF_FLAG_NON_POINTER) {
			dst.flags |= flags & CTYPEREF_FLAG_NON_POINTER;
			flags &= ~CTYPEREF_FLAG_NON_POINTER;
		}
		local attrib: CTypeAttributes | none = this.attrib;
		if (attrib !is none) {
			for (local moveAttrib: { "tags", "requireCallerTags", "aligned", "throws" }) {
				local value = attrib.operator . (moveAttrib);
				if (value !is none) {
					dst.requireAttrib.operator . (moveAttrib) = value;
					attrib.operator . (moveAttrib) = none;
				}
			}
		}
	}

	function isConvertibleTo(other: CTypeRef, explicit: bool = false): bool {
		local otherTyp: CType = other.typ;
		if (otherTyp === C_void)
			return true; /* Always able to convert anything to void */
		return typ.isConvertibleTo(otherTyp, explicit);
	}

	function isConvertibleToWithFlags(other: CTypeRef, explicit: bool = false): bool {
		if (!explicit) {
			/* Not allowed to cast away const/volatile */
			local myCV = flags & CTYPEREF_FLAG_CV;
			local otCV = other.flags & CTYPEREF_FLAG_CV;
			if ((myCV & otCV) != myCV)
				return false;
		}
		return isConvertibleTo(other, explicit);
	}

	function tostr(varname: string = ""): string {
		if (flags & CTYPEREF_FLAG_RESTRICT)
			varname = f"restrict {varname}";
		if (flags & CTYPEREF_FLAG_VOLATILE)
			varname = f"volatile {varname}";
		if (flags & CTYPEREF_FLAG_CONST)
			varname = f"const {varname}";
		if (flags & CTYPEREF_FLAG_NODEREF)
			varname = f"__attribute__((noderef)) {varname}";
		local attributeValues: {string...} = [];
		if (flags & CTYPEREF_FLAG_NODEREF)
			attributeValues.append("noderef");
		if (attrib !is none) {
			local temp = attrib.nothrow;
			if (temp !is none)
				attributeValues.append(f"nothrow({temp})");
			local temp = attrib.throws;
			if (temp) {
				local throwsCodes: {string...} = (
					for (local throwsId: temp)
						{ -1 : "*", 0 : "..." }.get(throwsId, throwsId.hex())
				);
				attributeValues.append(f"throws({", ".join(throwsCodes.sorted())})");
			}
			local temp = attrib.tag;
			if (temp)
				attributeValues.append(f"tag({repr temp})");
			local temp = attrib.requireCallerTag;
			if (temp)
				attributeValues.append(f"require_caller_tag({repr temp})");
			local temp = attrib.aligned;
			if (temp !is none)
				attributeValues.append(f"aligned({temp})");
		}
		if (attributeValues)
			varname = f"__attribute__(({", ".join(attributeValues)})) {varname}";
		return typ.tostr(varname);
	}

	@@Used to implement the `__builtin_has_attribute' function
	@@Note however that @this @CTypeRef is allowed to have *more* attributes!
	function hasAllAttributesFrom(other: CTypeRef): bool {
		if ((flags & other.flags) != other.flags)
			return false;
		if (attrib is none && other.attrib is none) {
			/* OK: no custom attributes anywhere */
		} else {
			if (!requireAttrib.hasAllAttributesFrom(other.requireAttrib))
				return false;
		}
		return true;
	}
}

function commonTypeRefFlags(a: int, b: int): int {
	return ((a | b) & ~CTYPEREF_FLAG_FORCE) |
	       ((a & b) & (CTYPEREF_FLAG_FORCE));
}

function cTypeRefWithCommonAttrib(self: CTypeRef, other: CTypeRef): CTypeRef {
	if (self.flags == other.flags && IDENTICAL(self.attrib, other.attrib))
		return self;
	local result = CTypeRef(typ: self.typ, flags: commonTypeRefFlags(self.flags, other.flags));
	if (self.attrib is none) {
		result.attrib = copy other.attrib;
	} else if (other.attrib is none) {
		result.attrib = copy self.attrib;
	} else {
		result.attrib = copy self.attrib;
		result.attrib.importFrom(other.attrib);
	}
	return result;
}



global C_NUMERIC;
class CCoreType: CType {
	this = default;
	public member name: string;
	public member sizeof: int;
	public member alignof: int;
	public operator hash(): int -> Object.id(this);
	public operator == (other: CCoreType): bool -> this === other;
	public operator != (other: CCoreType): bool -> this !== other;

	function tostr(varname: string = ""): string {
		return varname ? f"{name} {varname}" : name;
	}
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return this in C_NUMERIC && other in C_NUMERIC;
	}

	// public  function  peek(checker:  Checker, data:  Bytes,  offset: int):  int  | float;
	// public function poke(checker: Checker, data: Bytes, offset: int, value: int | float);
	// public function bytes(checker: Checker, value: int | float): Bytes;
}

global CPointerType;
global C_INT;
global C_LONG;
global C_LLONG;
global C_UNSIGNED;

final class CCoreIntType: CCoreType {
	public member signed: bool;
	public member mask: int;
	this(name: string, sizeof: int, alignof: int, signed: bool)
		: super(name, sizeof, alignof)
	{
		this.signed = signed;
		this.mask = (1 << (sizeof * 8)) - 1;
	}
	operator repr(): string ->
			f"CCoreIntType(name: {repr this.name}, "
			f"sizeof: {repr this.sizeof}, "
			f"alignof: {repr this.alignof}, "
			f"signed: {repr signed})";
	public function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return (other in C_NUMERIC) ||
		       (other is CPointerType);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		local intVal: int = peek(checker, data, offset);
		local suffix: string = "";
		if (this in C_LLONG) {
			suffix = this in C_UNSIGNED ? "ull" : "ll";
		} else if (this in C_LONG) {
			suffix = this in C_UNSIGNED ? "ul" : "l";
		}
		return f"{intVal}{suffix}";
	}
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + this.sizeof], checker.TARGET_ENDIAN, signed);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + this.sizeof] = (value & mask).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return (value & mask).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
}

final class CCoreBoolType: CCoreType {
	this = super;
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return str !!peek(checker, data, offset);
	}
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + this.sizeof]) ? 1 : 0;
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + this.sizeof] = (value ? 1 : 0).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return (value ? 1 : 0).tobytes(this.sizeof, checker.TARGET_ENDIAN, false);
	}
}

final class CCoreNullptrType: CCoreType {
	this = super;
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return (other is CPointerType) ||
		       (other is CCoreNullptrType) ||
		       (explicit && (other in C_NUMERIC));
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return "nullptr";
	}
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return 0;
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + this.sizeof] = Bytes(this.sizeof);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return Bytes(this.sizeof);
	}
}

final class CCoreVoidType: CCoreType {
	this(): super("void", 0, 1) {}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return "(void)0";
	}
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return other is CCoreVoidType;
	}
}

global final CTYPES_FLOAT_TYPES: {int: ctypes.StructuredType} = {
	ctypes.float.sizeof : ctypes.float,
	ctypes.double.sizeof : ctypes.double,
	ctypes.ldouble.sizeof : ctypes.ldouble,
};

function ctypesGetFloatTypeBySize(sizeof: int): ctypes.StructuredType {
	for (;;) {
		local result: ctypes.StructuredType | none;
		result = CTYPES_FLOAT_TYPES.get(sizeof);
		if (result !is none)
			return result;
		--sizeof;
		if (sizeof <= 0)
			throw Error("No floating point type known for this size");
	}
}

global final FLOAT_TYPES_SUFFIX: {Type: string};
final class CCoreFloatType: CCoreType {
	public member ctypesType: ctypes.StructuredType;
	this(name: string, sizeof: int, alignof: int)
		: super(name, sizeof, alignof)
	{
		ctypesType = ctypesGetFloatTypeBySize(sizeof);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		return f"{ctypesType.frombytes(data, offset)}{FLOAT_TYPES_SUFFIX[type this]}";
	}
	public function peek(checker: Checker, data: Bytes, offset: int): float {
		return (float)ctypesType.frombytes(data, offset);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: float) {
		ctypesType.tobytes((ctypesType)value, data, offset);
	}
	public function bytes(checker: Checker, value: float): Bytes {
		return ctypesType.tobytes((ctypesType)value);
	}
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		return other in C_NUMERIC;
	}
}


global final C_void = CCoreVoidType();
global final C_bool = CCoreBoolType("bool", 1, 1);
global final C_char = CCoreIntType("char", 1, 1, true);
global final C_schar = CCoreIntType("signed char", 1, 1, true);
global final C_uchar = CCoreIntType("unsigned char", 1, 1, false);
global final C_short = CCoreIntType("short", 2, 2, true);
global final C_ushort = CCoreIntType("unsigned short", 2, 2, false);
global final C_int = CCoreIntType("int", 4, 4, true);
global final C_uint = CCoreIntType("unsigned int", 4, 4, false);
global final C_long32 = CCoreIntType("long", 4, 4, true);
global final C_long64 = CCoreIntType("long", 8, 8, true);
global final C_ulong32 = CCoreIntType("unsigned long", 4, 4, false);
global final C_ulong64 = CCoreIntType("unsigned long", 8, 8, false);
global final C_llong_align4 = CCoreIntType("long long", 8, 4, true);
global final C_llong_align8 = CCoreIntType("long long", 8, 8, true);
global final C_ullong_align4 = CCoreIntType("unsigned long long", 8, 4, false);
global final C_ullong_align8 = CCoreIntType("unsigned long long", 8, 8, false);
global final C_int128_t_align4 = CCoreIntType("__int128", 16, 4, true);
global final C_int128_t_align8 = CCoreIntType("__int128", 16, 8, true);
global final C_uint128_t_align4 = CCoreIntType("unsigned __int128", 16, 4, false);
global final C_uint128_t_align8 = CCoreIntType("unsigned __int128", 16, 8, false);
global final C_wchar_t = CCoreIntType("wchar_t", 4, 4, false);
global final C_char8_t = CCoreIntType("char8_t", 1, 1, false);
global final C_char16_t = CCoreIntType("char16_t", 2, 2, false);
global final C_char32_t = CCoreIntType("char32_t", 4, 4, false);
global final C_float = CCoreFloatType("float", 4, 4);
global final C_double = CCoreFloatType("double", 8, 8);
global final C_ldouble_12 = CCoreFloatType("long double", 12, 8);
global final C_ldouble_16 = CCoreFloatType("long double", 16, 16);
global final C_nullptr_t_32 = CCoreNullptrType("nullptr_t", 4, 4);
global final C_nullptr_t_64 = CCoreNullptrType("nullptr_t", 8, 8);

global final FLOAT_TYPES_SUFFIX: {Type: string} = UniqueDict.Frozen({
	C_float : "F",
	C_double : "",
	C_ldouble_12 : "L",
	C_ldouble_16 : "L",
});


global final C_PROMOTE: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_char8_t,
	C_char16_t,
});
global final C_NUMERIC: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_int,
	C_uint,
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
	C_int128_t_align4,
	C_int128_t_align8,
	C_uint128_t_align4,
	C_uint128_t_align8,
	C_wchar_t,
	C_char8_t,
	C_char16_t,
	C_char32_t,
	C_float,
	C_double,
	C_ldouble_12,
	C_ldouble_16,
});

global final C_BOOLEAN: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
});

global final C_NULLPTR: {CCoreType...} = UniqueSet.Frozen({
	C_nullptr_t_32,
	C_nullptr_t_64,
});

global final C_INT: {CCoreType...} = UniqueSet.Frozen({
	C_int,
	C_uint,
});

global final C_LONG: {CCoreType...} = UniqueSet.Frozen({
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
});

global final C_LLONG: {CCoreType...} = UniqueSet.Frozen({
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
});

global final C_INTEGER: {CCoreType...} = UniqueSet.Frozen({
	C_bool,
	C_char,
	C_schar,
	C_uchar,
	C_short,
	C_ushort,
	C_int,
	C_uint,
	C_long32,
	C_long64,
	C_ulong32,
	C_ulong64,
	C_llong_align4,
	C_llong_align8,
	C_ullong_align4,
	C_ullong_align8,
	C_int128_t_align4,
	C_int128_t_align8,
	C_uint128_t_align4,
	C_uint128_t_align8,
	C_wchar_t,
	C_char8_t,
	C_char16_t,
	C_char32_t,
});

global final C_FLOATING: {CCoreType...} = UniqueSet.Frozen({
	C_float,
	C_double,
	C_ldouble_12,
	C_ldouble_16,
});

global final C_SIGNED: {CCoreType: CCoreType} = UniqueDict.Frozen({
	C_char:             C_schar,
	C_uchar:            C_schar,
	C_ushort:           C_short,
	C_uint:             C_int,
	C_ulong32:          C_long32,
	C_ulong64:          C_long64,
	C_ullong_align4:    C_llong_align4,
	C_ullong_align8:    C_llong_align8,
	C_uint128_t_align4: C_int128_t_align4,
	C_uint128_t_align8: C_int128_t_align8,
});
global final C_UNSIGNED: {CCoreType: CCoreType} = UniqueDict.Frozen({
	C_char:            C_uchar,
	C_schar:           C_uchar,
	C_short:           C_ushort,
	C_int:             C_uint,
	C_long32:          C_ulong32,
	C_long64:          C_ulong64,
	C_llong_align4:    C_ullong_align4,
	C_llong_align8:    C_ullong_align8,
	C_int128_t_align4: C_uint128_t_align4,
	C_int128_t_align8: C_uint128_t_align8,
});

class CPointerType: CType {
	this = default;
	public member base: CTypeRef;
	function tostr(varname: string = ""): string {
		return base.tostr("*" + varname);
	}
	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		local intVal: int = this.peek(checker, data, offset);
		return intVal ? f"({this}){intVal.hex()}ul" : "0";
	}
	public operator hash(): int -> hash(type(this), base);
	public operator == (other: CPointerType): bool -> type(this) === type(other) && base == other.base;
	public operator != (other: CPointerType): bool -> type(this) !== type(other) || base != other.base;
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other !is CPointerType)
			return false;
		if (explicit)
			return true;
		return base.isConvertibleToWithFlags(other.base, explicit);
	}
}

final class CPointerType32: CPointerType {
	this = super;
	public property sizeof: int = { get() -> 4; };
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + 4], checker.TARGET_ENDIAN, false);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + 4] = value.tobytes(4, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return value.tobytes(4, checker.TARGET_ENDIAN, false);
	}
}

final class CPointerType64: CPointerType {
	this = super;
	public property sizeof: int = { get() -> 8; };
	public function peek(checker: Checker, data: Bytes, offset: int): int {
		return int.frombytes(data[offset:offset + 8], checker.TARGET_ENDIAN, false);
	}
	public function poke(checker: Checker, data: Bytes, offset: int, value: int) {
		data[offset:offset + 8] = value.tobytes(8, checker.TARGET_ENDIAN, false);
	}
	public function bytes(checker: Checker, value: int): Bytes {
		return value.tobytes(8, checker.TARGET_ENDIAN, false);
	}
}

final class CStructType: CType {
	this = default;
	public member name: string;
	public member base: CStructType | none = none;
	public member fields: {string: (CTypeRef, int)} = Dict();
	public member fieldsByDeclarationOrder: {(CTypeRef, string)...} = [];

	public operator hash(): int -> Object.id(this);
	public operator == (other: CStructType) -> this === other;
	public operator != (other: CStructType) -> this !== other;

	public function dumpValue(checker: Checker, data: Bytes, offset: int, indent: int = -1): string {
		local writer = File.Writer();
		writer << "{";
		local prefix: string = "";
		local nextIndent: int = indent;
		if (indent >= 0) {
			writer << "\n";
			prefix = "\t" * indent;
			++nextIndent;
		}
		local isFirst = true;
		if (base !is none) {
			writer << prefix << "[" << base << "]: ";
			base.dumpValue(checker, data, offset, nextIndent);
			isFirst = false;
		}
		for (local fieldType, fieldName: fieldsByDeclarationOrder) {
			if (!isFirst) {
				writer << ",";
				if (indent >= 0)
					writer << "\n";
			}
			isFirst = false;
			writer << prefix;
			local fieldOffset: int;
			if (fieldName) {
				fieldOffset = fields[fieldName].last;
				writer << fieldName << ": ";
			} else {
				fieldOffset = 0;
				local innerStruct = fieldType.typ;
				if (innerStruct is CStructType) {
					local firstFieldName: string = innerStruct.fieldsByDeclarationOrder.first.last;
					fieldOffset = innerStruct.fields[firstFieldName].last;
				}
			}
			writer << fieldType.dumpValue(checker, data, offset + fieldOffset, nextIndent);
		}
		writer << "}";
		return writer.string;
	}

	public function isConvertibleTo(other: CType, explicit: bool = false): bool {
		local iter: CStructType | none = this;
		do {
			if (other === iter)
				return true;
			iter = iter.base;
		} while (iter !is none);
		return false;
	}

	public property structRepr: string = {
		get(): string {
			if (name)
				return f"struct {name}";
			local result = File.Writer();
			result << "struct {";
			for (local fieldType, fieldName: fieldsByDeclarationOrder)
				result << " " << fieldType.unwindWeakRef.tostr(fieldName) << ";";
			result << " }";
			return result.string;
		}
	}

	public function tostr(varname: string = ""): string {
		return varname ? f"{structRepr} {varname}" : structRepr;
	}

	public function getField(name: string): (CTypeRef, int) | none {
		local result = fields.get(name);
		if (result is none && base !is none)
			result = base.getField(name);
		if (result !is none)
			result = (result.first.unwindWeakRef, result.last);
		return result;
	}

	public property foreachField: {(string, CTypeRef, int)...} = {
		get(): {(string, CTypeRef, int)...} {
			if (base !is none)
				yield base.foreachField...;
			for (local name, typAndOffset: fields) {
				local typ, offset = typAndOffset...;
				yield (name, typ.unwindWeakRef, offset);
			}
		}
	}

	public function fieldByOffset(offset: int): (string, int) | none {
		local result: (string, int) | none = none;
		for (local fieldName, none, fieldOffset: foreachField) {
			if (fieldOffset <= offset) {
				local subOffset = offset - fieldOffset;
				if (result is none || subOffset < result.last)
					result = (fieldName, subOffset);
				if (subOffset == 0)
					break;
			}
		}
		return none;
	}

	private member _sizeof: int;
	public property sizeof: int = {
		get() {
			if (_sizeof !is bound) {
				local result = 0;
				for (local none, fieldType, fieldOffset: foreachField) {
					local offsetAfter = fieldOffset + fieldType.typ.sizeof;
					if (result < offsetAfter)
						result = offsetAfter;
				}
				_sizeof = result;
			}
			return _sizeof;
		}
	}

	public member _alignof: int; /* Must be public! */
	public property alignof: int = {
		get() {
			if (_alignof !is bound) {
				local result = 1;
				for (local none, fieldType, none: foreachField) {
					local temp = fieldType.typ.alignof;
					if (result < temp)
						result = temp;
				}
				_alignof = result;
			}
			return _alignof;
		}
	}
}

final class CEnumType: CType {
	this = default;
	public member name: string;
	public member base: CType = C_int;
	public property sizeof: int = { get(): int -> base.sizeof; };
	public property alignof: int = { get(): int -> base.alignof; };
	public operator hash(): int -> Object.id(this);
	public operator == (other: CStructType) -> this === other;
	public operator != (other: CStructType) -> this !== other;
	function isConvertibleTo(other: CType, explicit: bool = false): bool {
#if 1
		return base.isConvertibleTo(other, explicit);
#else
		if (explicit)
			return base.isConvertibleTo(other, explicit);
		return this === other;
#endif
	}
	function tostr(varname: string = ""): string {
		return varname ? f"enum {name} {varname}" : f"enum {name}";
	}
}

final class CFunctionType: CType {
	this = default;
	public member returnType: CType;
	public member args: {(CTypeRef, string)...} = [];
	@@Defaults for the last N arguments of the function
	public member defaults: {Bytes...} = [];
	public member isVarArgs: bool = false;
	public property sizeof: int = { get(): int -> 0; };
	public property alignof: int = { get(): int -> 1; };

	public operator hash(): int -> hash(returnType, isVarArgs, args.each.first);
	public operator == (other: CFunctionType) ->
		other is CFunctionType &&
		IDENTICAL(returnType, other.returnType) &&
		isVarArgs == other.isVarArgs &&
		(args.each.first as Sequence) == other.args.each.first;
	public operator != (other: CFunctionType) ->
		other !is CFunctionType ||
		!IDENTICAL(returnType, other.returnType) ||
		isVarArgs != other.isVarArgs ||
		(args.each.first as Sequence) != other.args.each.first;

	function isConvertibleTo(other: CType, explicit: bool = false): bool {
		if (other !is CFunctionType)
			return false;
		if (explicit)
			return true;
		if (isVarArgs != other.isVarArgs)
			return false;
		if (#args != #other.args)
			return false;
		for (local myArg, otArg: util.zip(args, other.args)) {
			if (!myArg.first.isConvertibleTo(otArg.first))
				return false;
		}
		return returnType.isConvertibleTo(other.returnType);
	}

	function tostr(varname: string = ""): string {
		if (!varname.replace(":", "").issymbol())
			varname = f"({varname})";
		if (args) {
			varname = f"{varname}({
				", ".join(for (local typ, name: args) typ.tostr(name))
			})";
		} else {
			varname += "(void)";
		}
		return returnType.tostr(varname);
	}

#define ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE      0 /* isConvertibleTo */
#define ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE_STDC 1 /* isConvertibleTo (but `char **' is not convertible to `char const **') */
#define ACCEPTS_CONFORMANCE_LEVEL_EXACT            2 /* Do types match exactly? */
#define ACCEPTS_CONFORMANCE_LEVEL_COUNT            3
	function acceptsArgumentTypes(types: {CType...},
	                              conformanceLevel: int = ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE): bool {
		local myTypes = args;
		if (#types != #myTypes) {
			if (#types > #myTypes) {
				if (!isVarArgs)
					return false;
				types = types[:#myTypes];
			} else {
				local myMinArgc: int = #myTypes - #defaults;
				if (#types < myMinArgc)
					return false;
				myTypes = myTypes[:#types];
			}
		}
		assert #types == #myTypes;
		/*print("acceptsArgumentTypes([", ", ".join(
			for (local typ, nam: myTypes) typ.tostr(nam)
		), "], [", ", ".join(types), "]) [conformanceLevel: ", conformanceLevel, "]");*/
		myTypes = myTypes.each.first.typ; /* {CType...} */
		for (local myTyp, rqTyp: util.zip(myTypes, types)) {
			switch (conformanceLevel) {
			case ACCEPTS_CONFORMANCE_LEVEL_EXACT:
				if (!IDENTICAL(myTyp, rqTyp))
					return false;
				break;
			case ACCEPTS_CONFORMANCE_LEVEL_CONVERTIBLE_STDC: {
				if (rqTyp is CPointerType && myTyp is CPointerType) {
					local rqTypBase: CType = rqTyp.base.typ;
					local myTypBase: CType = myTyp.base.typ;
					if (!IDENTICAL(rqTypBase, myTypBase))
						return false;
					local rqTypCV = rqTyp.base.flags & CTYPEREF_FLAG_CV;
					local myTypCV = myTyp.base.flags & CTYPEREF_FLAG_CV;
					if ((rqTypCV & myTypCV) != rqTypCV)
						return false;
				} else {
					if (!rqTyp.isConvertibleTo(myTyp))
						return false;
				}
			}	break;
			default:
				if (!rqTyp.isConvertibleTo(myTyp))
					return false;
				break;
			}
		}
		return true;
	}
}

final class CArrayType: CType {
	this = default;
	public member base: CType;
	@@Set to @none for flexible arrays
	public member dim: int | none;
	public member stride: int;
	public property sizeof: int = { get(): int -> dim is none ? 0 : base.sizeof * dim; };
	public property alignof: int = { get(): int -> base.alignof; };
	function tostr(varname: string = ""): string {
		if (varname.startswith("*") || " " in varname)
			varname = f"({varname})";
		return base.tostr(f"{varname}[{dim is none ? "" : dim}]");
	}

	public operator hash(): int -> hash(base, dim, stride);
	public operator == (other: CArrayType) ->
		other is CArrayType ||
		IDENTICAL(base, other.base) &&
		IDENTICAL(dim, other.dim) &&
		stride == other.stride;
	public operator != (other: CFunctionType) ->
		other !is CArrayType ||
		!IDENTICAL(base, other.base) ||
		!IDENTICAL(dim, other.dim) ||
		stride != other.stride;

	function indexByOffset(offset: int): (int, int) | none {
		local stride = base.alignof;
		if (stride <= 0)
			return none;
		local index, subOffset = offset.divmod(stride)...;
		if (index < 0 || (dim !is none && index >= dim))
			return none;
		return (index, subOffset);
	}

}


class CSymbol {
	this = default;
	@@Name of the symbol
	public member name: string;
	@@Declaration location `filename, line, column`
	public member decl: (string, int, int);
	@@Type of the symbol (@none for @COverloadedFunctionSymbol)
	public member typeref: CTypeRef | none;
	@@Constant value of the symbol, or unbound if never assigned, or @none if unknown
	public member val: Bytes | none;

	operator str(): string -> str typeref.tostr(name);
	public property valOrNone: Bytes | none = {
		get(): Bytes | none {
			try {
				return val;
			} catch (UnboundAttribute) {
				return none;
			}
		}
	}
}

global CSymbolTemplate;

@@Sub-class for overloaded function-like symbols (needed for overloads)
@@NOTE: The primary symbol element should not be used, and its fields are unbound!
final class COverloadedFunctionSymbol: CSymbol {
	this = default;
	@@The overloads of this function
	public member overloads: {CSymbol | CSymbolTemplate...} = [];

	@@Get or create an overload for the given @typeref c-function-type
	function getOrCreateOverload(checker: Checker, typeref: CTypeRef): CSymbol {
		for (local overload: overloads) {
			if (overload is CSymbolTemplate)
				continue;
			if (overload.typeref.redeclarationEquals(typeref)) {
				overload.typeref.redeclarationImport(checker, typeref);
				return overload;
			}
		}
		local result = CSymbol(this.name, this.decl, typeref);
		overloads.append(result);
		return result;
	}

	function getOrCreateTemplateOverload(typeInit: Bytes): CSymbolTemplate {
		for (local overload: overloads) {
			if (overload !is CSymbolTemplate)
				continue;
			if (overload.typeInit == typeInit)
				return overload;
		}
		local result = CSymbolTemplate();
		overloads.append(result);
		return result;
	}

	function getOverloadsForTypes(checker: Checker, argTypes: {CType...}): {CSymbol...} {
		local result: {CSymbol...} = [];
		for (local overload: overloads) {
			if (overload is CSymbolTemplate) {
				/* TODO: Instantiate template */
			} else {
				local symType: CType = overload.typeref.typ;
				if (symType is CFunctionType && symType.acceptsArgumentTypes(argTypes))
					result.append(overload);
			}
		}
		if (#result > 1) {
			for (local level: [1:ACCEPTS_CONFORMANCE_LEVEL_COUNT]) {
				local newResult: {CSymbol...} = [];
				for (local overload: result) {
					local symType: CType = overload.typeref.typ;
					if (symType.acceptsArgumentTypes(argTypes, level))
						newResult.append(overload);
				}
				if (newResult) {
					result = newResult;
					if (#result == 1)
						break;
				} else {
					break;
				}
			}
		}
		return result;
	}

}


#define TemplateParamValue (CTypeRef | Bytes)
class TemplateParam {
	this = default;
	@@Name of this template parameter
	@@ - `FOO` in `template<class FOO = int>`
	@@ - `N` in `template<size_t N = 4>`
	public member name: string;
	@@Declaration location of @name
	public member decl: (string, int, int);
	@@Parameter type, or @none if it's a type-parameter
	public member typeref: CTypeRef | none;
	@@Default initializer for this parameter
	@@ - `int` in `template<class FOO = int>`
	@@ - `4` in `template<size_t N = 4>`
	public member defaultInit: Bytes | none = none;
	@@Declaration location of @defaultInit
	public member defaultDecl: (string, int, int) | none = none;
	operator str(): string {
		if (defaultInit is none) {
			if (typeref is none)
				return f"class {name}";
			return typeref.tostr(name);
		} else {
			if (typeref is none)
				return f"class {name} = {defaultInit}";
			return f"{typeref.tostr(name)} = {defaultInit}";
		}
	}
}

class CTypeRefTemplate {
	this = default;
	@@Name of the typedef/symbol
	@@ - `Name` in `template<class T> using Name = T;`
	@@ - `bar` in `template<class T> T bar = (T)0;`
	@@ - `foo` in `template<class T> struct foo { T x; };`
	@@ - `foo` in `template<class T> void foo(T x) { callMe(); }`
	public member name: string;
	@@Declaration location of @name
	public member decl: (string, int, int);
	@@Template parameters
	public member params: {TemplateParam...};
	@@Raw source-code that represents the initializer for the template type
	@@ - `T` in `template<class T> using Name = T;`
	@@ - `struct foo { T x; }` in `template<class T> struct foo { T x; };`
	@@For @CSymbolTemplate:
	@@ - `T bar` in `template<class T> T bar = (T)0;`
	@@ - `void foo(T x)` in `template<class T> void foo(T x) { callMe(); }`
	@@NOTE: Unbound in case of an uninitialized struct/union/class template
	public member typeInit: Bytes;
	@@Declaration location of @typeInit
	public member typeDecl: (string, int, int);
	@@Instantiated instances of this template.
	@@ - For @CTypeRefTemplate, elements are @CTypeRef
	@@ - For @CSymbolTemplate, elements are @CSymbol
	public member instances: {{TemplateParamValue...} : CTypeRef | CSymbol} = Dict();

	function instantiationRepr(checker: Checker, args: {TemplateParamValue...}): string {
		local writer = File.Writer();
		writer << name << "<";
		local isFirst = true;
		for (local param, arg: util.zip(params, args)) {
			if (!isFirst)
				writer << ", ";
			isFirst = false;
			if (arg is CTypeRef) {
				writer << arg;
			} else {
				writer << param.typeref.typ.peek(checker, arg);
			}
		}
		writer << ">";
		return writer.string;
	}

	operator str(): string {
		if (typeInit is bound)
			return f"template<{", ".join(params)}> {typeInit.replace("\n", " ")}";
		return f"template<{", ".join(params)}> <uninitialized> {name}";
	}
}

class CSymbolTemplate: CTypeRefTemplate {
	@@Raw source-code that represents the initializer for this symbol template
	@@ - `(T)0` in `template<class T> T bar = (T)0;`
	@@ - `{ callMe(); }` in `template<class T> void foo(T x) { callMe(); }`
	@@NOTE: Unbound in case of an uninitialized symbol template
	public member valInit: Bytes;
	@@Declaration location of @valInit
	public member valDecl: (string, int, int);
	@@Set to @true if this is a function-template (i.e. *no* `=` exists before @valInit)
	public member isFunction: bool;
}


global CEnumClassType;
class CNamespace {
	this = default;
	public final member name: string;
	public final member symbols: {string: CSymbol | CSymbolTemplate} | none = none;
	public final member typedefs: {string: CTypeRef | CTypeRefTemplate} | none = none;
	public final member namespaces: {string: CNamespace} | none = none;
	public final member structSymbols: {string: CStructType} | none = none;
	public final member unionSymbols: {string: CStructType} | none = none;
	public final member enumSymbols: {string: CEnumType} | none = none;
	public final member importedNamespaces: {CNamespace...} | none = none;

	@@Only here so we don't need special handling when used as a @CScope
	public property symbolValues = { get() -> none; };

	@@@param tab: One of:
	@@            - @"symbols": @CSymbol or @CSymbolTemplate
	@@            - @"typedefs": @CTypeRef or @CTypeRefTemplate
	@@            - @"namespaces": @CNamespace
	@@            - @"structSymbols": @CStructType
	@@            - @"unionSymbols": @CStructType
	@@            - @"enumSymbols": @CEnumType
	public final function lookup(tab: string, name: string): Object | none {
		local result = this.operator . (tab).get(name);
		if (result !is none)
			return result;
		for (local importedNamespace: importedNamespaces) {
			result = importedNamespace.lookup(tab, name);
			if (result !is none)
				return result;
		}
		return none;
	}

	public final function defineTemplateParamValue(param: TemplateParam, value: TemplateParamValue) {
		local tabName: string = "typedefs";
		if (value is Bytes) {
			tabName = "symbols";
			assert param.typeref !is none;
			value = CSymbol(param.name, param.decl, param.typeref, value);
		}
		local tab: {string: Object} | none = this.operator . (tabName);
		if (tab is none)
			this.operator . (tabName) = tab = Dict();
		tab[param.name] = value;
	}

	public final function childNamespace(name: string): CNamespace {
		local result = lookup("namespaces", name);
		if (result is none) {
			result = CNamespace(name: name);
			if (namespaces is none)
				namespaces = Dict();
			namespaces[name] = result;
		}
		return result;
	}
}


final class CEnumClassType: CNamespace, CType {
	this = super;
	public member name: string;
	public member base: CTypeRef = C_int;
	public property sizeof: int = { get(): int -> base.sizeof; };
	public property alignof: int = { get(): int -> base.alignof; };
	function tostr(varname: string = ""): string {
		return varname ? f"enum class {this.name} {varname}" : f"enum class {this.name}";
	}
}
