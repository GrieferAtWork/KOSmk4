/* Copyright (c) 2019-2025 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2025 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from deemon;
import * from .ctype;
import UniqueDict from collections;
#define Checker Object

#define IDENTICAL(a, b) (type(a) === type(b) && ((a) == (b)))

global final OPERATORS1_BY_NAME: {string: Callable} = {
	"+"  : operator pos,
	"-"  : operator neg,
	"~"  : operator ~,
};
global final OPERATORS2_BY_NAME: {string: Callable} = {
	"+"  : operator add,
	"-"  : operator sub,
	"*"  : operator *,
	"/"  : operator /,  /* TODO: This is floordiv, but C needs truncdiv! */
	"%"  : operator %,  /* TODO: This is floormod, but C needs truncmod! */
	"<<" : operator <<,
	">>" : operator >>,
	"&"  : operator &,
	"|"  : operator |,
	"^"  : operator ^,
	"==" : operator ==,
	"!=" : operator !=,
	"<"  : operator <,
	"<=" : operator <=,
	">"  : operator >,
	">=" : operator >=,
};

global final FLIPPED_COMPARE_OPERATORS: {string: string} = {
	"<"  : ">",
	">"  : "<",
	"<=" : ">=",
	">=" : "<=",
};


#define CVALUE_RVALUE      1
#define CVALUE_AVALUE      2
#define CVALUE_ISLVALUE(x) (!((x) & CVALUE_RVALUE)) /* L-Value */
#define CVALUE_ISRVALUE(x) ((x) & CVALUE_RVALUE)    /* R-Value */
#define CVALUE_ISAVALUE(x) (((x) & (CVALUE_RVALUE | CVALUE_AVALUE)) == (CVALUE_RVALUE | CVALUE_AVALUE))
global final CVALUE_LVOID   = 0x00; /* L-Value: *(T *)??? Value */
global final CVALUE_RVOID   = 0x01; /* R-Value: *(T *)??? Value */
global final CVALUE_AVOID   = 0x03; /* R-Value:    (T)??? Value */
global final CVALUE_LCONST  = 0x04; /* L-Value: *(T *)&data[offset:offset+...] */
global final CVALUE_RCONST  = 0x05; /* R-Value: *(T *)&data[offset:offset+...] */
global final CVALUE_ACONST  = 0x07; /* R-Value:    (T)&data[offset:offset+...] */
global final CVALUE_LSYMBOL = 0x08; /* L-Value: *(T *)&CSymbol.val[offset:offset+...] */
global final CVALUE_RSYMBOL = 0x09; /* R-Value: *(T *)&CSymbol.val[offset:offset+...] */
global final CVALUE_ASYMBOL = 0x0b; /* R-Value:    (T)&CSymbol.val[offset:offset+...] */
global final CVALUE_LADDR   = 0x0c; /* L-Value: *(T *)offset */
global final CVALUE_RADDR   = 0x0d; /* R-Value: *(T *)offset */

#if 0
global final CVALUE_KINDNAME: {int: string} = {
	CVALUE_LVOID   : "LVOID",
	CVALUE_RVOID   : "RVOID",
	CVALUE_AVOID   : "AVOID",
	CVALUE_LCONST  : "LCONST",
	CVALUE_RCONST  : "RCONST",
	CVALUE_ACONST  : "ACONST",
	CVALUE_LSYMBOL : "LSYMBOL",
	CVALUE_RSYMBOL : "RSYMBOL",
	CVALUE_ASYMBOL : "ASYMBOL",
	CVALUE_LADDR   : "LADDR",
	CVALUE_RADDR   : "RADDR",
};
#define TRACE() \
	({ \
		print(__LINE__, ":", CVALUE_KINDNAME[kind], ":", typeref),; \
		if (offset is bound) \
			print(":", repr offset),; \
		if (data is bound) \
			print(":", repr data),; \
		print; \
	})
#else
#define TRACE() none
#endif
final class CValue {
	this = default;

	@@Value kind (one of `CVALUE_*`)
	public member kind: int;

	@@Value type
	public member typeref: CTypeRef;

	@@The actual value, or symbol-reference
	public member data: Bytes | CSymbol;

	@@Offset into @data
	public member offset: int;

	operator str(): string {
		switch (kind) {
		case CVALUE_LSYMBOL:
		case CVALUE_RSYMBOL:
			if (offset)
				return f"*({CPointerType(typeref)})((char *)&{data.name} + {offset})";
			return f"*({CPointerType(typeref)})&{data.name}";
		case CVALUE_ASYMBOL:
			if (offset)
				return f"({typeref})((char *)&{data.name} + {offset})";
			return f"({typeref})&{data.name}";
		case CVALUE_LADDR:
		case CVALUE_RADDR:
			return f"*({CPointerType(typeref)}){offset}";
		default:
			break;
		}
		return f"<instance of {typeref}>";
	}

	/* Utility functions */

	@@Check if @this is a compile-time constant value
	public property isConstExpr: bool = {
		get(): bool {
			return kind in [CVALUE_LCONST, CVALUE_RCONST];
		}
	}
	public property isSymbol: bool = {
		get(): bool {
			return kind in [CVALUE_LSYMBOL, CVALUE_RSYMBOL, CVALUE_ASYMBOL];
		}
	}
	public property constExprBytes: Bytes = {
		get(): Bytes {
			assert isConstExpr;
			return data[offset:offset+typeref.typ.sizeof];
		}
	}
	public function constExprValue(checker: Checker): int | float {
		assert isConstExpr;
		return typeref.typ.peek(checker, data, offset);
	}

	public property isConstExprString: bool = {
		get(): bool {
			local typ = typeref.typ;
			return kind == CVALUE_ACONST && typ is CPointerType && typ.base.typ === C_char;
		}
	}

	public property constExprStringBytes: Bytes = {
		get(): Bytes {
			assert isConstExprString;
			local stroff = offset;
			local strend = data.find(0, stroff);
			if (strend < 0)
				strend = #data;
			return data[stroff:strend];
		}
	}

	public property constExprString: string = {
		get(): string {
			return constExprStringBytes.decode("utf-8");
		}
	}

#define MAKE_VOID() (kind &= CVALUE_RVALUE)
	public property inplaceVoid: CValue = {
		get(): CValue {
			MAKE_VOID();
			return this;
		}
	}

	/* Utility API */

	public function rValue(checker: Checker): CValue -> copy(this).inplaceRValue(checker);
	public function inplaceRValue(checker: Object): CValue {
		local typ: CType = typeref.typ;
		if (typ is CArrayType) {
			if (CVALUE_ISRVALUE(kind))
				checker.err(f"Cannot decay r-value array `{typeref}' to pointer");
			local pointerTypeRef: CTypeRef = copy typeref;
			pointerTypeRef.typ = typ.base;
			typ = checker.TARGET_CPointerType(pointerTypeRef);
			typeref = CTypeRef(typ);
			kind |= CVALUE_AVALUE;
			if (kind == (CVALUE_LADDR | CVALUE_AVALUE)) {
				data   = typ.bytes(checker, offset);
				offset = 0;
				kind   = CVALUE_RCONST;
			}
		}
		kind |= CVALUE_RVALUE;
		if (kind == CVALUE_RSYMBOL) {
			/* Check if the symbol has an override */
			local symValue: Bytes | none = checker.getSymbolValue(data);

			/* Check if the symbol has a known, constant value */
			if (symValue is none && (data.typeref.flags & CTYPEREF_FLAG_CONST))
				symValue = data.valOrNone;
			if (symValue !is none) {
				kind = CVALUE_RCONST;
				data = symValue;
			}
		}
		TRACE();
		return this;
	}

	public function cast(checker: Checker, newTypeRef: CTypeRef,
	                     explicit: bool = false, canRetainNothrow: bool = true,
	                     getExtraCannotRetainInfo: Callable | none = none): CValue
		-> copy(this).inplaceCast(checker, newTypeRef, explicit, canRetainNothrow, getExtraCannotRetainInfo);
	public function inplaceCast(checker: Checker, newTypeRef: CTypeRef,
	                            explicit: bool = false, canRetainNothrow: bool = true,
	                            getExtraCannotRetainInfo: Callable | none = none): CValue {
		local oldTyp: CType = typeref.typ;
		local newTyp: CType = newTypeRef.typ;

		/* Special case for C++ L-Value types. */
		if (newTyp is CLValueType) {
			return inplaceRef(checker)
				.inplaceCast(checker, CTypeRef(checker.TARGET_CPointerType(newTyp.base)), explicit)
				.inplaceInd(checker);
		}

		/* Cast between function types isn't allowed (you can only cast function pointers) */
		if (newTyp is CFunctionType)
			goto err_bad_op;

		/* Check for special case: cast to array type:
		 * >> char foo[] = "foobar";
		 * This must happen before r-value conversion since that would result in a `char const *' */
		if (newTyp is CArrayType && oldTyp is CArrayType &&
		    IDENTICAL(oldTyp.base, newTyp.base)) {
			kind |= CVALUE_RVALUE;
			if (kind == CVALUE_RSYMBOL) {
				local symValue: Bytes | none = checker.getSymbolValue(data);
				if (symValue is none && (data.typeref.flags & CTYPEREF_FLAG_CONST))
					symValue = data.valOrNone;
				if (symValue !is none) {
					kind = CVALUE_RCONST;
					data = symValue;
					offset = 0;
				}
			}

			/* Array casts allow you to increase the array length, but not decrease it! */
			if (newTyp.stride != oldTyp.stride) {
				checker.err(f"Cannot cast from `{oldTyp}' to `{newTyp}': stride "
				            f"miss-match ({oldTyp.stride} != {newTyp.stride})");
			}
			if (newTyp.dim is none) {
				if (oldTyp.dim !is none) {
					/* Inherit array dimensions from old type (for flexible array initializers) */
					newTyp = copy newTyp;
					newTyp.dim = oldTyp.dim;
					newTypeRef = copy newTypeRef;
					newTypeRef.typ = newTyp;
				}
			} else if (oldTyp.dim !is none) {
				local oldDim: int = oldTyp.dim;
				local newDim: int = newTyp.dim;
				if (newDim > oldDim) {
					/* Array length increase is OK (but must reflect in compile-time constant) */
					switch (kind) {
					case CVALUE_LCONST:
					case CVALUE_RCONST:
					case CVALUE_ACONST: {
						local minLength = offset + newDim * newTyp.stride;
						if (#data < minLength)
							data = data.resized(minLength);
					}	break;
					default:
						break;
					}
				} else if (newDim < oldDim) {
					/* Array length decrease is an error */
					goto err_bad_op;
				}
			}
			typeref = newTypeRef;
			return this;
		}

		inplaceRValue(checker);
		oldTyp = typeref.typ;

		/* Filter out illegal cast should be allowed. */
		if (!typeref.isConvertibleTo(newTypeRef, explicit)) {
			/* Cast isn't allowed for some reason (figure out why) */
			if (oldTyp is CPointerType && newTyp is CPointerType) {
				if (!explicit) {
					local oldPointerBaseTypeRef: CTypeRef = oldTyp.base;
					local newPointerBaseTypeRef: CTypeRef = newTyp.base;
					if (oldPointerBaseTypeRef.typ.isConvertibleTo(newPointerBaseTypeRef.typ, explicit) ||
					    newPointerBaseTypeRef.typ === C_void ||
					    (oldPointerBaseTypeRef.typ === C_void && !checker.cxx)) {
						/* Pointer-cast where the the base-types are identical is OK,
						 * but warn if the  cast causes const/volatile to  disappear. */
						local oldCV = oldPointerBaseTypeRef.flags & CTYPEREF_FLAG_CV;
						local newCV = newPointerBaseTypeRef.flags & CTYPEREF_FLAG_CV;
						if ((oldCV & newCV) != oldCV) {
							checker.warn("-Wcast",
								f"Implicit cast from `{oldTyp}' to `{newTyp}' "
								f"removes `{' '.join(() -> {
									if (oldCV & CTYPEREF_FLAG_CONST)
										yield 'const';
									if (oldCV & CTYPEREF_FLAG_VOLATILE)
										yield 'volatile';
								}())}'");
						}
					} else {
						checker.warn("-Wcast",
								f"Implicit cast between incompatible pointer "
								f"types from `{oldTyp}' to `{newTyp}'");
					}
				}
			} else if (oldTyp is CPointerType && newTyp in C_NUMERIC) {
				if (!explicit) {
					checker.warn("-Wcast",
						f"Implicit pointer to integer cast from `{oldTyp}' to `{newTyp}'");
				}
			} else if (!explicit && typeref.isConvertibleTo(newTypeRef, true)) {
				checker.warn("-Wcast",
					f"Implicit cast from `{oldTyp}' to `{newTyp}' is only allowed when made explicit");
			} else {
				goto err_bad_op;
			}
		}

		/* If `!(newTypeRef.flags & CTYPEREF_FLAG_FORCE)', then retain nothrow attributes
		 * of  `(newTypeRef.typ as CPointerType).base.attrib' (also: warn if the new type
		 * has no force  attribute, and both  types have nothrow  levels, which are  also
		 * different from each other):
		 * >> #define NTX(n) __attribute__((__nothrow__(n)))
		 * >> #define FORCE  __attribute__((__force__))
		 * >>        void *p = (NTX(0) void *)42;       // p inherits the NTX(0) attribute (but also generates a warning to please annotate `p')
		 * >>        void *p = (FORCE NTX(0) void *)42; // p inherits the NTX(0) attribute
		 * >> NTX(0) void *p = (void *)42;              // OK: p retains the NTX(0) attribute
		 * >> NTX(0) void *p = (NTX(0) void *)42;       // OK: Nothing changes
		 * >> NTX(0) void *p = (NTX(1) void *)42;       // Warning: Multiple nothrow levels (p retains NTX(0))
		 * >> NTX(1) void *p = (NTX(0) void *)42;       // OK: Always allowed to increase nothrow level (p retains NTX(1))
		 * >> NTX(1) void *p = (FORCE NTX(0) void *)42; // OK: p inherits the NTX(0) attribute (but you shouldn't do this)
		 * >> FORCE NTX(1) void *p = (NTX(0) void *)42; // Warning: Multiple nothrow levels (p retains NTX(1))
		 */
		if (newTypeRef.flags & CTYPEREF_FLAG_FORCE) {
			/* Always use `newTypeRef' as-is */
		} else {
			if ((oldTyp is CPointerType) && (newTyp is CPointerType)) {
				local oldPointerBase: CTypeRef = oldTyp.base;
				local newPointerBase: CTypeRef = newTyp.base;
				local oldNothrowLevel: string | none = oldPointerBase.attribNothrow;
				local newNothrowLevel: string | none = newPointerBase.attribNothrow;
				if (newPointerBase.flags & CTYPEREF_FLAG_NODEREF) {
					/* If the target pointer type says that it will never dereference the
					 * pointer, then it won't matter if nothrow levels don't match or any
					 * other problems like that. */
				} else if (newPointerBase.typ is CFunctionType) {
					/* When casting to a function type, things are different. */
					if (oldPointerBase.typ !is CFunctionType) {
						/* Cast  from   non-function-pointer   to   function-pointer.
						 * In this case, warn if the pointer had a nothrow attribute. */
						if (oldNothrowLevel !is none) {
							checker.warn("-Wcast",
								f"annotated pointer of type `{oldTyp}' "
								f"cast to function pointer `{newTyp}'");
						}
					} else {
						/* When casting from one function pointer to another, must
						 * take special care about nothrow and throws annotations:
						 * - A `nothrow' annotation not present in `newNothrowLevel' is OK
						 * - A `nothrow' annotation not present in `oldNothrowLevel' is NOT OK,
						 *   as that would mean casting a throwing function into a pointer that
						 *   is annotated as non-throwing. */
						local functionName: string = "<unnamed>";
						if (isSymbol)
							functionName = data.name;
						if (canRetainNothrow) {
							if (!IDENTICAL(oldNothrowLevel, newNothrowLevel)) {
								if (newNothrowLevel !is none) {
									checker.warn("-Wcast",
										f"Retaining `{getPrettyNothrowLevelName(oldNothrowLevel)}` "
										f"instead of `{getPrettyNothrowLevelName(newNothrowLevel)}`");
								}
								newPointerBase = copy newPointerBase;
								newPointerBase.attribNothrow = oldNothrowLevel;
								newTyp = type(newTyp)(newPointerBase);
								newTypeRef = copy newTypeRef;
								newTypeRef.typ = newTyp;
							}
						} else if (newNothrowLevel !is none) {
							/* The new pointer requires a nothrow annotation. In this  case
							 * we have to ensure that `oldNothrowLevel' (i.e.: the function
							 * that is being cast) has a nothrow level <= `newNothrowLevel' */
							/* Function pointer is (probably) NOTHROW_NCX */
							if (oldNothrowLevel is none) {
								checker.warn("-Wcast",
									f"function pointer cast adds "
									f"`{getPrettyNothrowLevelName(newNothrowLevel)}' "
									f"to un-annotated function `{functionName}'");
							} else if (oldNothrowLevel == "0") {
								/* Always OK! */
							} else if (newNothrowLevel.startswith("*")) {
								/* Always OK! */
							} else if (oldNothrowLevel.startswith("*")) {
								goto warn_function_pointer_cast_changes_nothrow_level;
							} else if (int(oldNothrowLevel) <= int(newNothrowLevel)) {
								/* OK: nothrow level of new type is at least as high as that of old type. */
							} else {
warn_function_pointer_cast_changes_nothrow_level:
								checker.warn("-Wcast",
									f"function pointer cast changes "
									f"`{getPrettyNothrowLevelName(oldNothrowLevel)}' to"
									f"`{getPrettyNothrowLevelName(newNothrowLevel)}' "
									f"of function `{functionName}'");
							}
						} else {
							/* Target pointer is marked as OOB-throwing, so all annotations are OK */
						}

						/* Assert  that the function being casted doesn't
						 * throw more than is accepted by the target type */
						local oldThrows: Set with int = oldPointerBase.attribThrows;
						local newThrows: Set with int = newPointerBase.attribThrows;
						if (canRetainNothrow) {
							/* Have the final type retain all of the original throws
							 * In this case, warn if `newThrows' specifies different
							 * throws than the original type. */
							if (oldThrows != newThrows) {
								if (newThrows) {
									checker.warn("-Wcast",
										f"Retaining `THROWS({', '.join(
											checker.simpleExceptCodeNames(oldThrows))})` "
										f"instead of `THROWS({', '.join(
											checker.simpleExceptCodeNames(newThrows))})`");
								}
								newPointerBase = copy newPointerBase;
								newPointerBase.attribThrows = oldThrows;
								newTyp = type(newTyp)(newPointerBase);
								newTypeRef = copy newTypeRef;
								newTypeRef.typ = newTyp;
							}
						} else if (newThrows >= oldThrows) {
							/* OK: New type accepts at least those exceptions also accepted
							 *     by the original type. */
						} else if (THROWS_ANY !in newThrows) {
							local extraInfo: string = "";
							if (getExtraCannotRetainInfo !is none)
								extraInfo = getExtraCannotRetainInfo();
							checker.warn("-Wthrows",
								f"Cannot retain `THROWS({', '.join(
									checker.simpleExceptCodeNames(oldThrows - newThrows)
								)})' "
								f"in cast to `{newTyp}'{extraInfo}");
						}

						/* Assert that the function is implementing
						 * all tags  required by  the target  type. */
						// TODO

						/* Assert that the function doesn't  require
						 * any caller tags that aren't also required
						 * by the target type. */
						// TODO
					}
				} else if (oldPointerBase.typ is CFunctionType) {
					/* Function pointer -> non-function-pointer
					 * (don't try to retain the function's nothrow attribute) */
				} else if (oldNothrowLevel is none) {
					/* Automatically inherit the new nothrow-level */
				} else if (newPointerBase.flags & CTYPEREF_FLAG_FORCE) {
					/* Force inherit the new type's nothrow level */
				} else {
					if (newNothrowLevel !is none) {
						if (oldNothrowLevel == newNothrowLevel) {
							/* Both pointers have the same nothrow-level -> nothing changes */
						} else if (newNothrowLevel.startswith("*") || oldNothrowLevel.startswith("*")) {
							/* Ignore for automatic nothrow levels */
						} else if (int(newNothrowLevel) > int(oldNothrowLevel)) {
							checker.warn("-Wnothrow",
									f"Cast from `{oldTyp}' to `{newTyp}' results in "
									f"`{getPrettyNothrowLevelName(oldNothrowLevel)}', "
									f"rather than `{getPrettyNothrowLevelName(newNothrowLevel)}'. "
									f"Use `__attribute__((force))' to select which nothrow level "
									f"should be used");
							goto pointer_cast_retain_nothrow;
						} else {
							/* Retain nothrow level */
							goto pointer_cast_retain_nothrow;
						}
					} else {
pointer_cast_retain_nothrow:
						if (!canRetainNothrow) {
							local extraInfo: string = "";
							if (getExtraCannotRetainInfo !is none)
								extraInfo = getExtraCannotRetainInfo();
							checker.warn("-Wnothrow",
									f"Cannot retain `{getPrettyNothrowLevelName(oldNothrowLevel)}' "
									f"in cast to `{newTyp}'{extraInfo}");
						} else {
							newPointerBase = copy newPointerBase;
							newPointerBase.attribNothrow = oldNothrowLevel;
							newTyp = type(newTyp)(newPointerBase);
							newTypeRef = copy newTypeRef;
							newTypeRef.typ = newTyp;
						}
					}
				}
			}
		}
		typeref = newTypeRef;

		/* Perform value transformations based on the cast. */
		switch (kind) {

		case CVALUE_RCONST:
		case CVALUE_RSYMBOL:
			if (newTyp.sizeof > oldTyp.sizeof) {
				if (kind == CVALUE_RCONST) {
					/* Zero-/Sign-extend constant integer */
					data   = newTyp.bytes(checker, oldTyp.peek(checker, data, offset));
					offset = 0;
				} else {
					MAKE_VOID();
				}
			} else {
				if (checker.TARGET_BIG_ENDIAN) {
					offset += oldTyp.sizeof;
					offset -= newTyp.sizeof;
				}
			}
			break;

		case CVALUE_ACONST:
		case CVALUE_ASYMBOL:
			if (newTyp.sizeof < checker.TARGET_SIZEOF_POINTER)
				MAKE_VOID(); /* Pointer masking (treat value as unknown) */
			break;

		default:
			break;
		}
		TRACE();
		return this;
err_bad_op:
		checker.err(f"Bad operation `({newTypeRef}){this}'");
		return this;
	}

	public function field(checker: Checker, fieldName: string): CValue
		-> copy(this).inplaceField(checker, fieldName);
	public function inplaceField(checker: Checker, fieldName: string): CValue {
		local typ: CType = typeref.typ;
		if (typ !is CStructType)
			checker.err(f"Cannot access field `{fieldName}' of non-struct-type `{typ}'");
		local fieldInfo: (CTypeRef, int) | CSymbol | none = typ.getField(fieldName);
		if (fieldInfo is none) {
			checker.err(f"No such field `{fieldName}' in `{typ}'");
		} else if (fieldInfo is CSymbol) {
			/* Special case for c++ struct member functions */
			kind    = CVALUE_LSYMBOL;
			typeref = fieldInfo.typeref;
			data    = fieldInfo;
			offset  = 0;
		} else {
			/* Load the field in question */
			local cv: int = typeref.flags & CTYPEREF_FLAG_CV;
			if (cv) {
				/* const/volatile are inherited in field expressions:
				 * >> struct foo { int x; };
				 * >> struct foo const v = { 0 };
				 * >> typeof(v.x) z; // int const z; */
				typeref = copy fieldInfo.first;
				typeref.flags |= cv;
			} else {
				typeref = fieldInfo.first;
			}
			offset += fieldInfo.last;
		}
		TRACE();
		return this;
	}

	public function promote(checker: Checker): CValue -> copy(this).inplacePromote(checker);
	public function inplacePromote(checker: Checker): CValue {
		local typ: CType = typeref.typ;
		if (typ in C_PROMOTE) {
			return inplaceCast(checker, C_int_typeref, true);
		} else if (typ === C_float) {
			return inplaceCast(checker, C_double_typeref, true);
		} else if (typ is CEnumType) {
			return inplaceCast(checker, CTypeRef(typ.base), true);
		} else {
			return inplaceRValue(checker);
		}
	}

	public function ref(checker: Checker): CValue -> copy(this).inplaceRef(checker);
	public function inplaceRef(checker: Checker): CValue {
		typeref = CTypeRef(checker.TARGET_CPointerType(typeref));
		if (!CVALUE_ISLVALUE(kind))
			checker.err(f"Cannot reference expression: not an l-value");
		switch (kind) {
		case CVALUE_LADDR:
		case CVALUE_RADDR:
			kind   = CVALUE_RCONST;
			data   = offset.tobytes(checker.TARGET_SIZEOF_POINTER, checker.TARGET_ENDIAN, false);
			offset = 0;
			break;
		default:
			kind |= CVALUE_RVALUE | CVALUE_AVALUE;
			break;
		}
		TRACE();
		return this;
	}

	public function ind(checker: Checker): CValue -> copy(this).inplaceInd(checker);
	public function inplaceInd(checker: Checker): CValue {
		inplacePromote(checker); /* To deal with array decay */
		if (typeref.typ !is CPointerType) {
			/* Special case: ignore deref on function types. */
			if (typeref.typ is CFunctionType)
				return this;
			checker.err(f"Cannot dereference non-pointer type `{typeref}'");
		}
		typeref = typeref.typ.base;
		if (CVALUE_ISAVALUE(kind)) {
			kind &= ~(CVALUE_AVALUE | CVALUE_RVALUE);
		} else if (kind == CVALUE_RCONST) {
			/* Special case: dereference compile-time constant address */
			kind   = CVALUE_LADDR;
			offset = int.frombytes(
				data[offset:offset + checker.TARGET_SIZEOF_POINTER],
				checker.TARGET_ENDIAN, false);
			del data;
		} else {
			/* Unknown value */
			kind = CVALUE_LVOID;
		}

		/* Emit warnings about illegal dereference operations. */
		if (!checker.isUnreachable) {
			if (typeref.flags & CTYPEREF_FLAG_NODEREF) {
				checker.warn("-Wnoderef",
					f"Dereference pointer to `{typeref.typ}' "
					f"marked as `__attribute__((noderef))'");
			}
			if (checker.currentFunctionTypeRef !is none) {
				local pointerNoThrow: string | none = typeref.attribNothrow;
				if (pointerNoThrow !is none && !pointerNoThrow.startswith("*")) {
					/* Issue a warning if:
					 * - The current function doesn't have a __attribute__((nothrow(N))) attribute
					 * - The current function has a nothrow level N that is lower than `pointerNoThrow' */
					local pointerNoThrowLevel: int = int(pointerNoThrow);

					/* Access to a pointer with nothrow level > 0 can cause NCX exceptions */
					if (pointerNoThrowLevel > 0)
						checker.currentTryBlockExceptions.insert(THROWS_NCX);

					if (!checker.isInTryBlock) {
						local currentFunctionNothrow: string | none = checker.currentFunctionTypeRef.attribNothrow;
						if (checker.currentTryBlockGreatestNothrowLevel < pointerNoThrowLevel)
							checker.currentTryBlockGreatestNothrowLevel = pointerNoThrowLevel;
						if (currentFunctionNothrow !is none && !currentFunctionNothrow.startswith("*")) {
							local currentFunctionNothrowLevel: int = int(currentFunctionNothrow);
							if (currentFunctionNothrowLevel < pointerNoThrowLevel) {
								checker.warn("-Wnothrow",
									f"Dereference `{getPrettyNothrowLevelName(pointerNoThrowLevel)}'-pointer "
									f"in function `{checker.currentFunctionName}' marked as "
									f"`{getPrettyNothrowLevelName(currentFunctionNothrowLevel)}'");
							}
						}
					}
				}
			}
		}
		TRACE();
		return this;
	}

	public function op1(checker: Checker, op: string): CValue -> copy(this).inplaceOp1(checker, op);
	public function inplaceOp1(checker: Checker, op: string): CValue {
		switch (op) {

		case "&":
			return inplaceRef(checker);

		case "*":
			return inplaceInd(checker);

		case "bool":
			inplacePromote(checker);
			typeref = CTypeRef(C_bool);
			switch (kind) {
			case CVALUE_ACONST:
			case CVALUE_ASYMBOL:
				data = Bytes({ 1 }); /* Pointer-to-data/symbol is always non-NULL */
				break;
			case CVALUE_RCONST:
				data = Bytes({ constExprValue(checker) ? 1 : 0 });
				break;
			default:
				MAKE_VOID();
				break;
			}
			break;

		case "!":
			inplacePromote(checker);
			typeref = CTypeRef(C_bool);
			switch (kind) {
			case CVALUE_ACONST:
			case CVALUE_ASYMBOL:
				data = Bytes({ 0 }); /* Pointer-to-data/symbol is always non-NULL */
				break;
			case CVALUE_RCONST:
				data = Bytes({ constExprValue(checker) ? 0 : 1 });
				break;
			default:
				MAKE_VOID();
				break;
			}
			break;

		default:
			inplacePromote(checker);
			/* Default case: <op> <integer> */
			if (typeref.typ !in C_NUMERIC)
				goto err_bad_op;
			if (op == "~" && typeref.typ !in C_INTEGER)
				goto err_bad_op;
			switch (kind) {
			case CVALUE_RCONST:
				data = typeref.typ.bytes(checker, OPERATORS1_BY_NAME[op](constExprValue(checker)));
				offset = 0;
				break;
			default:
				if (op != "+")
					MAKE_VOID();
				break;
			}
			break;

		}
		TRACE();
		return this;
err_bad_op:
		throw Error(f"Bad operation: `{op} <{typeref}>'");
	}

	public function op2(checker: Checker, op: string, rhs: CValue): CValue
		-> copy(this).inplaceOp2(checker, op, rhs);
	public function inplaceOp2(checker: Checker, op: string, rhs: CValue): CValue {
		inplacePromote(checker);
		rhs = rhs.promote(checker);
again:
		local lhsTyp: CType = typeref.typ;
		local rhsTyp: CType = rhs.typeref.typ;

		/* Deal with floating-point */
		if (lhsTyp in C_FLOATING) {
			if (rhsTyp !in C_FLOATING)
				return inplaceOp2(checker, op, rhs.inplaceCast(checker, typeref));
			if (rhsTyp.sizeof > lhsTyp.sizeof) {
				inplaceCast(checker, rhs.typeref, true);
				goto again;
			}
			/* Floating-point operation. */
			if (op in ["==", "!=", "<", "<=", ">", ">="])
				goto do_compare_operation;
			if (op !in ["+", "-", "*", "/"])
				goto err_bad_op;
			local resTyp: CType = lhsTyp;
			if (resTyp.sizeof < rhsTyp.sizeof)
				resTyp = rhsTyp;
			typeref = CTypeRef(resTyp);
			if (isConstExpr && rhs.isConstExpr) {
				data = typeref.typ.bytes(checker, OPERATORS2_BY_NAME[op](
					constExprValue(checker), rhs.constExprValue(checker)));
				offset = 0;
			} else {
				MAKE_VOID();
			}
			TRACE();
			return this;
		} else if (rhsTyp in C_FLOATING) {
			inplaceCast(checker, rhs.typeref);
			goto again;
		}

		/* Deal with pointers */
		if (lhsTyp is CPointerType) {
			if (rhsTyp is CPointerType) {
				local lhsBase: CType = lhsTyp.base.typ;
				local rhsBase: CType = rhsTyp.base.typ;
				if (!IDENTICAL(lhsBase, rhsBase) && (lhsBase !== C_void && rhsBase !== C_void)) {
					checker.err(f"Pointer base types `{lhsTyp.base.typ}' "
					            f"and `{rhsTyp.base.typ}' are incompatible");
				}
				switch (op) {

				case "-": {
					local C_ptrdiff_t: Type = {
						4: C_int,
						8: C_long64
					}[{lhsTyp.sizeof, rhsTyp.sizeof} > ...];
					typeref = CTypeRef(C_ptrdiff_t);
					if (kind == rhs.kind) {
						switch (kind) {
						case CVALUE_RCONST: {
							local newVal = (
								constExprValue(checker) -
								rhs.constExprValue(checker)
							) / (lhsBase.sizeof ?: 1);
							data = C_ptrdiff_t.bytes(checker, newVal);
							offset = 0;
						}	break;
						case CVALUE_ACONST:
						case CVALUE_ASYMBOL: {
							if (data === rhs.data) {
								/* Special case: pointer-delta on identical symbols */
								local newVal = (offset - rhs.offset) / (lhsBase.sizeof ?: 1);
								data = C_ptrdiff_t.bytes(checker, newVal);
								kind = CVALUE_RCONST;
								offset = 0;
							} else {
								MAKE_VOID();
							}
						}	break;
						default:
							MAKE_VOID();
							break;
						}
					} else {
						MAKE_VOID();
					}
					TRACE();
					return this;
				}	break;

				case "==":
				case "!=":
				case "<":
				case "<=":
				case ">":
				case ">=":
					goto do_compare_operation;

				default:
					break;
				}
				goto err_bad_op;
			}

			switch (op) {

			case "+":
			case "-":
				if (rhs.isConstExpr) {
					local delta: int = rhs.constExprValue(checker) * lhsTyp.base.typ.sizeof;
					if (op == "-")
						delta = -delta;
					TRACE();
					switch (kind) {
					case CVALUE_RCONST:
						data = typeref.typ.bytes(checker, constExprValue(checker) + delta);
						offset = 0;
						break;
					case CVALUE_ACONST:
					case CVALUE_ASYMBOL:
						offset += delta;
						break;
					default:
						MAKE_VOID();
						break;
					}
					TRACE();
				} else {
					MAKE_VOID();
				}
				TRACE();
				return this;

			case "==":
			case "!=":
			case "<":
			case "<=":
			case ">":
			case ">=":
				goto do_compare_operation;

			default:
				break;
			}
			goto err_bad_op;
		} else if (rhsTyp is CPointerType) {
			switch (op) {
			case "+":
			case "==":
			case "!=":
			case "<":
			case "<=":
			case ">":
			case ">=":
				return rhs.op2(this, {
					"<"  : ">",
					"<=" : ">=",
					">"  : "<",
					">=" : "<=",
				}.get(op, op));
				break;
			default:
				break;
			}
			goto err_bad_op;
		}

		if (lhsTyp !in C_INTEGER)
			goto err_bad_op;
		if (rhsTyp !in C_INTEGER)
			goto err_bad_op;

		/* Generic operation. */
		switch (op) {

		case "+":
		case "-":
			if (rhs.isConstExpr) {
				local delta: int = rhs.constExprValue(checker);
				if (op == "-")
					delta = -delta;
				switch (kind) {
				case CVALUE_RCONST:
					data = typeref.typ.bytes(checker, constExprValue(checker) + delta);
					offset = 0;
					break;
				case CVALUE_ACONST:
				case CVALUE_ASYMBOL:
					offset += delta;
					break;
				default:
					MAKE_VOID();
					break;
				}
			} else {
				MAKE_VOID();
			}
			TRACE();
			return this;

		case "==":
		case "!=":
		case "<":
		case "<=":
		case ">":
		case ">=":
do_compare_operation:
			if (kind == rhs.kind) {
				switch (kind) {
				case CVALUE_RCONST:
					data = Bytes({
						OPERATORS2_BY_NAME[op](
							constExprValue(checker),
							rhs.constExprValue(checker)
						) ? 1 : 0
					});
					break;
				case CVALUE_ACONST:
				case CVALUE_ASYMBOL:
					if (data === rhs.data) {
						data = Bytes({ OPERATORS2_BY_NAME[op](offset, rhs.offset) ? 1 : 0 });
						offset = 0;
					} else if (op in ["==", "!="]) {
						data = Bytes({ op == "==" ? 0 : 1 });
						offset = 0;
					} else {
						MAKE_VOID();
					}
					break;
				default:
					MAKE_VOID();
					break;
				}
			} else {
				local nonNullPointerOperand: CValue | none = none;
				if (isConstExpr && !constExprValue(checker)) {
					nonNullPointerOperand = rhs;
					op = FLIPPED_COMPARE_OPERATORS.get(op, op);
				} else if (rhs.isConstExpr && !rhs.constExprValue(checker)) {
					nonNullPointerOperand = this;
				}
				if (nonNullPointerOperand !is none) {
					/* Special case: compare with null-pointer */
					switch (nonNullPointerOperand.kind) {
					case CVALUE_ACONST:
					case CVALUE_ASYMBOL:
						kind = CVALUE_RCONST;
						data = Bytes({
							"==" : 0, /* <symbol> == NULL */
							"!=" : 1, /* <symbol> != NULL */
							"<"  : 0, /* <symbol> < NULL */
							"<=" : 0, /* <symbol> <= NULL */
							">"  : 1, /* <symbol> > NULL */
							">=" : 1, /* <symbol> >= NULL */
						}[op]);
						offset = 0;
						break;
					default:
						MAKE_VOID();
						break;
					}
				} else {
					MAKE_VOID();
				}
			}
			typeref = CTypeRef(C_bool);
			TRACE();
			return this;

		default: {
			/* Default case: <integer> <op> <integer>
			 * In this case, the return type is the greater of the 2 integer
			 * types, and signed types are preferred over non-signed  types. */
			local lhsTypeSize = lhsTyp.sizeof;
			local rhsTypeSize = rhsTyp.sizeof;
			if ((lhsTypeSize < rhsTypeSize) ||
			    (lhsTypeSize == rhsTypeSize && (rhsTyp in C_SIGNED && lhsTyp !in C_SIGNED))) {
				/* The right-hand-side operand is the type to use. */
				inplaceCast(checker, rhs.typeref);
				goto again;
			}
			if (isConstExpr && rhs.isConstExpr) {
				data = lhsTyp.bytes(checker, OPERATORS2_BY_NAME[op](
					constExprValue(checker),
					rhs.constExprValue(checker)));
			} else {
				MAKE_VOID();
			}
		}	break;

		}
		TRACE();
		return this;
err_bad_op:
		throw Error(f"Bad operation: `<{lhsTyp}> {op} <{rhsTyp}>'");
	}

	public function assign(checker: Checker, value: CValue): CValue
		-> copy(this).inplaceAssign(checker, value);
	public function inplaceAssign(checker: Checker, value: CValue): CValue {
		/* NOTE: This cast also does rvalue transform! */
		value = value.cast(checker, typeref, canRetainNothrow: false,
			getExtraCannotRetainInfo: () ->
				f" (symbol `{isSymbol ? data.name : '<expression>'}' appears incorrectly annotated)");
		switch (kind) {
		case CVALUE_LVOID:
			break;
		case CVALUE_LCONST:
			checker.err(f"Write to compile-time constant expression of type `{typeref}'");
			break;
		case CVALUE_LSYMBOL:
			/* Remember the value override of the symbol (using `none' to indicate "unknown") */
			if (!checker.isUnreachable) {
				local scope: CNamespace = checker.namespaceStack.first;
				scope.symbolValues[data] = value.isConstExpr ? value.constExprBytes : none;
			}
			break;
		case CVALUE_LADDR:
			checker.warn("-Wconstaddr",
				f"Write to compile-time constant memory address `({typeref}){offset.hex()}'");
			break;
		default:
			checker.err(f"Cannot assign to r-value expression of type `{typeref}'");
			break;
		}
		TRACE();
		return this;
	}

	public function call(checker: Checker, args: {CValue...}, mustCastArgs: bool = true): CValue
		-> copy(this).inplaceCall(checker, args, mustCastArgs);
	public function inplaceCall(checker: Checker, args: {CValue...}, mustCastArgs: bool = true): CValue {
		/* Overloaded function support */
		local functionName: string = "<unnamed>";
		local functionDecl: (string, int, int) | none = none;
		switch (kind) {

		case CVALUE_LSYMBOL:
		case CVALUE_RSYMBOL:
		case CVALUE_ASYMBOL:
			functionName = data.name;
			functionDecl = data.decl;
			if (!functionName)
				functionName = "<unnamed>";
			if (data is COverloadedFunctionSymbol) {
				local types: {CType...} = Tuple(args.each.typeref.typ);
				local candidates: {CSymbol...} = data.getOverloadsForTypes(checker, types);
				if (!candidates) {
					checker.err(
						f"No overload of `{functionName}' matches "
						f"argument types `({', '.join(types)})'"
						f"{''.join(for (local overload: data.overloads)
							checker.forceFormatMessageAddend(
								overload.decl,
								overload is CSymbol
									? f"Known overload {overload}"
									: f"Template overload"
							)
						)}");
				} else if (#candidates > 1) {
					checker.err(
						f"More than one overload of `{functionName}' "
						f"matches argument list `({', '.join(types)})'"
						f"{''.join(
							for (local candidate: candidates)
								checker.forceFormatMessageAddend(
									candidate.decl, f"Candidate `{candidate}'")
						)}");
				} else {
					data         = candidates.first;
					typeref      = data.typeref;
					functionName = data.name;
					functionDecl = data.decl;
					if (!functionName)
						functionName = "<unnamed>";
				}
			}
			break;

		default:
			break;
		}

		inplaceRValue(checker);
		local funType: CType = typeref.typ;
		if (funType !is CFunctionType) {
			checker.err(
				f"Cannot call non-function-type `{funType.tostr(functionName)}'"
				f"{checker.formatMessageAddend(functionDecl, 'Symbol was declared here')}");
			return this;
		}

		/* Normalize arguments */
		local funArgs: {(CTypeRef, string)...} = funType.args;
		if (#args > #funArgs) {
			if (!funType.isVarArgs) {
				checker.warn("-Wcall",
					f"Too many arguments in call to `{functionName}': "
					f"need at most `{#funArgs}', but got `{#args}'"
					f"{checker.formatMessageAddend(functionDecl, 'Function was declared here')}");
			}
		} else if (#args < #funArgs) {
			local missingArgsFirst: int = #args;
			local missingArgsCount: int = #funArgs - missingArgsFirst;
			local defaultArgsCount: int = #funType.defaults;
			local defaultArgsFirst: int = #funArgs - defaultArgsCount;
			if (missingArgsFirst >= defaultArgsFirst) {
				/* Can substitute missing missing arguments from defaults */
				args = List(args);
				local defaultStart: int = missingArgsFirst - defaultArgsFirst;
				local defaultEnd: int   = defaultArgsCount - defaultStart;
				for (local i: [defaultStart: defaultEnd]) {
					args.append(CValue(
						kind:    CVALUE_RCONST,
						typeref: funArgs[defaultArgsFirst + i].first,
						data:    funType.defaults[i],
						offset:  0));
				}
			} else {
				checker.warn("-Wcall",
					f"Too few arguments in call to `{functionName}': "
					f"need at least `{defaultArgsFirst}', but only got `{#args}'");
			}
		}

		/* Cast arguments to their proper types if not done so already. */
		if (mustCastArgs) {
			args = List(args);
			local canRetainNothrow: bool = false;
			/* When the function is annotated as `nothrow(*...)', then  nothrow
			 * specifications of arguments passed to the function are retained. */
			local calleeNothrow: string | none = typeref.attribNothrow;
			if (calleeNothrow !is none && calleeNothrow.startswith("*"))
				canRetainNothrow = true;
			for (local i: [:#funArgs]) {
				args[i] = args[i].cast(checker, funArgs[i].first,
					canRetainNothrow: canRetainNothrow,
					getExtraCannotRetainInfo: canRetainNothrow ? none : () ->
						f" (argument `{funArgs[i].last}' of function "
						f"`{functionName}' appears incorrectly annotated)");
			}
		}

		/* Only do static checks if not inside of a dead code region. */
		if (!checker.isUnreachable) {
			/* Check if the called function requires its caller to have a certain tag. */
			local reqTags: Set with string = typeref.attribRequireCallerTags;
			if (reqTags) {
				local missingTags: Set with string = HashSet(checker.filterInactiveTags(reqTags));
				if (missingTags) {
					checker.warn("-Wtag",
						f"Function `{checker.currentFunctionName}' is missing "
						f"`__attribute__((tag({', '.join(
							for (local tag: missingTags.sorted())
								repr tag
						)})))' because it calls `{functionName}'");
				}
			}

			/* Check the throws-annotation of the called function and compare it to the caller's */
			local calleeThrows: {int...} = typeref.attribThrows;
			if (calleeThrows) {
				@@Mapping from throws exception codes to responsible parameter names
				local calleThrowsReferences: {int: string} = none;
				if (THROWS_CB in calleeThrows) {
					/* Special case: the function takes  a callback-argument  which it  invokes
					 *               and will propagate the exceptions thrown by said callback. */
					calleeThrows = HashSet(calleeThrows);
					local foundAny: bool = false;
					for (local arg: args) {
						local argTypeRef: CTypeRef = arg.typeref;
						while (argTypeRef.typ is CPointerType)
							argTypeRef = argTypeRef.typ.base;
						if (argTypeRef.typ is CFunctionType) {
							foundAny = true;
							local inner = argTypeRef.attribThrows;
							if (inner) {
								if (calleThrowsReferences is none)
									calleThrowsReferences = Dict();
								local reference: string = "";
								if (arg.isSymbol)
									reference = arg.data.name;
								if (!reference)
									reference = f"<value of {arg.name}>";
								for (local id: inner)
									calleThrowsReferences[id] = reference;
								calleeThrows.insertall(inner);
							}
						}
					}
					if (foundAny)
						calleeThrows.remove(THROWS_CB);
				}

				/* Remember exceptions that may be thrown. */
				checker.currentTryBlockExceptions.insertall(calleeThrows);

				/* When not inside of a try-block, can warn about exceptions that may be thrown. */
				if (!checker.isInTryBlock) {
					checker.verifyTopLevelThrows(calleeThrows, getReason: missingThrows -> {
						local references: string = "";
						if (calleThrowsReferences !is none) {
							local referencedFunctions: string = [];
							for (local id: missingThrows) {
								local ref: string | none = calleThrowsReferences.get(id);
								if (ref !is none && ref !in referencedFunctions)
									referencedFunctions.append(ref);
							}
							references = f" and passes callbacks {', '.join(
								for (local referencedFunction: referencedFunctions)
									f'`{referencedFunction}\'')}";
						}
						return f"it calls `{functionName}'{references}";
					});
				}
			}

			/* Verify the nothrow-attribute of the  called function (and since we  know
			 * the typing and attributes of all arguments used in the call, we can also
			 * resolve *-prefixed nothrow levels!) */
			local calleeNothrow: string | none = typeref.attribNothrow;
			if (calleeNothrow !is none) {
				local calleeNothrowLevel: int;
				local calleeNothrowLevelDerivedFromArguments: bool = false;
				if (calleeNothrow.startswith("*")) {
#define NO_LEVEL (-9999999999)
					calleeNothrowLevel = NO_LEVEL;

					/* Scan the argument list for pointers with nothrow arguments. */
					for (local arg: args) {
						local argType: CType = arg.typeref.typ;
						if (argType is CPointerType) {
							local pointerBaseTypeRef: CTypeRef = argType.base;
							local pointerNothrow: string | none = pointerBaseTypeRef.attribNothrow;
							if (pointerNothrow !is none && !pointerNothrow.startswith("*")) {
								pointerNothrow = int(pointerNothrow);
								if (calleeNothrowLevel < pointerNothrow) {
									calleeNothrowLevel = pointerNothrow;
									calleeNothrowLevelDerivedFromArguments = true;
								}
							}
						}
					}

					/* If we didn't find a nothrow level, use the function's default. */
					if (calleeNothrowLevel == NO_LEVEL)
						calleeNothrowLevel = int(calleeNothrow[1:]);
#undef NO_LEVEL
				} else {
					calleeNothrowLevel = int(calleeNothrow);
				}

				/* Special case:  the  function  might  throw  NCX
				 * Remember that fact if we're inside a TRY-block. */
				if (calleeNothrowLevel > 0)
					checker.currentTryBlockExceptions.insert(THROWS_NCX);

				/* Remember the greatest called nothrow level. */
				if (checker.currentTryBlockGreatestNothrowLevel < calleeNothrowLevel)
					checker.currentTryBlockGreatestNothrowLevel = calleeNothrowLevel;

				/* A warning will be issued if a nothrow function is called by another function
				 * that also has a nothrow attribute,  and whose nothrow attribute specifies  a
				 * level that is smaller than the called function. */
				local currentFunctionNothrow: string | none =
					checker.currentFunctionTypeRef.attribNothrow;
				if (currentFunctionNothrow !is none && !currentFunctionNothrow.startswith("*")) {
					local currentFunctionNothrowLevel: int = int(currentFunctionNothrow);
					if (currentFunctionNothrowLevel < calleeNothrowLevel) {
						checker.warn("-Wnothrow",
							f"Call to `{functionName}' follows `{
								getPrettyNothrowLevelName(calleeNothrowLevel)
							}'-semantics{
								calleeNothrowLevelDerivedFromArguments
									? ' because of passed arguments'
									: ''
							}"
							f", but caller function `{checker.currentFunctionName}' is marked "
							f"as `{getPrettyNothrowLevelName(currentFunctionNothrowLevel)}'"
						);
					}
				}
			} else {
				/* If the function has neither throws, nor nothrow, it may throw out-of-band */
				if (!calleeThrows)
					checker.currentTryBlockExceptions.insert(THROWS_OOB);
			}

			/* If the called function is noreturn, set isUnreachable=true */
			if (typeref.flags & CTYPEREF_FLAG_NORETURN)
				checker.isUnreachable = true;
		}

		/* Evaluate the function's return value
		 * XXX: support for `inline',  which is then  handled
		 *      by evaluating the function's body while using
		 *      fixed constants for arguments. */
		if (!isConstExpr) {
			MAKE_VOID();
		}
		typeref = CTypeRef(funType.returnType);
		TRACE();
		return this;
	}

}

global final C_char_typeref: CTypeRef = CTypeRef(C_char);

@@Construct a CValue object in the form of an array-of-char
@@for   a  deemon  @Bytes  or  sequence-of-integer  object.
function cvalueFromBytesAsString(s: Bytes): CValue {
	return CValue(
			kind:    CVALUE_LCONST,
			typeref: CTypeRef(CArrayType(C_char, #s, 1), CTYPEREF_FLAG_CONST),
			data:    s,
			offset:  0);
}

@@Wrapper for @cvalueFromBytesAsString for the purpose of encoding strings
function cvalueFromString(s: string): CValue {
	return cvalueFromBytesAsString((s + "\0").encode("utf-8"));
}

function cvalueFromValue(checker: Checker, typeref: CTypeRef, value: int | float): CValue {
	return CValue(
			kind:    CVALUE_RCONST,
			typeref: typeref,
			data:    typeref.typ.bytes(checker, value),
			offset:  0);
}

function cvalueFromSymbol(sym: CSymbol): CValue {
	return CValue(
			kind:    CVALUE_LSYMBOL,
			typeref: sym.typeref,
			data:    sym,
			offset:  0);
}

global final C_bool_typeref: CTypeRef = CTypeRef(C_bool);
global final C_false: CValue = CValue(kind: CVALUE_RCONST, typeref: C_bool_typeref, data: Bytes({ 0 }), offset: 0);
global final C_true:  CValue = CValue(kind: CVALUE_RCONST, typeref: C_bool_typeref, data: Bytes({ 1 }), offset: 0);
global final C_nullptr_32: CValue = CValue(kind: CVALUE_RCONST, typeref: CTypeRef(C_nullptr_t_32), data: Bytes({ 0, 0, 0, 0 }), offset: 0);
global final C_nullptr_64: CValue = CValue(kind: CVALUE_RCONST, typeref: CTypeRef(C_nullptr_t_64), data: Bytes({ 0, 0, 0, 0, 0, 0, 0, 0 }), offset: 0);
global final C_void_typeref: CTypeRef = CTypeRef(C_void);
global final C_voidval: CValue = CValue(kind: CVALUE_AVOID, typeref: C_void_typeref);


final class CScope: CNamespace {
	this = super;
	@@Symbol value overrides (for when a function overrides the value of a pre-defined symbol)
	public member symbolValues: {CSymbol: Bytes | none} = UniqueDict();

	@@Overrides for context tags that currently active or inactive
	public member tagOverrides: {string: bool | none} | none = none;

	@@Callbacks that are invoked when the scope is popped
	public member onPopCallbacks: {Callable...} | none = none;

	public property requireTagOverrides: {string: bool | none} = {
		get(): {string: bool | none} {
			if (tagOverrides is none)
				tagOverrides = Dict();
			return tagOverrides;
		}
	}

	@@Register a callback that should be invoked when the scope is popped
	public function registerOnPop(cb: Callable) {
		if (onPopCallbacks is none)
			onPopCallbacks = [];
		onPopCallbacks.pushfront(cb);
	}

	@@Called when the scope is popped (s.a. @CNamespace.onPop)
	public function invokeOnPopCallbacks() {
		for (local cb: onPopCallbacks)
			cb();
	}
}

@@Create a @CScope whose symbol value overrides and on-pop callbacks alias those of @forScope
function createCScopeAlias(forScope: CScope): CScope {
	local result: CScope = CScope();
	result.symbolValues = forScope.symbolValues;
	result.tagOverrides = forScope.tagOverrides;
	if (forScope.onPopCallbacks is none)
		forScope.onPopCallbacks = [];
	result.onPopCallbacks = forScope.onPopCallbacks;
	return result;
}
