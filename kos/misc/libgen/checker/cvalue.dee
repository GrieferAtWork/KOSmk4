/* Copyright (c) 2019-2023 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2023 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from deemon;
import * from .ctype;
import UniqueDict from collections;
#define Checker Object

#define IDENTICAL(a, b) (type(a) === type(b) && ((a) == (b)))

global final OPERATORS1_BY_NAME: {string: Callable} = {
	"+"  : operator pos,
	"-"  : operator neg,
	"~"  : operator ~,
};
global final OPERATORS2_BY_NAME: {string: Callable} = {
	"+"  : operator add,
	"-"  : operator sub,
	"*"  : operator *,
	"/"  : operator /,  /* TODO: This is floordiv, but C needs truncdiv! */
	"%"  : operator %,  /* TODO: This is floormod, but C needs truncmod! */
	"<<" : operator <<,
	">>" : operator >>,
	"&"  : operator &,
	"|"  : operator |,
	"^"  : operator ^,
	"==" : operator ==,
	"!=" : operator !=,
	"<"  : operator <,
	"<=" : operator <=,
	">"  : operator >,
	">=" : operator >=,
};

global final FLIPPED_COMPARE_OPERATORS: {string: string} = {
	"<"  : ">",
	">"  : "<",
	"<=" : ">=",
	">=" : "<=",
};


#define CVALUE_RVALUE      1
#define CVALUE_AVALUE      2
#define CVALUE_ISLVALUE(x) (!((x) & CVALUE_RVALUE)) /* L-Value */
#define CVALUE_ISRVALUE(x) ((x) & CVALUE_RVALUE)    /* R-Value */
#define CVALUE_ISAVALUE(x) (((x) & (CVALUE_RVALUE | CVALUE_AVALUE)) == (CVALUE_RVALUE | CVALUE_AVALUE))
global final CVALUE_LVOID   = 0x00; /* L-Value: *(T *)??? Value */
global final CVALUE_RVOID   = 0x01; /* R-Value: *(T *)??? Value */
global final CVALUE_AVOID   = 0x03; /* R-Value:    (T)??? Value */
global final CVALUE_LCONST  = 0x04; /* L-Value: *(T *)&data[offset:offset+...] */
global final CVALUE_RCONST  = 0x05; /* R-Value: *(T *)&data[offset:offset+...] */
global final CVALUE_ACONST  = 0x07; /* R-Value:    (T)&data[offset:offset+...] */
global final CVALUE_LSYMBOL = 0x08; /* L-Value: *(T *)&CSymbol.val[offset:offset+...] */
global final CVALUE_RSYMBOL = 0x09; /* R-Value: *(T *)&CSymbol.val[offset:offset+...] */
global final CVALUE_ASYMBOL = 0x0b; /* R-Value:    (T)&CSymbol.val[offset:offset+...] */
global final CVALUE_LADDR   = 0x0c; /* L-Value: *(T *)offset */
global final CVALUE_RADDR   = 0x0d; /* R-Value: *(T *)offset */

global final PRETTY_NOTHROW_LEVEL_NAME: {int: string} = {
	0 : "NOTHROW",
	1 : "NOTHROW_NCX",
	2 : "USER' or `CHECKED",
	3 : "BLOCKING",
};
function getPrettyNothrowLevelName(level: int): string {
	local result = PRETTY_NOTHROW_LEVEL_NAME.get(level);
	if (result !is none)
		return result;
	return f"__attribute__((nothrow({level})))";
}


#if 0
global final CVALUE_KINDNAME: {int: string} = {
	CVALUE_LVOID   : "LVOID",
	CVALUE_RVOID   : "RVOID",
	CVALUE_AVOID   : "AVOID",
	CVALUE_LCONST  : "LCONST",
	CVALUE_RCONST  : "RCONST",
	CVALUE_ACONST  : "ACONST",
	CVALUE_LSYMBOL : "LSYMBOL",
	CVALUE_RSYMBOL : "RSYMBOL",
	CVALUE_ASYMBOL : "ASYMBOL",
	CVALUE_LADDR   : "LADDR",
	CVALUE_RADDR   : "RADDR",
};
#define TRACE() \
	({ \
		print(__LINE__, ":", CVALUE_KINDNAME[kind], ":", typeref),; \
		if (offset is bound) \
			print(":", repr offset),; \
		if (data is bound) \
			print(":", repr data),; \
		print; \
	})
#else
#define TRACE() none
#endif
final class CValue {
	this = default;

	@@Value kind (one of `CVALUE_*`)
	public member kind: int;

	@@Value type
	public member typeref: CTypeRef;

	@@The actual value, or symbol-reference
	public member data: Bytes | CSymbol;

	@@Offset into @data
	public member offset: int;

	operator str(): string -> f"<instance of {typeref}>";

	/* Utility functions */

	@@Check if @this is a compile-time constant value
	public property isConstExpr: bool = {
		get(): bool {
			return kind in [CVALUE_LCONST, CVALUE_RCONST];
		}
	}
	public property constExprBytes: Bytes = {
		get(): Bytes {
			assert isConstExpr;
			return data[offset:offset+typeref.typ.sizeof];
		}
	}
	public function constExprValue(checker: Checker): int | float {
		assert isConstExpr;
		return typeref.typ.peek(checker, data, offset);
	}

#define MAKE_VOID() (kind &= CVALUE_RVALUE)
	public property inplaceVoid: CValue = {
		get(): CValue {
			MAKE_VOID();
			return this;
		}
	}

	/* Utility API */

	public function rValue(checker: Checker): CValue -> copy(this).inplaceRValue(checker);
	public function inplaceRValue(checker: Object): CValue {
		local typ: CType = typeref.typ;
		if (typ is CArrayType) {
			if (CVALUE_ISRVALUE(kind))
				checker.err(f"Cannot decay r-value array `{typeref}' to pointer");
			local pointerTypeRef: CTypeRef = copy typeref;
			pointerTypeRef.typ = typ.base;
			typ = checker.TARGET_CPointerType(pointerTypeRef);
			typeref = CTypeRef(typ);
		}
		kind |= CVALUE_RVALUE;
		if (kind == CVALUE_RSYMBOL) {
			/* Check if the symbol has an override */
			local symValue: Bytes | none = checker.getSymbolValue(data);

			/* Check if the symbol has a known, constant value */
			if (symValue is none && (data.typeref.flags & CTYPEREF_FLAG_CONST))
				symValue = data.valOrNone;
			if (symValue !is none) {
				kind = CVALUE_RCONST;
				data = symValue;
				offset = 0;
			}
		}
		TRACE();
		return this;
	}

	public function cast(checker: Checker, newTypeRef: CTypeRef, explicit: bool = false): CValue
		-> copy(this).inplaceCast(checker, newTypeRef, explicit);
	public function inplaceCast(checker: Checker, newTypeRef: CTypeRef, explicit: bool = false): CValue {
		inplaceRValue(checker);
		local oldTyp: CType = typeref.typ;
		local newTyp: CType = newTypeRef.typ;

		/* Filter out illegal casts */
		if (newTyp is CStructType)
			goto err_bad_op;
		if (newTyp is CFunctionType)
			goto err_bad_op;
		if (newTyp is CArrayType)
			goto err_bad_op;

		if (!explicit && !IDENTICAL(oldTyp, newTyp)) {
			/* Error  when  `!explicit' and  casting between
			 * pointer types, where neither type is `void *' */
			if (oldTyp is CPointerType && newTyp is CPointerType) {
				local oldPointerBase: CTypeRef = oldTyp.base;
				local newPointerBase: CTypeRef = newTyp.base;
				if (IDENTICAL(oldPointerBase, newPointerBase)) {
					/* Pointer-cast where the pointer bases are identical is always OK */
				} else if (IDENTICAL(oldPointerBase.typ, newPointerBase.typ)) {
					/* Pointer-cast where the the base-types are identical is OK,
					 * but warn if the  cast causes const/volatile to  disappear. */
					local oldCV = oldPointerBase.flags & CTYPEREF_FLAG_CV;
					local newCV = newPointerBase.flags & CTYPEREF_FLAG_CV;
					if ((oldCV & newCV) != oldCV) {
						checker.warn("-Wcast",
							f"Implicit cast from `{oldTyp}' to `{newTyp}' "
							f"removes `{" ".join(() -> {
								if (oldCV & CTYPEREF_FLAG_CONST)
									yield "const";
								if (oldCV & CTYPEREF_FLAG_VOLATILE)
									yield "volatile";
							}())}'");
					}
				} else if (oldPointerBase.typ === C_void || newPointerBase.typ === C_void) {
					/* Pointer-cast to/from void is always OK */
				} else {
					checker.warn("-Wcast",
							f"Implicit cast between incompatible pointer "
							f"types from `{oldTyp}' to `{newTyp}'");
				}
			} else if (newTyp is CPointerType) {
				if (oldTyp is C_NULLPTR) {
					/* Implicit cast from `nullptr' to pointer is OK. */
				} else if (oldTyp in C_INTEGER && isConstExpr && constExprValue(checker) == 0) {
					/* Implicit cast from 0-constant to pointer is OK. */
				} else {
					goto warn_implicit_pointer_cast;
				}
			} else if (oldTyp is CPointerType) {
warn_implicit_pointer_cast:
				checker.warn("-Wcast", f"Implicit integer/pointer-cast from `{oldTyp}' to `{newTyp}'");
			}
		}

		/* If `!(newTypeRef.flags & CTYPEREF_FLAG_FORCE)', then retain nothrow attributes
		 * of  `(newTypeRef.typ as CPointerType).base.attrib' (also: warn if the new type
		 * has no force  attribute, and both  types have nothrow  levels, which are  also
		 * different from each other):
		 * >> #define NTX(n) __attribute__((__nothrow__(n)))
		 * >> #define FORCE  __attribute__((__force__))
		 * >>        void *p = (NTX(0) void *)42;       // p inherits the NTX(0) attribute (but also generates a warning to please annotate `p')
		 * >>        void *p = (FORCE NTX(0) void *)42; // p inherits the NTX(0) attribute
		 * >> NTX(0) void *p = (void *)42;              // OK: p retains the NTX(0) attribute
		 * >> NTX(0) void *p = (NTX(0) void *)42;       // OK: Nothing changes
		 * >> NTX(0) void *p = (NTX(1) void *)42;       // Warning: Multiple nothrow levels (p retains NTX(0))
		 * >> NTX(1) void *p = (NTX(0) void *)42;       // OK: Always allowed to increase nothrow level (p retains NTX(1))
		 * >> NTX(1) void *p = (FORCE NTX(0) void *)42; // OK: p inherits the NTX(0) attribute (but you shouldn't do this)
		 * >> FORCE NTX(1) void *p = (NTX(0) void *)42; // Warning: Multiple nothrow levels (p retains NTX(1))
		 */
		if (newTypeRef.flags & CTYPEREF_FLAG_FORCE) {
			/* Always use `newTypeRef' as-is */
		} else {
			if ((oldTyp is CPointerType) && (newTyp is CPointerType)) {
				local oldPointerBase: CTypeRef = oldTyp.base;
				local newPointerBase: CTypeRef = newTyp.base;
				local oldNothrowLevel = oldPointerBase.attrib.get("nothrow");
				local newNothrowLevel = newPointerBase.attrib.get("nothrow");
				if (oldNothrowLevel is none) {
					/* Automatically inherit the new nothrow-level */
				} else if (newPointerBase.flags & CTYPEREF_FLAG_FORCE) {
					/* Force inherit the new type's nothrow level */
				} else {
					if (newNothrowLevel !is none) {
						if (oldNothrowLevel == newNothrowLevel) {
							/* Both pointers have the same nothrow-level -> nothing changes */
						} else if (newNothrowLevel > oldNothrowLevel) {
							checker.warn("-Wnothrow",
									f"Cast from `{oldTyp}' to `{newTyp}' results in nothrow "
									f"level `{oldNothrowLevel}', rather than `{newNothrowLevel}'. "
									f"Use `__attribute__((force))' to select which nothrow level "
									f"should be used");
							goto pointer_cast_retain_nothrow;
						} else {
							/* Retain nothrow level */
							goto pointer_cast_retain_nothrow;
						}
					} else {
						/* TODO: Warning when implicitly casting a function pointer such  that
						 *       it loses or gains any of its attributes (nothrow, tag, etc.).
						 * This is needed so that function pointer assignments doesn't silently
						 * change    a   function's   behavior    as   per   its   annotations. */

						/* TODO: Warning when passing a custom nothrow pointer to a function
						 *       whose arguments don't have any nothrow argument. This  case
						 *       must  be treated in  a special way  because the function in
						 *       question won't magically get the attribute just because  it
						 *       is called with the attribute!
						 */
pointer_cast_retain_nothrow:
						newPointerBase = copy newPointerBase;
						newPointerBase.attrib = copy newPointerBase.attrib;
						newPointerBase.attrib["nothrow"] = oldNothrowLevel;
						newTyp = type(newTyp)(newPointerBase);
						newTypeRef = copy newTypeRef;
						newTypeRef.typ = newTyp;
					}
				}
			}
		}
		typeref = newTypeRef;

		/* Perform value transformations based on the cast. */
		switch (kind) {

		case CVALUE_RCONST:
		case CVALUE_RSYMBOL:
			if (newTyp.sizeof > oldTyp.sizeof) {
				if (kind == CVALUE_RCONST) {
					/* Zero-/Sign-extend constant integer */
					data   = newTyp.bytes(checker, oldTyp.peek(checker, data, offset));
					offset = 0;
				} else {
					MAKE_VOID();
				}
			} else {
				if (checker.TARGET_BIG_ENDIAN) {
					offset += oldTyp.sizeof;
					offset -= newTyp.sizeof;
				}
			}
			break;

		case CVALUE_ACONST:
		case CVALUE_ASYMBOL:
			if (newTyp.sizeof < checker.TARGET_SIZEOF_POINTER)
				MAKE_VOID(); /* Pointer masking (treat value as unknown) */
			break;

		default:
			break;
		}
		TRACE();
		return this;
err_bad_op:
		checker.err(f"Bad operation `({newTypeRef}){this}'");
		return this;
	}

	public function field(checker: Checker, fieldName: string): CValue
		-> copy(this).inplaceField(checker, fieldName);
	public function inplaceField(checker: Checker, fieldName: string): CValue {
		local typ: CType = typeref.typ;
		if (typ !is CStructType)
			checker.err(f"Cannot access field `{fieldName}' of non-struct-type `{typ}'");
		local fieldInfo: (CTypeRef, int) | none = typ.fields.get(fieldName);
		if (fieldInfo is none) {
			checker.err(f"No such field `{fieldName}' in `{typ}'");
		} else {
			/* Load the field in question */
			typeref = fieldInfo.first;
			offset += fieldInfo.last;
		}
		TRACE();
		return this;
	}

	public function promote(checker: Checker): CValue -> copy(this).inplacePromote(checker);
	public function inplacePromote(checker: Checker): CValue {
		if (typeref.typ in C_PROMOTE) {
			return inplaceCast(checker, CTypeRef(C_int), true);
		} else if (typeref.typ === C_float) {
			return inplaceCast(checker, CTypeRef(C_double), true);
		} else {
			return inplaceRValue(checker);
		}
	}

	public function ref(checker: Checker): CValue -> copy(this).inplaceRef(checker);
	public function inplaceRef(checker: Checker): CValue {
		typeref = CTypeRef(checker.TARGET_CPointerType(typeref));
		if (!CVALUE_ISLVALUE(kind))
			checker.err(f"Cannot reference expression: not an l-value");
		switch (kind) {
		case CVALUE_LADDR:
		case CVALUE_RADDR:
			kind   = CVALUE_RCONST;
			data   = offset.tobytes(checker.TARGET_SIZEOF_POINTER, checker.TARGET_ENDIAN, false);
			offset = 0;
			break;
		default:
			kind |= CVALUE_RVALUE | CVALUE_AVALUE;
			break;
		}
		TRACE();
		return this;
	}

	public function ind(checker: Checker): CValue -> copy(this).inplaceInd(checker);
	public function inplaceInd(checker: Checker): CValue {
		inplacePromote(checker); /* To deal with array decay */
		if (typeref.typ !is CPointerType) {
			/* Special case: ignore deref on function types. */
			if (typeref.typ is CFunctionType)
				return this;
			checker.err(f"Cannot dereference non-pointer type `{typeref}'");
		}
		typeref = typeref.typ.base;
		if (CVALUE_ISAVALUE(kind)) {
			kind &= ~(CVALUE_AVALUE | CVALUE_RVALUE);
		} else if (kind == CVALUE_RCONST) {
			/* Special case: dereference compile-time constant address */
			kind   = CVALUE_LADDR;
			offset = int.frombytes(
				data[offset:offset + checker.TARGET_SIZEOF_POINTER],
				checker.TARGET_ENDIAN, false);
			del data;
		} else {
			/* Unknown value */
			kind = CVALUE_LVOID;
		}

		/* Emit warnings about illegal dereference operations. */
		if (!checker.isUnreachable) {
			if (typeref.flags & CTYPEREF_FLAG_NODEREF) {
				checker.warn("-Wnoderef",
					f"Dereference pointer to `{typeref.typ}' "
					f"marked as `__attribute__((noderef))'");
			}
			if (checker.currentFunctionTypeRef !is none) {
				local pointerNoThrow: string = typeref.attrib.get("nothrow");
				if (pointerNoThrow !is none) {
					/* Issue a warning if:
					 * - The current function doesn't have a __attribute__((nothrow(N))) attribute
					 * - The current function has a nothrow level N that is lower than `pointerNoThrow' */
					local pointerNoThrowLevel: int = int(pointerNoThrow);
					local currentFunctionNothrow: string | none =
						checker.currentFunctionTypeRef.attrib.get("nothrow");
					if (currentFunctionNothrow is none) {
						checker.warn("-Wnothrow",
							f"Dereference `{getPrettyNothrowLevelName(pointerNoThrowLevel)}'-pointer "
							f"in function that does not have any `__attribute__((nothrow(...)))'");
					} else {
						local currentFunctionNothrowLevel: int = int(currentFunctionNothrow.lstrip("*"));
						if (currentFunctionNothrowLevel < pointerNoThrowLevel) {
							checker.warn("-Wnothrow",
								f"Dereference `{getPrettyNothrowLevelName(pointerNoThrowLevel)}'-pointer "
								f"in function `{checker.currentFunctionName}' marked as "
								f"`{getPrettyNothrowLevelName(currentFunctionNothrowLevel)}'");
						}
					}
				}
			}
		}
		TRACE();
		return this;
	}

	public function op1(checker: Checker, op: string): CValue -> copy(this).inplaceOp1(checker, op);
	public function inplaceOp1(checker: Checker, op: string): CValue {
		switch (op) {

		case "&":
			return inplaceRef(checker);

		case "*":
			return inplaceInd(checker);

		case "bool":
			inplacePromote(checker);
			typeref = CTypeRef(C_bool);
			switch (kind) {
			case CVALUE_ACONST:
			case CVALUE_ASYMBOL:
				data = Bytes({ 1 }); /* Pointer-to-data/symbol is always non-NULL */
				break;
			case CVALUE_RCONST:
				data = Bytes({ constExprValue(checker) ? 1 : 0 });
				break;
			default:
				MAKE_VOID();
				break;
			}
			break;

		case "!":
			inplacePromote(checker);
			typeref = CTypeRef(C_bool);
			switch (kind) {
			case CVALUE_ACONST:
			case CVALUE_ASYMBOL:
				data = Bytes({ 0 }); /* Pointer-to-data/symbol is always non-NULL */
				break;
			case CVALUE_RCONST:
				data = Bytes({ constExprValue(checker) ? 0 : 1 });
				break;
			default:
				MAKE_VOID();
				break;
			}
			break;

		default:
			inplacePromote(checker);
			/* Default case: <op> <integer> */
			if (typeref.typ !in C_NUMERIC)
				goto err_bad_op;
			if (op == "~" && typeref.typ !in C_INTEGER)
				goto err_bad_op;
			switch (kind) {
			case CVALUE_RCONST:
				data = typeref.typ.bytes(checker, OPERATORS1_BY_NAME[op](constExprValue(checker)));
				offset = 0;
				break;
			default:
				if (op != "+")
					MAKE_VOID();
				break;
			}
			break;

		}
		TRACE();
		return this;
err_bad_op:
		throw Error(f"Bad operation: `{op} <{typeref}>'");
	}

	public function op2(checker: Checker, op: string, rhs: CValue): CValue
		-> copy(this).inplaceOp2(checker, op, rhs);
	public function inplaceOp2(checker: Checker, op: string, rhs: CValue): CValue {
		inplacePromote(checker);
		rhs = rhs.promote(checker);
again:
		local lhsTyp: CType = typeref.typ;
		local rhsTyp: CType = rhs.typeref.typ;

		/* Deal with floating-point */
		if (lhsTyp in C_FLOATING) {
			if (rhsTyp !in C_FLOATING)
				return inplaceOp2(checker, op, rhs.inplaceCast(checker, typeref));
			if (rhsTyp.sizeof > lhsTyp.sizeof) {
				inplaceCast(checker, rhs.typeref);
				goto again;
			}
			/* Floating-point operation. */
			if (op in ["==", "!=", "<", "<=", ">", ">="])
				goto do_compare_operation;
			if (op !in ["+", "-", "*", "/"])
				goto err_bad_op;
			local resTyp: CType = lhsTyp;
			if (resTyp.sizeof < rhsTyp.sizeof)
				resTyp = rhsTyp;
			typeref = CTypeRef(resTyp);
			if (isConstExpr && rhs.isConstExpr) {
				data = typeref.typ.bytes(checker, OPERATORS2_BY_NAME[op](
					constExprValue(checker), rhs.constExprValue(checker)));
				offset = 0;
			} else {
				MAKE_VOID();
			}
			TRACE();
			return this;
		} else if (rhsTyp in C_FLOATING) {
			inplaceCast(checker, rhs.typeref);
			goto again;
		}

		/* Deal with pointers */
		if (lhsTyp is CPointerType) {
			if (rhsTyp is CPointerType) {
				local lhsBase: CType = lhsTyp.base.typ;
				local rhsBase: CType = rhsTyp.base.typ;
				if (!IDENTICAL(lhsBase, rhsBase) && (lhsBase !== C_void && rhsBase !== C_void)) {
					checker.err(f"Pointer base types `{lhsTyp.base.typ}' "
					            f"and `{rhsTyp.base.typ}' are incompatible");
				}
				switch (op) {

				case "-": {
					local C_ptrdiff_t: Type = {
						4: C_int,
						8: C_long64
					}[{lhsTyp.sizeof, rhsTyp.sizeof} > ...];
					typeref = CTypeRef(C_ptrdiff_t);
					if (kind == rhs.kind) {
						switch (kind) {
						case CVALUE_RCONST: {
							local newVal = (
								constExprValue(checker) -
								rhs.constExprValue(checker)
							) / (lhsBase.sizeof ?: 1);
							data = C_ptrdiff_t.bytes(checker, newVal);
							offset = 0;
						}	break;
						case CVALUE_ACONST:
						case CVALUE_ASYMBOL: {
							if (data === rhs.data) {
								/* Special case: pointer-delta on identical symbols */
								local newVal = (offset - rhs.offset) / (lhsBase.sizeof ?: 1);
								data = C_ptrdiff_t.bytes(checker, newVal);
								kind = CVALUE_RCONST;
								offset = 0;
							} else {
								MAKE_VOID();
							}
						}	break;
						default:
							MAKE_VOID();
							break;
						}
					} else {
						MAKE_VOID();
					}
					TRACE();
					return this;
				}	break;

				case "==":
				case "!=":
				case "<":
				case "<=":
				case ">":
				case ">=":
					goto do_compare_operation;

				default:
					break;
				}
				goto err_bad_op;
			}

			switch (op) {

			case "+":
			case "-":
				if (rhs.isConstExpr) {
					local delta: int = rhs.constExprValue(checker) * lhsTyp.base.typ.sizeof;
					if (op == "-")
						delta = -delta;
					switch (kind) {
					case CVALUE_RCONST:
						data = typeref.typ.bytes(checker, constExprValue(checker) + delta);
						offset = 0;
						break;
					case CVALUE_ACONST:
					case CVALUE_ASYMBOL:
						offset += delta;
						break;
					default:
						MAKE_VOID();
						break;
					}
				} else {
					MAKE_VOID();
				}
				TRACE();
				return this;

			case "==":
			case "!=":
			case "<":
			case "<=":
			case ">":
			case ">=":
				goto do_compare_operation;

			default:
				break;
			}
			goto err_bad_op;
		} else if (rhsTyp is CPointerType) {
			switch (op) {
			case "+":
			case "==":
			case "!=":
			case "<":
			case "<=":
			case ">":
			case ">=":
				return rhs.op2(this, {
					"<"  : ">",
					"<=" : ">=",
					">"  : "<",
					">=" : "<=",
				}.get(op, op));
				break;
			default:
				break;
			}
			goto err_bad_op;
		}

		if (lhsTyp !in C_INTEGER)
			goto err_bad_op;
		if (rhsTyp !in C_INTEGER)
			goto err_bad_op;

		/* Generic operation. */
		switch (op) {

		case "+":
		case "-":
			if (rhs.isConstExpr) {
				local delta: int = rhs.constExprValue(checker);
				if (op == "-")
					delta = -delta;
				switch (kind) {
				case CVALUE_RCONST:
					data = typeref.typ.bytes(checker, constExprValue(checker) + delta);
					offset = 0;
					break;
				case CVALUE_ACONST:
				case CVALUE_ASYMBOL:
					offset += delta;
					break;
				default:
					MAKE_VOID();
					break;
				}
			} else {
				MAKE_VOID();
			}
			TRACE();
			return this;

		case "==":
		case "!=":
		case "<":
		case "<=":
		case ">":
		case ">=":
do_compare_operation:
			typeref = CTypeRef(C_bool);
			if (kind == rhs.kind) {
				switch (kind) {
				case CVALUE_RCONST:
					data = Bytes({ OPERATORS2_BY_NAME[op](
						constExprValue(checker),
						rhs.constExprValue(checker)) ? 1 : 0 });
					break;
				case CVALUE_ACONST:
				case CVALUE_ASYMBOL:
					if (data === rhs.data) {
						data = Bytes({ OPERATORS2_BY_NAME[op](offset, rhs.offset) ? 1 : 0 });
						offset = 0;
					} else if (op in ["==", "!="]) {
						data = Bytes({ op == "==" ? 0 : 1 });
						offset = 0;
					} else {
						MAKE_VOID();
					}
					break;
				default:
					MAKE_VOID();
					break;
				}
			} else {
				local nonNullPointerOperand: CValue | none = none;
				if (isConstExpr && !constExprValue(checker)) {
					nonNullPointerOperand = rhs;
					op = FLIPPED_COMPARE_OPERATORS.get(op, op);
				} else if (rhs.isConstExpr && !rhs.constExprValue(checker)) {
					nonNullPointerOperand = this;
				}
				if (nonNullPointerOperand !is none) {
					/* Special case: compare with null-pointer */
					switch (nonNullPointerOperand.kind) {
					case CVALUE_ACONST:
					case CVALUE_ASYMBOL:
						kind = CVALUE_RCONST;
						data = Bytes({
							"==" : 0, /* <symbol> == NULL */
							"!=" : 1, /* <symbol> != NULL */
							"<"  : 0, /* <symbol> < NULL */
							"<=" : 0, /* <symbol> <= NULL */
							">"  : 1, /* <symbol> > NULL */
							">=" : 1, /* <symbol> >= NULL */
						}[op]);
						offset = 0;
						break;
					default:
						MAKE_VOID();
						break;
					}
				} else {
					MAKE_VOID();
				}
			}
			TRACE();
			return this;

		default: {
			/* Default case: <integer> <op> <integer>
			 * In this case, the return type is the greater of the 2 integer
			 * types, and signed types are preferred over non-signed  types. */
			local lhsTypeSize = lhsTyp.sizeof;
			local rhsTypeSize = rhsTyp.sizeof;
			if ((lhsTypeSize < rhsTypeSize) ||
			    (lhsTypeSize == rhsTypeSize && rhsTyp in C_SIGNED)) {
				/* The right-hand-side operand is the type to use. */
				inplaceCast(checker, rhs.typeref);
				goto again;
			}
			if (isConstExpr && rhs.isConstExpr) {
				data = lhsTyp.bytes(checker, OPERATORS2_BY_NAME[op](
					constExprValue(checker),
					rhs.constExprValue(checker)));
			} else {
				MAKE_VOID();
			}
		}	break;

		}
		TRACE();
		return this;
err_bad_op:
		throw Error(f"Bad operation: `<{lhsTyp}> {op} <{rhsTyp}>'");
	}

	public function assign(checker: Checker, value: CValue): CValue
		-> copy(this).inplaceAssign(checker, value);
	public function inplaceAssign(checker: Checker, value: CValue): CValue {
		value = value.cast(checker, typeref); /* NOTE: This also does rvalue transform! */
		switch (kind) {
		case CVALUE_LVOID:
			break;
		case CVALUE_LCONST:
			checker.err(f"Write to compile-time constant expression of type `{typeref}'");
			break;
		case CVALUE_LSYMBOL:
			/* Remember the value override of the symbol (using `none' to indicate "unknown") */
			if (!checker.isUnreachable) {
				local scope: CNamespace = checker.namespaceStack.first;
				scope.symbolValues[data] = value.isConstExpr ? value.constExprBytes : none;
			}
			break;
		default:
			checker.err(f"Cannot assign to r-value expression of type `{typeref}'");
			break;
		}
		TRACE();
		return this;
	}

	public function call(checker: Checker, args: {CValue...}, mustCastArgs: bool = true): CValue
		-> copy(this).inplaceCall(checker, args, mustCastArgs);
	public function inplaceCall(checker: Checker, args: {CValue...}, mustCastArgs: bool = true): CValue {
		// TODO: Overloaded function support
		inplaceRValue(checker);
		local funType: CType = typeref.typ;
		if (funType !is CFunctionType) {
			checker.err(f"Cannot call non-function-type `{funType}'");
			return this;
		}

		/* Normalize arguments */
		local funArgs: {(CTypeRef, string)...} = funType.args;
		if (#args > #funArgs) {
			if (!funType.isVarArgs) {
				checker.warn("-Wcall",
					f"Too many arguments in function call: need at most "
					f"`{#funArgs}', but got `{#args}'");
			}
		} else if (#args < #funArgs) {
			local missingArgsFirst: int = #args;
			local missingArgsCount: int = #funArgs - missingArgsFirst;
			local defaultArgsCount: int = #funType.defaults;
			local defaultArgsFirst: int = #funArgs - defaultArgsCount;
			if (missingArgsFirst >= defaultArgsFirst) {
				/* Can substitute missing missing arguments from defaults */
				args = List(args);
				local defaultStart: int = missingArgsFirst - defaultArgsFirst;
				local defaultEnd: int   = defaultArgsCount - defaultStart;
				for (local i: [defaultStart: defaultEnd]) {
					args.append(CValue(
						kind:    CVALUE_RCONST,
						typedef: funArgs[defaultArgsFirst + i].first,
						data:    funType.defaults[i],
						offset:  0));
				}
			} else {
				checker.warn("-Wcall",
					f"Too few arguments in function call: need at least "
					f"`{defaultArgsFirst}', but only got `{#args}'");
			}
		}

		/* Cast arguments to their proper types if not done so already. */
		if (mustCastArgs) {
			args = List(args);
			for (local i: [:#funArgs]) {
				args[i] = args[i].cast(funArgs[i].first);
			}
		}

		/* Only do static checks if not inside of a dead code region. */
		if (!checker.isUnreachable) {
			/* Check if the called function requires its caller to have a certain tag. */
			local reqTag: string | none = typeref.attrib.get("require_caller_tag");
			if (reqTag !is none) {
				local callerTag: string | none = checker.currentFunctionTypeRef.attrib.get("tag");
				if (callerTag is none) {
					checker.warn("-Wtag",
						f"Function `{checker.currentFunctionName}' needs "
						f"`__attribute__((tag({repr reqTag})))'");
				} else if (reqTag != callerTag) {
					checker.warn("-Wtag",
						f"Function `{checker.currentFunctionName}' is tagged as "
						f"`__attribute__((tag({repr callerTag})))', but needs "
						f"`__attribute__((tag({repr reqTag})))'");
				}
			}

			/* Verify the nothrow-attribute of the  called function (and since we  know
			 * the typing and attributes of all arguments used in the call, we can also
			 * resolve *-prefixed nothrow levels!) */
			local calleeNothrow: string | none = typeref.attrib.get("nothrow");
			if (calleeNothrow !is none) {
				local calleeNothrowLevel: int;
				if (calleeNothrow.startswith("*")) {
#define NO_LEVEL (-9999999999)
					calleeNothrowLevel = NO_LEVEL;

					/* Scan the argument list for pointers with nothrow arguments. */
					for (local arg: args) {
						local argType: CType = arg.typeref.typ;
						if (argType is CPointerType) {
							local pointerBaseTypeRef: CTypeRef = argType.base;
							local pointerNothrow = pointerBaseTypeRef.attrib.get("nothrow");
							if (pointerNothrow !is none) {
								pointerNothrow = int(pointerNothrow);
								if (calleeNothrowLevel < pointerNothrow)
									calleeNothrowLevel = pointerNothrow;
							}
						}
					}

					/* If we didn't find a nothrow level, use the function's default. */
					if (calleeNothrowLevel == NO_LEVEL)
						calleeNothrowLevel = int(calleeNothrow[1:]);
#undef NO_LEVEL
				} else {
					calleeNothrowLevel = int(calleeNothrow);
				}

				/* Remember the greatest called nothrow level. */
				local lastNothrowLevel = checker.currentFunctionGreatestCalleNothrowLevel;
				if (lastNothrowLevel is none) {
					checker.currentFunctionGreatestCalleNothrowLevel = calleeNothrowLevel;
				} else if (lastNothrowLevel !== false) {
					if (lastNothrowLevel < calleeNothrowLevel)
						checker.currentFunctionGreatestCalleNothrowLevel = calleeNothrowLevel;
				}

				/* A warning will be issued if a nothrow function is called by another function
				 * that also has a nothrow attribute,  and whose nothrow attribute specifies  a
				 * level that is smaller than the called function. */
				local currentFunctionNothrow: string | none =
					checker.currentFunctionTypeRef.attrib.get("nothrow");
				if (currentFunctionNothrow !is none) {
					local currentFunctionNothrowLevel: int = int(currentFunctionNothrow.lstrip("*"));
					if (currentFunctionNothrowLevel < calleeNothrowLevel) {
						checker.warn("-Wnothrow",
							f"Call to `{getPrettyNothrowLevelName(calleeNothrowLevel)}'-function "
							f"in function `{checker.currentFunctionName}' marked as "
							f"`{getPrettyNothrowLevelName(currentFunctionNothrowLevel)}'");
					}
				}
			} else {
				/* Remember that a function was called without a nothrow level */
				checker.currentFunctionGreatestCalleNothrowLevel = false;
			}
		}

		/* Evaluate the function's return value
		 * TODO: support for `inline',  which is then  handled
		 *       by evaluating the function's body while using
		 *       fixed constants for arguments. */
		if (!isConstExpr) {
			MAKE_VOID();
		}
		typeref = CTypeRef(funType.returnType);
		TRACE();
		return this;
	}

}

global final C_char_typeref: CTypeRef = CTypeRef(C_char);

@@Construct a CValue object in the form of an array-of-char
@@for   a  deemon  @Bytes  or  sequence-of-integer  object.
function cvalueFromBytesAsString(s: Bytes): CValue {
	return CValue(
			kind:    CVALUE_RCONST,
			typeref: CTypeRef(CArrayType(C_char, #s, 1), CTYPEREF_FLAG_CONST),
			data:    s,
			offset:  0);
}

@@Wrapper for @cvalueFromBytesAsString for the purpose of encoding strings
function cvalueFromString(s: string): CValue {
	return cvalueFromBytesAsString((s + "\0").encode("utf-8"));
}

function cvalueFromValue(checker: Checker, typeref: CTypeRef, value: int | float): CValue {
	return CValue(
			kind:    CVALUE_RCONST,
			typeref: typeref,
			data:    typeref.typ.bytes(checker, value),
			offset:  0);
}

function cvalueFromSymbol(sym: CSymbol): CValue {
	return CValue(
			kind:    CVALUE_LSYMBOL,
			typeref: sym.typeref,
			data:    sym,
			offset:  0);
}

global final C_bool_typeref: CTypeRef = CTypeRef(C_bool);
global final C_false: CValue = CValue(kind: CVALUE_RCONST, typeref: C_bool_typeref, data: Bytes({ 0 }), offset: 0);
global final C_true:  CValue = CValue(kind: CVALUE_RCONST, typeref: C_bool_typeref, data: Bytes({ 1 }), offset: 0);
global final C_nullptr_32: CValue = CValue(kind: CVALUE_RCONST, typeref: CTypeRef(C_nullptr_t_32), data: Bytes({ 0, 0, 0, 0 }), offset: 0);
global final C_nullptr_64: CValue = CValue(kind: CVALUE_RCONST, typeref: CTypeRef(C_nullptr_t_64), data: Bytes({ 0, 0, 0, 0, 0, 0, 0, 0 }), offset: 0);

final class CScope: CNamespace {
	this = super;
	@@Symbol value overrides (for when a function overrides the value of a pre-defined symbol)
	public member symbolValues: {CSymbol: Bytes | none} = UniqueDict();
}
