/* Copyright (c) 2019-2024 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2024 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
import * from ..c.ppexpr;
import * from ..c.parser;
import * from deemon;
import fs;

/* CimPPlify -- Simply C source code by doing a partial preprocessor  pass.
 * For this purpose, you can specify a set of macros that can be assumed to
 * always/never be defined, as well as optionally remove comments.
 *
 * Usage:
 * $ deemon simplify.dee def/i386-kos-userspace.h < ../../../include/math.h > out.h
 *
 */

class SimpFunctionMacro {
	this = default;

	@@Macro argument names
	public member argv: {UserString | string...} = [];

	@@Macro function body
	public member body: UserString;

	@@Expand arguments and generate a proper body using the given @args
	function expandWithArguments(args: {UserString | string...}): string {
		local fp = File.Writer();
		local parser = CParser(this.body);
		local tok = parser.next();
		local text = parser.text;
		local flushStart = parser.tokStart;
		function getArgumentByName(name: string): string | none {
			if (name == "__VA_ARGS__")
				name = "...";
			local index = this.argv.find(name);
			if (index < 0)
				return none;
			if (index >= #args)
				return "";
			if (name == "...")
				return ",".join(args[index:]);
			return args[index];
		}
		while (tok) {
			if (tok.issymbol()) {
				local repl = getArgumentByName(tok);
				if (repl !is none) {
					fp << text[flushStart:parser.tokStart] << repl;
					flushStart = parser.tokEnd;
				}
			} else {
				switch (tok) {
				case "#":
					if (text.startswith("##", parser.tokStart)) {
						/* Concat */
						local flushEnd = parser.tokStart;
						while (flushEnd > flushStart && text.isspace(flushEnd - 1))
							--flushEnd;
						fp << text[flushStart:flushEnd];
						parser.tokEnd = flushEnd + 2;
						tok = parser.next();
						flushStart = parser.tokStart;
						continue;
					} else {
						/* Stringify */
						local flushEnd = parser.tokStart;
						tok = parser.next();
						if (!tok.issymbol())
							continue;
						local repl = getArgumentByName(tok);
						if (repl is none)
							continue;
						fp << text[flushStart:flushEnd] << repr(repl);
						tok = parser.next();
						flushStart = parser.tokStart;
						continue;
					}
					break;
				default:
					break;
				}
			}
			tok = parser.next();
		}
		if (flushStart < parser.end)
			fp << text[flushStart:parser.end];
		return fp.string;
	}

}

class SimpConfig {
	this = default;

	@@Used internally to prevent infinite macro expansion
	public member _activeMacroExpansions: {string...} = HashSet();

	@@Set to @true to  remove comments, and unnecessary  whitespace.
	@@However, do keep line-feeds, so-long as they appear right next
	@@to each other.
	public member truncateOutput: bool = true;

	@@Macros that are always/never defined or defined as something specific:
	@@ - @true:   Always  defined,  but  actual  value  is  unknown.  This  option
	@@            will allow the macro to replaced in `#ifdef x` and `defined(x)`,
	@@            but will cause it to be  left alone when encountered outside  of
	@@            such a context.
	@@ - @false:  Similar to @true, but the macro is assumed to never be defined.
	@@            This results in  `defined(x)` to always  be replaced with  `0`,
	@@            and `#ifdef x` to be the same as `#if 0`
	@@ - @string: The  replacement text  of the macro.  The macro is  assumed to be
	@@            defined, similar to when @true is used, but will also be replaced
	@@            with this  string, before  being re-interpreted  once again  when
	@@            encountered elsewhere.
	@@ - @SimpFunctionMacro: Similar to @string, but describe a function-like macro
	public member macros: {string: SimpFunctionMacro | string | bool} = Dict();

	@@A sorted list of prefixes for macros that aren't defined
	@@This list is only used when a macro name could not be found in @macros
	public member undefMacrosStartsWith: {string...} = [];

	@@Set of  keywords  (stripped  of  leading/trailing  '_')
	@@for which __has_builtin() evaluates to a given constant
	public member known___has_builtin: {string: int} = Dict();

	@@Return the definition of a macro, given its name
	@@If no definition  exists, return @none  instead.
	function getMacroDefinition(name: string)
			: SimpFunctionMacro | string | bool | none {
		local result = macros.get(name);
		if (result !is none)
			return result;
		local lo = 0, hi = #undefMacrosStartsWith;
		while (lo < hi) {
			local index = (lo + hi) / 2;
			local sName = undefMacrosStartsWith[index];
			if (name.startswith(sName))
				return false;
			if (name < sName) {
				hi = index;
			} else /*if (name > sName)*/ {
				lo = index + 1;
			}
		}
		return none;
	}
}


global _simpPpParse;
global _simpPpParseAfter_prod;
global _simpPpParseAfter_sum;
global _simpPpParseAfter_shift;
global _simpPpParseAfter_cmp;
global _simpPpParseAfter_cmpeq;
global _simpPpParseAfter_bitand;
global _simpPpParseAfter_bitxor;
global _simpPpParseAfter_bitor;
global _simpPpParseAfter_land;
global _simpPpParseAfter_lor;
global _simpPpParseAfter_cond;

#if 0
#define ASSERT(expr)              assert expr
#define ASSERT_AFTER_TOK(toks...) assert self.tok in toks
#else
#define ASSERT(expr)              none
#define ASSERT_AFTER_TOK(toks...) none
#endif

function _simpPpParse_unary(self: CParser, config: SimpConfig): PPBranch {
again:
	local tok = self.tok;
	local result;
	switch (tok) {

	case "":
		break;

	case "(":
		self.next();
		result = _simpPpParse(self, config);
		self.skip(")");
		return result;

	case "!":
		self.next();
		return PPBranch(BRT_NOT, _simpPpParse_unary(self, config));

	case "~":
		self.next();
		return PPBranch(BRT_INV, _simpPpParse_unary(self, config));

	case "+":
		self.next();
		goto again;

	case "-":
		self.next();
		return PPBranch(BRT_NEG, _simpPpParse_unary(self, config));

	case "__has_builtin": {
		local origTokStart = self.tokStart;
		tok = self.next();
		local hasParen: bool = tok == "(";
		if (hasParen)
			tok = self.next();
		if (!tok.issymbol())
			self.err(f"Expected keyword for '__has_builtin(...)', but got {repr tok}");
		self.next();
		if (hasParen)
			self.skip(")");
		tok = str(tok).strip("_");
		local val = config.known___has_builtin.get(tok);
		if (val !is none)
			return PPBranch(BRT_CONST, val);
		self.tokEnd = origTokStart;
		self.next();
	}	break;

	case "defined": {
		tok = self.next();
		local hasParen: bool = tok == "(";
		if (hasParen)
			tok = self.next();
		if (!tok.issymbol())
			self.err(f"Expected keyword for 'defined(...)', but got {repr tok}");
		self.next();
		if (hasParen)
			self.skip(")");
		local macDef = config.getMacroDefinition(tok);
		if (macDef is none)
			return PPBranch(BRT_DEFINED, tok);
		return PPBranch(BRT_CONST, macDef === false ? 0 : 1);
	}	break;

	default:
		if (tok.isnumeric(0)) {
			/* Integer constant */
			try {
				result = int(tok.rstrip("uUlL"));
			} catch (Error as e) {
				self.err(e.message);
			}
			self.next();
do_return_const:
			return PPBranch(BRT_CONST, result);
		} else if (tok[0] == "'") {
			/* Character literal */
			try {
				tok = tok.decode("c-escape");
			} catch (Error as e) {
				self.err(e.message);
			}
			if (!tok)
				self.err("Empty character literal");
			result = 0;
			for (local o: tok.ordinals)
				result = (result << 8) | o;
			self.next();
			goto do_return_const;
		}
		break;
	}
	if (!tok.issymbol())
		self.err(f"Unexpected token in preprocessor expression: {repr tok}");
	/* Check for a known macro. */
	{
		local macDef = config.getMacroDefinition(tok);
		if (macDef !is none) {
			if (macDef is string || macDef is UserString) {
				local innserParser = CParser(macDef);
				innserParser.next();
				result = _simpPpParse_unary(innserParser, config);
				if (innserParser.tok) {
					innserParser.err(
						f"Cannot parse garbage after expression: "
						f"{repr innserParser.text[innserParser.tokStart:]}"
					);
				}
				self.next();
				return result;
			} else if (macDef is SimpFunctionMacro) {
				local escapeStart = self.tokStart;
				local escapeEnd = self.tokEnd;
				tok = self.next();
				if (tok == "(") {
					local args = [];
					tok = self.next();
					if (tok != ")") {
						local argStart = self.tokStart;
						local argEnd = argStart;
						tok = self.next();
						while (tok != ")") {
							if (!tok)
								self.errAt(argStart, "Incomplete macro argument");
							while (tok in "([{<") {
								self.skipPair();
								argEnd = self.tokEnd;
								tok = self.next();
							}
							if (tok == ",") {
								args.append(self.getUserString(argStart, argEnd));
								tok = self.next();
								argStart = self.tokStart;
								argEnd = argStart;
							} else {
								argEnd = self.tokStart;
								tok = self.next();
							}
						}
						args.append(self.getUserString(argStart, argEnd));
					}
					local innserParser = CParser(macDef.expandWithArguments(args));
					innserParser.next();
					result = _simpPpParse_unary(innserParser, config);
					if (innserParser.tok) {
						innserParser.err(
							f"Cannot parse garbage after expression: "
							f"{repr innserParser.text[innserParser.tokStart:]}"
						);
					}
					return result;
				}
				while (tok in "([{<") {
					self.skipPair();
					escapeEnd = self.tokEnd;
					tok = self.next();
				}
				return PPBranch(BRT_UNDEF, self.text[escapeStart:escapeEnd]);
			}
		}
	}

	/* Fallback: Return a BRT_UNDEF branch. */
	{
		local escapeStart = self.tokStart;
		local escapeEnd = self.tokEnd;
		tok = self.next();
		while (tok in "([{<") {
			self.skipPair();
			escapeEnd = self.tokEnd;
			tok = self.next();
		}
		return PPBranch(BRT_UNDEF, self.text[escapeStart:escapeEnd]);
	}
}

#define DEFINE_PARSER_FUNCTION(name, before, is_suffix_token...)                \
	function _simpPpParse_##name(self: CParser, config: SimpConfig): PPBranch { \
		local result = _simpPpParse_##before(self, config);                     \
		if (self.tok is_suffix_token)                                           \
			return _simpPpParseAfter_##name(self, config, result);              \
		return result;                                                          \
	}
DEFINE_PARSER_FUNCTION(prod, unary, in ["*", "/", "%"])
DEFINE_PARSER_FUNCTION(sum, prod, in ["+", "-"])
DEFINE_PARSER_FUNCTION(shift, sum, in ["<<", ">>"])
DEFINE_PARSER_FUNCTION(cmp, shift, in ["<", "<=", ">", ">="])
DEFINE_PARSER_FUNCTION(cmpeq, cmp, in ["==", "!="])
DEFINE_PARSER_FUNCTION(bitand, cmpeq, == "&")
DEFINE_PARSER_FUNCTION(bitxor, bitand, == "^")
DEFINE_PARSER_FUNCTION(bitor, bitxor, == "|")
DEFINE_PARSER_FUNCTION(land, bitor, == "&&")
DEFINE_PARSER_FUNCTION(lor, land, == "||")
DEFINE_PARSER_FUNCTION(cond, lor, == "?")
#undef DEFINE_PARSER_FUNCTION


function _simpPpParseAfter_prod(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["*", "/", "%"]);
	do {
		local what = {
			"*" : BRT_PROD,
			"/" : BRT_DIV,
			"%" : BRT_MOD,
		}[self.tok];
		self.next();
		base = PPBranch(what, { base, _simpPpParse_unary(self, config) });
	} while (self.tok in ["*", "/", "%"]);
	return base;
}

function _simpPpParseAfter_sum(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["+", "-"]);
	do {
		local isNeg = self.tok == "-";
		self.next();
		local other = _simpPpParse_prod(self, config);
		if (isNeg)
			other = PPBranch(BRT_NEG, other);
		base = PPBranch(BRT_SUM, { base, other });
	} while (self.tok in ["+", "-"]);
	return base;
}

function _simpPpParseAfter_shift(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["<<", ">>"]);
	do {
		local what = {
			"<<" : BRT_SHL,
			">>" : BRT_SHR,
		}[self.tok];
		self.next();
		base = PPBranch(what, { base, _simpPpParse_sum(self) });
	} while (self.tok in ["+", "-"]);
	return base;
}

function _simpPpParseAfter_cmp(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["<", "<=", ">", ">="]);
	do {
		local what, isNot = {
			"<"  : (BRT_LO, false),
			"<=" : (BRT_LE, false),
			">"  : (BRT_LE, true),
			">=" : (BRT_LO, true),
		}[self.tok]...;
		self.next();
		base = PPBranch(what, { base, _simpPpParse_shift(self, config) });
		if (isNot)
			base = PPBranch(BRT_NOT, base);
	} while (self.tok in ["<", "<=", ">", ">="]);
	return base;
}

function _simpPpParseAfter_cmpeq(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["==", "!="]);
	do {
		local isNot = self.tok == "!=";
		self.next();
		base = PPBranch(BRT_EQ, { base, _simpPpParse_cmp(self, config) });
		if (isNot)
			base = PPBranch(BRT_NOT, base);
	} while (self.tok in ["==", "!="]);
	return base;
}

function _simpPpParseAfter_bitand(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["&"]);
	do {
		self.next();
		base = PPBranch(BRT_BITAND, { base, _simpPpParse_cmpeq(self, config) });
	} while (self.tok in ["&"]);
	return base;
}

function _simpPpParseAfter_bitxor(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["^"]);
	do {
		self.next();
		base = PPBranch(BRT_BITXOR, { base, _simpPpParse_bitand(self, config) });
	} while (self.tok in ["^"]);
	return base;
}

function _simpPpParseAfter_bitor(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["|"]);
	do {
		self.next();
		base = PPBranch(BRT_BITOR, { base, _simpPpParse_bitxor(self, config) });
	} while (self.tok in ["|"]);
	return base;
}

function _simpPpParseAfter_land(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["&&"]);
	do {
		self.next();
		base = PPBranch(BRT_ALL, { base, _simpPpParse_bitor(self, config) });
	} while (self.tok in ["&&"]);
	return base;
}

function _simpPpParseAfter_lor(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["||"]);
	do {
		self.next();
		base = PPBranch(BRT_ANY, { base, _simpPpParse_land(self, config) });
	} while (self.tok in ["||"]);
	return base;
}

function _simpPpParseAfter_cond(self: CParser, config: SimpConfig, base: PPBranch): PPBranch {
	ASSERT_AFTER_TOK(["?"]);
	self.next();
	local tt = _simpPpParse_lor(self, config);
	self.skip(":");
	local ff = _simpPpParse(self, config);
	return PPBranch(BRT_IFELSE, { base, tt, ff });
}

@@Parse and return a preprocessor expression
function _simpPpParse(self: string | UserString | CParser | File, config: SimpConfig): PPBranch {
	try {
		local result = _simpPpParse_unary(self, config);
		switch (self.tok) {

		case '*': case '/': case '%':
			result = _simpPpParseAfter_prod(self, config, result);
			if (self.tok in ["+", "-"]) {
		case "+": case "-":
				result = _simpPpParseAfter_sum(self, config, result);
			}
			if (self.tok in ["<<", ">>"]) {
		case "<<": case ">>":
				result = _simpPpParseAfter_shift(self, config, result);
			}
			if (self.tok in ["<", "<=", ">", ">="]) {
		case "<": case "<=": case ">": case ">=":
				result = _simpPpParseAfter_cmp(self, config, result);
			}
			if (self.tok in ["==", "!="]) {
		case "==": case "!=":
				result = _simpPpParseAfter_cmpeq(self, config, result);
			}
			if (self.tok in ["&"]) {
		case "&":
				result = _simpPpParseAfter_bitand(self, config, result);
			}
			if (self.tok in ["^"]) {
		case "^":
				result = _simpPpParseAfter_bitxor(self, config, result);
			}
			if (self.tok in ["|"]) {
		case "|":
				result = _simpPpParseAfter_bitor(self, config, result);
			}
			if (self.tok in ["&&"]) {
		case "&&":
				result = _simpPpParseAfter_land(self, config, result);
			}
			if (self.tok in ["||"]) {
		case "||":
				result = _simpPpParseAfter_lor(self, config, result);
			}
			if (self.tok in ["?"]) {
		case "?":
				result = _simpPpParseAfter_cond(self, config, result);
			}
			break;

		default:
			break;
		}
		return result;
	} catch (Error as e) {
		print "... while parsing expression string", repr(str(self));
		if (type(e) === Error)
			throw;
		if (self.tokStart !is bound)
			throw;
		print Traceback.current;
		self.err(e.message);
	}
}

function simpPpParse(
		self: string | UserString | CParser | File,
		config: SimpConfig): PPBranch | none {
	if (self !is CParser) {
		switch(str(self)) {
		case "0": return PPBranch(BRT_CONST, 0);
		case "1": return PPBranch(BRT_CONST, 1);
		default: break;
		}
		self = CParser(self);
		self.next();
	}
	local result = _simpPpParse(self, config);
	if (self.tok) {
//		print "Unexpected:", repr self.text[self.tokStart:];
		return none; /* Cannot fully parse expression */
	}
	return result;
}


@@Skip ahead until the next the "#" of the next "#else", "#elif" or "#endif"
@@directive,  returning  with  the  parser  set  to  select  the  "#" token.
@@@param: startPos: The starting index from where to start searching for directive.
function CParser_SkipPPBlock(self: CParser, startPos: int): string {
	local recursion = 0;
	self.tokEnd = startPos;
	self.next();
	local textText = self.text;
	for (;;) {
		local tok = self.tok;
		if (!tok)
			self.errAt(startPos, "Unclosed, inactive preprocessor block");
		if (tok != "#") {
			self.next();
			continue;
		}
		local directiveStart = self.tokEnd;
		local directiveEnd = textText.find("\n", directiveStart, self.end);
		if (directiveEnd < 0)
			directiveEnd = self.end;
		while (directiveStart < directiveEnd &&
		       textText.isspace(directiveStart))
			++directiveStart;
		while (directiveEnd > directiveStart &&
		       textText.isspace(directiveEnd - 1))
			--directiveEnd;
		if (directiveStart >= directiveEnd)
			goto next_directive; /* Empty directive */
		if (!textText.issymstrt(directiveStart)) {
			self.errAt(directiveStart,
				f"Expected keyword after '#', but got "
				f"{repr textText[directiveStart:directiveEnd]}"
			);
		}
		local directiveKeywordEnd = directiveStart + 1;
		while (directiveKeywordEnd < directiveEnd &&
		       textText.issymcont(directiveKeywordEnd))
			++directiveKeywordEnd;
		local directiveName = textText[directiveStart:directiveKeywordEnd];
		switch (directiveName) {
		case "if":
		case "ifdef":
		case "ifndef":
			++recursion;
			break;
		case "elif":
		case "else":
			if (!recursion)
				return directiveName;
			break;
		case "endif":
			if (!recursion)
				return directiveName;
			--recursion;
			break;
		default:
			break;
		}
next_directive:
		self.tokEnd = directiveEnd;
		self.next();
	}
}

function parseSimpConfigFile(
		text: string | UserString | CParser | File,
		config: SimpConfig | none = none): SimpConfig {
	local didCreateConfig = false;
	if (config is none) {
		config = SimpConfig();
		didCreateConfig = true;
	}
	if (text !is CParser) {
		text = CParser(text);
		text.next();
	}
	local textText = text.text;
	@@List of recursive ifdef-blocks:
	@@  true:  #else was encountered
	@@  false: #else wasn't encountered
	local ifdefBlocks: {bool...} = [];
	for (;;) {
		local tok = text.tok;
		if (!tok)
			break;
		if (tok != "#")
			text.err("Unexpected token in Simp config file");
		local directiveStart = text.tokEnd;
		local directiveEnd = textText.find("\n", directiveStart, text.end);
		if (directiveEnd < 0)
			directiveEnd = text.end;
		while (directiveStart < directiveEnd &&
		       textText.isspace(directiveStart))
			++directiveStart;
		while (directiveEnd > directiveStart &&
		       textText.isspace(directiveEnd - 1))
			--directiveEnd;
		if (directiveStart >= directiveEnd)
			goto next_directive; /* Empty directive */
		if (!textText.issymstrt(directiveStart)) {
			text.errAt(directiveStart,
				f"Expected keyword after '#', but got "
				f"{repr textText[directiveStart:directiveEnd]}"
			);
		}
		local directiveKeywordEnd = directiveStart + 1;
		while (directiveKeywordEnd < directiveEnd &&
		       textText.issymcont(directiveKeywordEnd))
			++directiveKeywordEnd;
		local directiveName = textText[directiveStart:directiveKeywordEnd];
		local directiveArgsStart = directiveKeywordEnd;
		while (directiveArgsStart < directiveEnd &&
		       textText.isspace(directiveArgsStart))
			++directiveArgsStart;
		switch (directiveName) {

		case "pragma": {
			if (directiveArgsStart >= directiveEnd ||
			    !textText.issymstrt(directiveArgsStart))
				break;
			local pragmaNameEnd = directiveArgsStart + 1;
			while (pragmaNameEnd < directiveEnd &&
			       textText.issymcont(pragmaNameEnd))
				++pragmaNameEnd;
			local pragmaName = textText[directiveArgsStart:pragmaNameEnd];
			local pragmaBodyStart = pragmaNameEnd;
			while (pragmaBodyStart < directiveEnd &&
			       textText.isspace(pragmaBodyStart))
				++pragmaBodyStart;
			switch (pragmaName) {

			case "defined": {
				/* #pragma defined FOO
				 * Instruct CimPPlify that a given macro FOO is defined, but it's
				 * exact definition is unknown, meaning that "defined(FOO) == 1",
				 * but FOO itself will not be replaced during expansion. */
				local macName = textText[pragmaBodyStart:directiveEnd];
				if (!macName.issymbol()) {
					text.errAt(pragmaBodyStart,
						f"Expected a keyword after #pragma defined, "
						f"but got {repr macName}"
					);
				}
				local oldDef = config.macros.get(macName);
				if (oldDef is none || oldDef === false) {
					if (oldDef !is none && oldDef !== true) {
						text.warnAt(directiveArgsStart,
							f"Macro {repr macName} re-definition "
							f"(old: {oldDef}, new: {true})"
						);
					}
					config.macros[macName] = true;
				}
			}	break;

			case "undef":
			case "define": {
				local nsNameEnd = pragmaBodyStart + 1;
				while (nsNameEnd < directiveEnd &&
				       textText.issymcont(nsNameEnd))
					++nsNameEnd;
				local namespaceName = textText[pragmaBodyStart:nsNameEnd];
				pragmaBodyStart = nsNameEnd;
				while (pragmaBodyStart < directiveEnd &&
				       textText.isspace(pragmaBodyStart))
					++pragmaBodyStart;
				local keyNameStart = pragmaBodyStart;
				local keyNameEnd = directiveEnd;
				if (keyNameStart < keyNameEnd &&
				    textText[keyNameStart] == "(" &&
				    textText[keyNameEnd - 1] == ")") {
					++keyNameStart;
					--keyNameEnd;
					while (keyNameStart < keyNameEnd && textText.isspace(keyNameStart))
						++keyNameStart;
					while (keyNameEnd > keyNameStart && textText.isspace(keyNameEnd - 1))
						--keyNameEnd;
				}
				local keyName = textText[keyNameStart:keyNameEnd];
				if (!keyName || !keyName.issymbol()) {
					text.errAt(keyNameStart,
						f"Expected keyword as argument for "
						f"#pragma define|undef <NS>, but got {repr keyName}"
					);
				}
				local ns: {string: int};
				switch (namespaceName) {
				case "__has_builtin":
					ns = config.known___has_builtin;
					break;
				default:
					text.errAt(pragmaBodyStart, f"Unknown namespace {repr namespaceName}");
					break;
				}
				ns[keyName.strip("_")] = { "define" : 1, "undef" : 0 }[pragmaName];
			}	break;

			default:
				break;
			}
		}	break;

		case "if":
		case "ifdef":
		case "ifndef": {
parse_if_expression:
			local expr;
			if (directiveName == "if") {
				expr = text.getUserString(directiveArgsStart, directiveEnd);
			} else {
				expr = f"defined({textText[directiveArgsStart:directiveEnd]})";
				if (directiveName == "ifndef")
					expr = "!" + expr;
			}
			expr = simpPpParse(expr, config).optimize();
			if (expr is none) {
				text.errAt(directiveArgsStart,
					f"Cannot parse PP-expression {
						repr textText[directiveArgsStart:directiveEnd]
					}");
			}
			if (expr.typ != BRT_CONST) {
				text.errAt(directiveArgsStart,
					f"Cannot reduce PP-expression to constant. "
					f"(Best I can do is {repr expr.tostr()})");
			}
			expr = expr.data;
			if (!expr) {
				/* Skip PP-block. */
				local tail = CParser_SkipPPBlock(text, directiveEnd);
				if (tail == "else") {
					/* Fallthru to push an active #if-block */
					ifdefBlocks.append(true);
					directiveStart = text.tokEnd;
					directiveEnd = textText.find("\n", directiveStart, text.end);
					if (directiveEnd < 0)
						directiveEnd = text.end;
					goto next_directive;
				} else if (tail == "elif") {
					/* Parse this expression instead. */
					directiveStart = text.tokEnd;
					directiveEnd = textText.find("\n", directiveStart, text.end);
					if (directiveEnd < 0)
						directiveEnd = text.end;
					while (directiveStart < directiveEnd &&
					       textText.isspace(directiveStart))
						++directiveStart;
					while (directiveEnd > directiveStart &&
					       textText.isspace(directiveEnd - 1))
						--directiveEnd;
					if (directiveStart >= directiveEnd)
						goto next_directive; /* Empty directive */
					if (!textText.issymstrt(directiveStart)) {
						text.errAt(directiveStart,
							f"Expected keyword after '#', but got "
							f"{repr textText[directiveStart:directiveEnd]}");
					}
					directiveKeywordEnd = directiveStart + 1;
					while (directiveKeywordEnd < directiveEnd &&
					       textText.issymcont(directiveKeywordEnd))
						++directiveKeywordEnd;
					directiveName = textText[directiveStart:directiveKeywordEnd];
					directiveArgsStart = directiveKeywordEnd;
					while (directiveArgsStart < directiveEnd &&
					       textText.isspace(directiveArgsStart))
						++directiveArgsStart;
					directiveName = "if";
					goto parse_if_expression;
				} else if (tail == "endif") {
					/* The block was fully skipped */
					directiveEnd = text.tokEnd;
					directiveEnd = textText.find("\n", directiveEnd, text.end);
					if (directiveEnd < 0)
						directiveEnd = text.end;
					goto next_directive;
				} else {
					/* Shouldn't get here. */
					assert false, "tail = " + repr(tail);
				}
			}
			/* Push an active #if-block */
			ifdefBlocks.append(false);
		}	break;

		case "elif":
		case "else": {
			if (!ifdefBlocks)
				text.errAt(directiveStart, "#else or #elif without #if");
			if (ifdefBlocks.last)
				text.errAt(directiveStart, "#else or #elif after #else");
			if (directiveName == "else")
				ifdefBlocks.last = true;
			/* Only get here after the preceding block was active, so always skip! */
			CParser_SkipPPBlock(text, directiveEnd);
			goto continue_parsing;
		}	break;

		case "endif": {
			if (!ifdefBlocks)
				text.errAt(directiveStart, "#endif without #if");
			ifdefBlocks.popback();
		}	break;

		case "include": {
			local filename = textText[directiveArgsStart:directiveEnd];
			if (filename.startswith("<") && filename.endswith(">")) {
				/* Include relative to $KOS_PROJECT_ROOT/kos/include */
				filename = fs.joinpath(fs.headof(__FILE__), "../../../include", filename[1:-1]);
			} else if (filename.startswith("\"") && filename.endswith("\"")) {
				/* Include relative to the directory of the current file */
				filename = fs.joinpath(fs.headof(text.filename), filename[1:-1]);
			} else {
				text.errAt(directiveArgsStart,
					f"Invalid filename {repr filename} after #include");
			}
			/* Recursively include and parse. */
			parseSimpConfigFile(File.open(filename), config);
		}	break;

		case "undef": {
			local macName = textText[directiveArgsStart:directiveEnd];
			local undefAll = false;
			if (macName.endswith("*")) {
				undefAll = true;
				macName = macName[:-1].rstrip();
			}
			if (!macName || !macName.issymbol()) {
				text.errAt(directiveArgsStart,
					f"Expected symbol name after '#undef', but got {repr macName}");
			}
			if (undefAll) {
				config.undefMacrosStartsWith.append(macName);
			} else {
				config.macros[macName] = false;
			}
		}	break;

		case "define":
		case "xdefine": {
			if (directiveArgsStart >= directiveEnd ||
			    !textText.issymstrt(directiveArgsStart)) {
				text.errAt(directiveArgsStart,
					f"Expected symbol name after '#define', but "
					f"got {repr textText[directiveArgsStart:directiveEnd]}"
				);
			}
			local macNameEnd = directiveArgsStart + 1;
			while (macNameEnd < directiveEnd &&
			       textText.issymcont(macNameEnd))
				++macNameEnd;
			local macName = textText[directiveArgsStart:macNameEnd];
			local macBodyStart = macNameEnd;
			while (macBodyStart < directiveEnd && textText.isspace(macBodyStart))
				++macBodyStart;
			local macDef;
			if (macNameEnd >= directiveEnd) {
				/* `#define foo' */
				macDef = "";
			} else if (macBodyStart == macNameEnd && textText[macBodyStart] == "(") {
				/* Function-like macro */
				local macArgvEnd = textText.find(")", macBodyStart, directiveEnd);
				if (macArgvEnd < 0)
					text.errAt(macBodyStart, f"Missing `)' after `#define {macName}(...");
				local macroArgv = Tuple(textText[macBodyStart+1:macArgvEnd]
					.split(",").each.strip());
				++macArgvEnd;
				while (macArgvEnd < directiveEnd && textText.isspace(macArgvEnd))
					++macArgvEnd;
				macDef = SimpFunctionMacro(
					argv: macroArgv,
					body: textText[macArgvEnd:directiveEnd]);
			} else {
				/* Normal macro */
				macDef = text.getUserString(macBodyStart, directiveEnd);
				if (macDef == macName)
					macDef = false; /* Define as itself. -> Same as "#pragma defined FOO" */
			}
			local oldDef = config.macros.get(macName);
			if (oldDef !is none && (type(oldDef) !== type(macDef) || oldDef != macDef)) {
				/* Don't warn if the old definition was that it was defined  as
				 * ~something~, when we now know exactly what it is defined as! */
				if (oldDef !== true) {
					if (directiveName == "xdefine")
						break; /* Ignore re-definition */
					text.warnAt(directiveArgsStart,
						f"Macro {repr macName} re-definition "
						f"(old: {oldDef}, new: {macDef})");
				}
			}
			config.macros[macName] = macDef;
		}	break;

		default:
			text.errAt(directiveStart, f"Unsupported directive {repr directiveName}");
			break;
		}
next_directive:
		text.tokEnd = directiveEnd;
		text.next();
continue_parsing:
		;
	}
	if (ifdefBlocks)
		text.err(f"Unclosed #if-blocks ({#ifdefBlocks} in total)");
	if (didCreateConfig)
		config.undefMacrosStartsWith.sort();
	return config;
}



/* Type annotation for object types used to represent C-file elements.
 * For the purpose of simplification, a C file is split into a tree of
 * #if-branches containing `{SimpPPElem...}' which in turn can contain
 * more PP-branches.
 *
 * TODO: Add  more  handling here  to  detct macro-pairs  that  can be
 *       optimized away  when  appearing  next  to  each  other  (e.g.
 *       `__NAMESPACE_STD_(ENTER|LEAVE)'), as well as `extern "..." {'
 *       and `}' pairs. */
#define SimpPPElem SimpPPIfCapsule | string

class SimpPPIfCapsule {
	this = default;

	@@The preprocessor #if-condition string
	public member cond: string;

	@@tt-body
	public member tt: {SimpPPElem...};

	@@ff-body
	public member ff: {SimpPPElem...};
}


function isBackslashEscaped(text: string, loc: int): bool {
	local isEscaped = false;
	while (loc && text[loc - 1] == "\\") {
		isEscaped = !isEscaped;
		--loc;
	}
	return isEscaped;
}

function findNonBackslashEscapedEOL(text: string, start: int, end: int): int {
	local result = start;
	for (;;) {
		result = text.find("\n", result, end);
		if (result < 0)
			break;
		if (!isBackslashEscaped(text, result))
			break;
		++result;
	}
	return result;
}

function findNonEscapedEOL(text: string, start: int, end: int): int {
	local i = start;
	while (i < end) {
		local ch = text[i];
		if (ch == "\\") {
			i += 2;
			continue;
		}
		if (ch == "/") {
			++i;
			if (i >= end)
				return -1;
			ch = text[i];
			if (ch == "/")
				return findNonBackslashEscapedEOL(text, i + 1, end);
			if (ch == "*") {
				i = text.find("*/", i + 1, end);
				if (i < 0)
					return -1;
			}
			continue;
		}
		if (ch == "\n")
			return i;
		++i;
	}
	return -1;
}

global simpParseCFile_impl;
function simpParseCFile_impl2(input: CParser, config: SimpConfig): {SimpPPElem...} {
	local prevItem = none;
	/* Join adjacent string items */
	for (local item: simpParseCFile_impl(input, config)) {
		if (item is string) {
			if (prevItem is none) {
				prevItem = item;
			} else {
				prevItem += item;
			}
			continue;
		}
		if (prevItem !is none) {
			yield prevItem;
			prevItem = none;
		}
		yield item;
	}
	if (prevItem !is none)
		yield prevItem;
}

function simpParseCFile_impl(input: CParser, config: SimpConfig): {SimpPPElem...} {
	local flushStart = input.tokStart;
	local inputText = input.text;
	local tok = input.tok;
	while (tok) {
		if (tok.issymbol()) {
			if (tok !in config._activeMacroExpansions) {
				/* Lookup+expand known macros. */
				local macro = config.macros.get(tok);
				if (macro is string || macro is UserString) {
					if (flushStart < input.tokStart)
						yield inputText[flushStart:input.tokStart].replace("\\\n", "");
					config._activeMacroExpansions.insert(tok);
					local expandParser = CParser(macro);
					expandParser.next();
					yield simpParseCFile_impl(expandParser, config)...;
					if (expandParser.tok)
						expandParser.err("Unmatched #else, #endif or #elif");
					config._activeMacroExpansions.remove(tok);
					flushStart = input.tokEnd;
					tok = input.next();
					continue;
				}
				if (macro is SimpFunctionMacro) {
					local macroName = tok;
					local macNameStart = input.tokStart;
					tok = input.next();
					if (tok != "(")
						continue;
					if (flushStart < macNameStart)
						yield inputText[flushStart:macNameStart].replace("\\\n", "");
					local macroArgv = [];
do_next_function_macro_argument:
					tok = input.next();
					local currentArgumentStart = input.tokStart;
					local currentArgumentEnd = currentArgumentStart;
					while (tok != ")") {
						if (tok in "([{<") {
							input.skipPair();
							currentArgumentEnd = input.tokEnd;
							tok = input.next();
							continue;
						}
						if (!tok)
							input.errAt(macNameStart, "Macro parameter list not closed");
						if (tok == ",") {
							macroArgv.append(inputText[currentArgumentStart:currentArgumentEnd]);
							goto do_next_function_macro_argument;
						}
						currentArgumentEnd = input.tokEnd;
						tok = input.next();
					}
					macroArgv.append(inputText[currentArgumentStart:currentArgumentEnd]);
					macro = macro.expandWithArguments(macroArgv);
					config._activeMacroExpansions.insert(macroName);
					local expandParser = CParser(macro);
					expandParser.next();
					yield simpParseCFile_impl(expandParser, config)...;
					if (expandParser.tok)
						expandParser.err("Unmatched #else, #endif or #elif");
					config._activeMacroExpansions.remove(macroName);
					flushStart = input.tokEnd;
					tok = input.next();
					continue;
				}
			}
			tok = input.next();
			continue;
		}
		if (tok != "#") {
			tok = input.next();
			continue;
		}
		/* Directive */
		local directiveStart = input.tokEnd;
		local directiveEnd = findNonEscapedEOL(inputText, directiveStart, input.end);
		if (directiveEnd < 0)
			directiveEnd = input.end;
		while (directiveStart < directiveEnd && inputText.isspace(directiveStart))
			++directiveStart;
		while (directiveEnd > directiveStart && inputText.isspace(directiveEnd - 1))
			--directiveEnd;
		if (directiveStart >= directiveEnd)
			goto next_directive; /* Empty directive */
		if (!inputText.issymstrt(directiveStart)) {
			tok = input.next();
			continue;
		}
		local directiveKeywordEnd = directiveStart + 1;
		while (directiveKeywordEnd < directiveEnd && inputText.issymcont(directiveKeywordEnd))
			++directiveKeywordEnd;
		local directiveName = inputText[directiveStart:directiveKeywordEnd];
		local directiveArgsStart = directiveKeywordEnd;
		while (directiveArgsStart < directiveEnd && inputText.isspace(directiveArgsStart))
			++directiveArgsStart;
		switch (directiveName) {

		case "if":
		case "ifdef":
		case "ifndef": {
			if (flushStart < input.tokStart)
				yield inputText[flushStart:input.tokStart].replace("\\\n", "");
			local capsule = inputText[directiveArgsStart:directiveEnd].replace("\\\n", "");
			if (directiveName != "if") {
				capsule = f"defined({capsule})";
				if (directiveName == "ifndef")
					capsule = "!" + capsule;
			}
			capsule = SimpPPIfCapsule(cond: capsule);
			local lastCapsule = capsule;

			/* Load the first token after the directive. */
parse_ppif_body:
			input.tokEnd = directiveEnd;
			input.next();
			lastCapsule.tt = List(simpParseCFile_impl2(input, config));
			if (input.tok != "#")
				input.errAt(directiveStart, "Unmatched #if");
			directiveStart = input.tokEnd;
			directiveEnd = findNonEscapedEOL(inputText, directiveStart, input.end);
			if (directiveEnd < 0)
				directiveEnd = input.end;
			while (directiveStart < directiveEnd && inputText.isspace(directiveStart))
				++directiveStart;
			while (directiveEnd > directiveStart && inputText.isspace(directiveEnd - 1))
				--directiveEnd;
			directiveKeywordEnd = directiveStart + 1;
			while (directiveKeywordEnd < directiveEnd && inputText.issymcont(directiveKeywordEnd))
				++directiveKeywordEnd;
			directiveName = inputText[directiveStart:directiveKeywordEnd];
			directiveArgsStart = directiveKeywordEnd;
			while (directiveArgsStart < directiveEnd && inputText.isspace(directiveArgsStart))
				++directiveArgsStart;
			switch (directiveName) {

			case "elif": {
				local newCapsule = SimpPPIfCapsule(
					cond: inputText[directiveArgsStart:directiveEnd].replace("\\\n", ""));
				lastCapsule.ff = { newCapsule };
				lastCapsule = newCapsule;
				goto parse_ppif_body;
			}	break;

			case "else":
				input.tokEnd = directiveEnd;
				input.next();
				lastCapsule.ff = List(simpParseCFile_impl2(input, config));
				if (input.tok != "#")
					input.errAt(directiveStart, "Unmatched #else");
				directiveStart = input.tokEnd;
				directiveEnd = findNonEscapedEOL(inputText, directiveStart, input.end);
				if (directiveEnd < 0)
					directiveEnd = input.end;
				while (directiveStart < directiveEnd && inputText.isspace(directiveStart))
					++directiveStart;
				while (directiveEnd > directiveStart && inputText.isspace(directiveEnd - 1))
					--directiveEnd;
				directiveKeywordEnd = directiveStart + 1;
				while (directiveKeywordEnd < directiveEnd && inputText.issymcont(directiveKeywordEnd))
					++directiveKeywordEnd;
				directiveName = inputText[directiveStart:directiveKeywordEnd];
				if (directiveName != "endif")
					input.errAt(directiveStart,
						f"Unmatched #endif after #else, but got {repr directiveName}");
				break;

			case "endif":
				lastCapsule.ff = {}; /* empty... */
				break;

			default:
				input.errAt(directiveStart,
					f"Expected #endif, #else or #elif after #if, but got {repr directiveName}");
				break;
			}
			flushStart = directiveEnd;
			if (flushStart < input.end && inputText.islf(flushStart))
				++flushStart;

			/* Yield the outer-most pp-condition-capsule. */
			yield capsule;
		}	break;

		case "elif":
		case "else":
		case "endif":
			/* Must let the caller deal with these! */
			goto done;

		default:
			break;
		}
next_directive:
		input.tokEnd = directiveEnd;
		tok = input.next();
	}
done:
	if (flushStart < input.tokStart)
		yield inputText[flushStart:input.tokStart].replace("\\\n", "");
}

function simpParseCFile(input: CParser, config: SimpConfig): {SimpPPElem...} {
	local result = List(simpParseCFile_impl2(input, config));
	if (input.tok)
		input.err("Unmatched #else, #endif or #elif");
	return result;
}

function needSpaceBetween(tok1: string, tok2: string): bool {
	local tok1_issym = tok1.last.issymcont();
	local tok2_issym = tok2.issymcont(0);
	if (tok1_issym) {
		/* TODO: "(" is only needed after `#define foo' so-as to prevent
		 *       `#define foo (x)'   from   becoming    `#define foo(x)' */
		if (!tok2_issym && tok2.first !in "\"\'(")
			return false;
	} else {
		if (tok2_issym) {
			if (tok1 != ")")
				return false;
		} else {
			if (tok1.first in "\"\'" && tok2.first in "\"\'")
				return true;
			return false;
		}
	}
	return true;
}

class SimpOutputPrinter {
	this = default;
	public member output: File;
	public member config: SimpConfig;
	public member lastWasLf: bool = false;

	public function finish() {
		if (!lastWasLf) {
			output.write("\n");
			lastWasLf = true;
		}
	}

	public function writeTruncated(text: string, start: int = 0, end: int = -1) {
		local parser = CParser(text, start: start, end: end);
		local spaceStart = start;
		local prevTok = none;
		local tok = parser.next();
		if (parser.tokEnd <= spaceStart)
			return; /* Empty input */
		for (;;) {
			local tokStart = parser.tokStart;
			if (tokStart > spaceStart && !lastWasLf) {
				if (text.contains("\n", spaceStart, tokStart)) {
					output.write("\n");
					lastWasLf = true;
				} else if (prevTok && tok && needSpaceBetween(prevTok, tok)) {
					output.write(" ");
				}
			}
			spaceStart = parser.tokEnd;
			switch (tok) {

			case "":
				return;

			case "__attribute__": {
				/* Optimize:
				 * >> __attribute__((foo)) __attribute__((bar))
				 * Into:
				 * >> __attribute__((foo, bar)) */
				output.write(tok);
				output.write("((");
join_attribute_annotations:
				parser.next();
				parser.skip("(");
				tok = parser.skip("(");
				local ind = 0;
				prevTok = "(";
				while (tok) {
					if (tok == "(") {
						++ind;
					} else if (tok == ")") {
						if (!ind)
							break;
						--ind;
					}
					if (needSpaceBetween(prevTok, tok))
						output.write(" ");
					output.write(tok);
					prevTok = tok;
					tok = parser.next();
				}
				tok = parser.skip(")");
				tok = parser.skip(")");
				if (tok == "__attribute__") {
					output.write(",");
					goto join_attribute_annotations;
				}
				output.write("))");
				lastWasLf = false;
				continue;
			}	break;

			default:
				if (tok.startswith("\"")) {
handle_string_token:
					local nextTok = parser.next();
					if (nextTok.startswith("\"")) {
						tok = tok[:-1] + nextTok[1:];
						goto handle_string_token;
					}
					output.write(tok);
					lastWasLf = false;
					prevTok = tok;
					tok = nextTok;
					continue;
				}
				break;
			}
			output.write(tok);
			lastWasLf = false;
			prevTok = tok;
			tok = parser.next();
		}
	}

	public function write(text: string, start: int = 0, end: int = -1) {
		if (end < 0)
			end = #text;
		if (config.truncateOutput) {
			return writeTruncated(text, start, end);
		} else {
			output.write(text[start:end]);
		}
	}

	public function writeElements(elem: {SimpPPElem...}) {
		for (local e: elem) {
			if (e is SimpPPIfCapsule) {
				local cond = e.cond;
				if (cond.startswith("defined(") && cond.endswith(")") &&
				    cond.findmatch("(", ")", 8) == #cond - 1) {
					write(f"#ifdef {cond[8:-1]}\n");
				} else if (cond.startswith("!defined(") && cond.endswith(")") &&
				           cond.findmatch("(", ")", 9) == #cond - 1) {
					write(f"#ifndef {cond[9:-1]}\n");
				} else {
					write(f"#if {cond}\n");
				}
do_write_ppif_elem:
				writeElements(e.tt);
				if (e.ff) {
					if (#e.ff == 1) {
						local firstFF = e.ff.first;
						if (firstFF is SimpPPIfCapsule) {
							write(f"#elif {firstFF.cond}\n");
							e = firstFF;
							goto do_write_ppif_elem;
						}
					}
					write("#else\n");
					writeElements(e.ff);
				}
				write("#endif\n");
				continue;
			}
			write(e);
		}
	}
}



global simpOptimizeElems;
function simpOptimizeElem(config: SimpConfig, assume: PPAssume, elem: SimpPPElem): {SimpPPElem...} {
	if (elem is SimpPPIfCapsule) {
again_optimize_ppif:
		if (!elem.tt) {
do_inverse_condition:
			if (!elem.ff)
				return {};
			elem.cond = f"!({elem.cond})";
			elem.tt   = elem.ff;
			elem.ff   = {};
		}
		local optCond = simpPpParse(elem.cond, config).optimize(assume: assume);
		local optCondStr = optCond.tostr();
		if (optCondStr !is none) {
			/* Flatten constant conditions */
			if (optCondStr == "1")
				return simpOptimizeElems(config, assume, elem.tt);
			if (optCondStr == "0")
				return simpOptimizeElems(config, assume, elem.ff);
			elem.cond = optCondStr;
			elem.tt = simpOptimizeElems(config, assume.withAssumption(optCond, true), elem.tt);
			if (elem.ff)
				elem.ff = simpOptimizeElems(config, assume.withAssumption(optCond, false), elem.ff);
			if (!elem.tt)
				goto do_inverse_condition;
		}
		if (!elem.ff && #elem.tt == 1) {
			local firstTT = elem.tt.first;
			if (firstTT is SimpPPIfCapsule && !firstTT.ff) {
				/* Optimize:              Info:
				 * >> #if FOO             >> #if FOO && BAR
				 * >> #if BAR             >> A
				 * >> A                   >> #endif
				 * >> #endif              >>
				 * >> #endif              >> */
				elem.cond = f"({elem.cond}) && ({firstTT.cond})";
				elem.tt   = firstTT.tt;
				goto again_optimize_ppif;
			}
		}

		/* TODO: Optimize:         Into:
		 * >> #if FOO              >> A
		 * >> A                    >> #if FOO
		 * >> B                    >> B
		 * >> D                    >> #else
		 * >> #else                >> C
		 * >> A                    >> #endif
		 * >> C                    >> D
		 * >> D
		 * >> #endif
		 * NOTE: This optimization should work line-wise! */

		return { elem };
	}
	/* TODO: Remove  comments  from strings  (when config.truncateOutput)
	 *       Needed so that more strings can become empty, and be removed
	 *       from  text blocks, allowing  for more optimizations relating
	 *       to adjacent #if-directives */
	return { elem };
}

function simpOptimizeElems(config: SimpConfig, assume: PPAssume, elems: {SimpPPElem...}): {SimpPPElem...} {
	local result = [];

	/* Do a shallow optimization pass. */
	for (local e: elems) {
		/* TODO: #define / #undef directives should affect `assume' */
		/* TODO: #include: Parse #include'd files for unconditionally defined macros,
		 *                 and include  those macro  definitions within  assumptions.
		 *                 For this purpose, we should also try to recognize #include
		 *                 guard macros and handle them as `#if 1', since  otherwise,
		 *                 we'd  (correctly)  deduce that  unconditional  macros from
		 *                 include files only get defined if the include guard hasn't
		 *                 been defined, yet.
		 *                 With this, we can optimize:
		 *                 >> #include <asm/crt/posix_spawn.h>
		 *                 >> #ifdef __POSIX_SPAWN_RESETIDS
		 *                 >> #define POSIX_SPAWN_RESETIDS __POSIX_SPAWN_RESETIDS
		 *                 >> #endif
		 *                 into:
		 *                 >> #include <asm/crt/posix_spawn.h>
		 *                 >> #define POSIX_SPAWN_RESETIDS __POSIX_SPAWN_RESETIDS
		 */
		result.extend(simpOptimizeElem(config, assume, e));
	}

	/* Merge adjacent string elements. */
	local n = #result - 1;
	for (local i = 0; i < n;) {
		local a = result[i];
		local b = result[i + 1];
		if (a is string && b is string) {
			result[i] = a + b;
			result.erase(i + 1);
			--n;
			continue;
		}
		++i;
	}

	/* Remove empty string elements. */
	result.removeif(e -> e is string && e.isspace());

	/* Merge adjacent `SimpPPIfCapsule' with equal/inverse conditions */
	local n = #result - 1;
	for (local i = 0; i < n;) {
		local a = result[i];
		local b = result[i + 1];
		if (a is SimpPPIfCapsule && b is SimpPPIfCapsule) {
			if (a.cond == b.cond) {
				a.tt.extend(b.tt);
				if (a.ff !is List)
					a.ff = List(a.ff);
				a.ff.extend(b.ff);
				result.erase(i + 1);
				--n;
				continue;
			}
			/* Optimize:             Into:
			 * >> #if BAR            >> #if BAR
			 * >> A                  >> A
			 * >> #endif             >> #if FOO
			 * >> #if FOO            >> B
			 * >> #if BAR            >> #else
			 * >> B                  >> C
			 * >> #endif             >> #endif
			 * >> #else              >> #endif
			 * >> #if BAR            >>
			 * >> C                  >>
			 * >> #endif             >>
			 * >> #endif             >>
			 */
			/* TODO */

			/* Optimize:             Into:
			 * >> #if BAR            >> #if BAR
			 * >> A                  >> A
			 * >> #else              >> #if FOO
			 * >> B                  >> C
			 * >> #endif             >> #else
			 * >> #if FOO            >> E
			 * >> #if BAR            >> #endif
			 * >> C                  >> #else
			 * >> #else              >> B
			 * >> D                  >> #if FOO
			 * >> #endif             >> D
			 * >> #else              >> #else
			 * >> #if BAR            >> F
			 * >> E                  >> #endif
			 * >> #else              >> #endif
			 * >> F                  >>
			 * >> #endif             >>
			 * >> #endif             >>
			 */
			/* TODO */

		}
		++i;
	}

	return result;
}


function simpPrintTree(tree: {SimpPPElem...}, indent: int = 0) {
	for (local e: tree) {
		print("\t" * indent),;
		if (e is SimpPPIfCapsule) {
			print("SimpPPIfCapsule[", repr e.cond, "][");
			simpPrintTree(e.tt, indent + 1);
			if (e.ff) {
				print("\t" * indent),;
				print("][");
				simpPrintTree(e.ff, indent + 1);
			}
			print("\t" * indent),;
			print("]");
			continue;
		}
		print repr e;
	}
}

function simplifyCFile(
		input: string | UserString | CParser | File,
		output: File, config: SimpConfig) {
	if (input !is CParser) {
		input = CParser(input);
		input.next();
	}
	local tree = simpParseCFile(input, config);
	local tree = simpOptimizeElems(config, createPPAssume(), tree);
//	simpPrintTree(tree);
	local out = SimpOutputPrinter(output, config);
	out.writeElements(tree);
	out.finish();
}







#ifdef __MAIN__
/* TODO: Set-up the GCC toolchain such that it becomes possible to overlay system headers
 *       with these  simplified alternatives,  such that  system headers  that have  been
 *       simplified for use with  GCC are used by  default, thus speeding up  compilation
 *       by  not including  unnecessary cross-compiler  constructs, or  even comments for
 *       that matter!
 *
 * TODO: Everywhere where we're searching for \n in the input stream, we must also be able
 *       to accept escaped line-feeds (i.e. "\\\n"), and not consider them in expressions.
 *
 * TODO: The parser above currently breaks for something like:
 *       >> #define foo 42 /.*
 *       >>                  * " *./
 *       Because it doesn't understand that the comment continues, and thus thinks that the
 *       next  line contains an unterminated string, which  then results in a syntax error.
 *       The fix (just like with the escape-line-feed  issue) would be to have a  dedicated
 *       function  to find the end of a line, that then skips escaped linefeeds, as well as
 *       line-feeds that appear inside of multi-line comments.
 */

local config = SimpConfig();
for (local configFile: [...][1:])
	parseSimpConfigFile(File.open(configFile), config);
simplifyCFile(File.stdin, File.stdout, config);
#endif /* __MAIN__ */
