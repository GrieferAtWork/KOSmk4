/* Copyright (c) 2019-2022 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2022 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

#pragma warning("-Wno-comment")

#undef CACHE_ALL_MODIFIED_OUTPUT_FILES
#if 0
#define CACHE_ALL_MODIFIED_OUTPUT_FILES 1
#endif

#undef ASYNC_FILE_ENUMERATION
#if 0 /* ASYNC is ~10% slower */
#define ASYNC_FILE_ENUMERATION 1
#endif


/* Generic library for automatic dependency tracing between files for the
 * purpose of automating source code compilation, mainly when it comes to
 * doing so in C or C++.
 * >> import fs;
 * >> import * from libmagic.libmagic;
 * >> import * from libmagic.steps.c;
 * >> import * from libmagic.toolchain.gcc;
 * >>
 * >> // Should always work from the same directory as the primary deemon script
 * >> fs.chdir(ROOTDIR);
 * >>
 * >> buildGroups(
 * >> 	toolchain: GCCToolchain(
 * >> 		config: Config(
 * >> 			BUILD_PATH: "build",
 * >> 		)
 * >> 	),
 * >> 	groups: {
 * >> 		Group(
 * >> 			name: "MyProject",  // Only for logs; `name' doesn't have syntactical meaning
 * >> 			steps: { COMPILE, LINK },
 * >> 			options: {
 * >> 				OPT_COMPILE_SOURCES  : ["src/*.cc"],
 * >> 				OPT_COMPILE_LANGUAGE : "c++",
 * >> 				OPT_LINK_OUTPUT      : "./MyProject",
 * >> 			},
 * >> 		),
 * >> 	}
 * >> );
 * Building groups where some source files need special options:
 * >> buildGroups(
 * >> 	toolchain: GCCToolchain(
 * >> 		config: Config(
 * >> 			BUILD_PATH: "build",
 * >> 		)
 * >> 	),
 * >> 	groups: {
 * >> 		Group(
 * >> 			name: "MyProject",
 * >> 			steps: { LINK },
 * >> 			options: {
 * >> 				OPT_COMPILE_SOURCES : ["src/a.cc", "src/b.cc"],
 * >> 				OPT_LINK_OUTPUT     : "out$EXE",
 * >> 			},
 * >> 		),
 * >> 		Group(
 * >> 			name: "MyProject",
 * >> 			steps: { COMPILE },
 * >> 			options: {
 * >> 				OPT_COMPILE_SOURCES : ["src/a.cc"],
 * >> 				OPT_COMPILE_MACROS  : { "MACRO_FOR_A_CC" : 1" },
 * >> 			},
 * >> 		),
 * >> 		Group(
 * >> 			name: "MyProject",
 * >> 			steps: { COMPILE },
 * >> 			options: {
 * >> 				OPT_COMPILE_SOURCES : ["src/b.cc"],
 * >> 				OPT_COMPILE_MACROS  : { "MACRO_FOR_B_CC" : 1" },
 * >> 			},
 * >> 		),
 * >> 	}
 * >> );
 * I know this doesn't  look that straight forward,  but remember that you  can
 * easily further automate this case by dynamically creating the Group objects.
 */


import ipc, fs, time;
import * from deemon;
import * from errors;

/* TODO: Use collections.UniqueSet instead of HashSet! */


@@Option: bool
@@An  option that  may be  used for  any group to
@@cause it to ignore the effects of @Config.FORCE
global final OPT_NOFORCE = "noforce";

local final LOG_START_MARKER  = ">";
local final LOG_END_MARKER    = "<";
local final LOG_UPDATE_MARKER = "~";


local final JOIN_WAIT_DELAY = 100000;

@@The absolute path of the directory containing the primary deemon script
global final ROOTDIR: string =
	fs.expand(fs.headof((argv from rt)[0]), "pac")
#ifdef __WINDOWS__
	.replace("\\", "/").lower()
#endif /* __WINDOWS__ */
	.rstrip("/") + "/";

function joinpath(paths...: string): string {
	return fs.expand(fs.joinpath(paths...), "p")
#ifdef __WINDOWS__
		.replace("\\", "/")
#endif /* __WINDOWS__ */
		.lsstrip("./")
	;
}

@@Returns the .latest-name of `filename':
@@> getLatestFilenameOf("/foo/bar.c"); // "/foo/.bar.c.latest"
function getLatestFilenameOf(filename: string): string {
	return "{}.{}.latest".format({
		fs.headof(filename),
		fs.tailof(filename),
	});
}


local final _readlinkCache: {string: string | bool | none} = Dict();
function readlink(path: string): string | bool | none {
	local result = _readlinkCache.get(path, true);
	if (result !== true)
		return result;
	result = try fs.readlink(path) catch (...) false;
	_readlinkCache[path] = result;
	return result;
}


local final _realpathCache: {string: string} = Dict();
function realpath(path: string): string {
	local orig_path = path;
again:
	local result = _realpathCache.get(path);
	if (result !is none)
		return result;
	if ("/" !in path)
		result = path;
	else {
		local link = readlink(path);
		if (link is string) {
			path = joinpath(fs.headof(path), link);
			goto again;
		}
		if (link !== false) {
			local head, none, tail = path.rpartition("/")...;
			result = joinpath(realpath(head), tail);
		} else {
			result = path;
		}
	}
	_realpathCache[orig_path] = result;
	return result;
}


@@Normalize a given file path
function normalizePath(path: string, expand_symlinks: bool = true): string {
#ifdef __WINDOWS__
	for (local pfx: { "/cygdrive/", "/mnt/" }) {
		if (path.startswith(pfx)) {
			path = path[#pfx:];
			path = path.partition("/");
			path = "{}:/{}".format({ path[0], path[2] });
			break;
		}
	}
#endif /* __WINDOWS__ */
	if (!fs.isabs(path))
		path = fs.abspath(path, ROOTDIR);
	path = fs.expand(path, "p").replace("\\", "/");
	if (expand_symlinks)
		path = realpath(path);
	if (path.lower().startswith(ROOTDIR))
		path = path[#ROOTDIR:];
	return path;
}

@@Cache of already created directories.
final local _createdDirectoriesCache: {string...} = HashSet();

@@Create a full tree of directories. (For build artifacts)
final global function createDirectoryTree(path: string) {
	path = path.rstrip("/");
	if (path in _createdDirectoriesCache)
		return;
	if (path && !fs.stat.isdir(path)) {
		createDirectoryTree(fs.headof(path));
		fs.mkdir(path);
	}
	_createdDirectoriesCache.insert(path);
}



local final _lastModfiedTimeCache: {string: time.Time} = Dict();
local final libwin32 = try import("win32") catch (...) none;

@@Get the last-modified timestamp for the given @filename
@@NOTE: This function keeps an internal cache that is volatime
@@      to   changes   to  the   current   working  directory.
function getLastModfiedTime(filename: string): time.Time | none {
	local result = _lastModfiedTimeCache.get(filename);
	if (result is none) {
		try {
			if (libwin32 is none) {
				/* FIXME: fs.stat() isn't as precise as win32.GetFileTime() is.
				 *        In a perfect world, time.Time() would be able to hold
				 *        timestamps of infinite precision... */
				result = fs.stat(filename).st_mtime;
			} else {
				/* Hack around a bit to get UNC paths working properly... */
				local handle = libwin32.CreateFile(
					lpFileName: filename,
					dwDesiredAccess: libwin32.FILE_GENERIC_READ,
					dwCreationDisposition: libwin32.OPEN_EXISTING);
				if (handle is none) {
					handle = libwin32.CreateFile(
						lpFileName: fs.abspath(filename),
						dwDesiredAccess: libwin32.FILE_GENERIC_READ,
						dwCreationDisposition: libwin32.OPEN_EXISTING);
					if (handle is none) {
						handle = libwin32.CreateFile(
							lpFileName: r"\\.\" + fs.abspath(filename),
							dwDesiredAccess: libwin32.FILE_GENERIC_READ,
							dwCreationDisposition: libwin32.OPEN_EXISTING);
					}
				}
				if (handle is none)
					result = none;
				else {
					try {
						/* GetFileTime() has a precision of 100 nanoseconds (or 0.1 microseconds)
						 * However, time.Time() only  has microsecond-precision  (so this  method
						 * is 10x more precise) */
						result = libwin32.GetFileTime(handle)[2];
					} finally {
						libwin32.CloseHandle(handle);
					}
				}
			}
		} catch (...) {
			result = none;
		}
		_lastModfiedTimeCache[filename] = result;
	}
	return result;
}

@@Assume that a given file has changed by settings its last-changed field to now()
function setForceChanged(filename: string, now: Object = none): Object {
	if (now is none) {
		if (libwin32 is none) {
			now = import("time").now();
		} else {
			now = (int)import("time").now() * 10;
		}
	}
	_lastModfiedTimeCache[filename] = now;
	return now;
}


@@Remove a given @filename from the cache of
@@known last-modified  timestamps of  files.
function fileMayHaveChanged(filename: string) {
	_lastModfiedTimeCache.pop(filename, none);
}


@@Selection for @Step.getRequiredFiles that refers to one file of many
class FirstFileOf {
	this = default;
	public final member files: {string...};
}


global BoundStep;
global Toolchain;

@@Vtable descriptor for a custom build Step
class Step {
	this = default;

	operator str() -> name;
	operator repr() -> name;

	@@The name of this step (Only for logs; no syntactical meaning)
	final member name: string;

	@@> run(step: BoundStep): {Waitable...}
	@@Execute the step and produce waitables
	final member run: Callable;

	@@> tostr(step: BoundStep): string
	@@Return a suitable, human-readable description for what this step does
	final member tostr: Callable = none;

	@@Set of group options used by this step
	final member options: {string...} = none;

	@@> split(step: BoundStep): {BoundStep...}
	@@Split this step into multiple, smaller steps
	final member split: Callable = none;

	@@> getRequiredFiles(step: BoundStep): {string | FirstFileOf...}
	@@Returns a List of required files
	final member getRequiredFiles: Callable = none; /* in */

	@@> getProducedFiles(step: BoundStep): {string...}
	@@Returns a List of produced files
	final member getProducedFiles: Callable = none; /* out */

	@@> getProducedOutputFiles(step: BoundStep): {string...}
	@@Returns the filenames of the  primary output files, that  is
	@@the files who's timestamps should be considered as the  ones
	@@used to determine if changes  in input files have  occurred.
	@@When  this callback  is defined,  all other  files which may
	@@also be produced by this build step are considered secondary
	@@build artifacts who's timestamp will be ignored, except when
	@@explicitly used as dependencies of other steps.
	final member getProducedOutputFiles: Callable = none; /* out */

	@@> getModifiedOutputFiles(step: BoundStep): {string...}
	@@Returns  the names of  output files that  (may) be modified or
	@@created by this step.  - This differs from  @getProducedFiles,
	@@in that modified  output files may  overlap with build  steps,
	@@however,  during execution, care will be taken that no 2 steps
	@@that may modify the same output file are executed in parallel.
	@@Also: In case another build step exists that may create such an
	@@      output file, that step is always executed first, allowing
	@@      it to create the output file before steps that may modify
	@@      it are then executed one by one.
	final member getModifiedOutputFiles: Callable = none; /* in|out */

	@@> getMaybeModifiedOutputFiles(step: BoundStep): {string...}
	@@Same  as  `getModifiedOutputFiles()',  but  the  enumerated  files  may
	@@not  necessarily get modified when the step  is run. - Instead of using
	@@the timestamp of the file itself, use a different file `.<name>.latest'
	@@to keep  track of  the timestamp  when such  a file  was last  updated.
	final member getMaybeModifiedOutputFiles: Callable = none; /* in|out */


	final function withRequiredFiles(files: {string...}): Step {
		getRequiredFiles = [](self: BoundStep) -> self.group.fixFilenames(files);
		return this;
	}

	final function withModifiedOutputFiles(files: {string...}): Step {
		getModifiedOutputFiles = [](self: BoundStep) -> self.group.fixFilenames(files);
		return this;
	}

	final function withMaybeModifiedOutputFiles(files: {string...}): Step {
		getMaybeModifiedOutputFiles = [](self: BoundStep) -> self.group.fixFilenames(files);
		return this;
	}

}

class Group {
	this = default;

	@@The name of this group (Only for logs; no syntactical meaning)
	public final member name: string;

	@@List  of  compilation steps,  which are  functions invoked
	@@as  Callable(group:  Group, changed:  bool): {Waitable...}
	@@The given parameter `changed' is set to true for the first
	@@step,  as well as any step performed after a previous step
	@@returned at least 1 Waitable Object
	public final member steps: {Step...} = [];

	@@Group-specific options (for use by step callbacks)
	public final member options: {string: Object} = Dict();

	@@The path in which this group is defined
	public final member defPath: string = "";

	public final function getDependencies(toolchain: Toolchain): {string | FirstFileOf...} {
		for (local s: steps) {
			local bss = BoundStep(this, s, toolchain);
			if (s.split !is none) {
				bss = s.split(bss);
			} else {
				bss = { bss };
			}
			for (local bs: bss)
				yield bs.requiredFiles...;
		}
	}

	private member _wildcardEnumerationCache: {string: {string...}} = Dict();

	function fixFilename(filename: string): string {
		if (filename.startswith("/"))
			return filename.lstrip("/");
		return joinpath(defPath, filename);
	}

	function fixFilenames(filenames: {string...}): {string...} {
		for (local x: filenames)
			yield fixFilename(x);
	}

	function enumerateWildcardFiles(pattern: string | {string...}): {string...} {
		if (pattern !is string) {
			for (local x: pattern)
				yield enumerateWildcardFiles(x)...;
			return;
		}
		local r = _wildcardEnumerationCache.get(pattern);
		if (r !is none) {
			yield r...;
			return;
		}
		local head: string = fs.headof(pattern);
		local tail: string = fs.tailof(pattern);
		if (head.startswith("/"))
			head = head.lstrip("/");
		else {
			head = joinpath(defPath, head);
		}
		local files: {string...};
		if ("*" in tail || "?" in tail) {
			files = [];
			for (local f: fs.dir(head)) {
				if (!f.wmatch(tail))
					continue;
				f = joinpath(head, f);
				files.append(f);
				yield f;
			}
		} else {
			files = { joinpath(head, tail) };
			yield files...;
		}
		_wildcardEnumerationCache[pattern] = files;
	}
}

@@Build configuration controller
class Config {
	this = default;

	@@The prefix that should be used by a cross-compiler  (needs
	@@to be used in conjunction with the implementing toolchain)
	public final member CROSS_PREFIX: string = "";

	@@Set to the location of where build artifacts should be placed
	public final member BUILD_PATH: string = "build";

	@@The default file extension for produced libraries
#ifdef __WINDOWS__
	public final member LIBRARY_SUFFIX: string = ".dll";
#else /* __WINDOWS__ */
	public final member LIBRARY_SUFFIX: string = ".so";
#endif /* !__WINDOWS__ */

	@@Set to true if a re-build of all steps should be forced
	public final member FORCE: bool = false;

	@@Set to true if error messages printed by build-tools
	@@should  be formatted into a singular, common format.
	public final member FORMAT_ERRORS: bool = false;

	@@Enable verbose mode (print executed commands)
	public final member VERBOSE: bool = false;

	@@Return the location of a some build artifact
	final function getBuildArtifact(group: Group, srcFile: string, ext: string): string {
		return joinpath(BUILD_PATH, group.name, srcFile.replace("/", ".") + ext);
	}

	@@Returns the location of disassembly
	final function getAssembledFilename(group: Group, srcFile: string): string    -> getBuildArtifact(group, srcFile, ".S");
	final function getModAssembledFilename(group: Group, srcFile: string): string -> getBuildArtifact(group, srcFile, ".mod.S");
	final function getPreprocessedFilename(group: Group, srcFile: string): string -> getBuildArtifact(group, srcFile, ".E");
	final function getDependencyFilename(group: Group, srcFile: string): string   -> getBuildArtifact(group, srcFile, ".MF");
	final function getObjectFilename(group: Group, srcFile: string): string       -> getBuildArtifact(group, srcFile, ".o");
}


class Waitable {
	this = default;
	//function    waitfor();
	//function trywaitfor();
}

function joinProcess(p: ipc.Process) {
	local error = p.join();
	if (error != 0) {
		throw Error("Process {!r} exited with {}"
			.format({ p.cmdline, error }));
	}
}

function tryJoinProcess(p: ipc.Process): bool {
	local error = p.tryjoin();
	if (error is none)
		return false;
	if (error != 0)
		throw Error("Process {!r} exited with {}"
			.format({ p.cmdline, error }));
	return true;
}

class WaitableJoin: Waitable {

	private member obj: ipc.Process | Thread | Object;

	this(obj) {
		this.obj = obj;
	}

	function waitfor() {
		return obj is ipc.Process
			? joinProcess(obj)
			: obj.join()
			;
	}

	function trywaitfor(): bool {
		return obj is ipc.Process
			? tryJoinProcess(obj)
			: obj is Thread
			? obj.tryjoin()[0]
			: obj.tryjoin()
			;
	}
}



class Toolchain {
	this = default;

	member config: Config;

	@@Name of the toolchain (for logs; if @none, then it isn't used)
	member name: string = none;

	@@Storage for toolchain extension configurations (e.g. mtools)
	member options: { string: Object } = Dict();

	/* C/C++ toolchain implementation prototypes */
	//function parseDependencyFile(text: string): {string...};
	//function createProcessorProcess(srcFile: string, ppFlags: {string...}): Waitable;
	//function createCompilerProcess(srcFile: string, ccFlags: {string...} = none, ppFlags: {string...} = none, asFlags: {string...} = none, depFile: string = none, objFile: string = none, language: string | none = none): Waitable;
	//function createArchiveProcess(exeFile: string, objFiles: {string...}, ldFlags: {string...} = none): Waitable;
	//function createLinkerProcess(exeFile: string, objFiles: {string...}, ldFlags: {string...} = none, language: string | none = none): Waitable;
}




class BoundStep {
	this = default;
	operator str(): string {
		if (step.tostr !is none)
			return step.tostr(this);
		return "[{}] {}".format({ group.name, step.name });
	}

	@@Create a new child-step of @this with @userData
	public final function createChildStep(userData: Object): BoundStep {
		return BoundStep(
			group:     group,
			step:      step,
			toolchain: toolchain,
			userData:  userData);
	}

	@@The bound group
	public final member group: Group;

	@@The bound step
	public final member step: Step;

	@@The used toolchain
	public final member toolchain: Toolchain;

	@@Step-specific data
	public final member userData: Object;

	@@List of required input files
	public final property requiredFiles: {string | FirstFileOf...} = {
		get(): {string | FirstFileOf...} {
#ifdef ASYNC_FILE_ENUMERATION
			if (_requiredFiles !is bound) {
				_requiredFiles = HashSet();
				for (local x: step.getRequiredFiles(this)) {
					_requiredFiles.insert(x);
					yield x;
				}
			} else {
				yield _requiredFiles...;
			}
#else /* ASYNC_FILE_ENUMERATION */
			if (_requiredFiles !is bound)
				_requiredFiles = HashSet(step.getRequiredFiles(this));
			return _requiredFiles;
#endif /* !ASYNC_FILE_ENUMERATION */
		}
	}

	@@List of produced build artifacts
	public final property producedFiles: {string...} = {
		get(): {string...} {
#ifdef ASYNC_FILE_ENUMERATION
			if (_producedFiles !is bound) {
				_producedFiles = HashSet();
				for (local x: step.getProducedFiles(this)) {
					if (_producedFiles.insert(x))
						yield x;
				}
			} else {
				yield _producedFiles...;
			}
#else /* ASYNC_FILE_ENUMERATION */
			if (_producedFiles !is bound)
				_producedFiles = HashSet(step.getProducedFiles(this));
			return _producedFiles;
#endif /* !ASYNC_FILE_ENUMERATION */
		}
	}

	@@List of intended build outputs
	public final property producedOutputFiles: {string...} = {
		get(): {string...} {
#ifdef ASYNC_FILE_ENUMERATION
			if (_producedOutputFiles !is bound) {
				local fun = step.getProducedOutputFiles;
				if (fun is none) {
					if (_producedFiles is bound) {
						_producedOutputFiles = _producedFiles;
						yield _producedOutputFiles...;
					} else {
						yield producedFiles...;
					}
				} else {
					_producedOutputFiles = HashSet();
					for (local x: fun(this)) {
						if (_producedOutputFiles.insert(x))
							yield x;
					}
				}
			} else {
				yield _producedOutputFiles...;
			}
#else /* ASYNC_FILE_ENUMERATION */
			if (_producedOutputFiles !is bound) {
				local fun = step.getProducedOutputFiles;
				if (fun is none)
					_producedOutputFiles = producedFiles;
				else {
					_producedOutputFiles = HashSet(fun(this));
				}
			}
			return _producedOutputFiles;
#endif /* !ASYNC_FILE_ENUMERATION */
		}
	}

	@@List of files that may be modified by this step
	@@NOTE: The second tuple element is the original last-modified
	@@      timestamp of the  file (or @none  if it didn't  exist)
	@@      This is needed  to ensure that  timestamps of  outputs
	@@      created  by other steps  are properly compared against
	@@      that timestamp at last point in time when the modified
	@@      output file was last known to be ~whole~
	@@Consider these 4 steps:
	@@       - IN: ...; OUT: a.txt
	@@       - IN: a.txt; MODIFY: log.txt
	@@       - IN: ...; OUT: b.txt
	@@       - IN: b.txt; MODIFY: log.txt
	@@These steps can  be executed  in the same  order, and  nothing
	@@would go wrong, however, the system is also allowed to execute
	@@them like this:
	@@       - IN: ...; OUT: a.txt
	@@       - IN: ...; OUT: b.txt
	@@       - IN: a.txt; MODIFY: log.txt
	@@       - IN: b.txt; MODIFY: log.txt
	@@In this case, the 4th step would be skipped because TIME(log.txt) > TIME(b.txt),
	@@since log.txt was already modified by `a.txt'
	@@Because of this, we need to make a compare TIME_AT_BUILD_START(log.txt) > TIME(b.txt),
	public final property modifiedOutputFiles: {(string, int | none)...} = {
		get(): {string...} {
#ifdef ASYNC_FILE_ENUMERATION
			if (_modifiedOutputFiles !is bound) {
				local fun = step.getModifiedOutputFiles;
				if (fun is none)
					_modifiedOutputFiles = {};
				else {
					_modifiedOutputFiles = HashSet();
					for (local f: fun(this)) {
						local pair = (f, getLastModfiedTime(f));
						if (_modifiedOutputFiles.insert(pair))
							yield pair;
					}
				}
			} else {
				yield _modifiedOutputFiles...;
			}
#else /* ASYNC_FILE_ENUMERATION */
			if (_modifiedOutputFiles !is bound) {
				local fun = step.getModifiedOutputFiles;
				if (fun is none)
					_modifiedOutputFiles = {};
				else {
					_modifiedOutputFiles = HashSet(
						for (local f: fun(this))
							(f, getLastModfiedTime(f)));
				}
			}
			return _modifiedOutputFiles;
#endif /* !ASYNC_FILE_ENUMERATION */
		}
	}

	public function updateModifiedOutputTimes() {
		if (_modifiedOutputFiles is bound) {
			local new = HashSet();
			for (local f, none: _modifiedOutputFiles)
				new.insert((f, getLastModfiedTime(f)));
			_modifiedOutputFiles = new;
		}
		if (_maybeModifiedOutputFiles is bound) {
			local new = HashSet();
			for (local f, none: _maybeModifiedOutputFiles)
				new.insert((f, getLastModfiedTime(getLatestFilenameOf(f))));
			_maybeModifiedOutputFiles = new;
		}
#ifdef CACHE_ALL_MODIFIED_OUTPUT_FILES
		try {
			del _allModifiedOutputFiles;
		} catch (...) {
		}
#endif /* CACHE_ALL_MODIFIED_OUTPUT_FILES */
	}

#ifdef CACHE_ALL_MODIFIED_OUTPUT_FILES
	private final member _allModifiedOutputFiles: {(string, int | none)...};
	public final property allModifiedOutputFiles: {(string, int | none)...} = {
		get(): {(string, int | none)...} {
			if (_allModifiedOutputFiles !is bound) {
				_allModifiedOutputFiles = HashSet();
				_allModifiedOutputFiles.update(modifiedOutputFiles);
				_allModifiedOutputFiles.update(maybeModifiedOutputFiles);
			}
			return _allModifiedOutputFiles;
		}
	}
#else /* CACHE_ALL_MODIFIED_OUTPUT_FILES */
	public final property allModifiedOutputFiles: {(string, int | none)...} = {
		get(): {(string, int | none)...} {
			yield modifiedOutputFiles...;
			yield maybeModifiedOutputFiles...;
		}
	}
#endif /* !CACHE_ALL_MODIFIED_OUTPUT_FILES */

	public final property maybeModifiedOutputFiles: {(string, int | none)...} = {
		get(): {string...} {
#ifdef ASYNC_FILE_ENUMERATION
			if (_maybeModifiedOutputFiles !is bound) {
				local fun = step.getMaybeModifiedOutputFiles;
				if (fun is none)
					_maybeModifiedOutputFiles = {};
				else {
					_maybeModifiedOutputFiles = HashSet();
					for (local f: fun(this)) {
						local pair = (f, getLastModfiedTime(getLatestFilenameOf(f)));
						if (_maybeModifiedOutputFiles.insert(pair))
							yield pair;
					}
				}
			} else {
				yield _maybeModifiedOutputFiles...;
			}
#else /* ASYNC_FILE_ENUMERATION */
			if (_maybeModifiedOutputFiles !is bound) {
				local fun = step.getMaybeModifiedOutputFiles;
				if (fun is none)
					_maybeModifiedOutputFiles = {};
				else {
					_maybeModifiedOutputFiles = HashSet(
						for (local f: fun(this))
							(f, getLastModfiedTime(getLatestFilenameOf(f))));
				}
			}
			return _maybeModifiedOutputFiles;
#endif /* !ASYNC_FILE_ENUMERATION */
		}
	}

	@@Check if this step has been completed
	final function complete(): bool {
		return _stepWaitables is bound && !_stepWaitables;
	}

	@@Mark this step as being skipped (presumably because none of its inputs have changed)
	final function skip() {
		_stepWaitables = [];
	}

	@@Reset this step
	final function reset() {
		try {
			del _stepWaitables;
		} catch (...) {
		}
	}

	@@Begin execution of this step
	@@If the step was already started or has already finished,
	@@return immediately.
	final function begin() {
		if (_stepWaitables is bound)
			return;
		_stepWaitables = List(step.run(this));
	}

	@@Wait for  all waitables  of this  step to  complete
	@@If this step had already been finished in the past,
	@@return immediately.
	@@If the step hadn't been started yet, start it now
	final function waitfor() {
		begin();
		while (_stepWaitables)
			_stepWaitables.pop().waitfor();
		onCompleted();
	}

	@@Try to wait for this step to have completed
	final function trywaitfor(): bool {
		begin();
		while (_stepWaitables) {
			if (!_stepWaitables[0].trywaitfor())
				return false;
			_stepWaitables.pop(0);
		}
		onCompleted();
		return true;
	}

	final function onCompleted() {
		/* Save that all (possibly) output files may have changed */
		for (local x: producedFiles)
			fileMayHaveChanged(x);
		for (local x, none: modifiedOutputFiles)
			fileMayHaveChanged(x);
		for (local x, none: maybeModifiedOutputFiles) {
			fileMayHaveChanged(x);
			x = getLatestFilenameOf(x);
			File.open(x, "wb").close(); /* touch */
			fileMayHaveChanged(x);
		}
	}

	@@Waitables that need to complete before this step can be finished
	private final member _stepWaitables: {Waitable...};

	@@Cache for @this.requiredFiles
	private final member _requiredFiles: {string | FirstFileOf...};

	@@Cache for @this.producedFiles
	private final member _producedFiles: {string...};

	@@Cache for @this.producedOutputFiles
	private final member _producedOutputFiles: {string...};

	@@Cache for @this.modifiedOutputFiles
	private final member _modifiedOutputFiles: {(string, int | none)...};

	@@Cache for @this.maybeModifiedOutputFiles
	private final member _maybeModifiedOutputFiles: {(string, int | none)...};

	operator == (other) -> this === other;
	operator != (other) -> this !== other;
	operator hash() -> Object.id(this);

	@@Dependent steps
	public final member dependencies: {BoundStep...} = HashSet();

	@@Recursively check if @this step has a dependency on @s
	function hasRecursiveDependency(s: BoundStep): bool {
		if (s === this)
			return true;
		if (s in dependencies)
			return true;
		for (local i: dependencies) {
			if (i.hasRecursiveDependency(s))
				return true;
		}
		return false;
	}

	@@Enumerate the full path of  dependencies
	@@to reach a given recursive dependency @s
	function walkRecursiveDependencies(s: BoundStep): {BoundStep...} {
		yield this;
		if (s !in dependencies) {
			for (local i: dependencies) {
				if (!i.hasRecursiveDependency(s))
					continue;
				yield i.walkRecursiveDependencies(s)...;
			}
		} else {
			yield s;
		}
	}

	@@Create folders for output files of this step
	function createOutputFolders() {
		for (local o: producedFiles)
			createDirectoryTree(fs.headof(o));
		for (local o, none: modifiedOutputFiles)
			createDirectoryTree(fs.headof(o));
		for (local o, none: maybeModifiedOutputFiles)
			createDirectoryTree(fs.headof(o));
	}
}


@@Combine the given steps into a single step
function combineSteps(steps...: Step): Step {
	if (#steps == 1)
		return steps[0];
	return Step(
		/* Just use the split mechanism to expand this step. */
		split: [](self: BoundStep): {BoundStep...} {
			for (local s: steps) {
				local bs = self.createChildStep(none);
				bs.step = s;
				if (s.split !is none) {
					yield s.split(bs)...;
				} else {
					yield bs;
				}
			}
		}
	);
}


@@Order build steps and return all steps that need to be performed to build all of the given groups.
@@The second set of steps  are steps that depend on  MaybeModified steps forming a dependency  loop.
@@When non-empty, the input files of these steps must be re-checked for changes.
function orderGroups(toolchainsAndGroups: {(Toolchain, {Group...})...}): ({BoundStep...}, {BoundStep...}) {
	local loop_recheck: {BoundStep...} = HashSet();
	local allsteps: {BoundStep...} = HashSet();
	for (local toolchain, groups: toolchainsAndGroups) {
		for (local p: groups) {
			for (local s: p.steps) {
				local bs = BoundStep(p, s, toolchain);
				if (s.split !is none)
					allsteps.update(s.split(bs));
				else {
					allsteps.insert(bs);
				}
			}
		}
	}
	local fileProducers: {string: BoundStep} = Dict();
	local fileModifiers: {string: {BoundStep...}} = Dict();
	for (local s: allsteps) {
		for (local f: s.producedFiles) {
			if (!fileProducers.setnew(f, s)) {
				local o = fileProducers[f];
				throw Error("File {!r} is produced by multiple steps {}:{}.{} and {}:{}.{}"
					.format({ f,
						s.toolchain.name, s.group.name, s.step.name,
						s.toolchain.name, o.group.name, o.step.name,
					}));
			}
		}
		for (local f, none: s.allModifiedOutputFiles) {
			local stps = fileModifiers.get(f);
			if (stps is none)
				fileModifiers[f] = stps = HashSet();
			stps.insert(s);
		}
	}
	local weak_dependency_pairs: {(BoundStep, BoundStep)...} = HashSet();
	/* Determine step dependencies. */
	for (local s: allsteps) {
		for (local f: s.requiredFiles) {
			local dep;
			if (f is FirstFileOf) {
				dep = none;
				for (local x: f.files) {
					dep = fileProducers.get(x);
					if (dep !is none)
						break;
				}
			} else {
				dep = fileProducers.get(f);
			}
			if (dep is none)
				continue;
			if (dep.hasRecursiveDependency(s)) {
				local chain = List(dep.walkRecursiveDependencies(s));
				for (local i = 0; i < #chain - 1; ++i) {
					local pair = (chain[i], chain[i+1]);
					if (pair in weak_dependency_pairs) {
						weak_dependency_pairs.remove(pair);
						pair[0].dependencies.remove(pair[1]);
						loop_recheck.insert(pair[0]);
						goto did_resolve;
					}
				}
				print "ERROR: Recursive dependency:";
				print "\t          ", s;
				for (local e: chain)
					print "\tdepends on", e;
				throw Error("Recursive dependency");
			}
did_resolve:
			s.dependencies.insert(dep);
		}
		/* Go  through required input files one more time and check if
		 * steps exist that may try to modify those files. - If adding
		 * those steps as dependencies won't create a loop, do so */
		for (local f: s.requiredFiles) {
			local mods = fileModifiers.get(f);
			for (local m: mods) {
				if (!m.hasRecursiveDependency(s)) {
					s.dependencies.insert(m);
					weak_dependency_pairs.insert((s, m));
				} else {
					loop_recheck.insert(s);
				}
			}
		}
		for (local f, none: s.allModifiedOutputFiles) {
			/* Check if modified output files are created by  some
			 * other step. - If so, that step becomes a dependency
			 * of `s' */
			local dep = fileProducers.get(f);
			if (dep !is none) {
				/* Don't create the dependency if it would cause a loop. */
				if (!dep.hasRecursiveDependency(s)) {
					s.dependencies.insert(dep);
					weak_dependency_pairs.insert((s, dep));
				} else {
					loop_recheck.insert(dep);
				}
			}
		}
	}
	return (allsteps, loop_recheck);
}


function executeBuildSteps(steps: {BoundStep...}, recheck: {BoundStep...}, maxParallelSteps: int = 8) {
	local missingSteps: {BoundStep...} = HashSet(steps);
	local finishedSteps: {BoundStep...} = HashSet();
	local runningSteps: {BoundStep...} = HashSet();
	function printStatus(marker: string, message: string) {
		local numMissing  = #missingSteps;
		local numFinished = #finishedSteps;
		local numRunning  = #runningSteps;
		local avgMissing  = (float)numMissing + (float)numRunning / 2;
		local avgFinished = (float)numFinished + (float)numRunning / 2;
		local progress = try ((avgFinished / (avgMissing + avgFinished))) catch(...) 1.0;
		print "[" + marker + numRunning + ":" + str(int(progress * 100.0)).rjust(3) + "%",;
		if (!message.startswith("["))
			print "] ",;
		else {
			print " ",;
			message = message[1:];
		}
		print message;
	}
	function printStepStatus(marker: string, step: BoundStep, message: string) {
		printStatus(marker, "[{}] {} ({})".format({
			step.toolchain.name !is none ? ("{}:{}".format({
				step.toolchain.name,
				step.group.name
			})) : step.group.name,
			step,
			message
		}));
	}
	function waitforAnyStep() {
		assert !runningSteps.empty(),
			"missingSteps: {!r}\n"
			"finishedSteps: {!r}\n"
			.format({
				for (local x: missingSteps) str(x),
				for (local x: finishedSteps) str(x),
			})
		;
		local unchangedIterations = 0;
again:
		if (#runningSteps == 1) {
			local s = runningSteps.first;
			s.waitfor();
			printStepStatus(LOG_END_MARKER, s, "done");
			runningSteps.clear();
			finishedSteps.insert(s);
		} else if (runningSteps) {
			for (local s: runningSteps) {
				if (!s.trywaitfor())
					continue;
				printStepStatus(LOG_END_MARKER, s, "done");
				runningSteps.remove(s);
				finishedSteps.insert(s);
				unchangedIterations = 0;
				return; /* Got one! */
			}
			if ((unchangedIterations % 10) == 9) {
				printStatus(LOG_UPDATE_MARKER, "Still waiting on:");
				for (local x: runningSteps)
					print "\t" + x;
			}
			Thread.sleep(JOIN_WAIT_DELAY);
			++unchangedIterations;
			goto again;
		}
	}
	function startStep(s: BoundStep, reason: string) {
		s.createOutputFolders();
		local unchangedIterations = 0;
again:
		if (runningSteps) {
			/* Make sure that no other steps are already running that
			 * may  also be trying to modify any of our in-out files. */
			local mod = s.allModifiedOutputFiles;
			if (mod) {
				local io_files = HashSet(mod.each[0]);
				local collidingSteps = HashSet();
				for (local run: runningSteps) {
					for (local o, none: run.allModifiedOutputFiles) {
						if (o in io_files) {
							collidingSteps.insert(run);
							break;
						}
					}
				}
				/* Wait for all colliding steps to complete. */
				while (collidingSteps) {
					local st = collidingSteps.popitem();
					st.waitfor();
					printStepStatus(LOG_END_MARKER, st, "done");
					runningSteps.remove(st);
					finishedSteps.insert(st);
				}
			}
		}
		if (s.complete()) {
			missingSteps.remove(s);
			finishedSteps.insert(s);
			return;
		}
		/* If there are too many running steps, wait for one of them to finish */
		if (#runningSteps >= maxParallelSteps) {
			for (local x: runningSteps) {
				if (x.trywaitfor()) {
					printStepStatus(LOG_END_MARKER, x, "done");
					runningSteps.remove(x);
					finishedSteps.insert(x);
					goto do_start_step;
				}
			}
			if ((unchangedIterations % 10) == 9) {
				printStatus(LOG_UPDATE_MARKER, "Still waiting on:");
				for (local x: runningSteps)
					print "\t" + x;
			}
			Thread.sleep(JOIN_WAIT_DELAY);
			++unchangedIterations;
			goto again;
		}
do_start_step:
		missingSteps.remove(s);
		runningSteps.insert(s);
		printStepStatus(LOG_START_MARKER, s, "begin: " + reason);
		s.begin();
	}
search_next_step:
	while (missingSteps) {
		local blockers: {BoundStep...} = HashSet();
		for (local s: missingSteps) {
			for (local x: s.dependencies) {
				if (x !in finishedSteps) {
					blockers.insert(s);
					goto try_next_step;
				}
			}
			/* Check if this step _must_ be rebuild */
			if (s.toolchain.config.FORCE) {
				/* Allow the use of OPT_NOFORCE to ignore config.FORCE */
				if (!s.group.options.get(OPT_NOFORCE, false)) {
					startStep(s, "FORCE");
					goto search_next_step;
				}
			}
			/* Check if this step needs to be executed.
			 * This  is the case if any of the step's output files
			 * are missing, or if any of its input files are newer
			 * that the newest output file. */
			local lmod = none;
			for (local o: s.producedOutputFiles) {
				assert o in s.producedFiles, "o:" + repr(o) + "\ns:" + repr(s);
				local temp = getLastModfiedTime(o);
				if (temp is none) {
					/* Create missing folders leading up to all output files. */
					startStep(s, "output {!r} is missing".format({ o }));
					goto search_next_step;
				}
				if (lmod is none || temp > lmod)
					lmod = temp;
			}
			for (local o, temp: s.modifiedOutputFiles) {
				if (temp is none) {
					/* The modified file didn't exist when dependencies were ordered */
					startStep(s, "file {!r} didn't exist".format({ o }));
					goto search_next_step;
				}
				if (lmod is none || temp > lmod)
					lmod = temp;
			}
			for (local o, temp: s.maybeModifiedOutputFiles) {
				if (temp is none) {
					startStep(s, "file {!r} was never updated".format({ o }));
					goto search_next_step;
				}
				if (lmod is none || temp > lmod)
					lmod = temp;
			}
			if (lmod !is none) {
				/* Check if any of the step's input files were modified after its output. */
				for (local i: s.requiredFiles) {
					local temp;
					local filename = i;
					if (i is FirstFileOf) {
						temp = none;
						for (local x: i.files) {
							temp = getLastModfiedTime(x);
							if (temp !is none) {
								filename = x;
								break;
							}
						}
					} else {
						temp = getLastModfiedTime(filename);
					}
					if (temp is none) {
						startStep(s, "{!r} was deleted".format({ filename }));
						goto search_next_step;
					}
					if (temp > lmod) {
						startStep(s, "{!r} has changed".format({ filename }));
						goto search_next_step;
					}
				}
			}
			/* This step can be skipped! */
			s.skip();
			missingSteps.remove(s);
			finishedSteps.insert(s);
			goto search_next_step;
try_next_step:
			;
		}
		if (blockers) {
			local common_deps = none;
			/* Search `blockers' for common dependencies and do a blocking wait on those */
			for (local x: blockers) {
				if (common_deps is none) {
					common_deps = x.dependencies;
					continue;
				}
				local new_common = HashSet();
				for (local y: x.dependencies) {
					if (y !in common_deps)
						continue;
					new_common.insert(y);
				}
				common_deps = new_common;
				if (!common_deps)
					break;
			}
			local did_wait_any = false;
			/* Wait until all blockers have finished
			 * Doing it this way is more efficient, since we don't have to keep
			 * on polling dependencies, and can instead blocking-waitfor all of
			 * them to finish.
			 */
			for (local block: common_deps) {
				if (block !in runningSteps)
					continue; /* Hasn't started, yet */
				block.waitfor();
				printStepStatus(LOG_END_MARKER, block, "done");
				runningSteps.remove(block);
				finishedSteps.insert(block);
				did_wait_any = true;
			}
			if (did_wait_any)
				goto search_next_step;
		}
		/* If no step was started, wait for one of the running steps to finish */
		waitforAnyStep();
	}
	/* Wait for all steps that are still running */
	while (runningSteps) {
		local st = runningSteps.first;
		st.waitfor();
		printStepStatus(LOG_END_MARKER, st, "done");
		runningSteps.remove(st);
		finishedSteps.insert(st);
	}
	if (recheck) {
		local recheck_reason;
		for (local s: recheck) {
			local lmod = none;
			s.updateModifiedOutputTimes();
			for (local o: s.producedOutputFiles) {
				assert o in s.producedFiles;
				local temp = getLastModfiedTime(o);
				if (temp is none) {
					recheck_reason = "output {!r} is missing".format({ o });
					goto do_reset_step;
				}
				if (lmod is none || temp > lmod)
					lmod = temp;
			}
			for (local o, temp: s.modifiedOutputFiles) {
				if (temp is none) {
					recheck_reason = "file {!r} didn't exist".format({ o });
					goto do_reset_step;
				}
				if (lmod is none || temp > lmod)
					lmod = temp;
			}
			for (local o, temp: s.maybeModifiedOutputFiles) {
				if (temp is none) {
					recheck_reason = "file {!r} was never updated".format({ o });
					goto do_reset_step;
				}
				if (lmod is none || temp > lmod)
					lmod = temp;
			}
			if (lmod !is none) {
				/* Check if any of the step's input files were modified after its output. */
				for (local i: s.requiredFiles) {
					local temp;
					local filename = i;
					if (i is FirstFileOf) {
						temp = none;
						for (local x: i.files) {
							temp = getLastModfiedTime(x);
							if (temp !is none) {
								filename = x;
								break;
							}
						}
					} else {
						temp = getLastModfiedTime(filename);
					}
					if (temp is none) {
						recheck_reason = "{!r} was deleted".format({ filename });
						goto do_reset_step;
					}
					if (temp > lmod) {
						recheck_reason = "{!r} has changed".format({ filename });
						goto do_reset_step;
					}
				}
			}
			continue;
do_reset_step:
			printStepStatus(LOG_UPDATE_MARKER, s, "Restarting: " + recheck_reason);
			missingSteps.insert(s);
			finishedSteps.remove(s);
			s.reset();
		}
		if (missingSteps) {
			/* Must also restart all steps that have
			 * dependencies on  on restarted  steps. */
again_search_fin_steps:
			for (local fin: finishedSteps) {
				local has_restart_dep = false;
				for (local dep: fin.dependencies) {
					if (dep in missingSteps) {
						has_restart_dep = true;
						break;
					}
				}
				if (has_restart_dep) {
					fin.reset();
					fin.updateModifiedOutputTimes();
					finishedSteps.remove(fin);
					missingSteps.insert(fin);
					goto again_search_fin_steps;
				}
			}
			print "Restarting the following steps:";
			for (local s: missingSteps) {
				print "\t",;
				print s;
			}
			goto search_next_step;
		}
	}
}



#if 0
class Timed {
	this = default;
	public member name: string = "Unnamed";
	private member start;
	operator enter() {
		import tick from time;
		start = tick();
	}
	operator leave() {
		import tick from time;
		local end = tick();
		print "Timed:", name, "took", (end - start);
	}
}
#endif


@@Helper function for  combining @orderGroups and  @executeBuildSteps
@@in order to perform a parallel build of all of the specified groups
function buildGroups(toolchainsAndGroups: {(Toolchain, {Group...})...}, maxParallelSteps: int = 8) {
#if 1
	local steps, recheck = orderGroups(toolchainsAndGroups)...;
	return executeBuildSteps(steps, recheck, maxParallelSteps);
#else
	local steps, recheck = (
		with(Timed("orderGroups"))
			orderGroups(toolchainsAndGroups)...;
	with(Timed("executeBuildSteps"))
		return executeBuildSteps(steps, recheck, maxParallelSteps);
#endif
}

function filterStepsWithCallback(
		steps: {BoundStep...},
		filterStep: Callable with BoundStep): {BoundStep...} {
	for (local s: steps) {
		if (filterStep(s))
			yield s;
	}
}

@@Same as @filterStepsWithCallback(), but also enumerate dependencies
function filterStepsWithCallbackWithDepdendencies(
		steps: {BoundStep...}, filterStep: Callable with BoundStep): {BoundStep...} {
	local result = HashSet();
	local recheckSteps = HashSet();
	for (local s: filterStepsWithCallback(steps, filterStep)) {
		if (s in result)
			continue;
		result.insert(s);
		local deps = s.dependencies;
		recheckSteps.update(deps);
	}
again_recheck_deps:
	local myRecheckSteps = recheckSteps;
	recheckSteps = HashSet();
	for (local s: myRecheckSteps) {
		if (s in result)
			continue;
		result.insert(s);
		local deps = s.dependencies;
		recheckSteps.update(deps);
	}
	if (recheckSteps)
		goto again_recheck_deps;
	return result;
}


@@Same as @buildGroups(), however only perform steps
@@for  which  the given  @filterStep()  returns true
function buildGroupsWithStepFilter(
		toolchainsAndGroups: {(Toolchain, {Group...})...},
		filterStep: {(bool,string)...} = none, maxParallelSteps: int = 8) {
	local steps, recheck = orderGroups(toolchainsAndGroups)...;
	if (filterStep !is none) {
		steps   = filterStepsWithCallbackWithDepdendencies(steps, filterStep);
		recheck = filterStepsWithCallbackWithDepdendencies(recheck, filterStep);
	}
	return executeBuildSteps(steps, recheck, maxParallelSteps);
}



function enumerateBoundStepOutputFilesForWhitelistChecking(step: BoundStep): {string...} {
	yield step.producedOutputFiles...;
	for (local o, none: step.modifiedOutputFiles)
		yield o;
	for (local o, none: step.maybeModifiedOutputFiles)
		yield o;
}

@@Same as @buildGroups(), however only perform steps that are required by other steps,
@@as well  as steps  that produce  output  files that  are apart  of  @outputWhiteList
@@@param outputWhiteList: Set of (is_regex, pattern_or_filename)
function buildGroupsWithOutputWhitelist(
		toolchainsAndGroups: {(Toolchain, {Group...})...},
		outputWhiteList: {(bool,string)...} = none, maxParallelSteps: int = 8) {
	if (outputWhiteList is none)
		return buildGroups(toolchainsAndGroups, maxParallelSteps);
	return buildGroupsWithStepFilter(toolchainsAndGroups, [](step: BoundStep) {
		/* `outputWhiteList'  must contain a regex pattern for
		 * any of the step's following output file categories:
		 *   - producedOutputFiles
		 *   - modifiedOutputFiles
		 *   - maybeModifiedOutputFiles
		 */
		for (local f: enumerateBoundStepOutputFilesForWhitelistChecking(step)) {
			for (local is_regex, pattern: outputWhiteList) {
				if (is_regex ? f.rematches(pattern) : f == pattern)
					return true; /* Got a match! */
			}
		}
		return false;
	}, maxParallelSteps);
}


@@Same as @buildGroups(), however only perform steps that are required by other steps,
@@as well as steps that are apart of one of the given groups
@@@param groupWhiteList: Set of List of whitelisted group names
function buildGroupsWithGroupWhitelist(
		toolchainsAndGroups: {(Toolchain, {Group...})...},
		groupWhiteList: {string...} = none, maxParallelSteps: int = 8) {
	if (groupWhiteList is none)
		return buildGroups(toolchainsAndGroups, maxParallelSteps);
	return buildGroupsWithStepFilter(toolchainsAndGroups, [](step: BoundStep) {
		return step.group.name in groupWhiteList;
	}, maxParallelSteps);
}


@@Same as @buildGroups(), however only perform steps that are required by other steps,
@@as well as steps that  are apart of identically-named  groups containing at least  a
@@single   step  that  requires   one  of  the   given  @inputFileWhitelist  as  input
@@Using  this,  you   can  implement   something  like   BUILD_PROJECT_OF(SOURCE_FILE)
@@@param inputFileWhitelist: Set of filenames normalized using `normalizePath(NAME, false)'
function buildGroupsWithGroupOfInputFileWhitelist(
		toolchainsAndGroups: {(Toolchain, {Group...})...},
		inputFileWhitelist: {string...} = none, maxParallelSteps: int = 8) {
	if (inputFileWhitelist is none)
		return buildGroups(toolchainsAndGroups, maxParallelSteps);
	local steps, recheck = orderGroups(toolchainsAndGroups)...;
	local whiteListGroupNames = HashSet();
	for (local bs: steps) {
		for (local rf: bs.requiredFiles) {
			if (rf in inputFileWhitelist) {
				whiteListGroupNames.insert(bs.group.name);
				goto next_step;
			}
		}
next_step:
		;
	}
	/* Apply a filter to only run steps apart of the whitelisted groups. */
	steps = filterStepsWithCallbackWithDepdendencies(steps,
		[](step: BoundStep) -> step.group.name in whiteListGroupNames);
	return executeBuildSteps(steps, recheck, maxParallelSteps);
}
