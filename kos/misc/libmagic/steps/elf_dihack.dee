/* Copyright (c) 2018 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifdef __WINDOWS__
#define HOST_EXE(x)  x ".exe"
#else
#define HOST_EXE(x)  x
#endif

/* Build steps designed specifically for working with ELF files */
import fs;
import ipc;
import * from deemon;
import * from errors;
import * from ..libmagic;
import OPT_LINK_OUTPUT from .c;

#include "../../../include/elf.h"

local function file_read2le(fp: File): int {
	return int.frombytes(fp.read(2), "little", false);
}
local function file_read4le(fp: File): int {
	return int.frombytes(fp.read(4), "little", false);
}
local function file_read8le(fp: File): int {
	return int.frombytes(fp.read(8), "little", false);
}
local function file_write4le(fp: File, v: int) {
	fp.write(v.tobytes(4, "little", false));
}
local function file_write8le(fp: File, v: int) {
	fp.write(v.tobytes(8, "little", false));
}


@@Option: string
global final OPT_ELF_DIHACK_FILE: string = "ELF_DIHACK.input";
@@Option: int   -- Offset between physical and virtual memory
global final OPT_ELF_DIHACK_PHYS2VIRT: string = "ELF_DIHACK.phys2virt";

class ElfDebuginfoParams {
	this = default;
	@@Index of the PHDR that was used for mapping .debug_*.wrapper
	final member phdr_debug_xxx_wrapper_index: int;
	@@Index of the SHDR for the .debug_*.wrapper section
	final member shdr_debug_xxx_wrapper_index: int;
	@@Index of the SHDR for the .debug_* section
	final member shdr_debug_xxx_index: int;
	@@Value of SHDR[shdr_debug_xxx_index].sh_offset
	final member shdr_debug_xxx_offset: int;
	@@Value of SHDR[shdr_debug_xxx_index].sh_size
	final member shdr_debug_xxx_size: int;
	@@Value of SHDR[shdr_debug_xxx_index].sh_addralign
	final member shdr_debug_xxx_align: int;
	@@Value of SYMBOLS["__kernel_${NAME.lstrip('.')}_start"].st_value
	final member symt___kernel_debug_xxx_start: int;
}


local function getLines(fp: File): Bytes {
	local result = fp.read();
again:
	if (result &&
	    !result.endswith("\n") &&
	    !result.endswith("\r") &&
	    !result.endswith("\r\n")) {
		local d = fp.read();
		if (d) {
			result = result + d;
			goto again;
		}
	}
	return result;
}

@@Hack to make .debug_* sections allocated in the produced binary
function elfDebuginfoAllocatedHack(
		self: BoundStep, filename: string, phys2virtOffset: int) {
	try {
		/* The kernel's shdr and phdr vectors have been set up such that
		 * for every .debug_* section $NAME, the following exists:
		 *
		 * >> orig = SHDR[INDEXOF("${NAME}")];
		 * >> assert orig !is none;
		 * >> assert !(orig.sh_flags & SHF_ALLOC);
		 * >>
		 * >> shdr = SHDR[INDEXOF("${NAME}.wrapper")];
		 * >> assert shdr !is none;
		 * >> assert shdr.sh_flags & SHF_ALLOC;
		 * >>
		 * >> phdr = PHDR[PHDR_OF_SECTION(shdr)];
		 * >> assert phdr !is none;
		 * >> assert phdr.p_type == PT_LOAD;
		 * >> assert phdr.p_vaddr == 0;
		 * >> assert phdr.number_of_mapped_sections == 1;
		 * >>
		 * >> strt = SYMTAB["__kernel_${NAME.lstrip('.')}_start"];
		 * >> assert strt !is none;
		 * >> assert strt.st_shndx != SHN_UNDEF;
		 *
		 * As such, we must now make the following changes:
		 * >> orig.sh_flags |= SHF_ALLOC;
		 * >> shdr.sh_flags &= ~SHF_ALLOC;
		 * >> phdr.p_offset = orig.sh_offset;
		 * >> phdr.p_paddr  = strt.st_value;
		 * >> phdr.p_filesz = orig.sh_size;
		 * >> phdr.p_memsz  = orig.sh_size;
		 * >> phdr.p_align  = orig.sh_addralign;
		 *
		 * To gather all of the information we need, we use the `readelf'
		 * utility, so we don't have to parse the kernel binary.
		 */
		local readelf_bin = HOST_EXE(self.toolchain.config.CROSS_PREFIX + "readelf");
		local readelf = ipc.Process(readelf_bin, { "-S", "-l", "-s", "-W", filename });
		local r, w = ipc.Pipe.new()...;
//		r = File.Buffer(r, "ro,c,none"); /* line-buffered */
		readelf.stdout = w;
		readelf.start();
		w.close();
		final local sections = {
			"debug_line"    : ElfDebuginfoParams(),
			"debug_info"    : ElfDebuginfoParams(),
			"debug_aranges" : ElfDebuginfoParams(),
			"debug_abbrev"  : ElfDebuginfoParams(),
			"debug_str"     : ElfDebuginfoParams(),
			"debug_ranges"  : ElfDebuginfoParams(),
			"debug_loc"     : ElfDebuginfoParams()
		};
#define CONTEXT_SECTION_HEADERS    0
#define CONTEXT_PROGRAM_HEADERS    1
#define CONTEXT_SECTION_TO_SEGMENT 2
#define CONTEXT_SYMBOL_TABLE       3
		local context = none;
		/* FIXME: for (local l: r)
		 * Deemon's line-based file reader is unbelievably slow! */
		while (local d = getLines(r))
		for (local l: d.splitlines()) {
			l = l.strip();
			if (l.endswith(":")) {
				if (l.startswith("Section Headers:")) { context = CONTEXT_SECTION_HEADERS; continue; }
				if (l.startswith("Program Headers:")) { context = CONTEXT_PROGRAM_HEADERS; continue; }
				if (l.startswith("Section to Segment mapping:")) { context = CONTEXT_SECTION_TO_SEGMENT; continue; }
				if (l.startswith("Symbol table")) { context = CONTEXT_SYMBOL_TABLE; continue; }
			}
			switch (context) {
			case CONTEXT_SECTION_HEADERS: {
				/* [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al */
				local id, name, addr, off, size, flg, al;
				try {
					id, name, none, addr, off, size, none, flg, none, none, al =
						l.scanf(" [ %[^\\]] ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ]")...;
				} catch (e...) {
					try {
						id, name, none, addr, off, size, none, none, none, al =
							l.scanf(" [ %[^\\]] ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ] %[^ ]")...;
						flg = "";
					} catch (e...) {
						continue;
					}
				}
				if (name == "NULL" && id == 0)
					continue;
				if (!name.startswith("."))
					continue;
				if (name.endswith(".wrapper")) {
					local d = sections.get(name[1:-8]);
					if (d is none)
						continue;
					assert "A" in flg;
					d.shdr_debug_xxx_wrapper_index = int(id.strip().lstrip("0"), 10);
				} else {
					local d = sections.get(name[1:]);
					if (d is none)
						continue;
					assert "A" !in flg;
					d.shdr_debug_xxx_index  = int(id.strip());
					d.shdr_debug_xxx_offset = int(off.strip(), 16);
					d.shdr_debug_xxx_size   = int(size.strip(), 16);
					d.shdr_debug_xxx_align  = int(al.strip(), 16);
				}
			}	break;
			case CONTEXT_PROGRAM_HEADERS:
				break;
			case CONTEXT_SECTION_TO_SEGMENT: {
				/* Segment Sections... */
				local segm, sects;
				try {
					segm, sects = l.scanf(" %[^ ] %[^]")...;
				} catch (e...) {
					continue;
				}
				sects = sects.strip();
				if (" " in sects)
					continue;
				if (!sects.startswith("."))
					continue;
				if (!sects.endswith(".wrapper"))
					continue;
				local d = sections.get(sects[1:-8]);
				if (d is none)
					continue;
				d.phdr_debug_xxx_wrapper_index = int(segm.strip().lstrip("0"), 10);
			}	break;
			case CONTEXT_SYMBOL_TABLE: {
				/*    Num:    Value  Size Type    Bind   Vis      Ndx Name */
				if ("__kernel_" !in l)
					continue;
				if (!l.rstrip().endswith("_start"))
					continue;
				local name_start = l.rfind(" ");
				if (name_start < 0)
					continue;
				local name = l[name_start+1:];
				if (!name.startswith("__kernel_"))
					continue;
				local d = sections.get(name[9:-6]);
				if (d is none)
					continue;
				/* Extract the `Value' part */
				local val_start = l.find(":");
				if (val_start < 0)
					continue;
				l = l[val_start + 1:].lstrip();
				local val_end = l.find(" ");
				if (val_end < 0)
					val_end = #l;
				d.symt___kernel_debug_xxx_start = int(l[:val_end], 16);
			}	break;
			default:
				break;
			}
		}
		r.close();
		joinProcess(readelf);
//		for (local name, data: sections)
//			print repr(name), ":", repr(data);
		with (local fp = File.open(filename, "rb+,nobuf")) {
			if (fp.read(SELFMAG) != ELFMAG)
				throw Error("Bad ELF magic");
			local elfclass = fp.getc();
			local is64 = false;
			if (elfclass == ELFCLASS64) {
				is64 = true;
			} else if (elfclass != ELFCLASS32) {
				throw Error("Unrecognized ELF class: " + repr(elfclass));
			}
			local file_readple = is64 ? file_read8le : file_read4le;
#define OFFSET(x) (is64 ? __OFFSET_ELF64_##x : __OFFSET_ELF32_##x)
			fp.seek(OFFSET(EHDR_PHOFF));
			local e_phoff = file_readple(fp);
			local e_shoff = file_readple(fp);
			fp.seek(OFFSET(EHDR_PHENTSIZE));
			local e_phentsize = file_read2le(fp);
			fp.seek(OFFSET(EHDR_SHENTSIZE));
			local e_shentsize = file_read2le(fp);

#if 0 /* GDB and addr2line doesn't like it when SHF_ALLOC is set for debug sections. \
       * When this happens while the section is also compressed, it will refuse to   \
       * load debug information from that section. - But that's entirely OK. Neither \
       * QEMU, nor Grub actually care about section headers, so all we ~really~ need \
       * to worry about is that .debug_info makes it into the program header table! */
			/* orig.sh_flags |= SHF_ALLOC; */
			for (local name, s: sections) {
				try {
					local flags_pos =
						(e_shoff + (s.shdr_debug_xxx_index * e_shentsize)) +
						OFFSET(SHDR_FLAGS);
					fp.seek(flags_pos);
					local f = file_read4le(fp);
					fp.seek(flags_pos);
					file_write4le(fp, f | SHF_ALLOC);
				} catch (...) {
					print File.stderr: "Error while setting SHF_ALLOC for", repr(name);
					throw;
				}
			}
#endif

#if 0 /* This would be the correct thing to do, and neither Grub nor addr2line complain \
       * if we actually do this, however given the fact that we can't set SHF_ALLOC for \
       * the actual .debug_* sections, clearing it for the fake ones also becomes kind- \
       * of unnecessary... */
			/* shdr.sh_flags &= ~SHF_ALLOC; */
			for (local name, s: sections) {
				try {
					local flags_pos =
						(e_shoff + (s.shdr_debug_xxx_wrapper_index * e_shentsize))
						+ OFFSET(SHDR_FLAGS);
					fp.seek(flags_pos);
					local f = file_read4le(fp);
					fp.seek(flags_pos);
					file_write4le(fp, f & ~SHF_ALLOC);
				} catch (...) {
					print File.stderr: "Error while clearing SHF_ALLOC for", repr(name);
					throw;
				}
			}
#endif

			/* >> phdr.p_offset = orig.sh_offset;
			 * >> phdr.p_paddr  = strt.st_value;
			 * >> phdr.p_filesz = orig.sh_size;
			 * >> phdr.p_memsz  = orig.sh_size;
			 * >> phdr.p_align  = orig.sh_addralign; */
			for (local name, s: sections) {
				try {
					local phdr_pos = (e_phoff + (s.phdr_debug_xxx_wrapper_index * e_phentsize));
					if (is64) {
						fp.seek(phdr_pos + __OFFSET_ELF64_PHDR_FLAGS);
						file_write4le(fp, PF_R);                   /* p_flags */
						file_write8le(fp, s.shdr_debug_xxx_offset); /* p_offset */
						fp.seek(phdr_pos + __OFFSET_ELF64_PHDR_PADDR);
						file_write8le(fp, s.symt___kernel_debug_xxx_start - phys2virtOffset); /* p_paddr */
						file_write8le(fp, s.shdr_debug_xxx_size);  /* p_filesz */
						file_write8le(fp, s.shdr_debug_xxx_size);  /* p_memsz */
						file_write8le(fp, s.shdr_debug_xxx_align); /* p_align */
					} else {
						fp.seek(phdr_pos + __OFFSET_ELF32_PHDR_OFFSET);
						file_write4le(fp, s.shdr_debug_xxx_offset); /* p_offset */
						fp.seek(phdr_pos + __OFFSET_ELF32_PHDR_PADDR);
						file_write4le(fp, s.symt___kernel_debug_xxx_start - phys2virtOffset); /* p_paddr */
						file_write4le(fp, s.shdr_debug_xxx_size);  /* p_filesz */
						file_write4le(fp, s.shdr_debug_xxx_size);  /* p_memsz */
						file_write4le(fp, PF_R);                   /* p_flags */
						file_write4le(fp, s.shdr_debug_xxx_align); /* p_align */
					}
				} catch (...) {
					print File.stderr: "Error while overwriting PHDR for", repr(name);
					throw;
				}
			}
		}
	} @[interrupt] catch (...) {
		try fs.unlink(filename); catch (...);
		throw;
	}
}


local final function ELF_DIHACK_run(self: BoundStep): {Waitable...} {
	local th = Thread([](self: BoundStep) {
		local group = self.group;
		local options = group.options;
		local filename = options.get(OPT_ELF_DIHACK_FILE);
		if (filename is none)
			filename = options[OPT_LINK_OUTPUT];
		local phys2virtOffset = options.get(OPT_ELF_DIHACK_PHYS2VIRT);
		if (phys2virtOffset is none)
			phys2virtOffset = 0;
		elfDebuginfoAllocatedHack(
			self, group.fixFilename(filename),
			phys2virtOffset);
	}, (self, ));
	th.start();
	yield WaitableJoin(th);
}
local final function ELF_DIHACK_tostr(self: BoundStep): string {
	local group = self.group;
	local options = group.options;
	local input = options.get(OPT_ELF_DIHACK_FILE);
	if (input is none)
		input = options[OPT_LINK_OUTPUT];
	return "[{}] Enable `SHF_ALLOC' for `.debug_*' in {!r}".format({
		self.group.name,
		group.fixFilename(input)
	});
}
local final function ELF_DIHACK_getRequiredFiles(self: BoundStep): {string...} {
	local group = self.group;
	local options = group.options;
	local input = options.get(OPT_ELF_DIHACK_FILE);
	if (input is none)
		input = options[OPT_LINK_OUTPUT];
	yield group.fixFilename(input);
}

global final ELF_DIHACK: Step = Step(
	name: "ELF_DIHACK",
	options: {
		OPT_ELF_DIHACK_FILE,
		OPT_ELF_DIHACK_PHYS2VIRT,
		OPT_LINK_OUTPUT,
	},
	run: ELF_DIHACK_run,
	tostr: ELF_DIHACK_tostr,
	getRequiredFiles: ELF_DIHACK_getRequiredFiles,
	getModifiedOutputFiles: ELF_DIHACK_getRequiredFiles,
);




