/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef _CXX_TYPE_TRAITS
#define _CXX_TYPE_TRAITS 1

#include <__stdcxx.h>
#include <hybrid/typecore.h>
#include <bits/c++/varargs-template.h>
#include <bits/c++/traits/integral_constant.h>
#include <bits/c++/traits/remove_reference.h>
#include <bits/c++/traits/conditional.h>
#include <bits/c++/traits/andor.h>
#include <bits/c++/traits/remove_cv.h>
#include <bits/c++/traits/is_void.h>
#include <bits/c++/traits/add_cv.h>
#include <bits/c++/traits/is_integral.h>
#include <bits/c++/traits/is_floating_point.h>
#include <bits/c++/traits/is_array.h>
#include <bits/c++/traits/is_pointer.h>
#include <bits/c++/traits/is_reference.h>
#include <bits/c++/traits/is_function.h>
#include <bits/c++/traits/is_member.h>
#include <bits/c++/traits/is_enum.h>
#include <bits/c++/traits/is_union.h>
#include <bits/c++/traits/is_class.h>
#include <bits/c++/traits/is_member_pointer.h>
#include <bits/c++/traits/is_object.h>
#include <bits/c++/traits/is_cv.h>
#include <bits/c++/traits/is_arithmetic.h>
#include <bits/c++/traits/is_sign.h>
#include <bits/c++/traits/add_reference.h>
#include <bits/c++/traits/extent.h>
#include <bits/c++/traits/declval.h>
#include <bits/c++/traits/remove_extent.h>
#include <bits/c++/traits/remove_all_extents.h>
#include <bits/c++/traits/is_destructible.h>
#include <bits/c++/traits/is_scalar.h>
#include <bits/c++/traits/is_null_pointer.h>
#include <bits/c++/traits/is_constructible.h>
#include <bits/c++/traits/is_same.h>
#include <bits/c++/traits/is_base_of.h>
#include <bits/c++/traits/is_assignable.h>
#include <bits/c++/traits/is_convertible.h>
#include <bits/c++/traits/make_sign.h>
#include <bits/c++/traits/remove_pointer.h>
#include <bits/c++/traits/add_pointer.h>
#include <bits/c++/traits/aligned_storage.h>
#include <bits/c++/traits/decay.h>
#include <bits/c++/traits/enable_if.h>
#include <bits/c++/traits/common_type.h>
#include <bits/c++/traits/underlying_type.h>
#include <bits/c++/traits/result_of.h>

#include <bits/c++/traits/__is_referenceable.h>
#include <bits/c++/traits/__is_array_bounds.h>

__CXXDECL_BEGIN
__NAMESPACE_STD_BEGIN

#ifdef __USE_ISOCXX14
#ifdef __COMPILER_HAVE_CXX_TEMPLATE_USING
#define __cpp_lib_bool_constant 201505
template<bool __v> using bool_constant = integral_constant<bool,__v>;
#endif /* __COMPILER_HAVE_CXX_TEMPLATE_USING */
#endif /* __USE_ISOCXX14 */

#ifdef __USE_ISOCXX17
#define __cpp_lib_logical_traits 201510
#ifdef __COMPILER_HAVE_CXX_VARIABLE_TEMPLATES
template<class ...__Conditions> struct conjunction: public __NAMESPACE_INT_SYM __and_<__Conditions...> {};
template<class ...__Conditions> struct disjunction: public __NAMESPACE_INT_SYM __or_<__Conditions...> {};
#endif /* __COMPILER_HAVE_CXX_VARIABLE_TEMPLATES */
template<class __Condition> struct negation: public __NAMESPACE_INT_SYM __not_<__Condition> {};
#ifdef __COMPILER_HAVE_CXX_TEMPLATE_CONSTEXPR
template<class ...__Conditions> inline constexpr bool conjunction_v = conjunction<__Conditions...>::value;
template<class ...__Conditions> inline constexpr bool disjunction_v = disjunction<__Conditions...>::value;
template<class __Condition> inline constexpr bool negation_v = negation<__Condition>::value;
#endif /* __COMPILER_HAVE_CXX_TEMPLATE_CONSTEXPR */
#endif /* __USE_ISOCXX17 */

#ifdef __USE_ISOCXX11
#ifdef __COMPILER_HAVE_CXX_TEMPLATE_USING
#define __cpp_lib_transformation_trait_aliases 201304
template<class __T> using remove_const_t = typename remove_const<__T>::type;
template<class __T> using remove_volatile_t = typename remove_volatile<__T>::type;
template<class __T> using remove_cv_t = typename remove_cv<__T>::type;
template<class __T> using add_const_t = typename add_const<__T>::type;
template<class __T> using add_volatile_t = typename add_volatile<__T>::type;
template<class __T> using add_cv_t = typename add_cv<__T>::type;
template<class __T> using remove_extent_t = typename remove_extent<__T>::type;
template<class __T> using remove_all_extents_t = typename remove_all_extents<__T>::type;
#define __cpp_lib_transformation_trait_aliases 201304
template<class __T> using remove_const_t = typename remove_const<__T>::type;
template<class __T> using remove_volatile_t = typename remove_volatile<__T>::type;
template<class __T> using remove_cv_t = typename remove_cv<__T>::type;
template<class __T> using add_const_t = typename add_const<__T>::type;
template<class __T> using add_volatile_t = typename add_volatile<__T>::type;
template<class __T> using add_cv_t = typename add_cv<__T>::type;
template<class __T> using remove_reference_t = typename remove_reference<__T>::type;
template<class __T> using add_lvalue_reference_t = typename add_lvalue_reference<__T>::type;
template<class __T> using add_rvalue_reference_t = typename add_rvalue_reference<__T>::type;
template<class __T> using make_signed_t = typename make_signed<__T>::type;
template<class __T> using make_unsigned_t = typename make_unsigned<__T>::type;
template<class __T> using remove_extent_t = typename remove_extent<__T>::type;
template<class __T> using remove_all_extents_t = typename remove_all_extents<__T>::type;
template<class __T> using remove_pointer_t = typename remove_pointer<__T>::type;
template<class __T> using add_pointer_t = typename add_pointer<__T>::type;
template<__SIZE_TYPE__ __StorageSize, __SIZE_TYPE__ __Alignment = __PRIVATE_MAX_ALIGN_FOR_LENGTH(__StorageSize)>
using aligned_storage_t = typename aligned_storage<__StorageSize,__Alignment>::type;
#ifdef __std_aligned_union_defined
#ifdef __COMPILER_HAVE_CXX_VARIABLE_TEMPLATES
template <__SIZE_TYPE__ __StorageSize, class ...__Types>
using aligned_union_t = typename aligned_union<__StorageSize,__Types...>::type;
#endif /* __COMPILER_HAVE_CXX_VARIABLE_TEMPLATES */
#endif /* __std_aligned_union_defined */
template<class __T> using decay_t = typename decay<__T>::type;
template<bool __Condition, class __T = void> using enable_if_t = typename enable_if<__Condition,__T>::type;
template<bool __Condition, class __TrueType, class __FalseType>
using conditional_t = typename conditional<__Condition,__TrueType,__FalseType>::type;
#ifdef __std_common_type_defined
#ifdef __COMPILER_HAVE_CXX_VARIABLE_TEMPLATES
template<class ...__T> using common_type_t = typename common_type<__T...>::type;
#endif /* __COMPILER_HAVE_CXX_VARIABLE_TEMPLATES */
#endif /* __std_common_type_defined */
#ifdef __std_underlying_type_defined
template<class __T> using underlying_type_t = typename underlying_type<__T>::type;
#endif /* __std_underlying_type_defined */
#ifdef __std_result_of_defined
template<class __Signature> using result_of_t = typename result_of<__Signature>::type;
#endif /* __std_result_of_defined */
#endif /* __COMPILER_HAVE_CXX_TEMPLATE_USING */
#endif /* __USE_ISOCXX11 */

template<class __T> struct is_fundamental: public __NAMESPACE_INT_SYM __or_<is_arithmetic<__T>,is_void<__T>,is_null_pointer<__T> >::type {};
template<class __T> struct is_compound: public integral_constant<bool,!is_fundamental<__T>::value> {};

template<class __T> struct is_trivial: public integral_constant<bool,__is_trivial(__T)> {};
template<class __T> struct is_trivially_copyable: public integral_constant<bool,__is_trivially_copyable(__T)> {};
template<class __T> struct is_standard_layout: public integral_constant<bool,__is_standard_layout(__T)> {};
template<class __T> struct is_pod: public integral_constant<bool,__is_pod(__T)> {};
template<class __T> struct is_literal_type: public integral_constant<bool,__is_literal_type(__T)> {};
template<class __T> struct is_empty: public integral_constant<bool,__is_empty(__T)> {};
template<class __T> struct is_polymorphic: public integral_constant<bool,__is_polymorphic(__T)> {};
#ifdef __USE_ISOCXX14
#define __cpp_lib_is_final 201402L
template<class __T> struct is_final: public integral_constant<bool,__is_final(__T)> {};
#endif /* __USE_ISOCXX14 */
template<class __T> struct is_abstract: public integral_constant<bool,__is_abstract(__T)> {};
template<class __T> struct alignment_of: public integral_constant<__SIZE_TYPE__,__COMPILER_ALIGNOF(__T)> {};
template<class __T> struct rank: public integral_constant<__SIZE_TYPE__,0> {};
template<class __T, __SIZE_TYPE__ __Size> struct rank<__T[__Size]>: public integral_constant<__SIZE_TYPE__,1+rank<__T>::value> {};
template<class __T> struct rank<__T[]>: public integral_constant<__SIZE_TYPE__,1+rank<__T>::value> {};

#ifndef __std_reference_wrapper_defined
#define __std_reference_wrapper_defined 1
template<class __T> class reference_wrapper;
#endif /* !__std_reference_wrapper_defined */

#if defined(__USE_ISOCXX14) || defined(__USE_GNU)
#ifdef __COMPILER_HAVE_CXX_TEMPLATE_USING
#define __cpp_lib_void_t 201411
template<__CXX_VARARGS_TEMPLATE_ARGS_DEF(class,__Types,void)> using void_t = void;
#endif /* __COMPILER_HAVE_CXX_TEMPLATE_USING */
#endif

__NAMESPACE_STD_END
__CXXDECL_END


#endif /* !_CXX_TYPE_TRAITS */
