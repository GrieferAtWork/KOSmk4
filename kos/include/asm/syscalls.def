/* Copyright (c) 2019-2020 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2020 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
/* NOTE: Changes to this file are applied by calling
 *       $ deemon misc/generate_syscalls.dee
 */


/* Define some universally applicable type compatibilities. */
%[typecompat(
	*:void = *:void,
)]
%[typesize(*:[u8,s8,uint8_t,u_int8_t,int8_t,__INT8_TYPE__,__UINT8_TYPE__] = 1)]
%[typesize(*:[u16,s16,uint16_t,u_int16_t,int16_t,__INT16_TYPE__,__UINT16_TYPE__] = 2)]
%[typesize(*:[u32,s32,uint32_t,u_int32_t,int32_t,ulong32_t,long32_t,__INT32_TYPE__,__UINT32_TYPE__,__LONG32_TYPE__,__ULONG32_TYPE__] = 4)]
%[typesize(*:[u64,s64,uint64_t,u_int64_t,int64_t,ulong64_t,long64_t,__INT64_TYPE__,__UINT64_TYPE__,__LONG64_TYPE__,__ULONG64_TYPE__] = 8)]
%[typesize(*:[u128,s128,uint128_t,u_int128_t,int128_t,ulong128_t,long128_t,__INT128_TYPE__,__UINT128_TYPE__,__LONG128_TYPE__,__ULONG128_TYPE__] = 16)]
%[typesize(*:[uid_t] = 4)]
%[typesize(*:[gid_t] = uid_t)]
%[typesize(*:[pid_t] = 4)]

%[typesize(*:[schar,uchar] = char)]
%[typesize(*:[ushort] = short)]
%[typesize(*:[unsigned,signed,uint] = int)]
%[typesize(*:[ulong] = long)]
%[typesize(*:[ullong] = llong)]
%[typesize(*:[errno_t,signo_t,mode_t,oflag_t,fd_t] = int)]
%[typesize(*:[syscall_ulong_t] = ulong)]
%[typesize(*:[syscall_slong_t] = syscall_ulong_t)]
%[typesize(*:[socklen_t,size_t] = syscall_ulong_t)]
%[typesize(*:[uintptr_t] = size_t)]
%[typesize(*:[intptr_t] = uintptr_t)]
%[typesize(*:[intptr_half_t] = uintptr_half_t)]
%[typesize(*:[intptr_quarter_t] = uintptr_quarter_t)]
%[typesize(*:[time32_t] = syscall_ulong_t)]
%[typesize(*:[time64_t] = 8)]

%[signed_types(schar, short, signed, int, long, llong)]
%[signed_types(s8, int8_t, __INT8_TYPE__)]
%[signed_types(s16, int16_t, __INT16_TYPE__)]
%[signed_types(s32, int32_t, long32_t, __INT32_TYPE__, __LONG32_TYPE__)]
%[signed_types(s64, int64_t, long64_t, __INT64_TYPE__, __LONG64_TYPE__)]
%[signed_types(s128, int128_t, long128_t, __INT128_TYPE__, __LONG128_TYPE__)]
%[signed_types(syscall_slong_t, intptr_t, intptr_half_t, intptr_quarter_t)]
%[signed_types(time32_t, time64_t, ssize_t)]
%[signed_types(errno_t, signo_t, oflag_t, fd_t)]

/* Syscall definition syntax
 * >> sysno:name
 * This is used as:
 * >> #define __NR_<name>  <sysno>      // In <asm/unistd.h>
 * >> #define SYS_<name>   __NR_<name>  // In <sys/syscall.h>
 * >> DEFINE_SYSCALLn(int, <name>, ...) // Somewhere in kernel-space
 * >> int <name>(...);                  // In <kos/syscalls.h>
 */

%[typeorg(<hybrid/typecore.h>: __UINT8_TYPE__, __INT8_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINT16_TYPE__, __INT16_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINT32_TYPE__, __INT32_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINT64_TYPE__, __INT64_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __SIZE_TYPE__, __PTRDIFF_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINTPTR_TYPE__, __INTPTR_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __ULONGPTR_TYPE__, __LONGPTR_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __ULONG32_TYPE__, __ULONG64_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __LONG32_TYPE__, __LONG64_TYPE__)]

%[typeorg(<bits/types.h>: __u_char, __u_short, __u_int, __u_long)]
%[typeorg(<bits/types.h>: __u8, __u16, __u32, __u64)]
%[typeorg(<bits/types.h>: __s8, __s16, __s32, __s64)]
%[typeorg(<bits/types.h>: __uint8_t, __uint16_t, __uint32_t, __uint64_t)]
%[typeorg(<bits/types.h>: __int8_t, __int16_t, __int32_t, __int64_t)]
%[typeorg(<bits/types.h>: __intptr_t, __uintptr_t)]
%[typeorg(<bits/types.h>: __quad_t, __u_quad_t)]
%[typeorg(<bits/types.h>: __ptrdiff_t, __size_t, __ssize_t)]
%[typeorg(<bits/types.h>: __byte_t, __register_t, __sregister_t)]
%[typeorg(<bits/types.h>: __syscall_slong_t, __syscall_ulong_t)]
%[typeorg(<bits/types.h>: __oflag_t, __mode_t, __atflag_t, __iomode_t, __fd_t, __ufd_t)]
%[typeorg(<bits/types.h>: __major_t, __minor_t, __dev_t, __id_t, __pid_t, __upid_t)]
%[typeorg(<bits/types.h>: __key_t, __daddr_t, __caddr_t, __qaddr_t)]
%[typeorg(<bits/types.h>: __off32_t, __off64_t, __blkcnt32_t, __blkcnt64_t)]
%[typeorg(<bits/types.h>: __fsblkcnt32_t, __fsblkcnt64_t)]
%[typeorg(<bits/types.h>: __fsfilcnt32_t, __fsfilcnt64_t)]
%[typeorg(<bits/types.h>: __ino32_t, __ino64_t, __pos32_t, __pos64_t)]
%[typeorg(<bits/types.h>: __loff_t, __lpos_t, __fsword_t)]
%[typeorg(<bits/types.h>: __socklen_t, __ssocklen_t, __rlim32_t, __rlim64_t)]
%[typeorg(<bits/types.h>: __blksize_t, __nlink_t, __fsid_t)]
%[typeorg(<bits/types.h>: __time32_t, __time64_t)]
%[typeorg(<bits/types.h>: __quantum_diff_t, __clock_t, __suseconds_t, __clockid_t)]
%[typeorg(<bits/types.h>: __gid_t, __uid_t, __useconds_t, __jtime_t, __timer_t)]
%[typeorg(<bits/itimerspec.h>: itimerspec, itimerspec32, itimerspec64, __itimerspec32, __itimerspec64)]
%[typeorg(<bits/itimerspec32.h>: __itimerspecx32, __itimerspecx32_64, itimerspecx32, itimerspecx32_64)]
%[typeorg(<bits/itimerspec64.h>: __itimerspecx64, itimerspecx64)]
%[typeorg(<bits/itimerval.h>: itimerval, itimerval32, itimerval64, __itimerval32, __itimerval64)]
%[typeorg(<bits/itimerval32.h>: __itimervalx32, __itimervalx32_64, itimervalx32, itimervalx32_64)]
%[typeorg(<bits/itimerval64.h>: __itimervalx64, itimervalx64)]
%[typeorg(<bits/timespec.h>: timespec, timespec32, timespec64, __timespec32, __timespec64)]
%[typeorg(<bits/timespec32.h>: __timespecx32, __timespecx32_64, timespecx32, timespecx32_64)]
%[typeorg(<bits/timespec64.h>: __timespecx64, timespecx64)]
%[typeorg(<bits/timeval.h>: timeval, timeval32, timeval64, __timeval32, __timeval64)]
%[typeorg(<bits/timeval32.h>: __timevalx32, __timevalx32_64, timevalx32, timevalx32_64)]
%[typeorg(<bits/timeval64.h>: __timevalx64, timevalx64)]
%[typeorg(<bits/timeb.h>: timeb, timeb32, timeb64, __timeb32, __timeb64)]
%[typeorg(<bits/timeb32.h>: __timebx32, __timebx32_64, timebx32, timebx32_64)]
%[typeorg(<bits/timeb64.h>: __timebx64, timebx64)]
%[typeorg(<bits/utimbuf.h>: utimbuf, utimbuf32, utimbuf64, __utimbuf32, __utimbuf64)]
%[typeorg(<bits/utimbuf32.h>: __utimbufx32, __utimbufx32_64, utimbufx32, utimbufx32_64)]
%[typeorg(<bits/utimbuf64.h>: __utimbufx64, utimbufx64)]
%[typeorg(<bits/rusage-struct.h>: rusage, __rusage32, __rusage64)]
%[typeorg(<bits/rusage-struct32.h>: rusagex32, __rusagex32, rusagex32_64, __rusagex32_64)]
%[typeorg(<bits/rusage-struct64.h>: rusagex64, __rusagex64)]
%[typeorg(<bits/stat-kos.h>: __kos_stat)]
%[typeorg(<bits/stat-kos32.h>: __kos_statx32)]
%[typeorg(<bits/stat-kos64.h>: __kos_statx64)]
%[typeorg(<bits/statfs.h>: statfs, statfs32, statfs64, __statfs32, __statfs64)]
%[typeorg(<bits/statfs32.h>: statfsx32, __statfsx32, statfsx32_64, __statfsx32_64)]
%[typeorg(<bits/statfs64.h>: statfsx64, __statfsx64)]
%[typeorg(<bits/sigaction-struct.h>: sigaction, __sighandler_t)]
%[typeorg(<bits/sigaction-struct32.h>: sigactionx32, __sigactionx32, __sighandlerx32_t)]
%[typeorg(<bits/sigaction-struct64.h>: sigactionx64, __sigactionx64, __sighandlerx64_t)]
%[typeorg(<bits/siginfo-struct.h>: __siginfo_struct, siginfo_t)]
%[typeorg(<bits/siginfo-struct32.h>: __siginfox32_struct, siginfox32_t)]
%[typeorg(<bits/siginfo-struct64.h>: __siginfox64_struct, siginfox64_t)]
%[typeorg(<hybrid/__pointer.h>: __HYBRID_PTR32, __HYBRID_PTR64)]
%[typeorg(<bits/iovec-struct.h>: iovec)]
%[typeorg(<bits/iovec-struct32.h>: iovecx32, __iovecx32)]
%[typeorg(<bits/iovec-struct64.h>: iovecx64, __iovecx64)]
%[typeorg(<bits/msghdr-struct.h>: msghdr)]
%[typeorg(<bits/msghdr-struct32.h>: msghdrx32, __msghdrx32)]
%[typeorg(<bits/msghdr-struct64.h>: msghdrx64, __msghdrx64)]
%[typeorg(<bits/cmsghdr-struct.h>: cmsghdr)]
%[typeorg(<bits/cmsghdr-struct32.h>: cmsghdrx32, __cmsghdrx32)]
%[typeorg(<bits/cmsghdr-struct64.h>: cmsghdrx64, __cmsghdrx64)]
%[typeorg(<bits/mmsghdr-struct.h>: mmsghdr)]
%[typeorg(<bits/mmsghdr-struct32.h>: mmsghdrx32, __mmsghdrx32)]
%[typeorg(<bits/mmsghdr-struct64.h>: mmsghdrx64, __mmsghdrx64)]
%[typeorg(<bits/sigstack.h>: sigstack, sigaltstack)]
%[typeorg(<bits/sigstack32.h>: __sigstackx32, __sigaltstackx32)]
%[typeorg(<bits/sigstack64.h>: __sigstackx64, __sigaltstackx64)]
%[typeorg(<bits/pollfd.h>: pollfd)]
%[typeorg(<bits/sigval.h>: sigval)]
%[typeorg(<bits/sigval32.h>: __sigvalx32)]
%[typeorg(<bits/sigval64.h>: __sigvalx64)]
%[typeorg(<kos/bits/rtm.h>: __rtm_status_t)]
%[typeorg(<kos/rtm.h>: rtm_status_t)]

/* Define how specific struct names should be escaped in headers */
%[struct_escape(sigactionx32 = __sigactionx32, sigactionx64 = __sigactionx64)]
%[struct_escape(iovecx32 = __iovecx32, iovecx64 = __iovecx64)]
%[struct_escape(msghdrx32 = __msghdrx32, msghdrx64 = __msghdrx64)]
%[struct_escape(cmsghdrx32 = __cmsghdrx32, cmsghdrx64 = __cmsghdrx64)]
%[struct_escape(mmsghdrx32 = __mmsghdrx32, mmsghdrx64 = __mmsghdrx64)]
%[struct_escape(timespec32 = __timespec32, timespecx32 = __timespecx32, timespecx32_64 = __timespecx32_64)]
%[struct_escape(timespec64 = __timespec64, timespecx64 = __timespecx64)]
%[struct_escape(timeval32 = __timeval32, timevalx32 = __timevalx32, timevalx32_64 = __timevalx32_64)]
%[struct_escape(timeval64 = __timeval64, timevalx64 = __timevalx64)]
%[struct_escape(itimerval32 = __itimerval32, itimervalx32 = __itimervalx32, itimervalx32_64 = __itimervalx32_64)]
%[struct_escape(itimerval64 = __itimerval64, itimervalx64 = __itimervalx64)]
%[struct_escape(itimerspec32 = __itimerspec32, itimerspecx32 = __itimerspecx32, itimerspecx32_64 = __itimerspecx32_64)]
%[struct_escape(itimerspec64 = __itimerspec64, itimerspecx64 = __itimerspecx64)]
%[struct_escape(rusage32 = __rusage32, rusagex32 = __rusagex32, rusagex32_64 = __rusagex32_64)]
%[struct_escape(rusage64 = __rusage64, rusagex64 = __rusagex64)]
%[struct_escape(timeb32 = __timeb32, timebx32 = __timebx32, timebx32_64 = __timebx32_64)]
%[struct_escape(timeb64 = __timeb64, timebx64 = __timebx64)]
%[struct_escape(utimbuf32 = __utimbuf32, utimbufx32 = __utimbufx32, utimbufx32_64 = __utimbufx32_64)]
%[struct_escape(utimbuf64 = __utimbuf64, utimbufx64 = __utimbufx64)]
%[struct_escape(statfs32 = __statfs32, statfsx32 = __statfsx32, statfsx32_64 = __statfsx32_64)]
%[struct_escape(statfs64 = __statfs64, statfsx64 = __statfsx64)]

%[typeorg(<librpc/bits/syscall-info.h>: rpc_syscall_info)]
%[typeorg(<librpc/bits/syscall-info32.h>: rpc_syscall_info32)]
%[typeorg(<librpc/bits/syscall-info64.h>: rpc_syscall_info64)]

%[typeorg(<kos/bits/except-handler.h>: __except_handler_t)]
%[typeorg(<kos/bits/except-handler32.h>: __except_handler32_t)]
%[typeorg(<kos/bits/except-handler64.h>: __except_handler64_t)]
%[typeorg(<kos/bits/debugtrap.h>: debugtrap_reason)]
%[typeorg(<kos/bits/debugtrap32.h>: debugtrap_reason32)]
%[typeorg(<kos/bits/debugtrap64.h>: debugtrap_reason64)]
%[typeorg(<kos/bits/exception_data.h>: exception_data)]
%[typeorg(<kos/bits/exception_data32.h>: exception_data32)]
%[typeorg(<kos/bits/exception_data64.h>: exception_data64)]
%[typeorg(<kos/exec/bits/peb.h>: process_peb)]
%[typeorg(<kos/exec/bits/peb32.h>: process_peb32)]
%[typeorg(<kos/exec/bits/peb64.h>: process_peb64)]
%[typeorg(<kos/exec/elf.h>: elfexec_info)]
%[typeorg(<kos/exec/asm/elf32.h>: elfexec_info32)]
%[typeorg(<kos/exec/asm/elf64.h>: elfexec_info64)]
%[typeorg(<kos/bits/ukern-struct.h>: userkern)]
%[typeorg(<kos/bits/ukern-struct32.h>: userkern32)]
%[typeorg(<kos/bits/ukern-struct64.h>: userkern64)]
%[typeorg(<kos/kernel/cpu-state.h>: ucpustate, lcpustate, kcpustate, icpustate, scpustate, fcpustate)]
%[typeorg(<kos/kernel/cpu-state32.h>: ucpustate32, lcpustate32, kcpustate32, icpustate32, scpustate32, fcpustate32)]
%[typeorg(<kos/kernel/cpu-state64.h>: ucpustate64, lcpustate64, kcpustate64, icpustate64, scpustate64, fcpustate64)]
%[typeorg(<kos/kernel/fpu-sstate.h>: sfpuenv, sfpustate)]
%[typeorg(<kos/kernel/fpu-state.h>: xfpustate, fpustate)]
%[typeorg(<kos/kernel/fpu-state32.h>: xfpustate32, fpustate32)]
%[typeorg(<kos/kernel/fpu-state64.h>: xfpustate64, fpustate64)]
%[typeorg(<kos/kernel/gdb-cpu-state.h>: gdb_cpustate)]
%[typeorg(<kos/kernel/gdb-cpu-state32.h>: gdb_cpustate32)]
%[typeorg(<kos/kernel/gdb-cpu-state64.h>: gdb_cpustate64)]
%[typeorg(<kos/kernel/segment.h>: segment, idt_segment)]
%[typeorg(<bits/mcontext.h>: gregset_t, fpregset_t, mcontext)]
%[typeorg(<bits/mcontext32.h>: __gregsetx32_t, __fpregsetx32_t, __mcontextx32)]
%[typeorg(<bits/mcontext64.h>: __gregsetx64_t, __fpregsetx64_t, __mcontextx64)]
%[typeorg(<bits/ucontext.h>: ucontext)]
%[typeorg(<bits/ucontext32.h>: __ucontextx32)]
%[typeorg(<bits/ucontext64.h>: __ucontextx64)]
%[typeorg(<kos/exec/bits/library-listdef.h>: library_listdef)]
%[typeorg(<kos/exec/bits/library-listdef32.h>: library_listdef32)]
%[typeorg(<kos/exec/bits/library-listdef64.h>: library_listdef64)]
%[typeorg(<kos/bits/futex-expr.h>: lfutexexpr)]
%[typeorg(<kos/bits/futex-expr32.h>: lfutexexprx32)]
%[typeorg(<kos/bits/futex-expr64.h>: lfutexexprx64)]
%[typeorg(<librt/bits/aiocb.h>: aiocb, aiocb32, aiocb64, __aiocb32, __aiocb64)]
%[typeorg(<librt/bits/aioinit.h>: aioinit)]
%[typeorg(<librt/bits/mqueue.h>: mq_attr)]
%[typeorg(<elf.h>: elf32_phdr, elf64_phdr)]
%[typeorg(<kos/bits/spawn-action.h>: spawn_action, spawn_actions, spawn_action_list)]
%[typeorg(<kos/bits/spawn-action32.h>: spawn_actionx32, spawn_actionsx32, spawn_action_listx32)]
%[typeorg(<kos/bits/spawn-action64.h>: spawn_actionx64, spawn_actionsx64, spawn_action_listx64)]

%[mustundef(timezone, timeb, stat, dirent)]

%[define_tostr(char               = CHAR)]
%[define_tostr(signed char        = SIGNED_CHAR)]
%[define_tostr(unsigned char      = UNSIGNED_CHAR)]
%[define_tostr(short              = SHORT)]
%[define_tostr(signed short       = SHORT)]
%[define_tostr(unsigned short     = UNSIGNED_SHORT)]
%[define_tostr(int                = INT)]
%[define_tostr(signed             = INT)]
%[define_tostr(signed int         = INT)]
%[define_tostr(unsigned           = UNSIGNED_INT)]
%[define_tostr(unsigned int       = UNSIGNED_INT)]
%[define_tostr(long               = LONG)]
%[define_tostr(signed long        = LONG)]
%[define_tostr(unsigned long      = UNSIGNED_LONG)]
%[define_tostr(long long          = LONG_LONG)]
%[define_tostr(signed long long   = LONG_LONG)]
%[define_tostr(unsigned long long = UNSIGNED_LONG_LONG)]

%[define_tostr(char const *         = STRING)]
%[define_tostr(timer_t              = TIMER_T)]
%[define_tostr(sighandler_t         = SIGHANDLER_T)]
%[define_tostr(except_handler_t     = EXCEPT_HANDLER_T)]
%[define_tostr(__except_handler32_t = EXCEPT_HANDLER_T)]
%[define_tostr(__except_handler64_t = EXCEPT_HANDLER_T)]
%[define_tostr(intptr_t             = INTPTR_T)]
%[define_tostr(uintptr_t            = UINTPTR_T)]
%[define_tostr(ssize_t              = SSIZE_T)]
%[define_tostr(ptrdiff_t            = PTRDIFF_T)]
%[define_tostr(size_t               = SIZE_T)]
%[define_tostr(int8_t               = INT8_T)]
%[define_tostr(uint8_t              = UINT8_T)]
%[define_tostr(int16_t              = INT16_T)]
%[define_tostr(uint16_t             = UINT16_T)]
%[define_tostr(int32_t              = INT32_T)]
%[define_tostr(uint32_t             = UINT32_T)]
%[define_tostr(int64_t              = INT64_T)]
%[define_tostr(uint64_t             = UINT64_T)]
%[define_tostr(id_t                 = ID_T)]
%[define_tostr(syscall_slong_t      = SYSCALL_SLONG_T)]
%[define_tostr(syscall_ulong_t      = SYSCALL_ULONG_T)]
%[define_tostr(clockid_t            = CLOCKID_T)]
%[define_tostr(pid_t                = PID_T)]
%[define_tostr(gid_t                = GID_T)]
%[define_tostr(uid_t                = UID_T)]
%[define_tostr(fd_t                 = FD_T)]
%[define_tostr(errno_t              = ERRNO_T)]
%[define_tostr(signo_t              = SIGNO_T)]
%[define_tostr(iomode_t             = IOMODE_T)]
%[define_tostr(atflag_t             = ATFLAG_T)]
%[define_tostr(oflag_t              = OFLAG_T)]
%[define_tostr(mode_t               = MODE_T)]
%[define_tostr(socklen_t            = SOCKLEN_T)]
%[define_tostr(dev_t                = DEV_T)]
%[define_tostr(time_t               = TIME_T)]
%[define_tostr(time32_t             = TIME_T)]
%[define_tostr(time64_t             = TIME_T)]





/* Unimplemented syscalls */
break:() -> errno_t;
restart_syscall:() -> errno_t;
stty:() -> errno_t;
gtty:() -> errno_t;
prof:() -> errno_t;
lock:() -> errno_t;
mpx:() -> errno_t;
ulimit:() -> errno_t;
idle:() -> errno_t;

[restart(must)][noreturn] exit:([tostr(EXIT_STATUS)] syscall_ulong_t status);
[restart(must)][noreturn] exit_group:([tostr(EXIT_STATUS)] syscall_ulong_t exit_code);

[restart(must)] fork:() -> pid_t;
[restart(must)] vfork:() -> pid_t;

[cp] read:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize) -> ssize_t;
[cp] readf:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize, iomode_t mode) -> ssize_t;
[cp] write:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize) -> ssize_t;
[cp] writef:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize, iomode_t mode) -> ssize_t;
[cp] open:([tostr(FILENAME)] char const *filename, oflag_t oflags, [tostr(MODE_T:oflags)] mode_t mode) -> fd_t;
[cp] openat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, oflag_t oflags, [tostr(MODE_T:oflags)] mode_t mode) -> fd_t;


@@Close a given file descriptor/handle `FD'
//[cp] /* Even though pthread allows this, I thing this would be a _really_ bad idea... */
[restart(must)] close:(fd_t fd) -> errno_t;

@@Wait for a child process:
@@ - `pid < -1':  Wait for any child process whose process group ID is `-PID'
@@ - `pid == -1': Wait for any child process
@@ - `pid == 0':  Wait for any child process whose process group ID is that of the caller
@@ - `pid > 0':   Wait for the child whose process ID is equal to `PID'
@@@param: options: Set of `WNOHANG | WUNTRACED | WCONTINUED' (as a KOS extension, `WNOWAIT' is also accepted)
[restart(dont)][cp]
waitpid:(pid_t pid, int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options) -> pid_t;

[cp] creat:([tostr(FILENAME)] char const *filename, mode_t mode) -> fd_t;
[cp] link:([tostr(FILENAME)] char const *existing_file, [tostr(FILENAME)] char const *link_file) -> errno_t;

[cp] unlink:([tostr(FILENAME)] char const *filename) -> errno_t;
@@@param: flags: Set of `0 | AT_REMOVEDIR | AT_REMOVEREG | AT_DOSPATH'
[cp] unlinkat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *name,
               [tostr(ATFLAG__REMOVEDIR__REMOVEREG__DOSPATH)] atflag_t flags) -> errno_t;
rmdir:(char const *path) -> errno_t;

[cp] chdir:([tostr(FILENAME)] char const *path) -> errno_t;
[cp] fchdir:(fd_t fd) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fchdirat:(fd_t dirfd,
               [tostr(FILENAME:dirfd)] char const *path,
               [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;

%[startgroup]
time:(time32_t *timer) -> time32_t;
time64:(time64_t *timer) -> [reg64] time64_t;
timex32:(int32_t *timer) -> [tostr(TIME_T)] int32_t;
timex64:(int64_t *timer) -> [reg64][tostr(TIME_T)] int64_t;
%[endgroup]

[cp] mknod:([tostr(FILENAME)] char const *nodename, mode_t mode, [tostr(DEV_T:mode)] dev_t dev) -> errno_t;
[cp] mknodat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *nodename,
              mode_t mode, [tostr(DEV_T:mode)] dev_t dev) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fmknodat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *nodename,
               mode_t mode, [tostr(DEV_T:mode)] dev_t dev,
               [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;

[cp] chmod:([tostr(FILENAME)] char const *filename, mode_t mode) -> errno_t;

%[startgroup]
[cp] lchown:([tostr(FILENAME)] char const *filename, uid_t owner, gid_t group) -> errno_t;
[cp] lchown16:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint16_t owner, [tostr(GID_T)] uint16_t group) -> errno_t;
[cp] lchown32:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint32_t owner, [tostr(GID_T)] uint32_t group) -> errno_t;
%[endgroup]

%[startgroup]
[cp] fchown:(fd_t fd, uid_t owner, gid_t group) -> errno_t;
[cp] fchown16:(fd_t fd, [tostr(UID_T)] uint16_t owner, [tostr(GID_T)] uint16_t group) -> errno_t;
[cp] fchown32:(fd_t fd, [tostr(UID_T)] uint32_t owner, [tostr(GID_T)] uint32_t group) -> errno_t;
%[endgroup]

%[startgroup]
[cp] chown:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uid_t owner, [tostr(GID_T)] gid_t group) -> errno_t;
[cp] chown16:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint16_t owner, [tostr(GID_T)] uint16_t group) -> errno_t;
[cp] chown32:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint32_t owner, [tostr(GID_T)] uint32_t group) -> errno_t;
%[endgroup]

@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] fchownat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, uid_t owner, gid_t group,
               [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;


%[startgroup]
[cp] lseek:(fd_t fd, syscall_slong_t offset, [tostr(SEEK_WHENCE)] syscall_ulong_t whence) -> syscall_slong_t;
[cp] lseek64:(fd_t fd, [reg64] int64_t offset, [tostr(SEEK_WHENCE)] syscall_ulong_t whence) -> [reg64] int64_t;
%[endgroup]

[restart(must)] getpid:() -> pid_t;
[cp] mount:([tostr(FILENAME)] char const *special_file,
            [tostr(FILENAME)] char const *dir,
            [tostr(STRING)] char const *fstype,
            [tostr(MOUNT_FLAGS)] syscall_ulong_t mountflags,
            [tostr(STRING)] void const *data) -> errno_t;
[cp] umount:([tostr(FILENAME)] char const *special_file) -> errno_t;



%[startgroup]
[restart(must)] getuid:() -> uid_t;
[restart(must)] getuid16:() -> [tostr(UID_T)] uint16_t;
[restart(must)] getuid32:() -> [tostr(UID_T)] uint32_t;
%[endgroup]

%[startgroup]
[restart(must)] setuid:(uid_t uid) -> errno_t;
[restart(must)] setuid16:([tostr(UID_T)] uint16_t uid) -> errno_t;
[restart(must)] setuid32:([tostr(UID_T)] uint32_t uid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] getgid:() -> gid_t;
[restart(must)] getgid16:() -> [tostr(GID_T)] uint16_t;
[restart(must)] getgid32:() -> [tostr(GID_T)] uint32_t;
%[endgroup]

%[startgroup]
[restart(must)] setgid:(gid_t gid) -> errno_t;
[restart(must)] setgid16:([tostr(GID_T)] uint16_t gid) -> errno_t;
[restart(must)] setgid32:([tostr(GID_T)] uint32_t gid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] geteuid:() -> uid_t;
[restart(must)] geteuid16:() -> [tostr(UID_T)] uint16_t;
[restart(must)] geteuid32:() -> [tostr(UID_T)] uint32_t;
%[endgroup]

%[startgroup]
[restart(must)] setreuid:(uid_t ruid, uid_t euid) -> errno_t;
[restart(must)] setreuid16:([tostr(UID_T)] uint16_t ruid, [tostr(UID_T)] uint16_t euid) -> errno_t;
[restart(must)] setreuid32:([tostr(UID_T)] uint32_t ruid, [tostr(UID_T)] uint32_t euid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] getegid:() -> gid_t;
[restart(must)] getegid16:() -> [tostr(GID_T)] uint16_t;
[restart(must)] getegid32:() -> [tostr(GID_T)] uint32_t;
%[endgroup]

%[startgroup]
[restart(must)] setregid:(gid_t rgid, gid_t egid) -> errno_t;
[restart(must)] setregid16:([tostr(GID_T)] uint16_t rgid, [tostr(GID_T)] uint16_t egid) -> errno_t;
[restart(must)] setregid32:([tostr(GID_T)] uint32_t rgid, [tostr(GID_T)] uint32_t egid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] getresuid:([tostr(out:UID_T)] uid_t *ruid, [tostr(out:UID_T)] uid_t *euid, [tostr(out:UID_T)] uid_t *suid) -> errno_t;
[restart(must)] getresuid16:([tostr(out:UID16_T)] uint16_t *ruid, [tostr(out:UID16_T)] uint16_t *euid, [tostr(out:UID16_T)] uint16_t *suid) -> errno_t;
[restart(must)] getresuid32:([tostr(out:UID32_T)] uint32_t *ruid, [tostr(out:UID32_T)] uint32_t *euid, [tostr(out:UID32_T)] uint32_t *suid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] setresuid:(uid_t ruid, uid_t euid, uid_t suid) -> errno_t;
[restart(must)] setresuid16:([tostr(UID_T)] uint16_t ruid, [tostr(UID_T)] uint16_t euid, [tostr(UID_T)] uint16_t suid) -> errno_t;
[restart(must)] setresuid32:([tostr(UID_T)] uint32_t ruid, [tostr(UID_T)] uint32_t euid, [tostr(UID_T)] uint32_t suid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] getresgid:([tostr(out:GID_T)] gid_t *rgid, [tostr(out:GID_T)] gid_t *egid, [tostr(out:GID_T)] gid_t *sgid) -> errno_t;
[restart(must)] getresgid16:([tostr(out:GID16_T)] uint16_t *rgid, [tostr(out:GID16_T)] uint16_t *egid, [tostr(out:GID16_T)] uint16_t *sgid) -> errno_t;
[restart(must)] getresgid32:([tostr(out:GID32_T)] uint32_t *rgid, [tostr(out:GID32_T)] uint32_t *egid, [tostr(out:GID32_T)] uint32_t *sgid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] setresgid:(gid_t rgid, gid_t egid, gid_t sgid) -> errno_t;
[restart(must)] setresgid16:([tostr(GID_T)] uint16_t rgid, [tostr(GID_T)] uint16_t egid, [tostr(GID_T)] uint16_t sgid) -> errno_t;
[restart(must)] setresgid32:([tostr(GID_T)] uint32_t rgid, [tostr(GID_T)] uint32_t egid, [tostr(GID_T)] uint32_t sgid) -> errno_t;
%[endgroup]

%[startgroup]
@@@return: * :     [count == 0] The required number of groups
@@@return: * :     [count != 0] The number of groups that were actually returned
@@@throw: -EINVAL: [count != 0] There are more than `count' groups (NOTE: No exception is thrown for this case!)
[restart(must)] getgroups:(size_t count, [tostr(out:GID_VECTOR:count)] gid_t list[]) -> ssize_t;
[doc_alias(getgroups)][restart(must)] getgroups32:(size_t count, [tostr(out:GID_VECTOR32:count)] uint32_t list[]) -> ssize_t;
[doc_alias(getgroups)][restart(must)] getgroups16:(size_t count, [tostr(out:GID_VECTOR16:count)] uint16_t list[]) -> ssize_t;
%[endgroup]

%[startgroup]
[restart(must)] setgroups:(size_t count, [tostr(GID_VECTOR:count)] gid_t const *groups) -> errno_t;
[restart(must)] setgroups16:(size_t count, [tostr(GID_VECTOR16:count)] uint16_t const *groups) -> errno_t;
[restart(must)] setgroups32:(size_t count, [tostr(GID_VECTOR32:count)] uint32_t const *groups) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] setfsuid:(uid_t uid) -> errno_t;
[restart(must)] setfsuid16:([tostr(UID_T)] uint16_t uid) -> errno_t;
[restart(must)] setfsuid32:([tostr(UID_T)] uint32_t uid) -> errno_t;
%[endgroup]

%[startgroup]
[restart(must)] setfsgid:(gid_t gid) -> errno_t;
[restart(must)] setfsgid16:([tostr(GID_T)] uint16_t gid) -> errno_t;
[restart(must)] setfsgid32:([tostr(GID_T)] uint32_t gid) -> errno_t;
%[endgroup]


%[startgroup]
stime:([tostr(TIME32_T_PTR)] time32_t const *t) -> errno_t;
stime64:([tostr(TIME64_T_PTR)] time64_t const *t) -> errno_t;
%[endgroup]

ptrace:(syscall_ulong_t request, pid_t pid, void *addr, void *data) -> syscall_slong_t;
alarm:(syscall_ulong_t seconds) -> syscall_ulong_t;
[restart(dont)][cp] pause:() -> errno_t;

%[startgroup]
[cp] utime:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUF)] struct utimbuf const *times) -> errno_t;
[cp] utime32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUF32)] struct utimbuf32 const *times) -> errno_t;
[cp] utime64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUF64)] struct utimbuf64 const *times) -> errno_t;
[cp] utimex32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUFX32)] struct utimbufx32 const *times) -> errno_t;
[cp] utimex32_64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUFX32_64)] struct utimbufx32_64 const *times) -> errno_t;
[cp] utimex64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUFX64)] struct utimbufx64 const *times) -> errno_t;
%[endgroup]

@@@param: type: Set of `R_OK|W_OK|X_OK' or `F_OK'
[cp] access:([tostr(FILENAME)] char const *filename,
             [tostr(ACCESS_TYPE)] syscall_ulong_t type) -> errno_t;

nice:(syscall_slong_t inc) -> errno_t;

%[startgroup]
ftime:([tostr(out:STRUCT_TIMEB)] struct timeb *tp) -> errno_t;
ftime32:([tostr(out:STRUCT_TIMEB32)] struct timeb32 *tp) -> errno_t;
ftime64:([tostr(out:STRUCT_TIMEB64)] struct timeb64 *tp) -> errno_t;
ftimex32:([tostr(out:STRUCT_TIMEBX32)] struct timebx32 *tp) -> errno_t;
ftimex32_64:([tostr(out:STRUCT_TIMEBX32_64)] struct timebx32_64 *tp) -> errno_t;
ftimex64:([tostr(out:STRUCT_TIMEBX64)] struct timebx64 *tp) -> errno_t;
%[endgroup]

[cp] sync:() -> errno_t;
kill:(pid_t pid, signo_t signo) -> errno_t;
tkill:(pid_t tid, signo_t signo) -> errno_t;
tgkill:(pid_t tgid, pid_t tid, signo_t signo) -> errno_t;


[cp] rename:([tostr(FILENAME)] char const *oldname,
             [tostr(FILENAME)] char const *newname_or_path) -> errno_t;
[cp] renameat:(fd_t oldfd, [tostr(FILENAME:oldfd)] char const *oldname,
               fd_t newfd, [tostr(FILENAME:newfd)] char const *newname_or_path) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] frenameat:(fd_t oldfd, [tostr(FILENAME:oldfd)] char const *oldname,
                fd_t newfd, [tostr(FILENAME:newfd)] char const *newname_or_path,
                [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;
@@@param: flags: Set of `RENAME_EXCHANGE | RENAME_NOREPLACE | RENAME_WHITEOUT'
[cp] renameat2:(fd_t olddirfd, [tostr(FILENAME:olddirfd)] char const *oldpath,
                fd_t newdirfd, [tostr(FILENAME:newdirfd)] char const *newpath,
                [tostr(RENAMEAT2_FLAGS)] syscall_ulong_t flags) -> errno_t;

[cp] mkdir:([tostr(FILENAME)] char const *pathname, mode_t mode) -> errno_t;
[cp] mkdirat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname, mode_t mode) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fmkdirat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname, mode_t mode,
               [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;


pipe:([tostr(out:FD_VECTOR2)] fd_t pipedes[2]) -> errno_t;
pipe2:([tostr(out:FD_VECTOR2)] fd_t pipedes[2],
       [tostr(OFLAG__CLOEXEC__CLOFORK__NONBLOCK__DIRECT)] oflag_t flags) -> errno_t;

dup:(fd_t fd) -> fd_t;
dup2:(fd_t oldfd, fd_t newfd) -> fd_t;
@@@param: flags:  Set of `O_CLOEXEC | O_CLOFORK'
dup3:(fd_t oldfd, fd_t newfd, [tostr(OFLAG__CLOEXEC__CLOFORK)] oflag_t flags) -> fd_t;

times:([tostr(out:STRUCT_TMS)] struct tms *buf) -> clock_t;

brk:(void *addr) -> errno_t;
signal:(signo_t signo, sighandler_t handler) -> sighandler_t;
acct:([tostr(FILENAME)] char const *filename) -> errno_t;

[cp][restart(must)] umount2:(char const *special_file, syscall_ulong_t flags) -> errno_t;
[cp] ioctl:(fd_t fd, [tostr(IOCTL_COMMAND)] syscall_ulong_t command, [tostr(IOCTL_ARG:command)] void *arg) -> syscall_slong_t;
[cp] ioctlf:(fd_t fd, [tostr(IOCTL_COMMAND)] syscall_ulong_t command, iomode_t mode, [tostr(IOCTL_ARG:command)] void *arg) -> syscall_slong_t;
[cp] fcntl:(fd_t fd, [tostr(FCNTL_COMMAND)] syscall_ulong_t command, [tostr(FCNTL_ARG:command)] void *arg) -> syscall_slong_t;
[cp] fcntl64:(fd_t fd, [tostr(FCNTL64_COMMAND)] syscall_ulong_t command, [tostr(FCNTL64_ARG:command)] void *arg) -> syscall_slong_t;

[restart(must)] setpgid:(pid_t pid, pid_t pgid) -> errno_t;
[restart(must)] umask:(mode_t mode) -> mode_t;
[restart(must)] fsmode:([reg64][tostr(FSMODE)] uint64_t mode) -> [reg64][tostr(FSMODE)] uint64_t;
chroot:([tostr(FILENAME)] char const *path) -> errno_t;
ustat:([tostr(DEV_BLK)] dev_t dev, [tostr(out:STRUCT_USTAT)] struct ustat *ubuf) -> errno_t;
[restart(must)] getppid:() -> pid_t;
[restart(must)] getpgrp:() -> pid_t;
[restart(must)] setsid:() -> pid_t;

oldolduname:([tostr(out:STRUCT_LINUX_OLDOLDUNAME)] struct linux_oldolduname *name) -> errno_t;
olduname:([tostr(out:STRUCT_LINUX_OLDUNAME)] struct linux_olduname *name) -> errno_t;
uname:([tostr(out:STRUCT_UTSNAME)] struct utsname *name) -> errno_t;

%[startgroup]
sigaction:(signo_t signo, [tostr(STRUCT_SIGACTION)] struct sigaction const *act, [tostr(out:STRUCT_SIGACTION)] struct sigaction *oact) -> errno_t;
sigactionx32:(signo_t signo, [tostr(STRUCT_SIGACTIONX32)] struct __sigactionx32 const *act, [tostr(out:STRUCT_SIGACTIONX32)] struct __sigactionx32 *oact) -> errno_t;
sigactionx64:(signo_t signo, [tostr(STRUCT_SIGACTIONX64)] struct __sigactionx64 const *act, [tostr(out:STRUCT_SIGACTIONX64)] struct __sigactionx64 *oact) -> errno_t;
%[endgroup]

%[startgroup]
rt_sigaction:(signo_t signo, [tostr(STRUCT_SIGACTION:sigsetsize)] struct sigaction const *act, [tostr(out:STRUCT_SIGACTION:sigsetsize)] struct sigaction *oact, size_t sigsetsize) -> errno_t;
rt_sigactionx32:(signo_t signo, [tostr(STRUCT_SIGACTIONX32:sigsetsize)] struct sigactionx32 const *act, [tostr(out:STRUCT_SIGACTIONX32:sigsetsize)] struct sigactionx32 *oact, size_t sigsetsize) -> errno_t;
rt_sigactionx64:(signo_t signo, [tostr(STRUCT_SIGACTIONX64:sigsetsize)] struct sigactionx64 const *act, [tostr(out:STRUCT_SIGACTIONX64:sigsetsize)] struct sigactionx64 *oact, size_t sigsetsize) -> errno_t;
%[endgroup]


sgetmask:() -> [tostr(SIGMASK)] syscall_ulong_t;
ssetmask:([tostr(SIGMASK)] syscall_ulong_t sigmask) -> [tostr(SIGMASK)] syscall_ulong_t;

[restart(dont)][cp]
sigsuspend:([tostr(STRUCT_SIGSET)] struct __sigset_struct const *set) -> errno_t;

sigpending:(struct __sigset_struct *set) -> errno_t;
sethostname:([tostr(STRING:len)] char const *name, size_t len) -> errno_t;

@@@param: resource: One of `RLIMIT_*' from <sys/resource.h>
setrlimit:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource,
           [tostr(STRUCT_RLIMIT)] struct rlimit const *rlimits) -> errno_t;

@@@param: resource: One of `RLIMIT_*' from <sys/resource.h>
getrlimit:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource,
           [tostr(out:STRUCT_RLIMIT)] struct rlimit *rlimits) -> errno_t;

%[startgroup]
@@@param: who: One of `RUSAGE_SELF', `RUSAGE_CHILDREN' or `RUSAGE_THREAD'
getrusage:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGE)] struct rusage *usage) -> errno_t;
[doc_alias(getrusage)] getrusage32:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *tv) -> errno_t;
[doc_alias(getrusage)] getrusage64:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *tv) -> errno_t;
[doc_alias(getrusage)] getrusagex32:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *tv) -> errno_t;
[doc_alias(getrusage)] getrusagex32_64:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *tv) -> errno_t;
[doc_alias(getrusage)] getrusagex64:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *tv) -> errno_t;
%[endgroup]

%[startgroup]
gettimeofday:([tostr(out:STRUCT_TIMEVAL)] struct timeval *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofday32:([tostr(out:STRUCT_TIMEVAL32)] struct timeval32 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofday64:([tostr(out:STRUCT_TIMEVAL64)] struct timeval64 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofdayx32:([tostr(out:STRUCT_TIMEVALX32)] struct timevalx32 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofdayx32_64:([tostr(out:STRUCT_TIMEVALX32_64)] struct timevalx32_64 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofdayx64:([tostr(out:STRUCT_TIMEVALX64)] struct timevalx64 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
%[endgroup]

%[startgroup]
settimeofday:([tostr(STRUCT_TIMEVAL)] struct timeval const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;
settimeofday32:([tostr(STRUCT_TIMEVAL32)] struct timeval32 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;
settimeofday64:([tostr(STRUCT_TIMEVAL64)] struct timeval64 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;
settimeofdayx32:([tostr(STRUCT_TIMEVALX32)] struct timevalx32 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;
settimeofdayx32_64:([tostr(STRUCT_TIMEVALX32_64)] struct timevalx32_64 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;
settimeofdayx64:([tostr(STRUCT_TIMEVALX64)] struct timevalx64 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;
%[endgroup]


[restart(dont)][cp]
poll:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds,
      size_t nfds, syscall_slong_t timeout) -> ssize_t;

%[startgroup]
[restart(dont)][cp] ppoll:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[restart(dont)][cp] ppoll32:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[restart(dont)][cp] ppoll64:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[restart(dont)][cp] ppollx32:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[restart(dont)][cp] ppollx32_64:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[restart(dont)][cp] ppollx64:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
%[endgroup]

%[startgroup]
[restart(dont)][cp] select:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVAL)] struct timeval *timeout) -> ssize_t;
[restart(dont)][cp] select32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVAL32)] struct timeval32 *timeout) -> ssize_t;
[restart(dont)][cp] select64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVAL64)] struct timeval64 *timeout) -> ssize_t;
[restart(dont)][cp] selectx32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVALX32)] struct timevalx32 *timeout) -> ssize_t;
[restart(dont)][cp] selectx32_64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVALX32_64)] struct timevalx32_64 *timeout) -> ssize_t;
[restart(dont)][cp] selectx64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVALX64)] struct timevalx64 *timeout) -> ssize_t;
%[endgroup]

%[startgroup]
[restart(dont)][cp] pselect6:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, [tostr(STRUCT_SIGMASK_SIGSET_AND_LEN)] void const *sigmask_sigset_and_len) -> ssize_t;
[restart(dont)][cp] pselect6_32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout, [tostr(STRUCT_SIGMASK_SIGSET_AND_LEN)] void const *sigmask_sigset_and_len) -> ssize_t;
[restart(dont)][cp] pselect6_64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, [tostr(STRUCT_SIGMASK_SIGSET_AND_LEN)] void const *sigmask_sigset_and_len) -> ssize_t;
[restart(dont)][cp] pselect6_x32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout, [tostr(STRUCT_SIGMASK_SIGSET_AND_LEN)] void const *sigmask_sigset_and_len) -> ssize_t;
[restart(dont)][cp] pselect6_x32_64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, [tostr(STRUCT_SIGMASK_SIGSET_AND_LEN)] void const *sigmask_sigset_and_len) -> ssize_t;
[restart(dont)][cp] pselect6_x64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, [tostr(STRUCT_SIGMASK_SIGSET_AND_LEN)] void const *sigmask_sigset_and_len) -> ssize_t;
%[endgroup]

_newselect:(int TODO_PROTOTYPE) -> errno_t;

[cp] symlink:(char const *link_text, [tostr(FILENAME)] char const *target_path) -> errno_t;
[cp] readlink:([tostr(FILENAME)] char const *path, [tostr(out:BUFFER:buflen)] char *buf, size_t buflen) -> ssize_t;
uselib:([tostr(FILENAME)] char const *library) -> errno_t;

%[startgroup]
@@Map the segments of a given library into memory
@@@param: addr:  Hint address (ignored unless `MAP_FIXED' is passed)
@@@param: flags: Set of `MAP_FIXED|MAP_LOCKED|MAP_NONBLOCK|
@@                      MAP_NORESERVE|MAP_POPULATE|MAP_SYNC|MAP_DONT_MAP|
@@                      MAP_DONT_OVERRIDE'
@@@param: fd:    A handle for the library file being mapped
@@               (must be a file or vm_datablock/inode)
@@@param: hdrv:  Pointer to a vector of `Elf32_Phdr' or `Elf64_Phdr'
@@               (depending on the caller running in 32- or 64-bit mode)
@@@param: hdrc:  The number of program headers
maplibrary:(void *addr,
	[tostr(MAPLIBRARY_FLAGS)] syscall_ulong_t flags, fd_t fd,
	[tostr(STRUCT_ELF_PHDR_VECTOR:hdrc)] ElfW(Phdr) const *hdrv, size_t hdrc) -> void *;
[doc_alias(maplibrary)] maplibraryx32:(void *addr, [tostr(MAPLIBRARY_FLAGS)] syscall_ulong_t flags, fd_t fd, [tostr(STRUCT_ELF_PHDR32_VECTOR:hdrc)] struct elf32_phdr const *hdrv, size_t hdrc) -> void *;
[doc_alias(maplibrary)] maplibraryx64:(void *addr, [tostr(MAPLIBRARY_FLAGS)] syscall_ulong_t flags, fd_t fd, [tostr(STRUCT_ELF_PHDR64_VECTOR:hdrc)] struct elf64_phdr const *hdrv, size_t hdrc) -> void *;
%[endgroup]

@@@param: swapflags: Set of `SWAP_FLAG_*'
swapon:([tostr(FILENAME)] char const *pathname, [tostr(SWAPFLAGS)] syscall_ulong_t swapflags) -> errno_t;
swapoff:([tostr(FILENAME)] char const *pathname) -> errno_t;

@@@param: how: One of the `RB_*' constants from <sys/reboot.h>
reboot:([tostr(REBOOT_HOW)] syscall_ulong_t how) -> errno_t;

@@Returns `0' to indicate end-of-directory; 1 to to indicate success
readdir:(fd_t fd, [tostr(out:STRUCT_OLD_LINUX_DIRENT:count)] struct old_linux_dirent *dirp, size_t count) -> errno_t;

@@@param: prot:  Either `PROT_NONE', or set of `PROT_EXEC | PROT_WRITE | PROT_READ | PROT_SEM | PROT_LOOSE | PROT_SHARED'
@@@param: flags: One of `MAP_SHARED`, 'MAP_SHARED_VALIDATE' or `MAP_PRIVATE', optionally or'd
@@              with a set of `MAP_ANONYMOUS|MAP_FIXED|MAP_GROWSDOWN|MAP_LOCKED|
@@              MAP_NONBLOCK|MAP_NORESERVE|MAP_POPULATE|MAP_STACK|MAP_SYNC|
@@              MAP_UNINITIALIZED|MAP_DONT_MAP|MAP_DONT_OVERRIDE|MAP_OFFSET64_POINTER'
mmap:(void *addr, size_t len,
	[tostr(MMAP_PROT)] syscall_ulong_t prot,
	[tostr(MMAP_FLAGS)] syscall_ulong_t flags,
	fd_t fd, syscall_ulong_t offset) -> void *;
mmap2:(void *addr, size_t len, [tostr(MMAP_PROT)] syscall_ulong_t prot,
       [tostr(MMAP_FLAGS)] syscall_ulong_t flags, fd_t fd,
       syscall_ulong_t pgoffset) -> void *;

[restart(must)] munmap:(void *addr, size_t len) -> errno_t;

@@@param: prot: Either `PROT_NONE', or set of `PROT_EXEC | PROT_WRITE | PROT_READ | PROT_SEM | PROT_LOOSE | PROT_SHARED'
[restart(must)] mprotect:(void *addr, size_t len, [tostr(MMAP_PROT)] syscall_ulong_t prot) -> errno_t;

@@@param: flags: Set of `MREMAP_MAYMOVE | MREMAP_FIXED'
mremap:(void *addr, size_t old_len, size_t new_len,
        [tostr(MREMAP_FLAGS)] syscall_ulong_t flags,
        void *new_address) -> void *;

remap_file_pages:(void *start, size_t size,
                  [tostr(MMAP_PROT)] syscall_ulong_t prot,
                  size_t pgoff, syscall_ulong_t flags) -> errno_t;

mincore:(void *start, size_t len, uint8_t *vec) -> errno_t;
madvise:(void *addr, size_t len, syscall_ulong_t advice) -> errno_t;

mlock:(void const *addr, size_t len) -> errno_t;
munlock:(void const *addr, size_t len) -> errno_t;

@@@param: flags: Set of `MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT'
mlockall:([tostr(MLOCKALL_FLAGS)] syscall_ulong_t flags) -> errno_t;
munlockall:() -> errno_t;

%[startgroup]
truncate:([tostr(FILENAME)] char const *filename, syscall_ulong_t length) -> errno_t;
truncate64:([tostr(FILENAME)] char const *filename, [reg64] uint64_t length) -> errno_t;
%[endgroup]

%[startgroup]
ftruncate:(fd_t fd, syscall_ulong_t length) -> errno_t;
ftruncate64:(fd_t fd, [reg64] uint64_t length) -> errno_t;
%[endgroup]

[cp] fchmod:(fd_t fd, mode_t mode) -> errno_t;

@@@param: which: One of `PRIO_PROCESS', `PRIO_PGRP' or `PRIO_USER'
getpriority:([tostr(SCHED_PRIORITY_WHICH)] syscall_ulong_t which, id_t who) -> syscall_slong_t;

@@@param: which: One of `PRIO_PROCESS', `PRIO_PGRP' or `PRIO_USER'
setpriority:([tostr(SCHED_PRIORITY_WHICH)] syscall_ulong_t which, id_t who, syscall_ulong_t value) -> errno_t;

profil:(uint16_t *sample_buffer, size_t size, size_t offset, syscall_ulong_t scale) -> errno_t;

%[startgroup]
statfs:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFS)] struct statfs *buf) -> errno_t;
statfs32:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFS32)] struct __statfs32 *buf) -> errno_t;
statfs64:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFS64)] struct __statfs64 *buf) -> errno_t;
statfsx32:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFSX32)] struct __statfsx32 *buf) -> errno_t;
statfsx32_64:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFSX32_64)] struct __statfsx32_64 *buf) -> errno_t;
statfsx64:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFSX64)] struct __statfsx64 *buf) -> errno_t;
%[endgroup]

%[startgroup]
fstatfs:(fd_t file, [tostr(out:STRUCT_STATFS)] struct statfs *buf) -> errno_t;
fstatfs32:(fd_t file, [tostr(out:STRUCT_STATFS32)] struct __statfs32 *buf) -> errno_t;
fstatfs64:(fd_t file, [tostr(out:STRUCT_STATFS64)] struct __statfs64 *buf) -> errno_t;
fstatfsx32:(fd_t file, [tostr(out:STRUCT_STATFSX32)] struct __statfsx32 *buf) -> errno_t;
fstatfsx32_64:(fd_t file, [tostr(out:STRUCT_STATFSX32_64)] struct __statfsx32_64 *buf) -> errno_t;
fstatfsx64:(fd_t file, [tostr(out:STRUCT_STATFSX64)] struct __statfsx64 *buf) -> errno_t;
%[endgroup]

ioperm:(syscall_ulong_t from, syscall_ulong_t num, syscall_ulong_t turn_on) -> errno_t;
socketcall:([tostr(SOCKETCALL_CALL)] syscall_ulong_t call,
            [tostr(SOCKETCALL_ARGS:call)] syscall_ulong_t *args) -> errno_t;

[restart(must)][cp]
syslog:([tostr(SYSLOG_LEVEL)] syscall_ulong_t level,
        [tostr(STRING:len)] char const *str, size_t len) -> ssize_t;

%[startgroup]
@@@param: which: One of `ITIMER_REAL', `ITIMER_VIRTUAL' or `ITIMER_PROF'
setitimer:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVAL)] struct itimerval const *newval, struct itimerval *oldval) -> errno_t;
[doc_alias(setitimer)] setitimer32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVAL32)] struct __itimerval32 const *newval, struct __itimerval32 *oldval) -> errno_t;
[doc_alias(setitimer)] setitimer64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVAL64)] struct __itimerval64 const *newval, struct __itimerval64 *oldval) -> errno_t;
[doc_alias(setitimer)] setitimerx32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVALX32)] struct __itimervalx32 const *newval, struct __itimervalx32 *oldval) -> errno_t;
[doc_alias(setitimer)] setitimerx64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVALX32_64)] struct __itimervalx64 const *newval, struct __itimervalx64 *oldval) -> errno_t;
[doc_alias(setitimer)] setitimerx32_64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVALX64)] struct __itimervalx32_64 const *newval, struct __itimervalx32_64 *oldval) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: which: One of `ITIMER_REAL', `ITIMER_VIRTUAL' or `ITIMER_PROF'
getitimer:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVAL)] struct itimerval *curr_value) -> errno_t;
[doc_alias(getitimer)] getitimer32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVAL32)] struct __itimerval32 *curr_value) -> errno_t;
[doc_alias(getitimer)] getitimer64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVAL64)] struct __itimerval64 *curr_value) -> errno_t;
[doc_alias(getitimer)] getitimerx32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVALX32)] struct __itimervalx32 *curr_value) -> errno_t;
[doc_alias(getitimer)] getitimerx32_64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVALX32_64)] struct __itimervalx32_64 *curr_value) -> errno_t;
[doc_alias(getitimer)] getitimerx64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVALX64)] struct __itimervalx64 *curr_value) -> errno_t;
%[endgroup]

iopl:(syscall_ulong_t level) -> errno_t;
vhangup:() -> errno_t;
vm86old:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
@@Same as `waitpid(pid, STAT_LOC, OPTIONS)', though also fills in `USAGE' when non-NULL
@@@param: options: Set of `WNOHANG | WUNTRACED | WCONTINUED' (as a KOS extension, `WNOWAIT' is also accepted)
[restart(dont)][cp] wait4:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE)] struct rusage *usage) -> pid_t;
[doc_alias(wait4)][restart(dont)][cp] wait4_32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *usage) -> pid_t;
[doc_alias(wait4)][restart(dont)][cp] wait4_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *usage) -> pid_t;
[doc_alias(wait4)][restart(dont)][cp] wait4_x32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *usage) -> pid_t;
[doc_alias(wait4)][restart(dont)][cp] wait4_x32_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *usage) -> pid_t;
[doc_alias(wait4)][restart(dont)][cp] wait4_x64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *usage) -> pid_t;
%[endgroup]

%[startgroup]
@@@param: options: Set of `WNOHANG | WUNTRACED | WCONTINUED'
[restart(dont)][cp] oldwait4:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE)] struct rusage *usage) -> pid_t;
[doc_alias(oldwait4)][restart(dont)][cp] oldwait4_32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *usage) -> pid_t;
[doc_alias(oldwait4)][restart(dont)][cp] oldwait4_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *usage) -> pid_t;
[doc_alias(oldwait4)][restart(dont)][cp] oldwait4_x32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *usage) -> pid_t;
[doc_alias(oldwait4)][restart(dont)][cp] oldwait4_x32_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *usage) -> pid_t;
[doc_alias(oldwait4)][restart(dont)][cp] oldwait4_x64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAG)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *usage) -> pid_t;
%[endgroup]

[cp] sysinfo:([tostr(out:STRUCT_SYSINFO)] struct sysinfo *info) -> errno_t;
ipc:(int TODO_PROTOTYPE) -> errno_t;
[cp] fsync:(fd_t fd) -> errno_t;

%[startgroup]
[restart(must)][noexcept] sigreturn:([tostr(STRUCT_FPUSTATE)] struct fpustate const *restore_fpu, [tostr(STRUCT_SIGSET)] struct __sigset_struct const *restore_sigmask, [tostr(STRUCT_RPC_SYSCALL_INFO)] struct rpc_syscall_info const *sc_info, [tostr(STRUCT_UCPUSTATE)] struct ucpustate const *restore_cpu);
[restart(must)][noexcept] sigreturn32:([tostr(STRUCT_FPUSTATE32)] struct fpustate32 const *restore_fpu, [tostr(STRUCT_SIGSET)] struct __sigset_struct const *restore_sigmask, [tostr(STRUCT_RPC_SYSCALL_INFO32)] struct rpc_syscall_info32 const *sc_info, [tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *restore_cpu);
[restart(must)][noexcept] sigreturn64:([tostr(STRUCT_FPUSTATE64)] struct fpustate64 const *restore_fpu, [tostr(STRUCT_SIGSET)] struct __sigset_struct const *restore_sigmask, [tostr(STRUCT_RPC_SYSCALL_INFO64)] struct rpc_syscall_info64 const *sc_info, [tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *restore_cpu);
[restart(must)][noexcept] rt_sigreturn:([tostr(STRUCT_FPUSTATE)] struct fpustate const *restore_fpu, [tostr(STRUCT_SIGSET)] struct __sigset_struct const *restore_sigmask, [tostr(STRUCT_RPC_SYSCALL_INFO)] struct rpc_syscall_info const *sc_info, [tostr(STRUCT_UCPUSTATE)] struct ucpustate const *restore_cpu);
[restart(must)][noexcept] rt_sigreturn32:([tostr(STRUCT_FPUSTATE32)] struct fpustate32 const *restore_fpu, [tostr(STRUCT_SIGSET)] struct __sigset_struct const *restore_sigmask, [tostr(STRUCT_RPC_SYSCALL_INFO32)] struct rpc_syscall_info32 const *sc_info, [tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *restore_cpu);
[restart(must)][noexcept] rt_sigreturn64:([tostr(STRUCT_FPUSTATE64)] struct fpustate64 const *restore_fpu, [tostr(STRUCT_SIGSET)] struct __sigset_struct const *restore_sigmask, [tostr(STRUCT_RPC_SYSCALL_INFO64)] struct rpc_syscall_info64 const *sc_info, [tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *restore_cpu);
%[endgroup]

clone:([tostr(CLONE_FLAGS)] syscall_ulong_t flags, void *child_stack, [tostr(out:PID_T)] pid_t *ptid,
       [tostr(POINTER)] uintptr_t newtls, [tostr(out:PID_T)] pid_t *ctid) -> pid_t;

setdomainname:([tostr(STRING:len)] char const *name, size_t len) -> errno_t;
modify_ldt:(syscall_ulong_t func, void *ptr, syscall_ulong_t bytecount) -> syscall_slong_t;
adjtimex:(int TODO_PROTOTYPE) -> errno_t;

@@@param: how: One of `SIG_BLOCK', `SIG_UNBLOCK' or `SIG_SETMASK'
sigprocmask:([tostr(SIGPROCMASK_HOW)] syscall_ulong_t how,
             [tostr(STRUCT_SIGSET)] struct __sigset_struct const *set,
             [tostr(out:STRUCT_SIGSET)] struct __sigset_struct *oset) -> errno_t;

create_module:(int TODO_PROTOTYPE) -> errno_t;
init_module:(int TODO_PROTOTYPE) -> errno_t;
delete_module:(int TODO_PROTOTYPE) -> errno_t;
get_kernel_syms:(int TODO_PROTOTYPE) -> errno_t;
quotactl:(int TODO_PROTOTYPE) -> errno_t;

bdflush:(int TODO_PROTOTYPE) -> errno_t;
sysfs:(int TODO_PROTOTYPE) -> errno_t;
personality:(int TODO_PROTOTYPE) -> errno_t;
afs_syscall:(int TODO_PROTOTYPE) -> errno_t;

[restart(must)] getpgid:(pid_t pid) -> pid_t;

[cp] _llseek:(fd_t fd, [reg64] int64_t offset, [tostr(out:UINT64_T)] uint64_t *result, [tostr(SEEK_WHENCE)] syscall_ulong_t whence) -> errno_t;
[cp] getdents:(fd_t fd, [tostr(out:STRUCT_LINUX_DIRENT:count:return)] struct linux_dirent *dirp, size_t count) -> ssize_t;
[cp] getdents64:(fd_t fd, [tostr(out:STRUCT_LINUX_DIRENT64:count:return)] struct linux_dirent64 *dirp, size_t count) -> ssize_t;

@@@param: mode: One of `READDIR_DEFAULT', `READDIR_CONTINUE', `READDIR_PEEK' or `READDIR_MULTIPLE',
@@              optionally or'd with any of `READDIR_SKIPREL | READDIR_WANTEOF'
[cp] kreaddir:(fd_t fd, [tostr(out:STRUCT_DIRENT:bufsize:return)] struct dirent *buf, size_t bufsize,
               [tostr(KREADDIR_MODE)] syscall_ulong_t mode) -> ssize_t;

@@@param: mode: One of `READDIR_DEFAULT', `READDIR_CONTINUE', `READDIR_PEEK' or `READDIR_MULTIPLE',
@@              optionally or'd with any of `READDIR_SKIPREL | READDIR_WANTEOF'
[cp] kreaddirf:(fd_t fd, [tostr(out:STRUCT_DIRENT:bufsize:return)] struct dirent *buf, size_t bufsize,
                [tostr(KREADDIR_MODE)] syscall_ulong_t mode, iomode_t iomode) -> ssize_t;


[cp] flock:(fd_t fd, syscall_ulong_t operation) -> errno_t;
[cp] msync:(void *addr, size_t len, syscall_ulong_t flags) -> errno_t;

%[startgroup]
[cp] readv:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count) -> ssize_t;
[cp] readvx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count) -> ssize_t;
[cp] readvx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count) -> ssize_t;
%[endgroup]

%[startgroup]
[cp] readvf:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp] readvfx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp] readvfx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count, iomode_t mode) -> ssize_t;
%[endgroup]

%[startgroup]
[cp] writev:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count) -> ssize_t;
[cp] writevx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count) -> ssize_t;
[cp] writevx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count) -> ssize_t;
%[endgroup]

%[startgroup]
[cp] writevf:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp] writevfx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp] writevfx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count, iomode_t mode) -> ssize_t;
%[endgroup]

[restart(must)] getsid:(pid_t pid) -> pid_t;
[cp] fdatasync:(fd_t fd) -> errno_t;
_sysctl:(int TODO_PROTOTYPE) -> errno_t;

sched_setparam:(pid_t pid, [tostr(STRUCT_SCHED_PARAM)] struct sched_param const *param) -> errno_t;
sched_getparam:(pid_t pid, [tostr(out:STRUCT_SCHED_PARAM)] struct sched_param *param) -> errno_t;


@@@param: policy: One of `SCHED_OTHER', `SCHED_FIFO', `SCHED_RR', `SCHED_BATCH',
@@                `SCHED_IDLE', optionally or'd with `SCHED_RESET_ON_FORK'
sched_setscheduler:(pid_t pid, [tostr(SCHED_POLICY)] syscall_ulong_t policy,
                    [tostr(STRUCT_SCHED_PARAM)] struct sched_param const *param) -> errno_t;
sched_getscheduler:(pid_t pid) -> [tostr(SCHED_POLICY)] syscall_slong_t;

[restart(dont)] sched_yield:() -> errno_t;
[restart(dont)][cp] rpc_service:() -> syscall_slong_t;
sched_get_priority_max:([tostr(SCHED_POLICY)] syscall_ulong_t algorithm) -> syscall_slong_t;
sched_get_priority_min:([tostr(SCHED_POLICY)] syscall_ulong_t algorithm) -> syscall_slong_t;

%[startgroup]
sched_rr_get_interval:(pid_t pid, [tostr(out:STRUCT_TIMESPEC)] struct timespec *tms) -> errno_t;
sched_rr_get_interval32:(pid_t pid, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *tms) -> errno_t;
sched_rr_get_interval64:(pid_t pid, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *tms) -> errno_t;
sched_rr_get_intervalx32:(pid_t pid, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *tms) -> errno_t;
sched_rr_get_intervalx32_64:(pid_t pid, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *tms) -> errno_t;
sched_rr_get_intervalx64:(pid_t pid, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *tms) -> errno_t;
%[endgroup]

%[startgroup]
[restart(dont)][cp] nanosleep:([tostr(STRUCT_TIMESPEC)] struct timespec const *req, [tostr(out:STRUCT_TIMESPEC)] struct timespec *rem) -> errno_t;
[restart(dont)][cp] nanosleep32:([tostr(STRUCT_TIMESPEC32)] struct timespec32 const *req, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *rem) -> errno_t;
[restart(dont)][cp] nanosleep64:([tostr(STRUCT_TIMESPEC64)] struct timespec64 const *req, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *rem) -> errno_t;
[restart(dont)][cp] nanosleepx32:([tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *req, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *rem) -> errno_t;
[restart(dont)][cp] nanosleepx32_64:([tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *req, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *rem) -> errno_t;
[restart(dont)][cp] nanosleepx64:([tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *req, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *rem) -> errno_t;
%[endgroup]

vm86:(int TODO_PROTOTYPE) -> errno_t;
query_module:(int TODO_PROTOTYPE) -> errno_t;

nfsservctl:(int TODO_PROTOTYPE) -> errno_t;
prctl:(int TODO_PROTOTYPE) -> errno_t;

@@@param: how: One of `SIG_BLOCK', `SIG_UNBLOCK' or `SIG_SETMASK'
rt_sigprocmask:([tostr(SIGPROCMASK_HOW)] syscall_ulong_t how,
                [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set,
                [tostr(out:STRUCT_SIGSET:sigsetsize)] struct __sigset_struct *oset,
                size_t sigsetsize) -> errno_t;

rt_sigpending:([tostr(out:STRUCT_SIGSET:sigsetsize)] struct __sigset_struct *set,
               size_t sigsetsize) -> errno_t;

%[startgroup]
[restart(dont)][cp] rt_sigtimedwait:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *info, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, size_t sigsetsize) -> syscall_slong_t;
[restart(dont)][cp] rt_sigtimedwait32:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *info, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[restart(dont)][cp] rt_sigtimedwait64:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *info, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[restart(dont)][cp] rt_sigtimedwaitx32:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *info, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[restart(dont)][cp] rt_sigtimedwaitx32_64:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *info, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[restart(dont)][cp] rt_sigtimedwaitx64:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFOX64)] struct __siginfox64_struct *info, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, size_t sigsetsize) -> syscall_slong_t;
%[endgroup]

%[startgroup]
rt_sigqueueinfo:(pid_t tgid, signo_t signo, [tostr(STRUCT_SIGINFO)] struct __siginfo_struct const *uinfo) -> errno_t;
rt_sigqueueinfox32:(pid_t tgid, signo_t signo, [tostr(STRUCT_SIGINFOX32)] struct __siginfox32_struct const *uinfo) -> errno_t;
rt_sigqueueinfox64:(pid_t tgid, signo_t signo, [tostr(STRUCT_SIGINFOX64)] struct __siginfox64_struct const *uinfo) -> errno_t;
%[endgroup]

[restart(dont)]
rt_sigsuspend:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set,
               size_t sigsetsize) -> errno_t;

[cp] pread64:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize, [reg64] uint64_t offset) -> ssize_t;
[cp] pread64f:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp] pwrite64:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize, [reg64] uint64_t offset) -> ssize_t;
[cp] pwrite64f:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;


[cp] getcwd:([tostr(out:BUFFER:size:return)] char *buf, size_t size) -> ssize_t;
capget:(int TODO_PROTOTYPE) -> errno_t;
capset:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
sigaltstack:([tostr(STRUCT_SIGALTSTACK)] struct sigaltstack const *ss, [tostr(out:STRUCT_SIGALTSTACK)] struct sigaltstack *oss) -> errno_t;
sigaltstackx32:([tostr(STRUCT_SIGALTSTACKX32)] struct __sigaltstackx32 const *ss, [tostr(out:STRUCT_SIGALTSTACKX32)] struct __sigaltstackx32 *oss) -> errno_t;
sigaltstackx64:([tostr(STRUCT_SIGALTSTACKX64)] struct __sigaltstackx64 const *ss, [tostr(out:STRUCT_SIGALTSTACKX64)] struct __sigaltstackx64 *oss) -> errno_t;
%[endgroup]

%[startgroup]
[restart(dont)][cp] sendfile:(fd_t out_fd, fd_t in_fd, syscall_ulong_t *pin_offset, size_t num_bytes) -> ssize_t;
[restart(dont)][cp] sendfile32:(fd_t out_fd, fd_t in_fd, __ULONG32_TYPE__ *pin_offset, size_t num_bytes) -> ssize_t;
[restart(dont)][cp] sendfile64:(fd_t out_fd, fd_t in_fd, __ULONG64_TYPE__ *pin_offset, size_t num_bytes) -> ssize_t;
%[endgroup]

[cp] getpmsg:(int TODO_PROTOTYPE) -> errno_t;
[cp] putpmsg:(int TODO_PROTOTYPE) -> errno_t;
ugetrlimit:(int TODO_PROTOTYPE) -> errno_t;

%[typeorg(<kos/compat/linux-stat.h>: linux_oldstat)]
%[typeorg(<kos/compat/linux-stat.h>: linux_stat, linux_stat32, linux_stat64)]
%[typeorg(<kos/compat/linux-stat.h>: linux_statx32, linux_statx64, linux_statx32_64)]

[cp] linux_oldfstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                       [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf,
                       [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp] linux_oldfstat:(fd_t fd, [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf) -> errno_t;
[cp] linux_oldlstat:([tostr(FILENAME)] char const *filename,
                     [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf) -> errno_t;
[cp] linux_oldstat:([tostr(FILENAME)] char const *filename,
                    [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf) -> errno_t;

%[startgroup]
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] linux_fstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(linux_fstatat)][cp] linux_fstatat32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(linux_fstatat)][cp] linux_fstatat64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(linux_fstatat)][cp] linux_fstatatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(linux_fstatat)][cp] linux_fstatatx32_64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(linux_fstatat)][cp] linux_fstatatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
%[endgroup]

%[startgroup]
[cp] linux_fstat:(fd_t fd, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf) -> errno_t;
[cp] linux_fstat32:(fd_t fd, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf) -> errno_t;
[cp] linux_fstat64:(fd_t fd, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf) -> errno_t;
[cp] linux_fstatx32:(fd_t fd, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf) -> errno_t;
[cp] linux_fstatx32_64:(fd_t fd, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf) -> errno_t;
[cp] linux_fstatx64:(fd_t fd, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf) -> errno_t;
%[endgroup]

%[startgroup]
[cp] linux_lstat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf) -> errno_t;
[cp] linux_lstat32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf) -> errno_t;
[cp] linux_lstat64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf) -> errno_t;
[cp] linux_lstatx32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf) -> errno_t;
[cp] linux_lstatx32_64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf) -> errno_t;
[cp] linux_lstatx64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf) -> errno_t;
%[endgroup]

%[startgroup]
[cp] linux_stat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf) -> errno_t;
[cp] linux_stat32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf) -> errno_t;
[cp] linux_stat64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf) -> errno_t;
[cp] linux_statx32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf) -> errno_t;
[cp] linux_statx32_64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf) -> errno_t;
[cp] linux_statx64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf) -> errno_t;
%[endgroup]


%[startgroup]
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] kfstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
               [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf,
               [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(kfstatat)][cp] kfstatatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                                       [tostr(out:STRUCT_KOS_STATX32)] struct __kos_statx32 *statbuf,
                                       [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(kfstatat)][cp] kfstatatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                                       [tostr(out:STRUCT_KOS_STATX64)] struct __kos_statx64 *statbuf,
                                       [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
%[endgroup]

[cp] linux_newfstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                       [tostr(out:STRUCT_LINUX64_STAT32)] struct linux64_stat32 *statbuf,
                       [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;

%[startgroup]
[cp] kfstat:(fd_t fd, [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf) -> errno_t;
[cp] kfstatx32:(fd_t fd, [tostr(out:STRUCT_KOS_STATX32)] struct __kos_statx32 *statbuf) -> errno_t;
[cp] kfstatx64:(fd_t fd, [tostr(out:STRUCT_KOS_STATX64)] struct __kos_statx64 *statbuf) -> errno_t;
%[endgroup]

%[startgroup]
[cp] klstat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf) -> errno_t;
[cp] klstatx32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STATX32)] struct __kos_statx32 *statbuf) -> errno_t;
[cp] klstatx64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STATX64)] struct __kos_statx64 *statbuf) -> errno_t;
%[endgroup]

%[startgroup]
[cp] kstat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf) -> errno_t;
[cp] kstatx32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STATX32)] struct __kos_statx32 *statbuf) -> errno_t;
[cp] kstatx64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STATX64)] struct __kos_statx64 *statbuf) -> errno_t;
%[endgroup]

pivot_root:(int TODO_PROTOTYPE) -> errno_t;

[restart(must)] gettid:() -> pid_t;
readahead:(fd_t fd, [reg64] uint64_t offset, size_t count) -> ssize_t;

@@@param: flags: One of `0', `XATTR_CREATE' or `XATTR_REPLACE'
[cp] setxattr:([tostr(FILENAME)] char const *path,
               [tostr(STRING)] char const *name,
               [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
               [tostr(XATTR_FLAGS)] syscall_ulong_t flags) -> errno_t;

@@@param: flags: One of `0', `XATTR_CREATE' or `XATTR_REPLACE'
[cp] lsetxattr:([tostr(FILENAME)] char const *path,
                [tostr(STRING)] char const *name,
                [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
                [tostr(XATTR_FLAGS)] syscall_ulong_t flags) -> errno_t;

@@@param: flags: One of `0', `XATTR_CREATE' or `XATTR_REPLACE'
[cp] fsetxattr:(fd_t fd, [tostr(STRING)] char const *name,
                [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
                [tostr(XATTR_FLAGS)] syscall_ulong_t flags) -> errno_t;

[cp] getxattr:([tostr(FILENAME)] char const *path,
               [tostr(STRING)] char const *name,
               [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize) -> ssize_t;
[cp] lgetxattr:([tostr(FILENAME)] char const *path,
                [tostr(STRING)] char const *name,
                [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize) -> ssize_t;
[cp] fgetxattr:(fd_t fd, [tostr(STRING)] char const *name,
                [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize) -> ssize_t;
[cp] listxattr:([tostr(FILENAME)] char const *path,
                [tostr(out:BUFFER:listbufsize:return)] char *listbuf, size_t listbufsize) -> ssize_t;
[cp] llistxattr:([tostr(FILENAME)] char const *path,
                 [tostr(out:BUFFER:listbufsize:return)] char *listbuf, size_t listbufsize) -> ssize_t;
[cp] flistxattr:(fd_t fd, [tostr(out:BUFFER:listbufsize:return)] char *listbuf, size_t listbufsize) -> ssize_t;
[cp] removexattr:([tostr(FILENAME)] char const *path, [tostr(STRING)] char const *name) -> errno_t;
[cp] lremovexattr:([tostr(FILENAME)] char const *path, [tostr(STRING)] char const *name) -> errno_t;
[cp] fremovexattr:(fd_t fd, [tostr(STRING)] char const *name) -> errno_t;

%[startgroup]
@@@param: futex_op: One of `FUTEX_*' from <linux/futex.h>
[cp] futex:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPEC_OR_UINT32:futex_op)] struct timespec const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[doc_alias(futex)][cp] futex32:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPEC32_OR_UINT32:futex_op)] struct timespec32 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[doc_alias(futex)][cp] futex64:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPEC64_OR_UINT32:futex_op)] struct timespec64 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[doc_alias(futex)][cp] futexx32:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32_OR_UINT32:futex_op)] struct timespecx32 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[doc_alias(futex)][cp] futexx32_64:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32_64_OR_UINT32:futex_op)] struct timespecx32_64 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[doc_alias(futex)][cp] futexx64:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX64_OR_UINT32:futex_op)] struct timespecx64 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
%[endgroup]

sched_setaffinity:(pid_t pid, size_t cpusetsize, [tostr(CPUSET:cpusetsize)] struct __cpu_set_struct const *cpuset) -> errno_t;
sched_getaffinity:(pid_t pid, size_t cpusetsize, [tostr(out:CPUSET:cpusetsize)] struct __cpu_set_struct *cpuset) -> errno_t;

set_thread_area:(int TODO_PROTOTYPE) -> errno_t;
get_thread_area:(int TODO_PROTOTYPE) -> errno_t;

io_setup:(int TODO_PROTOTYPE) -> errno_t;
io_destroy:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_getevents:(int TODO_PROTOTYPE) -> errno_t;
io_submit:(int TODO_PROTOTYPE) -> errno_t;
io_cancel:(int TODO_PROTOTYPE) -> errno_t;

fadvise64:(int TODO_PROTOTYPE) -> errno_t;
fadvise64_64:(int TODO_PROTOTYPE) -> errno_t;
lookup_dcookie:(int TODO_PROTOTYPE) -> errno_t;

epoll_create:(syscall_ulong_t size) -> fd_t;
epoll_create1:(syscall_ulong_t flags) -> fd_t; /* TODO: flags:tostr(...) */

@@@param: op: One of `EPOLL_CTL_ADD', `EPOLL_CTL_DEL', `EPOLL_CTL_MOD'
epoll_ctl:(fd_t epfd, [tostr(EPOLL_OP)] syscall_ulong_t op, fd_t fd, struct epoll_event *event) -> errno_t;

@@@param: op: One of `EPOLL_CTL_ADD', `EPOLL_CTL_DEL', `EPOLL_CTL_MOD'
epoll_ctl_old:(fd_t epfd, [tostr(EPOLL_OP)] syscall_ulong_t op, fd_t fd, struct epoll_event *event) -> errno_t;

[restart(dont)][cp]
epoll_wait:(fd_t epfd, [tostr(out:STRUCT_EPOLL_EVENTS:maxevents)] struct epoll_event *events,
            syscall_ulong_t maxevents, syscall_slong_t timeout) -> errno_t;
[restart(dont)][cp]
epoll_wait_old:(fd_t epfd, [tostr(out:STRUCT_EPOLL_EVENTS:maxevents)] struct epoll_event *events,
                syscall_ulong_t maxevents, syscall_slong_t timeout) -> errno_t;

[restart(dont)][cp]
epoll_pwait:(fd_t epfd, [tostr(out:STRUCT_EPOLL_EVENTS:maxevents)] struct epoll_event *events, syscall_ulong_t maxevents,
             syscall_slong_t timeout, [tostr(STRUCT_SIGSET)] struct __sigset_struct const *ss) -> errno_t;


eventfd:(syscall_ulong_t initval) -> fd_t;
@@@param: flags: Set of `EFD_SEMAPHORE | EFD_NONBLOCK | EFD_CLOEXEC'
eventfd2:(syscall_ulong_t initval, [tostr(EVENTFD2_FLAGS)] syscall_ulong_t flags) -> fd_t;


set_tid_address:(pid_t *tidptr) -> pid_t;
timer_create:(clockid_t clock_id,
              [tostr(out:STRUCT_SIGEVENT)] struct sigevent *evp,
              [tostr(out:TIMER_T)] timer_t *timerid) -> errno_t;

%[startgroup]
@@@param: flags: Set of `0 | TIMER_ABSTIME'
timer_settime:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC)] struct itimerspec const *value, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *ovalue) -> errno_t;
[doc_alias(timer_settime)] timer_settime32:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC32)] struct itimerspec32 const *value, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *ovalue) -> errno_t;
[doc_alias(timer_settime)] timer_settime64:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC64)] struct itimerspec64 const *value, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *ovalue) -> errno_t;
[doc_alias(timer_settime)] timer_settimex32:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32)] struct itimerspecx32 const *value, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *ovalue) -> errno_t;
[doc_alias(timer_settime)] timer_settimex32_64:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 const *value, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *ovalue) -> errno_t;
[doc_alias(timer_settime)] timer_settimex64:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX64)] struct itimerspecx64 const *value, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *ovalue) -> errno_t;
%[endgroup]

%[startgroup]
timer_gettime:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *value) -> errno_t;
timer_gettime32:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *value) -> errno_t;
timer_gettime64:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *value) -> errno_t;
timer_gettimex32:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *value) -> errno_t;
timer_gettimex32_64:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *value) -> errno_t;
timer_gettimex64:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *value) -> errno_t;
%[endgroup]

timer_getoverrun:(timer_t timerid) -> syscall_slong_t;
timer_delete:(timer_t timerid) -> errno_t;

%[startgroup]
clock_settime:(clockid_t clock_id, [tostr(STRUCT_TIMESPEC)] struct timespec const *tp) -> errno_t;
clock_settime32:(clockid_t clock_id, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *tp) -> errno_t;
clock_settime64:(clockid_t clock_id, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *tp) -> errno_t;
clock_settimex32:(clockid_t clock_id, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *tp) -> errno_t;
clock_settimex32_64:(clockid_t clock_id, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *tp) -> errno_t;
clock_settimex64:(clockid_t clock_id, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *tp) -> errno_t;
%[endgroup]

%[startgroup]
clock_gettime:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC)] struct timespec *tp) -> errno_t;
clock_gettime32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *tp) -> errno_t;
clock_gettime64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *tp) -> errno_t;
clock_gettimex32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *tp) -> errno_t;
clock_gettimex32_64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *tp) -> errno_t;
clock_gettimex64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *tp) -> errno_t;
%[endgroup]

%[startgroup]
clock_getres:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC)] struct timespec *res) -> errno_t;
clock_getres32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *res) -> errno_t;
clock_getres64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *res) -> errno_t;
clock_getresx32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *res) -> errno_t;
clock_getresx32_64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *res) -> errno_t;
clock_getresx64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *res) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: flags: Set of `0 | TIMER_ABSTIME'
[restart(dont)][cp] clock_nanosleep:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPEC)] struct timespec const *requested_time, [tostr(out:STRUCT_TIMESPEC)] struct timespec *remaining) -> errno_t;
[restart(dont)][cp] clock_nanosleep32:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *requested_time, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *remaining) -> errno_t;
[restart(dont)][cp] clock_nanosleep64:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *requested_time, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *remaining) -> errno_t;
[restart(dont)][cp] clock_nanosleepx32:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *requested_time, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *remaining) -> errno_t;
[restart(dont)][cp] clock_nanosleepx32_64:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *requested_time, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *remaining) -> errno_t;
[restart(dont)][cp] clock_nanosleepx64:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *requested_time, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *remaining) -> errno_t;
%[endgroup]

%[startgroup]
[cp] utimes:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVAL_VEC2)] struct timeval const times[2]) -> errno_t;
[cp] utimes32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVAL32_VEC2)] struct timeval32 const times[2]) -> errno_t;
[cp] utimes64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVAL64_VEC2)] struct timeval64 const times[2]) -> errno_t;
[cp] utimesx32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVALX32_VEC2)] struct timevalx32 const times[2]) -> errno_t;
[cp] utimesx32_64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVALX32_64_VEC2)] struct timevalx32_64 const times[2]) -> errno_t;
[cp] utimesx64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVALX64_VEC2)] struct timevalx64 const times[2]) -> errno_t;
%[endgroup]

vserver:(int TODO_PROTOTYPE) -> errno_t;
mbind:(int TODO_PROTOTYPE) -> errno_t;
get_mempolicy:(int TODO_PROTOTYPE) -> errno_t;
set_mempolicy:(int TODO_PROTOTYPE) -> errno_t;
kexec_load:(int TODO_PROTOTYPE) -> errno_t;

mq_open:(char const *name, oflag_t oflags, [tostr(MODE_T:oflags)] mode_t mode) -> fd_t;
mq_unlink:(char const *name) -> errno_t;

%[startgroup]
[cp] mq_timedsend:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPEC)] struct timespec const *abs_timeout) -> errno_t;
[cp] mq_timedsend32:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *abs_timeout) -> errno_t;
[cp] mq_timedsend64:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *abs_timeout) -> errno_t;
[cp] mq_timedsendx32:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *abs_timeout) -> errno_t;
[cp] mq_timedsendx32_64:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *abs_timeout) -> errno_t;
[cp] mq_timedsendx64:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *abs_timeout) -> errno_t;
%[endgroup]

%[startgroup]
[cp] mq_timedreceive:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPEC)] struct timespec const *abs_timeout) -> ssize_t;
[cp] mq_timedreceive32:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *abs_timeout) -> ssize_t;
[cp] mq_timedreceive64:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *abs_timeout) -> ssize_t;
[cp] mq_timedreceivex32:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *abs_timeout) -> ssize_t;
[cp] mq_timedreceivex32_64:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *abs_timeout) -> ssize_t;
[cp] mq_timedreceivex64:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *abs_timeout) -> ssize_t;
%[endgroup]

mq_notify:(fd_t mqdes, [tostr(STRUCT_SIGEVENT)] struct sigevent const *notification) -> errno_t;
mq_getsetattr:(fd_t mqdes, [tostr(STRUCT_MQ_ATTR)] struct mq_attr const *newattr, [tostr(out:STRUCT_MQ_ATTR)] struct mq_attr *oldattr) -> errno_t;

%[startgroup]
@@@param: idtype:  One of `P_ALL', `P_PID', `P_PGID'
@@@param: options: At least one of `WEXITED', `WSTOPPED', `WCONTINUED', optionally or'd with `WNOHANG | WNOWAIT'
[restart(dont)][cp]
waitid:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, struct __siginfo_struct *infop,
        [tostr(WAITID_OPTIONS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE)] struct rusage *ru) -> errno_t;
[restart(dont)][cp][doc_alias(waitid)] waitid32:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *infop, [tostr(WAITID_OPTIONS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *ru) -> errno_t;
[restart(dont)][cp][doc_alias(waitid)] waitid64:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *infop, [tostr(WAITID_OPTIONS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *ru) -> errno_t;
[restart(dont)][cp][doc_alias(waitid)] waitidx32:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *infop, [tostr(WAITID_OPTIONS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *ru) -> errno_t;
[restart(dont)][cp][doc_alias(waitid)] waitidx32_64:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *infop, [tostr(WAITID_OPTIONS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *ru) -> errno_t;
[restart(dont)][cp][doc_alias(waitid)] waitidx64:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFOX64)] struct __siginfox64_struct *infop, [tostr(WAITID_OPTIONS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *ru) -> errno_t;
%[endgroup]

add_key:(int TODO_PROTOTYPE) -> errno_t;
request_key:(int TODO_PROTOTYPE) -> errno_t;
keyctl:(int TODO_PROTOTYPE) -> errno_t;

@@NOTE: Linux calls `who' `which', and `id' `who' (refactored to prevent confusion)
@@@param: who: One of `IOPRIO_WHO_PROCESS', `IOPRIO_WHO_PGRP' or `IOPRIO_WHO_USER'
ioprio_set:([tostr(IOPRIO_WHO)] syscall_ulong_t who,
            [tostr(IOPRIO_ID:who)] syscall_ulong_t id,
            [tostr(IOPRIO_VALUE)] syscall_ulong_t ioprio) -> errno_t;

@@NOTE: Linux calls `who' `which', and `id' `who' (refactored to prevent confusion)
@@@param: who: One of `IOPRIO_WHO_PROCESS', `IOPRIO_WHO_PGRP' or `IOPRIO_WHO_USER'
ioprio_get:([tostr(IOPRIO_WHO)] syscall_ulong_t who,
            [tostr(IOPRIO_ID:who)] syscall_ulong_t id) -> [tostr(IOPRIO_VALUE)] syscall_slong_t;

inotify_init:(int TODO_PROTOTYPE) -> errno_t;
inotify_add_watch:(int TODO_PROTOTYPE) -> errno_t;
inotify_rm_watch:(int TODO_PROTOTYPE) -> errno_t;
migrate_pages:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
[cp] futimesat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVAL_VEC2)] struct timeval const times[2]) -> errno_t;
[cp] futimesat32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVAL32_VEC2)] struct timeval32 const times[2]) -> errno_t;
[cp] futimesat64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVAL64_VEC2)] struct timeval64 const times[2]) -> errno_t;
[cp] futimesatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVALX32_VEC2)] struct timevalx32 const times[2]) -> errno_t;
[cp] futimesatx32_64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVALX32_64_VEC2)] struct timevalx32_64 const times[2]) -> errno_t;
[cp] futimesatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVALX64_VEC2)] struct timevalx64 const times[2]) -> errno_t;
%[endgroup]

@@@param: flags: Set of `0 | AT_EMPTY_PATH | AT_SYMLINK_FOLLOW | AT_DOSPATH'
[cp] linkat:(fd_t fromfd, [tostr(FILENAME:fromfd)] char const *existing_file,
             fd_t tofd, [tostr(FILENAME:tofd)] char const *target_path,
             [tostr(ATFLAG__EMPTY_PATH__SYMLINK_FOLLOW__DOSPATH)] atflag_t flags) -> errno_t;

[cp] symlinkat:([tostr(STRING)] char const *link_text, fd_t tofd,
                [tostr(FILENAME:tofd)] char const *target_path) -> errno_t;

@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fsymlinkat:([tostr(STRING)] char const *link_text, fd_t tofd,
                 [tostr(FILENAME:tofd)] char const *target_path,
                 [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;

[cp] readlinkat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *path,
                 [tostr(out:BUFFER:buflen:return)] char *buf, size_t buflen) -> ssize_t;

@@@param: flags: Set of `0 | AT_READLINK_REQSIZE | AT_DOSPATH'
[cp] freadlinkat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *path,
                  [tostr(out:BUFFER:buflen:return)] char *buf, size_t buflen,
                  [tostr(ATFLAG__READLINK_REQSIZE__DOSPATH)] atflag_t flags) -> ssize_t;

@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] fchmodat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, mode_t mode,
               [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;

@@@param: type: Set of `R_OK | W_OK | X_OK' or `F_OK'
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_EACCESS | AT_DOSPATH'
[cp] faccessat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                [tostr(ACCESS_TYPE)] syscall_ulong_t type,
                [tostr(ATFLAG__SYMLINK_NOFOLLOW__EACCESS__DOSPATH)] atflag_t flags) -> errno_t;

@@param flags: Set of `CLONE_*'
unshare:([tostr(CLONE_FLAGS_UNSHARE)] syscall_ulong_t flags) -> errno_t;

set_robust_list:(int TODO_PROTOTYPE) -> errno_t;
get_robust_list:(int TODO_PROTOTYPE) -> errno_t;

@@@param: flags: Set of `SPLICE_F_MOVE | SPLICE_F_NONBLOCK | SPLICE_F_MORE | SPLICE_F_GIFT'
[cp] splice:(fd_t fdin, uint64_t *offin, fd_t fdout, uint64_t *offout,
             size_t length, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t;

%[startgroup]
@@@param: flags: Set of `SPLICE_F_MOVE | SPLICE_F_NONBLOCK | SPLICE_F_MORE | SPLICE_F_GIFT'
[cp] vmsplice:(fd_t fdout, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iov, size_t count, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t;
[doc_alias(vmsplice)][cp] vmsplicex32:(fd_t fdout, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iov, size_t count, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t;
[doc_alias(vmsplice)][cp] vmsplicex64:(fd_t fdout, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iov, size_t count, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t;
%[endgroup]

@@@param: flags: Set of `SPLICE_F_MOVE | SPLICE_F_NONBLOCK | SPLICE_F_MORE | SPLICE_F_GIFT'
[cp] tee:(fd_t fdin, fd_t fdout, size_t length,
          [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t;

@@@param: flags: Set of `SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER'
[cp] sync_file_range:(fd_t fd, [reg64] uint64_t offset, [reg64] uint64_t count,
                      [tostr(SYNC_FILE_RANGE_FLAGS)] syscall_ulong_t flags) -> errno_t;

move_pages:(int TODO_PROTOTYPE) -> errno_t;
getcpu:([tostr(out:UINT32_T)] uint32_t *cpu,
        [tostr(out:UINT32_T)] uint32_t *node,
        [tostr(out:STRUCT_GETCPU_CACHE)] struct getcpu_cache *tcache) -> errno_t;

%[startgroup]
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_CHANGE_CTIME | AT_DOSPATH'
[cp] utimensat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPEC_VEC2_OR_3:flags)] struct timespec const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_CTIME__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(utimensat)][cp] utimensat32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPEC32_VEC2_OR_3:flags)] struct timespec32 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_CTIME__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(utimensat)][cp] utimensat64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPEC64_VEC2_OR_3:flags)] struct timespec64 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_CTIME__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(utimensat)][cp] utimensatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPECX32_VEC2_OR_3:flags)] struct timespecx32 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_CTIME__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(utimensat)][cp] utimensatx32_64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPECX32_64_VEC2_OR_3:flags)] struct timespecx32_64 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_CTIME__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(utimensat)][cp] utimensatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPECX64_VEC2_OR_3:flags)] struct timespecx64 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_CTIME__DOSPATH)] atflag_t flags) -> errno_t;
%[endgroup]

signalfd:(fd_t fd, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> errno_t;

%[startgroup]
@@@param: mode: Set of `0 | FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE | FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE'
fallocate:(fd_t fd, [tostr(FALLOCATE_MODE)] syscall_ulong_t mode, syscall_ulong_t offset, syscall_ulong_t length) -> errno_t;
fallocate64:(fd_t fd, [tostr(FALLOCATE_MODE)] syscall_ulong_t mode, [reg64] uint64_t offset, [reg64] uint64_t length) -> errno_t;
%[endgroup]

@@Return file descriptor for new interval timer source
@@@param: flags: Set of `0 | TFD_NONBLOCK | TFD_CLOEXEC | TFD_CLOFORK'
timerfd_create:(clockid_t clock_id, [tostr(TIMERFD_FLAGS)] syscall_ulong_t flags) -> fd_t;

%[startgroup]
@@Set next expiration time of interval timer source `timerfd' to `utmr'.
@@If `flags' has the `TFD_TIMER_ABSTIME' flag set the timeout value
@@is absolute. Optionally return the old expiration time in `otmr''
@@@param: flags: Set of `0 | TFD_TIMER_ABSTIME'
timerfd_settime:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC)] struct itimerspec const *utmr, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *otmr) -> errno_t;
[doc_alias(timerfd_settime)] timerfd_settime32:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC32)] struct itimerspec32 const *utmr, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *otmr) -> errno_t;
[doc_alias(timerfd_settime)] timerfd_settime64:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC64)] struct itimerspec64 const *utmr, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *otmr) -> errno_t;
[doc_alias(timerfd_settime)] timerfd_settimex32:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32)] struct itimerspecx32 const *utmr, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *otmr) -> errno_t;
[doc_alias(timerfd_settime)] timerfd_settimex32_64:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 const *utmr, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *otmr) -> errno_t;
[doc_alias(timerfd_settime)] timerfd_settimex64:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX64)] struct itimerspecx64 const *utmr, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *otmr) -> errno_t;
%[endgroup]

%[startgroup]
@@Return the next expiration time of UFD
timerfd_gettime:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *otmr) -> errno_t;
[doc_alias(timerfd_gettime)] timerfd_gettime32:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *otmr) -> errno_t;
[doc_alias(timerfd_gettime)] timerfd_gettime64:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *otmr) -> errno_t;
[doc_alias(timerfd_gettime)] timerfd_gettimex32:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *otmr) -> errno_t;
[doc_alias(timerfd_gettime)] timerfd_gettimex32_64:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *otmr) -> errno_t;
[doc_alias(timerfd_gettime)] timerfd_gettimex64:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *otmr) -> errno_t;
%[endgroup]

@@@param: flags: Set of `SFD_NONBLOCK | SFD_CLOEXEC'
signalfd4:(fd_t fd, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask,
           size_t sigsetsize, [tostr(SIGNALFD4_FLAGS)] syscall_ulong_t flags) -> errno_t;

inotify_init1:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
[cp] preadv:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp] preadvx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp] preadvx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp] preadvf:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp] preadvfx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp] preadvfx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
%[endgroup]

%[startgroup]
[cp] pwritev:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp] pwritevx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp] pwritevx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp] pwritevf:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp] pwritevfx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp] pwritevfx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
%[endgroup]

%[startgroup]
rt_tgsigqueueinfo:(pid_t tgid, pid_t tid, signo_t signo, [tostr(STRUCT_SIGINFO)] struct __siginfo_struct const *uinfo) -> errno_t;
rt_tgsigqueueinfox32:(pid_t tgid, pid_t tid, signo_t signo, [tostr(STRUCT_SIGINFOX32)] struct __siginfox32_struct const *uinfo) -> errno_t;
rt_tgsigqueueinfox64:(pid_t tgid, pid_t tid, signo_t signo, [tostr(STRUCT_SIGINFOX64)] struct __siginfox64_struct const *uinfo) -> errno_t;
%[endgroup]

perf_event_open:(int TODO_PROTOTYPE) -> errno_t;

fanotify_init:(int TODO_PROTOTYPE) -> errno_t;
fanotify_mark:(int TODO_PROTOTYPE) -> errno_t;

@@@param: resource: One of `RLIMIT_*' from <sys/resource.h>
prlimit64:(pid_t pid, [tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource,
           [tostr(STRUCT_RLIMIT64)] struct rlimit64 const *new_limit,
           [tostr(out:STRUCT_RLIMIT64)] struct rlimit64 *old_limit) -> errno_t;

@@@param: flags: Set of `0 | AT_EMPTY_PATH | AT_SYMLINK_FOLLOW | AT_DOSPATH'
[cp]
name_to_handle_at:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                   [tostr(out:STRUCT_FILE_HANDLE)] struct file_handle *handle,
                   [tostr(out:INT32_T)] int32_t *mnt_id,
                   [tostr(ATFLAG__EMPTY_PATH__SYMLINK_FOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp]
open_by_handle_at:(fd_t mountdirfd, [tostr(STRUCT_FILE_HANDLE)] struct file_handle const *handle,
                   oflag_t flags) -> fd_t;

clock_adjtime:(int TODO_PROTOTYPE) -> errno_t;

[cp] syncfs:(fd_t fd) -> errno_t;

setns:(fd_t fd, [tostr(CLONE_FLAGS_SETNS)] syscall_ulong_t nstype) -> errno_t;

%[startgroup]
@@@param: flags: Must be `0'
process_vm_readv:(pid_t pid,
                  [tostr(STRUCT_IOVEC:liovcnt)] struct iovec const *local_iov, size_t liovcnt,
                  [tostr(STRUCT_IOVEC:riovcnt)] struct iovec const *remote_iov, size_t riovcnt,
                  syscall_ulong_t flags) -> ssize_t;
[doc_alias(process_vm_readv)]
process_vm_readvx32:(pid_t pid,
                     [tostr(STRUCT_IOVECX32:liovcnt)] struct iovecx32 const *local_iov, size_t liovcnt,
                     [tostr(STRUCT_IOVECX32:riovcnt)] struct iovecx32 const *remote_iov, size_t riovcnt,
                     syscall_ulong_t flags) -> ssize_t;
[doc_alias(process_vm_readv)]
process_vm_readvx64:(pid_t pid,
                     [tostr(STRUCT_IOVECX64:liovcnt)] struct iovecx64 const *local_iov, size_t liovcnt,
                     [tostr(STRUCT_IOVECX64:riovcnt)] struct iovecx64 const *remote_iov, size_t riovcnt,
                     syscall_ulong_t flags) -> ssize_t;
%[endgroup]

%[startgroup]
@@@param: flags: Must be `0'
process_vm_writev:(pid_t pid,
                   [tostr(STRUCT_IOVEC_C:liovcnt)] struct iovec const *local_iov, size_t liovcnt,
                   [tostr(STRUCT_IOVEC:riovcnt)] struct iovec const *remote_iov, size_t riovcnt,
                   syscall_ulong_t flags) -> ssize_t;
[doc_alias(process_vm_writev)]
process_vm_writevx32:(pid_t pid,
                      [tostr(STRUCT_IOVECX32_C:liovcnt)] struct iovecx32 const *local_iov, size_t liovcnt,
                      [tostr(STRUCT_IOVECX32:riovcnt)] struct iovecx32 const *remote_iov, size_t riovcnt,
                      syscall_ulong_t flags) -> ssize_t;
[doc_alias(process_vm_writev)]
process_vm_writevx64:(pid_t pid,
                      [tostr(STRUCT_IOVECX64_C:liovcnt)] struct iovecx64 const *local_iov, size_t liovcnt,
                      [tostr(STRUCT_IOVECX64:riovcnt)] struct iovecx64 const *remote_iov, size_t riovcnt,
                      syscall_ulong_t flags) -> ssize_t;
%[endgroup]

@@@param: type: One of `KCMP_FILE', `KCMP_FILES', `KCMP_FS', `KCMP_IO',
@@              `KCMP_SIGHAND', `KCMP_SYSVSEM', `KCMP_VM', `KCMP_EPOLL_TFD'
kcmp:(pid_t pid1, pid_t pid2, [tostr(KCMP_TYPE)] syscall_ulong_t type,
      syscall_ulong_t idx1, syscall_ulong_t idx2) -> syscall_slong_t;

finit_module:(int TODO_PROTOTYPE) -> errno_t;
sched_setattr:(int TODO_PROTOTYPE) -> errno_t;
sched_getattr:(int TODO_PROTOTYPE) -> errno_t;

seccomp:(int TODO_PROTOTYPE) -> errno_t;

@@@param: flags: Set of `0 | GRND_RANDOM | GRND_NONBLOCK'
getrandom:(void *buf, size_t num_bytes, [tostr(GETRANDOM_FLAGS)] syscall_ulong_t flags) -> ssize_t;

@@@param: flags: Set of `MFD_CLOEXEC | MFD_ALLOW_SEALING'
memfd_create:(char const *name, [tostr(MEMFD_CREATE_FLAGS)] syscall_ulong_t flags) -> fd_t;

bpf:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
[cp] execve:([tostr(FILENAME)] char const *path,
             [tostr(STRING_VECTOR)] char const *const *argv,
             [tostr(STRING_VECTOR)] char const *const *envp) -> errno_t;
[cp] execvex32:(char const *path,
                [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *argv,
                [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *envp) -> errno_t;
[cp] execvex64:(char const *path,
                [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *argv,
                [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *envp) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: flags: Set of `0 | AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] execveat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
               [tostr(STRING_VECTOR)] char const *const *argv,
               [tostr(STRING_VECTOR)] char const *const *envp,
               [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(execveat)][cp]
execveatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
             [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *argv,
             [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *envp,
             [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[doc_alias(execveat)][cp]
execveatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
             [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *argv,
             [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *envp,
             [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
%[endgroup]

@@@param: family:   Socket address family (one of `AF_*' from `<sys/socket.h>')
@@@param: type:     Socket type (one of `SOCK_*' from `<sys/socket.h>')
@@                  May optionally be or'd with `SOCK_CLOEXEC | SOCK_CLOFORK | SOCK_NONBLOCK'
@@@param: protocol: Socket protocol (`0' for automatic). Available socket protocols mainly
@@                  depend on the selected `family', and may be further specialized by the
@@                  `type' argument. for example, `AF_INET' takes one of `IPPROTO_*'
@@                  >> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
@@                  Also note that protocol IDs can be enumerated by `getprotoent(3)' from `<netdb.h>'
socket:([tostr(SOCKET_DOMAIN)] syscall_ulong_t domain,
        [tostr(SOCKET_TYPE)] syscall_ulong_t type,
        [tostr(SOCKET_PROTOCOL:domain)] syscall_ulong_t protocol) -> fd_t;

[doc_alias(socket)]
socketpair:([tostr(SOCKET_DOMAIN)] syscall_ulong_t domain,
            [tostr(SOCKET_TYPE)] syscall_ulong_t type,
            [tostr(SOCKET_PROTOCOL:domain)] syscall_ulong_t protocol,
            fd_t fds[2]) -> errno_t;

bind:(fd_t sockfd, [tostr(STRUCT_SOCKADDR:addr_len)] struct sockaddr const *addr, socklen_t addr_len) -> errno_t;
[restart(dont)][cp]
connect:(fd_t sockfd, [tostr(STRUCT_SOCKADDR:addr_len)] struct sockaddr const *addr, socklen_t addr_len) -> errno_t;
listen:(fd_t sockfd, syscall_ulong_t max_backlog) -> errno_t;

@@@param: sock_flags: Set of `SOCK_NONBLOCK | SOCK_CLOEXEC | SOCK_CLOFORK'
[restart(dont)][cp]
accept4:(fd_t sockfd,
         [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
         [tostr(out:SOCKLEN_T)] socklen_t *addr_len,
         [tostr(ACCEPT4_FLAGS)] syscall_ulong_t sock_flags) -> fd_t;

[restart(dont)][cp]
accept:(fd_t sockfd,
        [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
        [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> fd_t;

@@@param: level:   One of `SOL_*' (e.g.: `SOL_SOCKET')
@@@param: optname: Dependent on `level'
getsockopt:(fd_t sockfd,
            [tostr(SOCKOPT_LEVEL)] syscall_ulong_t level,
            [tostr(SOCKOPT_OPTNAME:level)] syscall_ulong_t optname,
            [tostr(out:BUFFER:*optlen)] void *optval,
            [tostr(out:SOCKLEN_T)] socklen_t *optlen) -> errno_t;

@@@param: level:   One of `SOL_*' (e.g.: `SOL_SOCKET')
@@@param: optname: Dependent on `level'
[restart(dont)]
setsockopt:(fd_t sockfd,
            [tostr(SOCKOPT_LEVEL)] syscall_ulong_t level,
            [tostr(SOCKOPT_OPTNAME:level)] syscall_ulong_t optname,
            [tostr(SOCKOPT_OPTVAL:optlen)] void const *optval,
            socklen_t optlen) -> errno_t;

getsockname:(fd_t sockfd,
             [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
             [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> errno_t;
getpeername:(fd_t sockfd,
             [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
             [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> errno_t;

@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
[restart(dont)][cp]
send:(fd_t sockfd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
      [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;

@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
[restart(dont)][cp]
sendto:(fd_t sockfd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
        [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags,
        [tostr(STRUCT_SOCKADDR:addr_len)] struct sockaddr const *addr, socklen_t addr_len) -> ssize_t;

%[startgroup]
@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
[restart(dont)][cp] sendmsg:(fd_t sockfd, [tostr(STRUCT_MSGHDR)] struct msghdr const *message, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[doc_alias(sendmsg)][restart(dont)][cp] sendmsgx32:(fd_t sockfd, [tostr(STRUCT_MSGHDRX32)] struct msghdrx32 const *message, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[doc_alias(sendmsg)][restart(dont)][cp] sendmsgx64:(fd_t sockfd, [tostr(STRUCT_MSGHDRX64)] struct msghdrx64 const *message, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
%[endgroup]

%[startgroup]
@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
[restart(dont)][cp] sendmmsg:(fd_t sockfd, [tostr(STRUCT_MMSGHDR:vlen)] struct mmsghdr *vmessages, size_t vlen, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[doc_alias(sendmmsg)][restart(dont)][cp] sendmmsgx32:(fd_t sockfd, [tostr(STRUCT_MMSGHDRX32:vlen)] struct mmsghdrx32 *vmessages, size_t vlen, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[doc_alias(sendmmsg)][restart(dont)][cp] sendmmsgx64:(fd_t sockfd, [tostr(STRUCT_MMSGHDRX64:vlen)] struct mmsghdrx64 *vmessages, size_t vlen, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
%[endgroup]

@@@param: msg_flags: Set of `MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK | MSG_TRUNC | MSG_WAITALL'
[restart(dont)][cp]
recv:(fd_t sockfd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize,
      [tostr(SOCKET_RECVMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;

@@@param: msg_flags: Set of `MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK | MSG_TRUNC | MSG_WAITALL'
[restart(dont)][cp]
recvfrom:(fd_t sockfd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize,
          [tostr(SOCKET_RECVMSG_FLAGS)] syscall_ulong_t msg_flags,
          [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
          [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> ssize_t;

%[startgroup]
@@@param: msg_flags: Set of `MSG_CMSG_CLOEXEC | MSG_CMSG_CLOFORK |
@@                           MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK | MSG_TRUNC | MSG_WAITALL'
[restart(dont)][cp]
recvmsg:(fd_t sockfd, struct msghdr *message,
         [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags) -> ssize_t;
[doc_alias(recvmsg)][restart(dont)][cp]
recvmsgx32:(fd_t sockfd, struct msghdrx32 *message,
            [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags) -> ssize_t;
[doc_alias(recvmsg)][restart(dont)][cp]
recvmsgx64:(fd_t sockfd, struct msghdrx64 *message,
            [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags) -> ssize_t;
%[endgroup]

%[startgroup]
@@@param: msg_flags: Set of `MSG_CMSG_CLOEXEC | MSG_CMSG_CLOFORK |
@@                           MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK | MSG_TRUNC | MSG_WAITALL'
[restart(dont)][cp] recvmmsg:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDR:vlen:return)] struct mmsghdr *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPEC)] struct timespec const *tmo) -> ssize_t;
[doc_alias(recvmmsg)][restart(dont)][cp] recvmmsg32:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX32:vlen:return)] struct mmsghdrx32 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *tmo) -> ssize_t;
[doc_alias(recvmmsg)][restart(dont)][cp] recvmmsg64:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX64:vlen:return)] struct mmsghdrx64 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *tmo) -> ssize_t;
[doc_alias(recvmmsg)][restart(dont)][cp] recvmmsgx32:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX32:vlen:return)] struct mmsghdrx32 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *tmo) -> ssize_t;
[doc_alias(recvmmsg)][restart(dont)][cp] recvmmsgx32_64:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX32:vlen:return)] struct mmsghdrx32 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *tmo) -> ssize_t;
[doc_alias(recvmmsg)][restart(dont)][cp] recvmmsgx64:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX64:vlen:return)] struct mmsghdrx64 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *tmo) -> ssize_t;
%[endgroup]

@@@param: how: One of `SHUT_RD', `SHUT_WR' or `SHUT_RDWR'
shutdown:(fd_t sockfd, [tostr(SOCKET_SHUTDOWN_HOW)] syscall_ulong_t how) -> errno_t;

userfaultfd:(int TODO_PROTOTYPE) -> errno_t;
membarrier:(int TODO_PROTOTYPE) -> errno_t;
mlock2:(int TODO_PROTOTYPE) -> errno_t;

shmget:(int TODO_PROTOTYPE) -> errno_t;
shmat:(int TODO_PROTOTYPE) -> errno_t;
shmctl:(int TODO_PROTOTYPE) -> errno_t;
semget:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semop:(int TODO_PROTOTYPE) -> errno_t;
semctl:(int TODO_PROTOTYPE) -> errno_t;
shmdt:(int TODO_PROTOTYPE) -> errno_t;
msgget:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)][cp] msgsnd:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)][cp] msgrcv:(int TODO_PROTOTYPE) -> errno_t;
msgctl:(int TODO_PROTOTYPE) -> errno_t;
arch_prctl:(int TODO_PROTOTYPE) -> errno_t;
tuxcall:(int TODO_PROTOTYPE) -> errno_t;
security:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semtimedop:(int TODO_PROTOTYPE) -> errno_t;
kexec_file_load:(int TODO_PROTOTYPE) -> errno_t;

[cp] hop:(fd_t fd, [tostr(HOP_COMMAND)] syscall_ulong_t command, [tostr(HOP_ARG:command)] void *arg) -> syscall_slong_t;
[cp] hopf:(fd_t fd, [tostr(HOP_COMMAND)] syscall_ulong_t command, iomode_t mode, [tostr(HOP_ARG:command)] void *arg) -> syscall_slong_t;

@@>> detach(2)
@@Detach the descriptor of `PID' from the thread that
@@would have received a signal when it changes state,
@@as well as prevent the thread from turning into a
@@zombie once it dies.
@@For simplicity, think of it like this:
@@  - pthread_create()  -->  clone()
@@  - pthread_join()    -->  wait()
@@  - pthread_detach()  -->  detach()  // Linux's missing link, now implemented
@@A total of 4 special cases exists to alter the behavior of this function:
@@  - PID == 0 || PID == gettid():
@@    Detach the calling thread from the set of running children within
@@    its own process. Note however that when this is done by the main
@@    thread of the process, gettid() will equal getpid(), and the behavior
@@    will be different.
@@  - PID == getpid():
@@    Detach the calling process from its parent, essentially daemonizing
@@    the calling process the same way a double-fork would:
@@    >> if (fork() == 0) {
@@    >> 	if (fork() == 0) {
@@    >> 		// This is a daemonized process
@@    >> 		// aka. the parent process no longer knows
@@    >> 		// about us, and also can't wait(2) on us.
@@    >> 		...
@@    >> 	}
@@    >> 	exit(0);
@@    >> }
@@    Same as:
@@    >> if (fork() == 0) {
@@    >> 	detach(0); // or `detach(getpid())', since 0 --> gettid() and gettid() == getpid()
@@    >> 	// This is a daemonized process
@@    >> 	// aka. the parent process no longer knows
@@    >> 	// about us, and also can't wait(2) on us.
@@    >> 	...
@@    >> }
@@  - PID == -1:
@@    Detach all child processes/threads of the calling process, essentially
@@    turning its chain of children into a clean slate that no longer contains
@@    any wait(2)able child threads or processes.
@@    If no waitable children existed, `ECHILD' is set; else `0' is returned.
@@Before any of this is done, the thread referred to by `PID' is one of the following:
@@  - The leader of the process that called `fork()' or `clone()' without
@@   `CLONE_PARENT' to create the thread referred to by `PID'
@@  - The creator of the process containing a thread that called
@@   `clone()' with `CLONE_PARENT', which then created the thread
@@    referred to by `PID'.
@@  - Even if the thread doesn't deliver a signal upon it terminating,
@@    the process that would have received such a signal is still relevant.
@@  -> In other words: The thread `PID' must be one of your children,
@@                     or you had to have been assigned as its child.
@@If the calling thread isn't part of that process that will receive
@@the signal if the thread dies without being detached first, then
@@the call fails by throwing an `E_ILLEGAL_OPERATION'.
@@If the thread had already been detached, then the call fails by
@@throwing an `E_ILLEGAL_OPERATION' as well.
@@Upon success, the thread referred to by `PID' will clean up its own
@@PID descriptor without the need of anyone to wait() for it, a behavior
@@that linux implements using `CLONE_THREAD' (which you shouldn't use,
@@because it's flawed by design)
@@Once detached, any further use of PID results in a race condition
@@(which linux neglects to mention for `CLONE_THREAD'), because there
@@is no way of ensuring that PID still refers to the original thread,
@@as another thread may have been created using the same PID, after
@@the detached thread exited.
@@NOTE: If a thread is created using clone() with `CLONE_DETACHED' set,
@@      it will behave effectively as though this function had already
@@      be called.
@@NOTE: If the thread already has terminated, detaching it will kill
@@      its zombie the same way wait() would.
@@NOTE: Passing ZERO(0) for `PID' will detach the calling thread.
@@      However, this operation fails if the calling thread isn't
@@      part of the same process as the parent process of the thread.
@@      In other words, the child of a fork() can't do this, and
@@      neither can the spawnee of clone(CLONE_THREAD|CLONE_PARENT),
@@      clone(0) or clone(CLONE_PARENT).
@@@return: -EPERM:             The calling process isn't the recipient of signals
@@                             delivered when `PID' changes state. This can either
@@                             be because `PID' has already been detached, or because
@@                             YOU CAN'T DETACH SOMEONE ELSE'S THREAD!
@@                             Another possibility is that the thread was already
@@                             detached, then exited, following which a new thread
@@                             got created and had been assigned the PID of your
@@                             ancient, no longer existent thread.
@@@return: -ECHILD:           `PID' was equal to `-1', but no waitable children existed
@@@throw: E_PROCESS_EXITED:    The process referred to by `PID' doesn't exist.
@@                             This could mean that it had already been detached
@@                             and exited, or that the `PID' is just invalid (which
@@                             would also be the case if it was valid at some point)
[restart(must)] detach:(pid_t pid) -> errno_t;

@@Returns a bitset of all of the currently mounted dos-drives
[restart(must)] getdrives:() -> syscall_slong_t;

@@You may pass `AT_READLINK_REQSIZE' to always have the function return
@@the required buffer size, rather than the used size.
@@@param: flags: Set of `0 | AT_ALTPATH | AT_READLINK_REQSIZE | AT_DOSPATH'
[cp] frealpath4:(fd_t fd, [tostr(out:BUFFER:buflen:return)] char *resolved, size_t buflen,
                 [tostr(ATFLAG__ALTPATH__READLINK_REQSIZE__DOSPATH)] atflag_t flags) -> ssize_t;

@@Returns the absolute filesystem path for the specified file
@@When `AT_SYMLINK_NOFOLLOW' is given, a final symlink is dereferenced,
@@causing the pointed-to file location to be retrieved. - Otherwise, the
@@location of the link is printed instead.
@@You may pass `AT_READLINK_REQSIZE' to always have the function return
@@the required buffer size, rather than the used size.
@@@param: flags: Set of `0 | AT_ALTPATH | AT_SYMLINK_NOFOLLOW | AT_READLINK_REQSIZE | AT_DOSPATH'
[cp] frealpathat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, char *buf, size_t buflen,
                  [tostr(ATFLAG__ALTPATH__SYMLINK_NOFOLLOW__READLINK_REQSIZE__DOSPATH)] atflag_t flags) -> ssize_t;

%[startgroup]
@@Schedule an RPC for execution on the specified `target' thread.
@@@param: target:    The targeted thread.
@@@param: flags:     RPC flags (one of `RPC_SCHEDULE_*', or'd with a set of `RPC_SCHEDULE_FLAG_*')
@@@param: program:   An RPC loader program (vector of `RPC_PROGRAM_OP_*')
@@@param: arguments: Arguments for the RPC loader program.
@@@return: 1:  The specified `target' thread has already terminated.
@@@return: 0:  Success.
@@@return: -1: Error (s.a. `errno')
@@@throws: E_PROCESS_EXITED:  `target' does not reference a valid process
@@@throws: E_INVALID_ARGUMENT: The given `flag' is invalid.
rpc_schedule:(pid_t target, [tostr(RPC_SCHEDULE_FLAGS)] syscall_ulong_t flags, uint8_t const *program, void **arguments) -> syscall_slong_t;
[doc_alias(rpc_schedule)] rpc_schedulex32:(pid_t target, [tostr(RPC_SCHEDULE_FLAGS)] syscall_ulong_t flags, uint8_t const *program, __HYBRID_PTR32(void) *arguments) -> syscall_slong_t;
[doc_alias(rpc_schedule)] rpc_schedulex64:(pid_t target, [tostr(RPC_SCHEDULE_FLAGS)] syscall_ulong_t flags, uint8_t const *program, __HYBRID_PTR64(void) *arguments) -> syscall_slong_t;
%[endgroup]

[cp] ksysctl:([tostr(KSYSCTL_COMMAND)] syscall_ulong_t command,
              [tostr(KSYSCTL_ARG:command)] void *arg) -> syscall_slong_t;

@@Create a new pseudo-terminal driver and store handles to both the master and slave ends of the connection in the given pointers.
openpty:([tostr(out:FD_T)] fd_t *amaster,
         [tostr(out:FD_T)] fd_t *aslave,
         [tostr(out:STRING)] char *name,
         [tostr(STRUCT_TERMIOS)] struct termios const *termp,
         [tostr(STRUCT_WINSIZE)] struct winsize const *winp) -> errno_t;

@@Set the exception handler mode for the calling thread.
@@Examples:
@@  Set mode #3 from you `main()': `set_exception_handler(EXCEPT_HANDLER_MODE_SIGHAND, NULL, NULL)'
@@  Configure mode #2 in libc:     `set_exception_handler(EXCEPT_HANDLER_MODE_ENABLED | EXCEPT_HANDLER_FLAG_SETHANDLER, &kernel_except_handler, NULL)'
@@@param: MODE:       One of `EXCEPT_HANDLER_MODE_*', optionally or'd with `EXCEPT_HANDLER_FLAG_*'
@@@param: HANDLER:    When `EXCEPT_HANDLER_FLAG_SETHANDLER' is set, the address of the exception handler to use
@@@param: HANDLER_SP: When `EXCEPT_HANDLER_FLAG_SETSTACK' is set, the address of the exception handler stack
@@@return: 0 :        Success.
@@@return: -1:EINVAL: The given MODE is invalid
[restart(must)]
set_exception_handler:([tostr(EXCEPTION_HANDLER_MODE)] syscall_ulong_t mode,
                       except_handler_t handler, void *handler_sp) -> errno_t;

%[startgroup]
@@Get the current exception handler mode for the calling thread.
@@@param: PMODE:       When non-NULL, store the current mode, which is encoded as:
@@                      - One of `EXCEPT_HANDLER_MODE_(DISABLED|ENABLED|SIGHAND)'
@@                      - Or'd with a set of `EXCEPT_HANDLER_FLAG_(ONESHOT|SETHANDLER|SETSTACK)'
@@@param: PHANDLER:    The address of the user-space exception handler.
@@                     Note that when no handler has been set (`!(*PMODE & EXCEPT_HANDLER_FLAG_SETHANDLER)'),
@@                     then this pointer is set to `NULL'.
@@@param: PHANDLER_SP: The starting address of the user-space exception handler stack.
@@                     Note that when no stack has been set (`!(*PMODE & EXCEPT_HANDLER_FLAG_SETSTACK)'),
@@                     or when the stack was defined to re-use the previous stack,
@@                     then this pointer is set to `EXCEPT_HANDLER_SP_CURRENT'.
@@@return: 0 :         Success.
@@@return: -1:EFAULT:  One of the given pointers is non-NULL and faulty
[restart(must)]
get_exception_handler:([tostr(out:EXCEPTION_HANDLER_MODE)] syscall_ulong_t *pmode,
                       [tostr(out:EXCEPT_HANDLER_T)] except_handler_t *phandler,
                       [tostr(out:POINTER)] void **phandler_sp) -> errno_t;
[doc_alias(get_exception_handler)][restart(must)]
get_exception_handlerx32:([tostr(out:EXCEPTION_HANDLER_MODE32)] __ULONG32_TYPE__ *pmode,
                          [tostr(out:EXCEPT_HANDLER32_T)] __except_handler32_t *phandler,
                          [tostr(out:POINTER32)] __HYBRID_PTR32(void) *phandler_sp) -> errno_t;
[doc_alias(get_exception_handler)][restart(must)]
get_exception_handlerx64:([tostr(out:EXCEPTION_HANDLER_MODE64)] __ULONG64_TYPE__ *pmode,
                          [tostr(out:EXCEPT_HANDLER64_T)] __except_handler64_t *phandler,
                          [tostr(out:POINTER64)] __HYBRID_PTR64(void) *phandler_sp) -> errno_t;
%[endgroup]

%[startgroup]
@@Set per-vm meta-data for allowing the kernel to enumerate loaded code modules
[restart(must)] set_library_listdef:([tostr(STRUCT_LIBRARY_LISTDEF)] struct library_listdef const *listdef) -> errno_t;
[restart(must)][doc_alias(set_library_listdef)] set_library_listdefx32:([tostr(STRUCT_LIBRARY_LISTDEF32)] struct library_listdef32 const *listdef) -> errno_t;
[restart(must)][doc_alias(set_library_listdef)] set_library_listdefx64:([tostr(STRUCT_LIBRARY_LISTDEF64)] struct library_listdef64 const *listdef) -> errno_t;
%[endgroup]

%[startgroup]
@@Trigger a debugger trap `trapno', optionally extended with `regs'
@@at either the system call return location, or at the given `state'
@@In the later case, this system call will by default return to the
@@given `state', though given the purpose of this system call being
@@to inform a connected debugger of some breakable event, allowing
@@it to do whatever it wishes before execution is resumed.
@@@param: reason:   When non-NULL, the reason for the debug trap (else: use `SIGTRAP:DEBUGTRAP_REASON_NONE')
@@@param: state:    When non-NULL, the CPU state where the trap should return to by default
@@@return: -EOK:    `state' was NULL and the trap returned successfully
@@@return: -ENOENT: No debugger is connected to the calling process/process-group/system
debugtrap:([tostr(STRUCT_UCPUSTATE)] struct ucpustate const *state, [tostr(STRUCT_DEBUGTRAP_REASON)] struct debugtrap_reason const *reason) -> errno_t;
[doc_alias(debugtrap)] debugtrapx32:([tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *state, [tostr(STRUCT_DEBUGTRAP_REASON32)] struct debugtrap_reason32 const *reason) -> errno_t;
[doc_alias(debugtrap)] debugtrapx64:([tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *state, [tostr(STRUCT_DEBUGTRAP_REASON64)] struct debugtrap_reason64 const *reason) -> errno_t;
%[endgroup]

%[startgroup]
@@>> lfutex(2)
@@Provide the bottom-most API for implementing user-space synchronization on KOS
@@@param: futex_op: One of:
@@   - LFUTEX_WAKE:               (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAKE, size_t val = count)
@@   - LFUTEX_WAKEMASK:           (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAKEMASK, size_t val = count, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout = mask_and, uintptr_t val2 = mask_or)
@@   - LFUTEX_NOP:                (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_NOP)
@@   - LFUTEX_WAIT:               (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT, uintptr_t val = ignored, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout)
@@   - LFUTEX_WAIT_LOCK:          (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_LOCK, uintptr_t val = lock_value, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout)
@@   - LFUTEX_WAIT_WHILE:         (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_WHILE, uintptr_t val = value, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout)
@@   - LFUTEX_WAIT_UNTIL:         (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_UNTIL, uintptr_t val = value, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout)
@@   - LFUTEX_WAIT_WHILE_ABOVE:   (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_WHILE_ABOVE, uintptr_t val = value, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout)
@@   - LFUTEX_WAIT_WHILE_BELOW:   (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_WHILE_BELOW, uintptr_t val = value, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout)
@@   - LFUTEX_WAIT_WHILE_BITMASK: (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_WHILE_BITMASK, uintptr_t val = bitmask, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, uintptr_t val2 = setmask)
@@   - LFUTEX_WAIT_UNTIL_BITMASK: (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_UNTIL_BITMASK, uintptr_t val = bitmask, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, uintptr_t val2 = setmask)
@@   - LFUTEX_WAIT_WHILE_CMPXCH:  (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_WHILE_CMPXCH, uintptr_t val = oldval, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, uintptr_t val2 = newval)
@@   - LFUTEX_WAIT_UNTIL_CMPXCH:  (uintptr_t *uaddr, syscall_ulong_t futex_op = LFUTEX_WAIT_UNTIL_CMPXCH, uintptr_t val = oldval, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, uintptr_t val2 = newval)
@@@param: timeout: Timeout for wait operations (s.a. `LFUTEX_WAIT_FLAG_TIMEOUT_*')
@@@return: * : Depending on `futex_op'
@@@return: -1:EFAULT:    A faulty pointer was given
@@@throw:  E_INVALID_ARGUMENT: The given `futex_op' is invalid
@@@throw:  E_INTERRUPT:        A blocking futex-wait operation was interrupted
@@@return: -ETIMEDOUT:         A blocking futex-wait operation has timed out
[restart(dont)][cp] lfutex:(uintptr_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uintptr_t val, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, uintptr_t val2) -> syscall_slong_t;
[restart(dont)][cp][doc_alias(lfutex)] lfutex32:(uintptr_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uintptr_t val, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout, uintptr_t val2) -> syscall_slong_t;
[restart(dont)][cp][doc_alias(lfutex)] lfutex64:(uintptr_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uintptr_t val, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, uintptr_t val2) -> syscall_slong_t;
[restart(dont)][cp][doc_alias(lfutex)] lfutexx32:(uint32_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout, uint32_t val2) -> syscall_slong_t;
[restart(dont)][cp][doc_alias(lfutex)] lfutexx32_64:(uint32_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, uint32_t val2) -> syscall_slong_t;
[restart(dont)][cp][doc_alias(lfutex)] lfutexx64:(uint64_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uint64_t val, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, uint64_t val2) -> syscall_slong_t;
%[endgroup]

%[startgroup]
@@>> lfutexexpr(2)
@@The lfutexexpr() system call can be used to specify arbitrarily complex
@@expressions that must atomically (in relation to other futex operations)
@@hold true before the scheduler will suspend the calling thread, as well as
@@have the calling thread wait for any number of futex objects associated with
@@any address that is checked as part of the expression. (s.a. `lfutex()')
@@Notes:
@@  - This is the only futex function that can be used to wait on multiple futex
@@    objects (i.e. resume execution when `LFUTEX_WAKE' is called on _any_ of them)
@@  - For more precise control over waiting on futex objects, as well as waiting on
@@    futexes in conjunction with waiting on other things such as files, see the
@@    documentation on this topic (lfutex() and select()) at the top of <kos/futex.h>
@@@param: base:          Base pointer added to the `fe_offset' fields of given expressions
@@@param: exprv:         Vector of expressions for which to check 
@@@param: exprc:         Number of expressions given in `exprv'
@@@param: timeout:       Timeout for wait operations (s.a. `LFUTEX_WAIT_FLAG_TIMEOUT_*')
@@@param: timeout_flags: Set of `LFUTEX_WAIT_FLAG_TIMEOUT_*'
@@@return: * : The first non-zero return value from executing all of the given `exprv'
@@             in order (s.a. the documentations of the individual `LFUTEX_WAIT_*' functions
@@             to see their possible return values, which are always `0' when they would
@@             perform a wait operation, and usually `1' otherwise) or `0' if the calling
@@             thread had to perform a wait operation, at which point this function returning
@@             that value means that you've once again been re-awoken.
@@@return: -1:EFAULT:    A faulty pointer was given
@@@return: -1:EINVAL:    One of the given commands is invalid, or `exprc' was `0'
@@@return: -1:EINTR:     A blocking futex-wait operation was interrupted
@@@return: -1:ETIMEDOUT: A blocking futex-wait operation has timed out
[restart(dont)][cp] lfutexexpr:(void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPR_VECTOR:exprc)] struct lfutexexpr const *exprv, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexexpr)] lfutexexpr32:(void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPR_VECTOR:exprc)] struct lfutexexpr const *exprv, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexexpr)] lfutexexpr64:(void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPR_VECTOR:exprc)] struct lfutexexpr const *exprv, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexexpr)] lfutexexprx32:(void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPRX32_VECTOR:exprc)] struct lfutexexprx32 const *exprv, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexexpr)] lfutexexprx32_64:(void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPRX32_VECTOR:exprc)] struct lfutexexprx32 const *exprv, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexexpr)] lfutexexprx64:(void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPRX64_VECTOR:exprc)] struct lfutexexprx64 const *exprv, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
%[endgroup]


%[startgroup]
@@>> lfutexlockexpr(2)
@@A function that is similar to `lfutexexpr()', but allows for the use of one central
@@locking futex that is used for waiting and may be distinct from any other given futex
@@object pointer.
@@Notes:
@@  - This function only has the calling thread wait on a single futex `ulockaddr',
@@    rather than having it wait on an arbitrary number of futexes, as would be the case when
@@    the `lfutexexpr()' function is used.
@@  - For more precise control over waiting on futex objects, as well as waiting on futexes
@@    in conjunction with waiting on other things such as files, see the documentation on
@@    this topic (lfutex() and select()) at the top of <kos/futex.h>
@@@param: ulockaddr:     Address of the futex lock to-be used / The futex on which to wait
@@@param: base:          Base pointer added to the `fe_offset' fields of given expressions
@@@param: exprv:         Vector of expressions for which to check 
@@@param: exprc:         Number of expressions given in `exprv'
@@@param: timeout:       Timeout for wait operations (s.a. `LFUTEX_WAIT_FLAG_TIMEOUT_*')
@@@param: timeout_flags: Set of `LFUTEX_WAIT_FLAG_TIMEOUT_*'
@@@return: * : The first non-zero return value from executing all of the given `exprv'
@@             in order (s.a. the documentations of the individual `LFUTEX_WAIT_*' functions
@@             to see their possible return values, which are always `0' when they would
@@             perform a wait operation, and usually `1' otherwise) or `0' if the calling
@@             thread had to perform a wait operation, at which point this function returning
@@             that value means that you've once again been re-awoken.
@@@return: -1:EFAULT:    A faulty pointer was given
@@@return: -1:EINVAL:    One of the given commands is invalid, or `exprc' was `0'
@@@return: -1:EINTR:     A blocking futex-wait operation was interrupted
@@@return: -1:ETIMEDOUT: A blocking futex-wait operation has timed out
[restart(dont)][cp]
lfutexlockexpr:(uintptr_t *ulockaddr, void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPR_VECTOR:exprc)] struct lfutexexpr const *exprv,
                [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexlockexpr)] lfutexlockexpr32:(uint32_t *ulockaddr, void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPR_VECTOR:exprc)] struct lfutexexpr const *exprv, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexlockexpr)] lfutexlockexpr64:(uint64_t *ulockaddr, void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPR_VECTOR:exprc)] struct lfutexexpr const *exprv, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexlockexpr)] lfutexlockexprx32:(uint32_t *ulockaddr, void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPRX32_VECTOR:exprc)] struct lfutexexprx32 const *exprv, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexlockexpr)] lfutexlockexprx32_64:(uint32_t *ulockaddr, void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPRX32_VECTOR:exprc)] struct lfutexexprx32 const *exprv, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
[restart(dont)][cp][doc_alias(lfutexlockexpr)] lfutexlockexprx64:(uint64_t *ulockaddr, void *base, size_t exprc, [tostr(STRUCT_LFUTEXEXPRX64_VECTOR:exprc)] struct lfutexexprx64 const *exprv, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t timeout_flags) -> errno_t;
%[endgroup]

@@Create and return a new tty terminal controller connected to the given keyboard and display
@@The newly created device automatically gets assigned an arbitrary device number, before
@@being made available under a file `/dev/${name}' (or rather: as ${name} within the devfs)
@@@param: reserved: Reserved set of flags (Must pass `0'; for future expansion)
mktty:(fd_t keyboard, fd_t display, [tostr(STRING)] char const *name, syscall_ulong_t rsvd) -> fd_t; /* TODO: Make `name' the first argument! */

%[startgroup]
@@Raise a signal within the calling thread alongside the given CPU state
@@This system call is used when translating exceptions into POSIX signal in error mode #4
@@@param: state: The state state at which to raise the signal, or `NULL' if the signal should
@@               be raised for the caller's source location. Note that only in the later case
@@               will this function return to its caller. - When `state' is non-NULL, it will
@@               return to the text location described by it.
[restart(must)] raiseat:([tostr(STRUCT_UCPUSTATE)] struct ucpustate const *state, [tostr(STRUCT_SIGINFO)] struct __siginfo_struct const *si) -> errno_t;
[doc_alias(raiseat)][restart(must)] raiseatx32:([tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *state, [tostr(STRUCT_SIGINFOX32)] struct __siginfox32_struct const *si) -> errno_t;
[doc_alias(raiseat)][restart(must)] raiseatx64:([tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *state, [tostr(STRUCT_SIGINFOX64)] struct __siginfox64_struct const *si) -> errno_t;
%[endgroup]

%[startgroup]
@@Trigger a coredump of the calling process.
@@@param: curr_state:       The state as is still valid after any possible unwinding has already been done
@@                          Note that this state does not necessarily point to the location that originally
@@                          caused the problem that escalated into a coredump, but is the last valid stack-
@@                          unwind location at which unwinding could no longer continue.
@@                          When `NULL', `orig_state' is used instead, and `traceback_vector' and `traceback_length' are ignored.
@@@param: orig_state:       The original CPU state at where the associated `exception' got triggered
@@                          When `NULL', `curr_state' is used instead, and `traceback_vector' and `traceback_length' are ignored.
@@                          When `curr_state' is also `NULL', then the current CPU state is used instead.
@@@param: traceback_vector: (potentially incomplete) vector of additional program pointers that were
@@                          travered when the stack was walked from `orig_state' to `curr_state'
@@                          Note that earlier entires within this vector are further up the call-stack, with
@@                          traceback_vector[0] being meant to be the call-site of the function of `orig_state'.
@@                          Note that when `traceback_length != 0 && traceback_vector[traceback_length-1] == ucpustate_getpc(curr_state)',
@@                          it can be assumed that the traceback is complete and contains all travered instruction locations.
@@                          In this case, a traceback displayed to a human should not include the text location at
@@                          `traceback_vector[traceback_length-1]', since that location would also be printed when
@@                          unwinding is completed for the purposes of displaying a traceback.
@@@param: traceback_length: The number of program counters stored within `traceback_vector'
@@@param: exception:        The exception that resulted in the coredump (or `NULL' to get the same behavior as `E_OK')
@@                          Note that when `unwind_error == UNWIND_SUCCESS', this argument is interpreted as `siginfo_t *',
@@                          allowing coredumps to also be triggerred for unhandled signals.
@@@param: unwind_error:     The unwind error that caused the coredump, or `UNWIND_SUCCESS' if unwinding
@@                          was never actually performed, and `exception' is actually a `siginfo_t *'
[restart(must)]
coredump:([tostr(STRUCT_UCPUSTATE)] struct ucpustate const *curr_state,
          [tostr(STRUCT_UCPUSTATE)] struct ucpustate const *orig_state,
          [tostr(VOID_VECTOR:traceback_length)] void *const *traceback_vector, size_t traceback_length,
          [tostr(STRUCT_EXCEPTION_DATA)] struct exception_data const *exception,
          [tostr(UNWIND_ERROR)] syscall_ulong_t unwind_error) -> errno_t;
[doc_alias(coredump)][restart(must)]
coredumpx32:([tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *curr_state,
             [tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *orig_state,
             [tostr(VOID_VECTOR32:traceback_length)] __HYBRID_PTR32(void) const *traceback_vector, size_t traceback_length,
             [tostr(STRUCT_EXCEPTION_DATA32)] struct exception_data32 const *exception,
             [tostr(UNWIND_ERROR)] syscall_ulong_t unwind_error) -> errno_t;
[doc_alias(coredump)][restart(must)]
coredumpx64:([tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *curr_state,
             [tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *orig_state,
             [tostr(VOID_VECTOR64:traceback_length)] __HYBRID_PTR64(void) const *traceback_vector, size_t traceback_length,
             [tostr(STRUCT_EXCEPTION_DATA64)] struct exception_data64 const *exception,
             [tostr(UNWIND_ERROR)] syscall_ulong_t unwind_error) -> errno_t;
%[endgroup]


%[startgroup]
@@@param: flags: Set of `0 | AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp]
process_spawnveat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
                   [tostr(STRING_VECTOR)] char const *const *argv,
                   [tostr(STRING_VECTOR)] char const *const *envp,
                   [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags,
                   [tostr(STRUCT_SPAWN_ACTIONS)] struct spawn_actions const *actions) -> pid_t;
[doc_alias(process_spawnveat)][cp]
process_spawnveatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
                      [tostr(STRING_VECTOR64)] __HYBRID_PTR32(char const) const *argv,
                      [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *envp,
                      [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags,
                      [tostr(STRUCT_SPAWN_ACTIONSX32)] struct spawn_actionsx32 const *actions) -> errno_t;
[doc_alias(process_spawnveat)][cp]
process_spawnveatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
                      [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *argv,
                      [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *envp,
                      [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags,
                      [tostr(STRUCT_SPAWN_ACTIONSX64)] struct spawn_actionsx64 const *actions) -> errno_t;
%[endgroup]


@@Construct a user-fault-fd object supporting mmap(2), with actual
@@memory accesses being dispatched by adding them as pending requests
@@to an internal queue that should be read(2) from by a worker thread,
@@which should then service those requests before responding by write(2)ing
@@the results of the operation back to the same fd.
@@HINT: The format of the structures that are read(2) and
@@      write(2)en can be found in `<libvio/userviofd.h>'
@@NOTE: Don't use this system call directly. Use `vio_create(3)'
@@      from `<libvio/vio.h>' instead.
@@@param: initial_size: The initial mmap(2)able size of the returned handle.
@@                      This size may be altered at a later point in time
@@                      through use of `ftruncate(return)'
@@@param: flags:        Set of `0 | O_CLOEXEC | O_CLOFORK | O_NONBLOCK'
userviofd:(size_t initial_size, [tostr(OFLAG__CLOEXEC__CLOFORK__NONBLOCK)] syscall_ulong_t flags) -> fd_t;


@@Begin an RTM operation. Note that if the arch-specific RTM driver
@@wasn't already loaded into the kernel, it will be loaded automatically,
@@though any error that may happen during this will result in `RTM_NOSYS'
@@begin returned.
@@Note that while an RTM operation is in progress, only a very small hand
@@full of system calls are allowed to be used. Attempting to use arbitrary
@@system calls, or attempting to access too much system memory in general
@@will result in this function returning with `RTM_ABORT_CAPACITY', rather
@@than succeeding. The following is a list of system calls which are
@@whitelisted for use during a transaction:
@@  - sys_rtm_begin:  Nested RTM operation
@@  - sys_rtm_end:    End an RTM operation
@@  - sys_rtm_abort:  Abort an RTM operation
@@  - sys_rtm_test:   Check if an RTM operation is in progress (always returns `1')
@@Anything else will most likely result in this system call returning `RTM_ABORT_FAILED'
@@@return: RTM_STARTED : RTM operation was started.
@@@return: RTM_NOSYS   : RTM isn't supposed because the associated driver is missing, or cannot be loaded.
@@@return: RTM_ABORT_* : RTM operation failed (s.a. code from `<kos/rtm.h>')
rtm_begin:() -> rtm_status_t;

@@End a transaction
@@If the transaction was successful, return normally (by returning `-EOK').
@@If the transaction failed, `sys_rtm_begin()' returns `RTM_ABORT_*'
@@If no transaction was in progress, an `E_ILLEGAL_OPERATION' exception is thrown
rtm_end:() -> errno_t;

@@Abort the current transaction by having `sys_rtm_begin()' return with
@@`RTM_ABORT_EXPLICIT | ((code << RTM_ABORT_CODE_S) & RTM_ABORT_CODE_M)'
@@If no transaction was in progress, behave as a no-op and return `-EOK'.
@@Otherwise, this system call does not return normally, but returns from
@@the original `sys_rtm_begin()'
rtm_abort:(syscall_ulong_t code) -> errno_t;

@@Check if a transaction is currently in progress
@@@return: 0 : No RTM operation in progress
@@@return: 1 : An RTM operation is currently in progress
rtm_test:() -> syscall_ulong_t;



/* Generic system call numbers */
0:io_setup
1:io_destroy
2:io_submit
3:io_cancel
4:io_getevents
5:setxattr
6:lsetxattr
7:fsetxattr
8:getxattr
9:lgetxattr
10:fgetxattr
11:listxattr
12:llistxattr
13:flistxattr
14:removexattr
15:lremovexattr
16:fremovexattr
17:getcwd
18:lookup_dcookie
19:eventfd2
20:epoll_create1
21:epoll_ctl
22:epoll_pwait
23:dup
24:dup3
//25:__NR3264_fcntl
26:inotify_init1
27:inotify_add_watch
28:inotify_rm_watch
29:ioctl
30:ioprio_set
31:ioprio_get
32:flock
33:mknodat
34:mkdirat
35:unlinkat
36:symlinkat
37:linkat
38:renameat
39:umount2
40:mount
41:pivot_root
42:nfsservctl
//43:__NR3264_statfs
//44:__NR3264_fstatfs
//45:__NR3264_truncate
//46:__NR3264_ftruncate
47:fallocate
48:faccessat
49:chdir
50:fchdir
51:chroot
52:fchmod
53:fchmodat
54:fchownat
55:fchown
56:openat
57:close
58:vhangup
59:pipe2
60:quotactl
61:getdents64
//62:__NR3264_lseek
63:read
64:write
65:readv
66:writev
67:pread64
68:pwrite64
69:preadv
70:pwritev
//71:__NR3264_sendfile
72:pselect6
73:ppoll
74:signalfd4
75:vmsplice
76:splice
77:tee
78:readlinkat
//79:__NR3264_fstatat
//80:__NR3264_fstat
81:sync
82:fsync
83:fdatasync
84:sync_file_range
85:timerfd_create
86:timerfd_settime
87:timerfd_gettime
88:utimensat
89:acct
90:capget
91:capset
92:personality
93:exit
94:exit_group
95:waitid
96:set_tid_address
97:unshare
98:futex
99:set_robust_list
100:get_robust_list
101:nanosleep
102:getitimer
103:setitimer
104:kexec_load
105:init_module
106:delete_module
107:timer_create
108:timer_gettime
109:timer_getoverrun
110:timer_settime
111:timer_delete
112:clock_settime
113:clock_gettime
114:clock_getres
115:clock_nanosleep
116:syslog
117:ptrace
118:sched_setparam
119:sched_setscheduler
120:sched_getscheduler
121:sched_getparam
122:sched_setaffinity
123:sched_getaffinity
124:sched_yield
125:sched_get_priority_max
126:sched_get_priority_min
127:sched_rr_get_interval
128:restart_syscall
129:kill
130:tkill
131:tgkill
132:sigaltstack
133:rt_sigsuspend
134:rt_sigaction
135:rt_sigprocmask
136:rt_sigpending
137:rt_sigtimedwait
138:rt_sigqueueinfo
139:rt_sigreturn
140:setpriority
141:getpriority
142:reboot
143:setregid
144:setgid
145:setreuid
146:setuid
147:setresuid
148:getresuid
149:setresgid
150:getresgid
151:setfsuid
152:setfsgid
153:times
154:setpgid
155:getpgid
156:getsid
157:setsid
158:getgroups
159:setgroups
160:uname
161:sethostname
162:setdomainname
163:getrlimit
164:setrlimit
165:getrusage
166:umask
167:prctl
168:getcpu
169:gettimeofday
170:settimeofday
171:adjtimex
172:getpid
173:getppid
174:getuid
175:geteuid
176:getgid
177:getegid
178:gettid
179:sysinfo
180:mq_open
181:mq_unlink
182:mq_timedsend
183:mq_timedreceive
184:mq_notify
185:mq_getsetattr
186:msgget
187:msgctl
188:msgrcv
189:msgsnd
190:semget
191:semctl
192:semtimedop
193:semop
194:shmget
195:shmctl
196:shmat
197:shmdt
198:socket
199:socketpair
200:bind
201:listen
202:accept
203:connect
204:getsockname
205:getpeername
206:sendto
207:recvfrom
208:setsockopt
209:getsockopt
210:shutdown
211:sendmsg
212:recvmsg
213:readahead
214:brk
215:munmap
216:mremap
217:add_key
218:request_key
219:keyctl
220:clone
221:execve
//222:__NR3264_mmap
//223:__NR3264_fadvise64
224:swapon
225:swapoff
226:mprotect
227:msync
228:mlock
229:munlock
230:mlockall
231:munlockall
232:mincore
233:madvise
234:remap_file_pages
235:mbind
236:get_mempolicy
237:set_mempolicy
238:migrate_pages
239:move_pages
240:rt_tgsigqueueinfo
241:perf_event_open
242:accept4
243:recvmmsg
260:wait4
261:prlimit64
262:fanotify_init
263:fanotify_mark
264:name_to_handle_at
265:open_by_handle_at
266:clock_adjtime
267:syncfs
268:setns
269:sendmmsg
270:process_vm_readv
271:process_vm_writev
272:kcmp
273:finit_module
274:sched_setattr
275:sched_getattr
276:renameat2
277:seccomp
278:getrandom
279:memfd_create
280:bpf
281:execveat
282:userfaultfd
283:membarrier
284:mlock2
1024:open
1025:link
1026:unlink
1027:mknod
1028:chmod
1029:chown
1030:mkdir
1031:rmdir
1032:lchown
1033:access
1034:rename
1035:readlink
1036:symlink
1037:utimes
//1038:__NR3264_stat
//1039:__NR3264_lstat
1040:pipe
1041:dup2
1042:epoll_create
1043:inotify_init
1044:eventfd
1045:signalfd
1046:sendfile
1047:ftruncate
1048:truncate
1049:linux_stat
1050:linux_lstat
1051:linux_fstat
1052:fcntl
1053:fadvise64
1054:linux_newfstatat
1055:fstatfs
1056:statfs
1057:lseek
1058:mmap
1059:alarm
1060:getpgrp
1061:pause
1062:time
1063:utime
1064:creat
1065:getdents
1066:futimesat
1067:select
1068:poll
1069:epoll_wait
1070:ustat
1071:vfork
1072:oldwait4
1073:recv
1074:send
1075:bdflush
1076:umount
1077:uselib
1078:_sysctl
1079:fork
