/* Copyright (c) 2019-2025 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2025 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
/* NOTE: Changes to this file are applied by calling
 *       $ deemon misc/generate_syscalls.dee
 */


/* Define some universally applicable type compatibilities. */
%[typecompat(
	*:void = *:void,
)]
%[typesize(*:[u8,s8,uint8_t,u_int8_t,int8_t,__INT8_TYPE__,__UINT8_TYPE__] = 1)]
%[typesize(*:[u16,s16,uint16_t,u_int16_t,int16_t,__INT16_TYPE__,__UINT16_TYPE__] = 2)]
%[typesize(*:[u32,s32,uint32_t,u_int32_t,int32_t,ulong32_t,long32_t,__INT32_TYPE__,__UINT32_TYPE__,__LONG32_TYPE__,__ULONG32_TYPE__] = 4)]
%[typesize(*:[u64,s64,uint64_t,u_int64_t,int64_t,ulong64_t,long64_t,__INT64_TYPE__,__UINT64_TYPE__,__LONG64_TYPE__,__ULONG64_TYPE__] = 8)]
%[typesize(*:[u128,s128,uint128_t,u_int128_t,int128_t,ulong128_t,long128_t,__INT128_TYPE__,__UINT128_TYPE__,__LONG128_TYPE__,__ULONG128_TYPE__] = 16)]
%[typesize(*:[uid_t] = 4)]
%[typesize(*:[gid_t] = uid_t)]
%[typesize(*:[pid_t] = 4)]

%[typesize(*:[schar,uchar] = char)]
%[typesize(*:[ushort] = short)]
%[typesize(*:[unsigned,signed,uint] = int)]
%[typesize(*:[ulong] = long)]
%[typesize(*:[ullong] = llong)]
%[typesize(*:[errno_t,signo_t,mode_t,oflag_t,fd_t,fcntl_t] = int)]
%[typesize(*:[syscall_ulong_t] = ulong)]
%[typesize(*:[syscall_slong_t] = syscall_ulong_t)]
%[typesize(*:[socklen_t,size_t,ioctl_t] = syscall_ulong_t)]
%[typesize(*:[uintptr_t] = size_t)]
%[typesize(*:[intptr_t] = uintptr_t)]
%[typesize(*:[intptr_half_t] = uintptr_half_t)]
%[typesize(*:[intptr_quarter_t] = uintptr_quarter_t)]
%[typesize(*:[time32_t] = syscall_ulong_t)]
%[typesize(*:[time64_t] = 8)]

/* These types are signed, and when passed to system calls, may need to be sign-extended. */
%[signed_types(schar, short, signed, int, long, llong)]
%[signed_types(s8, int8_t, __INT8_TYPE__)]
%[signed_types(s16, int16_t, __INT16_TYPE__)]
%[signed_types(s32, int32_t, long32_t, __INT32_TYPE__, __LONG32_TYPE__)]
%[signed_types(s64, int64_t, long64_t, __INT64_TYPE__, __LONG64_TYPE__)]
%[signed_types(s128, int128_t, long128_t, __INT128_TYPE__, __LONG128_TYPE__)]
%[signed_types(syscall_slong_t, intptr_t, intptr_half_t, intptr_quarter_t)]
%[signed_types(time32_t, time64_t, ssize_t)]
%[signed_types(errno_t, signo_t, oflag_t, fd_t)]

/* Define which headers to include to get the definitions for specific types */
%[typeorg(<hybrid/typecore.h>: __UINT8_TYPE__, __INT8_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINT16_TYPE__, __INT16_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINT32_TYPE__, __INT32_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINT64_TYPE__, __INT64_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __SIZE_TYPE__, __PTRDIFF_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __UINTPTR_TYPE__, __INTPTR_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __ULONGPTR_TYPE__, __LONGPTR_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __ULONG32_TYPE__, __ULONG64_TYPE__)]
%[typeorg(<hybrid/typecore.h>: __LONG32_TYPE__, __LONG64_TYPE__)]

%[typeorg(<bits/types.h>: __u_char, __u_short, __u_int, __u_long)]
%[typeorg(<bits/types.h>: __u8, __u16, __u32, __u64)]
%[typeorg(<bits/types.h>: __s8, __s16, __s32, __s64)]
%[typeorg(<bits/types.h>: __uint8_t, __uint16_t, __uint32_t, __uint64_t)]
%[typeorg(<bits/types.h>: __int8_t, __int16_t, __int32_t, __int64_t)]
%[typeorg(<bits/types.h>: __intptr_t, __uintptr_t)]
%[typeorg(<bits/types.h>: __quad_t, __u_quad_t)]
%[typeorg(<bits/types.h>: __ptrdiff_t, __size_t, __ssize_t)]
%[typeorg(<bits/types.h>: __byte_t, __register_t, __sregister_t)]
%[typeorg(<bits/types.h>: __syscall_slong_t, __syscall_ulong_t)]
%[typeorg(<bits/types.h>: __oflag_t, __mode_t, __atflag_t, __iomode_t, __fd_t, __ufd_t)]
%[typeorg(<bits/types.h>: __major_t, __minor_t, __dev_t, __id_t, __pid_t, __upid_t)]
%[typeorg(<bits/types.h>: __key_t, __daddr_t, __caddr_t, __qaddr_t)]
%[typeorg(<bits/types.h>: __off32_t, __off64_t, __blkcnt32_t, __blkcnt64_t)]
%[typeorg(<bits/types.h>: __fsblkcnt32_t, __fsblkcnt64_t)]
%[typeorg(<bits/types.h>: __fsfilcnt32_t, __fsfilcnt64_t)]
%[typeorg(<bits/types.h>: __ino32_t, __ino64_t, __pos32_t, __pos64_t)]
%[typeorg(<bits/types.h>: __loff_t, __lpos_t, __fsword_t)]
%[typeorg(<bits/types.h>: __socklen_t, __ssocklen_t, __rlim32_t, __rlim64_t)]
%[typeorg(<bits/types.h>: __blksize_t, __nlink_t, __fsid_t)]
%[typeorg(<bits/types.h>: __time32_t, __time64_t)]
%[typeorg(<bits/types.h>: __quantum_diff_t, __clock_t, __suseconds_t, __clockid_t)]
%[typeorg(<bits/types.h>: __gid_t, __uid_t, __useconds_t, __timer_t)]
%[typeorg(<bits/os/itimerspec.h>: itimerspec, itimerspec32, itimerspec64, __itimerspec32, __itimerspec64)]
%[typeorg(<bits/os/generic/itimerspec32.h>: __itimerspecx32, __itimerspecx32_64, itimerspecx32, itimerspecx32_64)]
%[typeorg(<bits/os/generic/itimerspec64.h>: __itimerspecx64, itimerspecx64)]
%[typeorg(<bits/os/itimerval.h>: itimerval, itimerval32, itimerval64, __itimerval32, __itimerval64)]
%[typeorg(<bits/os/generic/itimerval32.h>: __itimervalx32, __itimervalx32_64, itimervalx32, itimervalx32_64)]
%[typeorg(<bits/os/generic/itimerval64.h>: __itimervalx64, itimervalx64)]
%[typeorg(<bits/os/timespec.h>: timespec, timespec32, timespec64, __timespec32, __timespec64)]
%[typeorg(<bits/os/generic/timespec32.h>: __timespecx32, __timespecx32_64, timespecx32, timespecx32_64)]
%[typeorg(<bits/os/generic/timespec64.h>: __timespecx64, timespecx64)]
%[typeorg(<bits/os/timeval.h>: timeval, timeval32, timeval64, __timeval32, __timeval64)]
%[typeorg(<bits/os/generic/timeval32.h>: __timevalx32, __timevalx32_64, timevalx32, timevalx32_64)]
%[typeorg(<bits/os/generic/timeval64.h>: __timevalx64, timevalx64)]
%[typeorg(<bits/os/timeb.h>: timeb, timeb32, timeb64, __timeb32, __timeb64)]
%[typeorg(<bits/os/kos/timeb32.h>: __timebx32, __timebx32_64, timebx32, timebx32_64)]
%[typeorg(<bits/os/kos/timeb64.h>: __timebx64, timebx64)]
%[typeorg(<bits/os/utimbuf.h>: utimbuf, utimbuf32, utimbuf64, __utimbuf32, __utimbuf64)]
%[typeorg(<bits/os/kos/utimbuf32.h>: __utimbufx32, __utimbufx32_64, utimbufx32, utimbufx32_64)]
%[typeorg(<bits/os/kos/utimbuf64.h>: __utimbufx64, utimbufx64)]
%[typeorg(<bits/os/rusage.h>: rusage, __rusage32, __rusage64)]
%[typeorg(<bits/os/kos/rusage32.h>: rusagex32, __rusagex32, rusagex32_64, __rusagex32_64)]
%[typeorg(<bits/os/kos/rusage64.h>: rusagex64, __rusagex64)]
%[typeorg(<bits/os/rlimit.h>: rlimit, __rlimit32, __rlimit64)]
%[typeorg(<bits/os/kos/rlimit32.h>: rlimitx32, __rlimitx32, rlimitx32_64, __rlimitx32_64)]
%[typeorg(<bits/os/kos/rlimit64.h>: rlimitx64, __rlimitx64)]
%[typeorg(<bits/os/kos/stat.h>: __kos_stat)]
%[typeorg(<bits/os/statfs.h>: statfs, statfs32, statfs64, __statfs32, __statfs64)]
%[typeorg(<bits/os/kos/statfs32.h>: statfsx32, __statfsx32, statfsx32_64, __statfsx32_64)]
%[typeorg(<bits/os/kos/statfs64.h>: statfsx64, __statfsx64)]
%[typeorg(<bits/os/sigaction.h>: sigaction, __kernel_sigaction, __old_kernel_sigaction, __sigaction_sa_handler_t, __sighandler_t)]
%[typeorg(<bits/os/kos/sigaction32.h>: __sigactionx32, __kernel_sigactionx32, __old_kernel_sigactionx32, __sigactionx32_sa_handler_t)]
%[typeorg(<bits/os/kos/sigaction64.h>: __sigactionx64, __kernel_sigactionx64, __old_kernel_sigactionx64, __sigactionx64_sa_handler_t)]
%[typeorg(<bits/os/siginfo.h>: __siginfo_struct, siginfo_t)]
%[typeorg(<bits/os/kos/siginfo32.h>: __siginfox32_struct, siginfox32_t)]
%[typeorg(<bits/os/kos/siginfo64.h>: __siginfox64_struct, siginfox64_t)]
%[typeorg(<hybrid/__pointer.h>: __HYBRID_PTR32, __HYBRID_PTR64)]
%[typeorg(<bits/os/iovec.h>: iovec)]
%[typeorg(<bits/os/generic/iovec32.h>: iovecx32, __iovecx32)]
%[typeorg(<bits/os/generic/iovec64.h>: iovecx64, __iovecx64)]
%[typeorg(<bits/os/msghdr.h>: msghdr)]
%[typeorg(<bits/os/kos/msghdr32.h>: msghdrx32, __msghdrx32)]
%[typeorg(<bits/os/kos/msghdr64.h>: msghdrx64, __msghdrx64)]
%[typeorg(<bits/os/cmsghdr.h>: cmsghdr)]
%[typeorg(<bits/os/kos/cmsghdr.h>: cmsghdrx32, __cmsghdrx32)]
%[typeorg(<bits/os/kos/cmsghdr.h>: cmsghdrx64, __cmsghdrx64)]
%[typeorg(<bits/os/mmsghdr.h>: mmsghdr)]
%[typeorg(<bits/os/kos/mmsghdr32.h>: mmsghdrx32, __mmsghdrx32)]
%[typeorg(<bits/os/kos/mmsghdr64.h>: mmsghdrx64, __mmsghdrx64)]
%[typeorg(<bits/os/sigstack.h>: sigstack, sigaltstack)]
%[typeorg(<bits/os/kos/sigstack32.h>: __sigstackx32, __sigaltstackx32)]
%[typeorg(<bits/os/kos/sigstack64.h>: __sigstackx64, __sigaltstackx64)]
%[typeorg(<bits/os/pollfd.h>: pollfd)]
%[typeorg(<bits/os/sigval.h>: sigval)]
%[typeorg(<bits/os/kos/sigval32.h>: __sigvalx32)]
%[typeorg(<bits/os/kos/sigval64.h>: __sigvalx64)]
%[typeorg(<bits/os/tms.h>: tms)]
%[typeorg(<bits/os/kos/tms32.h>: __tmsx32)]
%[typeorg(<bits/os/kos/tms64.h>: __tmsx64)]
%[typeorg(<kos/bits/rtm.h>: __rtm_status_t)]
%[typeorg(<kos/rtm.h>: rtm_status_t)]
%[typeorg(<kos/compat/linux-stat.h>: linux_oldstat)]
%[typeorg(<kos/compat/linux-stat.h>: linux_stat, linux_stat32, linux_stat64)]
%[typeorg(<kos/compat/linux-stat.h>: linux_statx32, linux_statx64, linux_statx32_64)]
%[typeorg(<bits/os/sigevent.h>: sigevent)]
%[typeorg(<bits/os/sysinfo.h>: sysinfo)]
%[typeorg(<bits/os/kos/sysinfo32.h>: sysinfox32, __sysinfox32)]
%[typeorg(<bits/os/kos/sysinfo64.h>: sysinfox64, __sysinfox64)]
%[typeorg(<asm/os/sched.h>: clone_args)]
%[typeorg(<bits/os/sigset_with_size.h>: sigset_with_size)]
%[typeorg(<bits/os/generic/sigset_with_size32.h>: __sigset_with_sizex32)]
%[typeorg(<bits/os/generic/sigset_with_size64.h>: __sigset_with_sizex64)]
%[typeorg(<libunwind/errno.h>: unwind_errno_t)]

/* Define how specific struct names should be escaped in headers */
%[struct_escape(iovecx32 = __iovecx32, iovecx64 = __iovecx64)]
%[struct_escape(msghdrx32 = __msghdrx32, msghdrx64 = __msghdrx64)]
%[struct_escape(cmsghdrx32 = __cmsghdrx32, cmsghdrx64 = __cmsghdrx64)]
%[struct_escape(mmsghdrx32 = __mmsghdrx32, mmsghdrx64 = __mmsghdrx64)]
%[struct_escape(timespec32 = __timespec32, timespecx32 = __timespecx32, timespecx32_64 = __timespecx32_64)]
%[struct_escape(timespec64 = __timespec64, timespecx64 = __timespecx64)]
%[struct_escape(timeval32 = __timeval32, timevalx32 = __timevalx32, timevalx32_64 = __timevalx32_64)]
%[struct_escape(timeval64 = __timeval64, timevalx64 = __timevalx64)]
%[struct_escape(itimerval32 = __itimerval32, itimervalx32 = __itimervalx32, itimervalx32_64 = __itimervalx32_64)]
%[struct_escape(itimerval64 = __itimerval64, itimervalx64 = __itimervalx64)]
%[struct_escape(itimerspec32 = __itimerspec32, itimerspecx32 = __itimerspecx32, itimerspecx32_64 = __itimerspecx32_64)]
%[struct_escape(itimerspec64 = __itimerspec64, itimerspecx64 = __itimerspecx64)]
%[struct_escape(rusage32 = __rusage32, rusagex32 = __rusagex32, rusagex32_64 = __rusagex32_64)]
%[struct_escape(rusage64 = __rusage64, rusagex64 = __rusagex64)]
%[struct_escape(rlimit32 = __rlimit32, rlimitx32 = __rlimitx32, rlimitx32_64 = __rlimitx32_64)]
%[struct_escape(rlimit64 = __rlimit64, rlimitx64 = __rlimitx64)]
%[struct_escape(timeb32 = __timeb32, timebx32 = __timebx32, timebx32_64 = __timebx32_64)]
%[struct_escape(timeb64 = __timeb64, timebx64 = __timebx64)]
%[struct_escape(tmsx32 = __tmsx32, tmsx64 = __tmsx64)]
%[struct_escape(utimbuf32 = __utimbuf32, utimbufx32 = __utimbufx32, utimbufx32_64 = __utimbufx32_64)]
%[struct_escape(utimbuf64 = __utimbuf64, utimbufx64 = __utimbufx64)]
%[struct_escape(statfs32 = __statfs32, statfsx32 = __statfsx32, statfsx32_64 = __statfsx32_64)]
%[struct_escape(statfs64 = __statfs64, statfsx64 = __statfsx64)]

%[typeorg(<kos/bits/syscall-info.h>: rpc_syscall_info)]
%[typeorg(<kos/bits/syscall-info32.h>: rpc_syscall_info32)]
%[typeorg(<kos/bits/syscall-info64.h>: rpc_syscall_info64)]
%[typeorg(<kos/bits/except-handler.h>: __except_handler_t)]
%[typeorg(<kos/bits/except-handler32.h>: __except_handler32_t)]
%[typeorg(<kos/bits/except-handler64.h>: __except_handler64_t)]
%[typeorg(<kos/bits/debugtrap.h>: debugtrap_reason)]
%[typeorg(<kos/bits/debugtrap32.h>: debugtrap_reason32)]
%[typeorg(<kos/bits/debugtrap64.h>: debugtrap_reason64)]
%[typeorg(<kos/bits/exception_data.h>: exception_data)]
%[typeorg(<kos/bits/exception_data32.h>: __exception_data32)]
%[typeorg(<kos/bits/exception_data64.h>: __exception_data64)]
%[typeorg(<kos/bits/coredump.h>: coredump_info, coredump_assert)]
%[typeorg(<kos/bits/coredump32.h>: coredump_info32, coredump_assert32)]
%[typeorg(<kos/bits/coredump64.h>: coredump_info64, coredump_assert64)]
%[typeorg(<kos/exec/bits/peb.h>: process_peb)]
%[typeorg(<kos/exec/bits/peb32.h>: process_peb32)]
%[typeorg(<kos/exec/bits/peb64.h>: process_peb64)]
%[typeorg(<kos/exec/elf.h>: elfexec_info)]
%[typeorg(<kos/exec/asm/elf32.h>: elfexec_info32)]
%[typeorg(<kos/exec/asm/elf64.h>: elfexec_info64)]
%[typeorg(<kos/bits/ukern-struct.h>: userkern)]
%[typeorg(<kos/bits/ukern-struct32.h>: userkern32)]
%[typeorg(<kos/bits/ukern-struct64.h>: userkern64)]
%[typeorg(<kos/kernel/cpu-state.h>: ucpustate, lcpustate, kcpustate, icpustate, scpustate, fcpustate)]
%[typeorg(<kos/kernel/bits/cpu-state32.h>: ucpustate32, lcpustate32, kcpustate32, icpustate32, scpustate32, fcpustate32)]
%[typeorg(<kos/kernel/bits/cpu-state64.h>: ucpustate64, lcpustate64, kcpustate64, icpustate64, scpustate64, fcpustate64)]
%[typeorg(<kos/kernel/bits/fpu-sstate.h>: sfpuenv, sfpustate)]
%[typeorg(<kos/kernel/fpu-state.h>: xfpustate, fpustate)]
%[typeorg(<kos/kernel/bits/fpu-state32.h>: xfpustate32, fpustate32)]
%[typeorg(<kos/kernel/bits/fpu-state64.h>: xfpustate64, fpustate64)]
%[typeorg(<kos/kernel/gdb-cpu-state.h>: gdb_cpustate)]
%[typeorg(<kos/kernel/bits/gdb-cpu-state32.h>: gdb_cpustate32)]
%[typeorg(<kos/kernel/bits/gdb-cpu-state64.h>: gdb_cpustate64)]
%[typeorg(<kos/kernel/x86/segment.h>: segment, idt_segment)]
%[typeorg(<kos/bits/userprocmask.h>: userprocmask)]
%[typeorg(<bits/os/mcontext.h>: gregset_t, fpregset_t, mcontext)]
%[typeorg(<bits/os/kos/mcontext32.h>: __gregsetx32_t, __fpregsetx32_t, __mcontextx32)]
%[typeorg(<bits/os/kos/mcontext64.h>: __gregsetx64_t, __fpregsetx64_t, __mcontextx64)]
%[typeorg(<bits/os/ucontext.h>: ucontext)]
%[typeorg(<bits/os/kos/ucontext32.h>: __ucontextx32)]
%[typeorg(<bits/os/kos/ucontext64.h>: __ucontextx64)]
%[typeorg(<kos/bits/futex-expr.h>: lfutexexpr)]
%[typeorg(<kos/bits/futex-expr32.h>: lfutexexprx32)]
%[typeorg(<kos/bits/futex-expr64.h>: lfutexexprx64)]
%[typeorg(<bits/os/mqueue.h>: __mqd_t, mq_attr)]
%[typeorg(<elf.h>: elf32_phdr, elf64_phdr)]
%[typeorg(<kos/compat/linux-oldselect.h>: sel_arg_struct, sel_arg_structx32, sel_arg_structx64)]
%[typeorg(<kos/compat/linux-olddirent.h>: old_linux_dirent, old_linux_direntx32, old_linux_direntx64)]
%[typeorg(<kos/compat/linux-dirent.h>: linux_dirent, linux_direntx32, linux_direntx64)]
%[typeorg(<kos/compat/linux-dirent64.h>: linux_dirent64)]
%[typeorg(<bits/os/timex.h>: timex)]

%[typecompat(*:linux_dirent64 = *:linux_dirent64)]
%[typecompat(*:clone_args = *:clone_args)]

/* Certain keywords which -- if they appear in system call
 * declarations  -- must be #undef'd before being written.
 *
 * The  reason for this is that these keywords may be defined
 * as macros in other system headers, so we need to wrap  our
 * stuff with #pragma push_macro()+#undef+#pragma pop_maco(). */
%[mustundef(timezone, timeb, stat, dirent)]


/* Define default rules on how libsctrace should represent argument types. */
%[define_tostr(char               = CHAR)]
%[define_tostr(signed char        = SIGNED_CHAR)]
%[define_tostr(unsigned char      = UNSIGNED_CHAR)]
%[define_tostr(short              = SHORT)]
%[define_tostr(signed short       = SHORT)]
%[define_tostr(unsigned short     = UNSIGNED_SHORT)]
%[define_tostr(int                = INT)]
%[define_tostr(signed             = INT)]
%[define_tostr(signed int         = INT)]
%[define_tostr(unsigned           = UNSIGNED_INT)]
%[define_tostr(unsigned int       = UNSIGNED_INT)]
%[define_tostr(long               = LONG)]
%[define_tostr(signed long        = LONG)]
%[define_tostr(unsigned long      = UNSIGNED_LONG)]
%[define_tostr(long long          = LONG_LONG)]
%[define_tostr(signed long long   = LONG_LONG)]
%[define_tostr(unsigned long long = UNSIGNED_LONG_LONG)]

%[define_tostr(char const *         = STRING)]
%[define_tostr(timer_t              = TIMER_T)]
%[define_tostr(__sighandler_t              = SIGHANDLER_T)]
%[define_tostr(__sigaction_sa_handler_t    = SIGHANDLER_T)]
%[define_tostr(__sigactionx32_sa_handler_t = SIGHANDLER_T)]
%[define_tostr(__sigactionx64_sa_handler_t = SIGHANDLER_T)]
%[define_tostr(except_handler_t     = EXCEPT_HANDLER_T)]
%[define_tostr(__except_handler32_t = EXCEPT_HANDLER_T)]
%[define_tostr(__except_handler64_t = EXCEPT_HANDLER_T)]
%[define_tostr(intptr_t             = INTPTR_T)]
%[define_tostr(uintptr_t            = UINTPTR_T)]
%[define_tostr(ssize_t              = SSIZE_T)]
%[define_tostr(ptrdiff_t            = PTRDIFF_T)]
%[define_tostr(size_t               = SIZE_T)]
%[define_tostr(int8_t               = INT8_T)]
%[define_tostr(uint8_t              = UINT8_T)]
%[define_tostr(int16_t              = INT16_T)]
%[define_tostr(uint16_t             = UINT16_T)]
%[define_tostr(int32_t              = INT32_T)]
%[define_tostr(uint32_t             = UINT32_T)]
%[define_tostr(int64_t              = INT64_T)]
%[define_tostr(uint64_t             = UINT64_T)]
%[define_tostr(id_t                 = ID_T)]
%[define_tostr(syscall_slong_t      = SYSCALL_SLONG_T)]
%[define_tostr(syscall_ulong_t      = SYSCALL_ULONG_T)]
%[define_tostr(clockid_t            = CLOCKID_T)]
%[define_tostr(pid_t                = PID_T)]
%[define_tostr(gid_t                = GID_T)]
%[define_tostr(uid_t                = UID_T)]
%[define_tostr(fd_t                 = FD_T)]
%[define_tostr(errno_t              = ERRNO_T)]
%[define_tostr(signo_t              = SIGNO_T)]
%[define_tostr(iomode_t             = IOMODE_T)]
%[define_tostr(atflag_t             = ATFLAG_T)]
%[define_tostr(oflag_t              = OFLAG_T)]
%[define_tostr(mode_t               = MODE_T)]
%[define_tostr(socklen_t            = SOCKLEN_T)]
%[define_tostr(dev_t                = DEV_T)]
%[define_tostr(time_t               = TIME_T)]
%[define_tostr(time32_t             = TIME_T)]
%[define_tostr(time64_t             = TIME_T)]
%[define_tostr(unwind_errno_t       = UNWIND_ERRNO_T)]





/* Syscalls not even implemented by linux */
break:() -> errno_t;
restart_syscall:() -> errno_t;
stty:() -> errno_t;
gtty:() -> errno_t;
prof:() -> errno_t;
lock:() -> errno_t;
mpx:() -> errno_t;
ulimit:() -> errno_t;
idle:() -> errno_t;
/*[cp]*/ getpmsg:() -> errno_t;
/*[cp]*/ putpmsg:() -> errno_t;
afs_syscall:() -> errno_t;
profil:() -> errno_t;
/*profil:(uint16_t *sample_buffer, size_t size, size_t offset, syscall_ulong_t scale) -> errno_t;*/
tuxcall:() -> errno_t;         /* Used-to-be implemented by linux, but no longer is. */
query_module:() -> errno_t;    /* Used-to-be implemented by linux, but no longer is. */
create_module:() -> errno_t;   /* Used-to-be implemented by linux, but no longer is. */
get_kernel_syms:() -> errno_t; /* Used-to-be implemented by linux, but no longer is. */
security:() -> errno_t;
vserver:() -> errno_t;





/************************************************************************/
/* EXIT                                                                 */
/************************************************************************/
@@Terminate the calling thread (_NOT_ process!)
@@@param: exit_code: Thread exit code (as returned by `wait(2)')
[restart(must)][noreturn]
exit:([tostr(EXIT_STATUS)] syscall_ulong_t exit_code);

@@Terminate the calling process
@@@param: exit_code: Thread exit code (as returned by `wait(2)')
[restart(must)][noreturn]
exit_group:([tostr(EXIT_STATUS)] syscall_ulong_t exit_code);





/************************************************************************/
/* Fork                                                                 */
/************************************************************************/
@@Clone the calling thread into a second process and return twice, once
@@in  the parent process where this function returns the (non-zero) PID
@@of  the forked child process, and a  second time in the child process
@@itself, where ZERO(0) is returned.
@@The child then usually proceeds by calling `exec(2)' to replace its
@@application image with  that of another  program that the  original
@@parent can then `wait(2)' for. (s.a. `vfork(2)')
@@@return: 0 : You're the new process that was created
@@@return: * : The `return' value is the pid of your new child process
[restart(must)] fork:() -> pid_t;

@@Same as `fork(2)', but the child process may be executed within in the same VM
@@as the parent process, with the  parent process remaining suspended until  the
@@child process invokes one of the following system calls:
@@  - `exit(2)'       Terminate the child process
@@  - `exit_group(2)' Terminate the child process
@@  - `execve(2)'     Create a new VM that is populated with the specified process
@@                    image. The parent process will  only be resumed in case  the
@@                    new  program image could  be loaded successfully. Otherwise,
@@                    the call  to  `execve(2)'  returns normally  in  the  child.
@@                    Other functions from the exec()-family behave the same
@@
@@Care  must be taken when using this system call, since you have to make sure that
@@the  child process doesn't clobber any part of its (shared) stack that may be re-
@@used once execution resumes in  the parent process. The  same also goes for  heap
@@functions,  but generally speaking:  you really shouldn't  do anything that isn't
@@reentrant after calling any one of the fork() functions (since anything but would
@@rely on underlying implementations making proper use of pthread_atfork(3),  which
@@is something that KOS intentionally doesn't do,  since I feel like doing so  only
@@adds unnecessary bloat to code that doesn't rely on this)
@@
@@Additionally, this system call may be implemented as an alias for `fork(2)', in
@@which  case the parent process will not  actually get suspended until the child
@@process performs any of the actions above.
[restart(must)] vfork:() -> pid_t;

clone:([tostr(CLONE_FLAGS)] syscall_ulong_t flags, void *child_stack, [tostr(out:PID_T)] pid_t *ptid,
       [tostr(POINTER)] uintptr_t newtls, [tostr(out:PID_T)] pid_t *ctid) -> pid_t;

clone3:([tostr(STRUCT_CLONE_ARGS:size)] struct clone_args *cl_args, size_t size) -> syscall_slong_t;

@@param: what: Set of `CLONE_*'
unshare:([tostr(CLONE_FLAGS_UNSHARE)] syscall_ulong_t what) -> errno_t;
setns:(fd_t fd, [tostr(CLONE_FLAGS_SETNS)] syscall_ulong_t nstype) -> errno_t; /* UNIMPLEMENTED! */





/************************************************************************/
/* Exec                                                                 */
/************************************************************************/
%[startgroup]
@@Replace the calling  process with  the application  image referred  to by  `path' /  `file'
@@and execute it's `main()' method, passing the given `argv', and setting `environ' to `envp'
[cp][restart(must)]
execve:([tostr(FILENAME)] char const *path,
        [tostr(STRING_VECTOR)] char const *const *argv,
        [tostr(STRING_VECTOR)] char const *const *envp) -> errno_t;
[cp][restart(must)][doc_alias(execve)]
execvex32:(char const *path,
           [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *argv,
           [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *envp) -> errno_t;
[cp][restart(must)][doc_alias(execve)]
execvex64:(char const *path,
           [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *argv,
           [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *envp) -> errno_t;
%[endgroup]

%[startgroup]
@@Replace the calling  process with  the application  image referred  to by  `path' /  `file'
@@and execute it's `main()' method, passing the given `argv', and setting `environ' to `envp'
@@@param: flags: Set of `0 | AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp][restart(must)] execveat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
               [tostr(STRING_VECTOR)] char const *const *argv,
               [tostr(STRING_VECTOR)] char const *const *envp,
               [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp][restart(must)][doc_alias(execveat)]
execveatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
             [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *argv,
             [tostr(STRING_VECTOR32)] __HYBRID_PTR32(char const) const *envp,
             [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp][restart(must)][doc_alias(execveat)]
execveatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname,
             [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *argv,
             [tostr(STRING_VECTOR64)] __HYBRID_PTR64(char const) const *envp,
             [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
%[endgroup]





/************************************************************************/
/* Read/Write                                                           */
/************************************************************************/
@@Read up to `bufsize' bytes from `fd' into `buf'
@@When  `fd' has the `O_NONBLOCK' flag set, only read as much data as was
@@available at the time the call was made, and throw `E_WOULDBLOCK' if no
@@data was available at the time.
@@@return: <= bufsize: The actual amount of read bytes
@@@return: 0         : EOF
[cp] read:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize) -> ssize_t;
[cp][doc_alias(read)] readf:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize, iomode_t mode) -> ssize_t;

@@Write up to `bufsize' bytes from `buf' into `fd'
@@When `fd' has the `O_NONBLOCK' flag set, only write as much data as
@@possible at the time the call was made, and throw `E_WOULDBLOCK' if
@@no data could be written at the time.
@@@return: <= bufsize: The actual amount of written bytes
@@@return: 0         : No more data can be written
[cp] write:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize) -> ssize_t;
[cp][doc_alias(write)] writef:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize, iomode_t mode) -> ssize_t;

%[startgroup]
[cp] lseek:(fd_t fd, syscall_slong_t offset, [tostr(SEEK_WHENCE)] syscall_ulong_t whence) -> syscall_slong_t;
[cp] lseek64:(fd_t fd, [reg64] int64_t offset, [tostr(SEEK_WHENCE)] syscall_ulong_t whence) -> [reg64] int64_t;
%[endgroup]
[cp] _llseek:(fd_t fd, [reg64] int64_t offset, [tostr(out:UINT64_T)] uint64_t *result, [tostr(SEEK_WHENCE)] syscall_ulong_t whence) -> errno_t;

%[startgroup]
@@Same as `read(2)', but rather than specifying a single, continuous buffer,
@@read  data into `count'  separate buffers, though  still return the actual
@@number of read bytes.
@@When `fd' has the `O_NONBLOCK' flag set, only read as much data as was
@@available at  the time  the call  was made,  and throw  `E_WOULDBLOCK'
@@no data was available at the time.
@@@return: <= SUM(iov[*].iov_len): The actual amount of read bytes
@@@return: 0                     : EOF
[cp] readv:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count) -> ssize_t;
[cp][doc_alias(readv)] readvx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count) -> ssize_t;
[cp][doc_alias(readv)] readvx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count) -> ssize_t;
%[endgroup]

%[startgroup]
[cp][doc_alias(readv)] readvf:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp][doc_alias(readv)] readvfx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp][doc_alias(readv)] readvfx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count, iomode_t mode) -> ssize_t;
%[endgroup]

[cp] pread64:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize, [reg64] uint64_t offset) -> ssize_t;
[cp] pread64f:(fd_t fd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp] pwrite64:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize, [reg64] uint64_t offset) -> ssize_t;
[cp] pwrite64f:(fd_t fd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;

%[startgroup]
@@Same as  `readv(2)', but  read data  from a  file at  a
@@specific `offset', rather than the current R/W position
@@@return: <= SUM(iov[*].iov_len): The actual amount of read bytes
[cp] preadv:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp][doc_alias(preadv)] preadvx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp][doc_alias(preadv)] preadvx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp][doc_alias(preadv)] preadvf:(fd_t fd, [tostr(STRUCT_IOVEC:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp][doc_alias(preadv)] preadvfx32:(fd_t fd, [tostr(STRUCT_IOVECX32:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp][doc_alias(preadv)] preadvfx64:(fd_t fd, [tostr(STRUCT_IOVECX64:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
%[endgroup]

%[startgroup]
@@Same as  `writev(2)', but  write data  to a  file at  a
@@specific `offset', rather than the current R/W position
@@@return: <= SUM(iov[*].iov_len): The actual amount of written bytes
[cp] pwritev:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp][doc_alias(pwritev)] pwritevx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp][doc_alias(pwritev)] pwritevx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset) -> ssize_t;
[cp][doc_alias(pwritev)] pwritevf:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp][doc_alias(pwritev)] pwritevfx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
[cp][doc_alias(pwritev)] pwritevfx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count, [reg64] uint64_t offset, iomode_t mode) -> ssize_t;
%[endgroup]

%[startgroup]
@@Same as `write(2)', but rather than specifying a single, continuous buffer,
@@write  data from `count'  separate buffers, though  still return the actual
@@number of written bytes.
@@When  `fd' has the  `O_NONBLOCK' flag set, only  write as much data
@@as possible at the time the call was made, and throw `E_WOULDBLOCK'
@@if no data could be written at the time.
@@@return: <= SUM(iov[*].iov_len): The actual amount of written bytes
@@@return: 0                     : No more data can be written
[cp] writev:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count) -> ssize_t;
[cp][doc_alias(writev)] writevx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count) -> ssize_t;
[cp][doc_alias(writev)] writevx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count) -> ssize_t;
%[endgroup]

%[startgroup]
[cp][doc_alias(writev)] writevf:(fd_t fd, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp][doc_alias(writev)] writevfx32:(fd_t fd, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iovec, size_t count, iomode_t mode) -> ssize_t;
[cp][doc_alias(writev)] writevfx64:(fd_t fd, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iovec, size_t count, iomode_t mode) -> ssize_t;
%[endgroup]

%[startgroup]
@@Read up to `num_bytes' from `infd', and write that data to `outfd'
@@Files must be opened with the relevant access permissions (same as
@@would be enforced by `read(2)' and `write(2)')
@@When `pin_offset != NULL', the pointed-to location is used to track
@@the read-position in `infd'. Note that in the event that writing to
@@this address faults, data may  have still been written to  `outfd',
@@so be sure to have this point to writable memory.
@@@param: outfd:      Output file descriptor
@@@param: infd:       Input file descriptor
@@@param: pin_offset: If non-NULL, position from which to start reading,
@@                    and updated to reflect  how much could be  copied.
@@@param: num_bytes:  The max number of bytes to transfer
@@@return: * :        The actual number of bytes transferred
[cp][restart(dont)] sendfile:(fd_t outfd, fd_t infd, syscall_ulong_t *pin_offset, size_t num_bytes) -> ssize_t;
[cp][restart(dont)][doc_alias(sendfile)] sendfile32:(fd_t outfd, fd_t infd, __ULONG32_TYPE__ *pin_offset, size_t num_bytes) -> ssize_t;
[cp][restart(dont)][doc_alias(sendfile)] sendfile64:(fd_t outfd, fd_t infd, __ULONG64_TYPE__ *pin_offset, size_t num_bytes) -> ssize_t;
%[endgroup]

@@@param: flags: Set of `SPLICE_F_MOVE | SPLICE_F_NONBLOCK | SPLICE_F_MORE | SPLICE_F_GIFT'
[cp] tee:(fd_t fdin, fd_t fdout, size_t length,
          [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */

@@@param: flags: Set of `SPLICE_F_MOVE | SPLICE_F_NONBLOCK | SPLICE_F_MORE | SPLICE_F_GIFT'
[cp] splice:(fd_t fdin, uint64_t *offin, fd_t fdout, uint64_t *offout,
             size_t length, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */

%[startgroup]
@@@param: flags: Set of `SPLICE_F_MOVE | SPLICE_F_NONBLOCK | SPLICE_F_MORE | SPLICE_F_GIFT'
[cp] vmsplice:(fd_t fdout, [tostr(STRUCT_IOVEC_C:count)] struct iovec const *iov, size_t count, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t;                               /* UNIMPLEMENTED! */
[cp][doc_alias(vmsplice)] vmsplicex32:(fd_t fdout, [tostr(STRUCT_IOVECX32_C:count)] struct iovecx32 const *iov, size_t count, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
[cp][doc_alias(vmsplice)] vmsplicex64:(fd_t fdout, [tostr(STRUCT_IOVECX64_C:count)] struct iovecx64 const *iov, size_t count, [tostr(SPLICE_FLAGS)] syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
@@Read exactly one directory entry from `fd'
@@Note that the linux version of this system call has one additional argument `count'.
@@However, within the  linux kernel implementation,  that argument is  unconditionally
@@ignored,  and the system call will _always_ read exactly 1 directory entry from `fd'
@@@return: 1 : Read on directory entry
@@@return: 0 : End-of-directory
[cp] readdir:(fd_t fd, [tostr(out:STRUCT_OLD_LINUX_DIRENT)] struct old_linux_dirent *buf) -> syscall_slong_t;
[cp][doc_alias(readdir)] readdirx32:(fd_t fd, [tostr(out:STRUCT_OLD_LINUX_DIRENTX32)] struct old_linux_direntx32 *buf) -> syscall_slong_t;
[cp][doc_alias(readdir)] readdirx64:(fd_t fd, [tostr(out:STRUCT_OLD_LINUX_DIRENTX64)] struct old_linux_direntx64 *buf) -> syscall_slong_t;
%[endgroup]

%[startgroup]
@@@return: * : The actual number of read entries
@@@return: 0 : End-of-directory
[cp] getdents:(fd_t fd, [tostr(out:STRUCT_LINUX_DIRENT:buflen:return)] struct linux_dirent *buf, size_t buflen) -> ssize_t;
[cp][doc_alias(getdents)] getdentsx32:(fd_t fd, [tostr(out:STRUCT_LINUX_DIRENTX32:buflen:return)] struct linux_direntx32 *buf, size_t buflen) -> ssize_t;
[cp][doc_alias(getdents)] getdentsx64:(fd_t fd, [tostr(out:STRUCT_LINUX_DIRENTX64:buflen:return)] struct linux_direntx64 *buf, size_t buflen) -> ssize_t;
%[endgroup]

@@@return: * : The actual number of read entries
@@@return: 0 : End-of-directory
[cp] getdents64:(fd_t fd, [tostr(out:STRUCT_LINUX_DIRENT64:buflen:return)] struct linux_dirent64 *buf, size_t buflen) -> ssize_t;

@@@param: mode: One of `READDIR_DEFAULT', `READDIR_CONTINUE', `READDIR_PEEK' or `READDIR_MULTIPLE',
@@              optionally     or'd     with     any     of     `READDIR_SKIPREL | READDIR_WANTEOF'
[cp] kreaddir:(fd_t fd, [tostr(out:STRUCT_DIRENT:bufsize:return)] struct dirent *buf, size_t bufsize,
               [tostr(KREADDIR_MODE)] syscall_ulong_t mode) -> ssize_t;

@@@param: mode: One of `READDIR_DEFAULT', `READDIR_CONTINUE', `READDIR_PEEK' or `READDIR_MULTIPLE',
@@              optionally     or'd     with     any     of     `READDIR_SKIPREL | READDIR_WANTEOF'
[cp] kreaddirf:(fd_t fd, [tostr(out:STRUCT_DIRENT:bufsize:return)] struct dirent *buf, size_t bufsize,
                [tostr(KREADDIR_MODE)] syscall_ulong_t mode, iomode_t iomode) -> ssize_t;






/************************************************************************/
/* FD-related functions                                                 */
/************************************************************************/
@@Close a given file descriptor/handle `fd'
//[cp] /* Even though pthread allows this, I thing this would be a _really_ bad idea... */
[restart(must)] close:(fd_t fd) -> errno_t;

@@@param: flags: Set of `CLOSE_RANGE_*' from <linux/close_range.h>
[restart(must)]
close_range:(unsigned int minfd, unsigned int maxfd,
             [tostr(CLOSE_RANGE_FLAGS)] unsigned int flags) -> errno_t;

dup:(fd_t fd) -> fd_t;
dup2:(fd_t oldfd, fd_t newfd) -> fd_t;

@@@param: flags:  Set of `O_CLOEXEC | O_CLOFORK'
dup3:(fd_t oldfd, fd_t newfd, [tostr(OFLAG__CLOEXEC__CLOFORK)] oflag_t flags) -> fd_t;

[cp] ioctl:(fd_t fd, [tostr(IOCTL_COMMAND)] ioctl_t command, [tostr(IOCTL_ARG:command)] void *arg) -> syscall_slong_t;
[cp] ioctlf:(fd_t fd, [tostr(IOCTL_COMMAND)] ioctl_t command, iomode_t mode, [tostr(IOCTL_ARG:command)] void *arg) -> syscall_slong_t;
[cp] fcntl:(fd_t fd, [tostr(FCNTL_COMMAND)] fcntl_t command, [tostr(FCNTL_ARG:command)] void *arg) -> syscall_slong_t;
[cp] fcntl64:(fd_t fd, [tostr(FCNTL64_COMMAND)] fcntl_t command, [tostr(FCNTL64_ARG:command)] void *arg) -> syscall_slong_t; /* UNIMPLEMENTED! */
[cp] flock:(fd_t fd, syscall_ulong_t operation) -> errno_t; /* UNIMPLEMENTED! */
readahead:(fd_t fd, [reg64] uint64_t offset, size_t count) -> ssize_t; /* UNIMPLEMENTED! */

[cp] sync:() -> errno_t;
[cp] syncfs:(fd_t fd) -> errno_t;

@@Synchronize a file (including its descriptor which contains timestamps, and its size),
@@meaning  that  changes   to  its   data  and/or   descriptor  are   written  to   disk
[cp] fsync:(fd_t fd) -> errno_t;

@@Synchronize only the data of a file (not its descriptor which contains
@@timestamps,  and its size),  meaning that changes  are written to disk
[cp] fdatasync:(fd_t fd) -> errno_t;

@@@param: flags: Set of `SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER'
[cp] sync_file_range:(fd_t fd, [reg64] uint64_t offset, [reg64] uint64_t count,
                      [tostr(SYNC_FILE_RANGE_FLAGS)] syscall_ulong_t flags) -> errno_t; /* UNIMPLEMENTED! */
[cp] sync_file_range2:(fd_t fd, [tostr(SYNC_FILE_RANGE_FLAGS)] syscall_ulong_t flags,
                       [reg64] uint64_t offset, [reg64] uint64_t count) -> errno_t; /* UNIMPLEMENTED! */

%[startgroup]
@@@param: mode: Set of `0 | FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE | FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE'
fallocate:(fd_t fd, [tostr(FALLOCATE_MODE)] syscall_ulong_t mode, syscall_ulong_t offset, syscall_ulong_t length) -> errno_t;
fallocate64:(fd_t fd, [tostr(FALLOCATE_MODE)] syscall_ulong_t mode, [reg64] uint64_t offset, [reg64] uint64_t length) -> errno_t;
%[endgroup]

[cp][restart(dont)]
poll:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds,
      size_t nfds, syscall_slong_t timeout) -> ssize_t;

%[startgroup]
[cp][restart(dont)] ppoll:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[cp][restart(dont)] ppoll32:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[cp][restart(dont)] ppoll64:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[cp][restart(dont)] ppollx32:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[cp][restart(dont)] ppollx32_64:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
[cp][restart(dont)] ppollx64:([tostr(STRUCT_POLLFD:nfds)] struct pollfd *fds, size_t nfds, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout_ts, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *sigmask, size_t sigsetsize) -> ssize_t;
%[endgroup]

@@Same as `select(0, NULL, NULL, NULL, NULL)'
[cp][restart(dont)] pause:() -> errno_t;

%[startgroup]
[cp][restart(dont)] _oldselect:([tostr(STRUCT_SEL_ARG)] struct sel_arg_struct const *arg) -> ssize_t;
[cp][restart(dont)] _oldselectx32:([tostr(STRUCT_SEL_ARGX32)] struct sel_arg_structx32 const *arg) -> ssize_t;
[cp][restart(dont)] _oldselectx64:([tostr(STRUCT_SEL_ARGX64)] struct sel_arg_structx64 const *arg) -> ssize_t;
%[endgroup]

%[startgroup]
[cp][restart(dont)] select:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVAL)] struct timeval *timeout) -> ssize_t;
[cp][restart(dont)] select32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVAL32)] struct timeval32 *timeout) -> ssize_t;
[cp][restart(dont)] select64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVAL64)] struct timeval64 *timeout) -> ssize_t;
[cp][restart(dont)] selectx32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVALX32)] struct timevalx32 *timeout) -> ssize_t;
[cp][restart(dont)] selectx32_64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVALX32_64)] struct timevalx32_64 *timeout) -> ssize_t;
[cp][restart(dont)] selectx64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMEVALX64)] struct timevalx64 *timeout) -> ssize_t;
%[endgroup]

%[startgroup]
[cp][restart(dont)] pselect6:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, [tostr(STRUCT_SIGSET_WITH_SIZE)] struct sigset_with_size const *sigmask_sigset_with_size) -> ssize_t;
[cp][restart(dont)] pselect6_32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout, [tostr(STRUCT_SIGSET_WITH_SIZE)] struct sigset_with_size const *sigmask_sigset_with_size) -> ssize_t;
[cp][restart(dont)] pselect6_64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, [tostr(STRUCT_SIGSET_WITH_SIZE)] struct sigset_with_size const *sigmask_sigset_with_size) -> ssize_t;
[cp][restart(dont)] pselect6_x32:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout, [tostr(STRUCT_SIGSET_WITH_SIZE_X32)] struct __sigset_with_sizex32 const *sigmask_sigset_with_size) -> ssize_t;
[cp][restart(dont)] pselect6_x32_64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, [tostr(STRUCT_SIGSET_WITH_SIZE_X32)] struct __sigset_with_sizex32 const *sigmask_sigset_with_size) -> ssize_t;
[cp][restart(dont)] pselect6_x64:(size_t nfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *readfds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *writefds, [tostr(STRUCT_FDSET:nfds)] struct __fd_set_struct *exceptfds, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, [tostr(STRUCT_SIGSET_WITH_SIZE_X64)] struct __sigset_with_sizex64 const *sigmask_sigset_with_size) -> ssize_t;
%[endgroup]

@@@param: type: One of  `KCMP_FILE',  `KCMP_FILES',  `KCMP_FS',  `KCMP_IO',
@@              `KCMP_SIGHAND', `KCMP_SYSVSEM', `KCMP_VM', `KCMP_EPOLL_TFD'
kcmp:(pid_t pid1, pid_t pid2, [tostr(KCMP_TYPE)] syscall_ulong_t type,
      syscall_ulong_t idx1, syscall_ulong_t idx2) -> syscall_slong_t;






/************************************************************************/
/* Filesystem notifications                                             */
/************************************************************************/
inotify_init:() -> fd_t;

@@@param: flags: Set of `IN_NONBLOCK | IN_CLOEXEC | IN_CLOFORK'
inotify_init1:([tostr(INOTIFY_INIT_FLAGS)] syscall_ulong_t flags) -> fd_t;

@@@param: mask: Set of `IN_ALL_EVENTS | ...'
inotify_add_watch:(fd_t notify_fd, char const *pathname, [tostr(INOTIFY_MASK)] uint32_t mask) -> int;

@@@param: atflags: Set of `AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
@@@param: mask:    Set of `IN_ALL_EVENTS | ...'
inotify_add_watch_at:(fd_t notify_fd, fd_t dirfd, char const *pathname,
                      [tostr(ATFLAG__EMPTY_PATH__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t atflags,
                      [tostr(INOTIFY_MASK)] uint32_t mask) -> int; /* KOS Extension! */

@@@param: wd: Watch fd (as returned by `inotify_add_watch{_at}')
inotify_rm_watch:(fd_t notify_fd, int wd) -> errno_t;






/************************************************************************/
/* Misc file handle functions                                           */
/************************************************************************/
pipe:([tostr(out:FD_VECTOR2)] fd_t pipedes[2]) -> errno_t;
pipe2:([tostr(out:FD_VECTOR2)] fd_t pipedes[2],
       [tostr(OFLAG__CLOEXEC__CLOFORK__NONBLOCK__DIRECT)] oflag_t flags) -> errno_t;

eventfd:(syscall_ulong_t initval) -> fd_t;
@@@param: flags: Set of `EFD_SEMAPHORE | EFD_NONBLOCK | EFD_CLOEXEC | EFD_CLOFORK'
eventfd2:(syscall_ulong_t initval, [tostr(EVENTFD2_FLAGS)] syscall_ulong_t flags) -> fd_t;

@@Create a poll(2)-able file descriptor which can be used to wait for the
@@delivery of signals masked by `sigmask' to the waiting  thread/process.
signalfd:(fd_t fd, [tostr(STRUCT_SIGSET:sigmasksize)] struct __sigset_struct const *sigmask, size_t sigmasksize) -> errno_t;

@@Create a poll(2)-able file descriptor which can be used to wait for the
@@delivery of signals masked by `sigmask' to the waiting  thread/process.
@@@param: flags: Set of `0 | SFD_NONBLOCK | SFD_CLOEXEC | SFD_CLOFORK'
signalfd4:(fd_t fd, [tostr(STRUCT_SIGSET:sigmasksize)] struct __sigset_struct const *sigmask,
           size_t sigmasksize, [tostr(SIGNALFD4_FLAGS)] syscall_ulong_t flags) -> errno_t;

@@@param: flags: Set of `MFD_CLOEXEC | MFD_CLOFORK | MFD_ALLOW_SEALING | MFD_HUGETLB'
memfd_create:(char const *name, [tostr(MEMFD_CREATE_FLAGS)] syscall_ulong_t flags) -> fd_t;

@@Construct   a   user-vio-fd  object   supporting  mmap(2),   with  actual
@@memory  accesses  being dispatched  by  adding them  as  pending requests
@@to an internal  queue that  should be read(2)  from by  a worker  thread,
@@which should then service those requests before responding by write(2)ing
@@the results of the operation back to the same fd.
@@HINT: The format of the structures that are read(2) and
@@      write(2)en can be found in `<libvio/userviofd.h>'
@@NOTE: Don't use this system call directly. Use `vio_create(3)'
@@      from `<libvio/vio.h>' instead.
@@@param: initial_size: The initial mmap(2)able size of the returned handle.
@@                      This  size may be  altered at a  later point in time
@@                      through use of `ftruncate(return)'
@@@param: flags:        Set of `0 | O_CLOEXEC | O_CLOFORK | O_NONBLOCK'
userviofd:(size_t initial_size, [tostr(OFLAG__CLOEXEC__CLOFORK__NONBLOCK)] syscall_ulong_t flags) -> fd_t;

userfaultfd:(syscall_ulong_t flags) -> fd_t; /* UNIMPLEMENTED */






/************************************************************************/
/* Memory functions                                                     */
/************************************************************************/
@@@param: prot:  Either `PROT_NONE', or set of `PROT_EXEC | PROT_WRITE | PROT_READ | PROT_SEM | PROT_SHARED'
@@@param: flags: One of `MAP_SHARED', 'MAP_SHARED_VALIDATE' or `MAP_PRIVATE', optionally or'd
@@              with  a  set of  `MAP_ANONYMOUS  | MAP_FIXED  |  MAP_GROWSDOWN |  MAP_LOCKED |
@@              MAP_NONBLOCK  |  MAP_NORESERVE  |  MAP_POPULATE  |  MAP_STACK  |  MAP_SYNC   |
@@              MAP_UNINITIALIZED | MAP_DONT_MAP | MAP_FIXED_NOREPLACE | MAP_OFFSET64_POINTER'
mmap:(void *addr, size_t len,
	[tostr(MMAP_PROT)] syscall_ulong_t prot,
	[tostr(MMAP_FLAGS)] syscall_ulong_t flags,
	fd_t fd, syscall_ulong_t offset) -> void *;
mmap2:(void *addr, size_t len, [tostr(MMAP_PROT)] syscall_ulong_t prot,
       [tostr(MMAP_FLAGS)] syscall_ulong_t flags, fd_t fd,
       syscall_ulong_t pgoffset) -> void *;

[restart(must)] munmap:(void *addr, size_t len) -> errno_t;

@@@param: prot: Either `PROT_NONE', or set of `PROT_EXEC | PROT_WRITE | PROT_READ | PROT_SEM | PROT_SHARED'
[restart(must)] mprotect:(void *addr, size_t len, [tostr(MMAP_PROT)] syscall_ulong_t prot) -> errno_t;

%[startgroup]
@@Map the segments of a given library into memory
@@@param: addr:  Hint address (ignored unless `MAP_FIXED' is passed)
@@@param: flags: Set of `MAP_FIXED | MAP_32BIT | MAP_GROWSDOWN |
@@               MAP_GROWSUP  |  MAP_LOCKED  |  MAP_NORESERVE  |
@@               MAP_POPULATE  |  MAP_NONBLOCK   |  MAP_SYNC   |
@@               MAP_FIXED_NOREPLACE | MAP_NOASLR'
@@@param: fd:    A handle for the library file being mapped (must be mmap(2)-able)
@@@param: hdrv:  Pointer  to  a vector  of `Elf32_Phdr'  or `Elf64_Phdr'
@@               (depending on the caller running in 32- or 64-bit mode)
@@@param: hdrc:  The number of program headers
maplibrary:(void *addr,
	[tostr(MMAP_FLAGS)] syscall_ulong_t flags, fd_t fd,
	[tostr(STRUCT_ELF_PHDR_VECTOR:hdrc)] ElfW(Phdr) const *hdrv, size_t hdrc) -> void *;
[doc_alias(maplibrary)] maplibraryx32:(void *addr, [tostr(MMAP_FLAGS)] syscall_ulong_t flags, fd_t fd, [tostr(STRUCT_ELF_PHDR32_VECTOR:hdrc)] struct elf32_phdr const *hdrv, size_t hdrc) -> void *;
[doc_alias(maplibrary)] maplibraryx64:(void *addr, [tostr(MMAP_FLAGS)] syscall_ulong_t flags, fd_t fd, [tostr(STRUCT_ELF_PHDR64_VECTOR:hdrc)] struct elf64_phdr const *hdrv, size_t hdrc) -> void *;
%[endgroup]

@@@param: flags: Set of `MREMAP_MAYMOVE | MREMAP_FIXED'
mremap:(void *addr, size_t old_len, size_t new_len,
        [tostr(MREMAP_FLAGS)] syscall_ulong_t flags,
        void *new_address) -> void *;

remap_file_pages:(void *start, size_t size,
                  [tostr(MMAP_PROT)] syscall_ulong_t prot,
                  size_t pgoff, syscall_ulong_t flags) -> errno_t; /* UNIMPLEMENTED! */

mincore:(void *start, size_t len, uint8_t *vec) -> errno_t;
madvise:(void *addr, size_t len, syscall_ulong_t advice) -> errno_t;        /* UNIMPLEMENTED! */
mlock:(void const *addr, size_t len) -> errno_t;
mlock2:(void const *addr, size_t length, syscall_ulong_t flags) -> errno_t;
munlock:(void const *addr, size_t len) -> errno_t;
[cp] msync:(void *addr, size_t len, syscall_ulong_t flags) -> errno_t;

@@@param: flags: Set of `MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT'
mlockall:([tostr(MLOCKALL_FLAGS)] syscall_ulong_t flags) -> errno_t;
munlockall:() -> errno_t;

uselib:([tostr(FILENAME)] char const *library) -> errno_t; /* UNIMPLEMENTED! */

%[startgroup]
@@Read memory from another process's VM
@@@param: flags: Must be `0'
@@@return: * :   The actual number of read bytes
process_vm_readv:(pid_t pid,
                  [tostr(STRUCT_IOVEC:liovcnt)] struct iovec const *local_iov, size_t liovcnt,
                  [tostr(STRUCT_IOVEC:riovcnt)] struct iovec const *remote_iov, size_t riovcnt,
                  syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
[doc_alias(process_vm_readv)]
process_vm_readvx32:(pid_t pid,
                     [tostr(STRUCT_IOVECX32:liovcnt)] struct iovecx32 const *local_iov, size_t liovcnt,
                     [tostr(STRUCT_IOVECX32:riovcnt)] struct iovecx32 const *remote_iov, size_t riovcnt,
                     syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
[doc_alias(process_vm_readv)]
process_vm_readvx64:(pid_t pid,
                     [tostr(STRUCT_IOVECX64:liovcnt)] struct iovecx64 const *local_iov, size_t liovcnt,
                     [tostr(STRUCT_IOVECX64:riovcnt)] struct iovecx64 const *remote_iov, size_t riovcnt,
                     syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
@@Write memory to another process's VM
@@@param: flags: Must be `0'
@@@return: * :   The actual number of written bytes
process_vm_writev:(pid_t pid,
                   [tostr(STRUCT_IOVEC_C:liovcnt)] struct iovec const *local_iov, size_t liovcnt,
                   [tostr(STRUCT_IOVEC:riovcnt)] struct iovec const *remote_iov, size_t riovcnt,
                   syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
[doc_alias(process_vm_writev)]
process_vm_writevx32:(pid_t pid,
                      [tostr(STRUCT_IOVECX32_C:liovcnt)] struct iovecx32 const *local_iov, size_t liovcnt,
                      [tostr(STRUCT_IOVECX32:riovcnt)] struct iovecx32 const *remote_iov, size_t riovcnt,
                      syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
[doc_alias(process_vm_writev)]
process_vm_writevx64:(pid_t pid,
                      [tostr(STRUCT_IOVECX64_C:liovcnt)] struct iovecx64 const *local_iov, size_t liovcnt,
                      [tostr(STRUCT_IOVECX64:riovcnt)] struct iovecx64 const *remote_iov, size_t riovcnt,
                      syscall_ulong_t flags) -> ssize_t; /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
@@@param: futex_op: One of `FUTEX_*' from <linux/futex.h>
[cp] futex:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPEC_OR_UINT32:futex_op)] struct timespec const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[cp][doc_alias(futex)] futex32:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPEC32_OR_UINT32:futex_op)] struct timespec32 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[cp][doc_alias(futex)] futex64:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPEC64_OR_UINT32:futex_op)] struct timespec64 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[cp][doc_alias(futex)] futexx32:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32_OR_UINT32:futex_op)] struct timespecx32 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[cp][doc_alias(futex)] futexx32_64:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32_64_OR_UINT32:futex_op)] struct timespecx32_64 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
[cp][doc_alias(futex)] futexx64:(uint32_t *uaddr, [tostr(FUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX64_OR_UINT32:futex_op)] struct timespecx64 const *timeout_or_val2, uint32_t *uaddr2, uint32_t val3) -> syscall_slong_t;
%[endgroup]

%[startgroup]
@@>> lfutex(2)
@@Provide the bottom-most API for implementing user-space synchronization on KOS
@@@param: futex_op: One of:
@@   - LFUTEX_WAKE:                (lfutex_t *uaddr, LFUTEX_WAKE, size_t count)
@@   - LFUTEX_WAKEMASK:            (lfutex_t *uaddr, LFUTEX_WAKEMASK, size_t count, lfutex_t mask_and, lfutex_t mask_or)
@@   - LFUTEX_WAIT_WHILE:          (lfutex_t *uaddr, LFUTEX_WAIT_WHILE, lfutex_t value, struct timespec const *timeout)
@@   - LFUTEX_WAIT_UNTIL:          (lfutex_t *uaddr, LFUTEX_WAIT_UNTIL, lfutex_t value, struct timespec const *timeout)
@@   - LFUTEX_WAIT_WHILE_ABOVE:    (lfutex_t *uaddr, LFUTEX_WAIT_WHILE_ABOVE, lfutex_t value, struct timespec const *timeout)
@@   - LFUTEX_WAIT_WHILE_BELOW:    (lfutex_t *uaddr, LFUTEX_WAIT_WHILE_BELOW, lfutex_t value, struct timespec const *timeout)
@@   - LFUTEX_WAIT_WHILE_BITMASK:  (lfutex_t *uaddr, LFUTEX_WAIT_WHILE_BITMASK, lfutex_t bitmask, struct timespec const *timeout, lfutex_t setmask)
@@   - LFUTEX_WAIT_UNTIL_BITMASK:  (lfutex_t *uaddr, LFUTEX_WAIT_UNTIL_BITMASK, lfutex_t bitmask, struct timespec const *timeout, lfutex_t setmask)
@@   - LFUTEX_WAIT_WHILE_EX:       (lfutex_t *uaddr, LFUTEX_WAIT_WHILE_EX, void const *rhs, struct timespec const *timeout, size_t num_bytes)
@@   - LFUTEX_WAIT_UNTIL_EX:       (lfutex_t *uaddr, LFUTEX_WAIT_UNTIL_EX, void const *rhs, struct timespec const *timeout, size_t num_bytes)
@@   - LFUTEX_WAIT_WHILE_ABOVE_EX: (lfutex_t *uaddr, LFUTEX_WAIT_WHILE_ABOVE_EX, void const *rhs, struct timespec const *timeout, size_t num_bytes)
@@   - LFUTEX_WAIT_WHILE_BELOW_EX: (lfutex_t *uaddr, LFUTEX_WAIT_WHILE_BELOW_EX, void const *rhs, struct timespec const *timeout, size_t num_bytes)
@@@param: timeout: Timeout for wait operations (s.a. `LFUTEX_WAIT_FLAG_TIMEOUT_*')
@@@return: * : Depending on `futex_op'
@@@return: -1:EFAULT:    A faulty pointer was given
@@@throw:  E_INVALID_ARGUMENT: The given `futex_op' is invalid
@@@throw:  E_INTERRUPT:        A blocking futex-wait operation was interrupted
@@@return: -ETIMEDOUT:         A blocking futex-wait operation has timed out
[cp][restart(dont)]                    lfutex:(uintptr_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uintptr_t val, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, uintptr_t val2) -> syscall_slong_t;
[cp][restart(dont)][doc_alias(lfutex)] lfutex32:(uintptr_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uintptr_t val, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, uintptr_t val2) -> syscall_slong_t;
[cp][restart(dont)][doc_alias(lfutex)] lfutex64:(uintptr_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uintptr_t val, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, uintptr_t val2) -> syscall_slong_t;
[cp][restart(dont)][doc_alias(lfutex)] lfutexx32:(uint32_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, uint32_t val2) -> syscall_slong_t;
[cp][restart(dont)][doc_alias(lfutex)] lfutexx32_64:(uint32_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uint32_t val, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, uint32_t val2) -> syscall_slong_t;
[cp][restart(dont)][doc_alias(lfutex)] lfutexx64:(uint64_t *uaddr, [tostr(LFUTEX_OP)] syscall_ulong_t futex_op, uint64_t val, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, uint64_t val2) -> syscall_slong_t;
%[endgroup]


%[startgroup]
@@>> lfutexexpr(2)
@@The lfutexexpr(2) system call can be used to specify arbitrarily complex
@@expressions that must atomically (in relation to other futex operations)
@@hold true before the scheduler will suspend the calling thread.
@@@param: futexaddr: The futex on which to wait
@@@param: base:      Base pointer added to the `fe_offset' fields of given expressions
@@@param: expr:      Vector of expressions for which to check, terminated by `LFUTEX_EXPREND'
@@@param: timeout:   Timeout for wait operations (s.a. `LFUTEX_WAIT_FLAG_TIMEOUT_*')
@@                   When `LFUTEX_FDBIT'  is  set,  this argument  must  be  `NULL'.
@@@param: flags:     Set of `LFUTEX_WAIT_FLAG_TIMEOUT_*' or `LFUTEX_FDBIT'
@@@return: * : The first  non-zero  return value  from  executing  all of  the  given  `expr'
@@             in order (s.a. the documentations of the individual `LFUTEX_WAIT_*'  functions
@@             to see their  possible return  values, which are  always `0'  when they  would
@@             perform a wait  operation, and usually  `1' otherwise) or  `0' if the  calling
@@             thread had to perform a wait operation, at which point this function returning
@@             that value means that you've once again been re-awoken.
@@             When `LFUTEX_FDBIT' is set, the return value is an `fd_t' for a futex fd that
@@             can be used to poll for the specified `exprv'. Note that in this case `exprv'
@@             is limited to `LFUTEXFD_DEFAULT_MAXEXPR' (`/proc/kos/futexfd-maxexpr')
@@@return: -1:EFAULT:    A faulty pointer was given
@@@return: -1:EINVAL:    One of the given commands is invalid, or `expr[0].fe_condition == LFUTEX_EXPREND'
@@@return: -1:EINTR:     A blocking futex-wait operation was interrupted
@@@return: -1:ETIMEDOUT: A blocking futex-wait operation has timed out
[cp][restart(dont)]                        lfutexexpr:(uintptr_t *futexaddr, void *base, [tostr(STRUCT_LFUTEXEXPR_VECTOR)] struct lfutexexpr const *expr, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t flags) -> errno_t;
[cp][restart(dont)][doc_alias(lfutexexpr)] lfutexexpr32:(uint32_t *futexaddr, void *base, [tostr(STRUCT_LFUTEXEXPR_VECTOR)] struct lfutexexpr const *expr, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t flags) -> errno_t;
[cp][restart(dont)][doc_alias(lfutexexpr)] lfutexexpr64:(uint64_t *futexaddr, void *base, [tostr(STRUCT_LFUTEXEXPR_VECTOR)] struct lfutexexpr const *expr, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t flags) -> errno_t;
[cp][restart(dont)][doc_alias(lfutexexpr)] lfutexexprx32:(uint32_t *futexaddr, void *base, [tostr(STRUCT_LFUTEXEXPRX32_VECTOR)] struct lfutexexprx32 const *expr, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t flags) -> errno_t;
[cp][restart(dont)][doc_alias(lfutexexpr)] lfutexexprx32_64:(uint32_t *futexaddr, void *base, [tostr(STRUCT_LFUTEXEXPRX32_VECTOR)] struct lfutexexprx32 const *expr, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t flags) -> errno_t;
[cp][restart(dont)][doc_alias(lfutexexpr)] lfutexexprx64:(uint64_t *futexaddr, void *base, [tostr(STRUCT_LFUTEXEXPRX64_VECTOR)] struct lfutexexprx64 const *expr, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, [tostr(LFUTEX_TIMEOUT_FLAGS)] syscall_ulong_t flags) -> errno_t;
%[endgroup]

brk:(void *addr) -> errno_t; /* UNIMPLEMENTED! */





/************************************************************************/
/* Filesystem functions                                                 */
/************************************************************************/
@@Open  a  new  file  handle  to  the  file  specified  by `filename'
@@When  `oflags & O_CREAT',   then  `mode'   specifies  the   initial
@@file  access  permissions with  which  the file  should  be opened.
@@On KOS, the returned handle can be anything, but is usually one of:
@@  - HANDLE_TYPE_PATH:       When `O_PATH' was given
@@  - HANDLE_TYPE_FILEHANDLE: For `S_IFREG' regular files
@@  - HANDLE_TYPE_FIFOHANDLE: For `S_IFIFO' pipe files
@@  - HANDLE_TYPE_DIRHANDLE:  For `S_IFDIR' directories
@@  - HANDLE_TYPE_MFILE:      The actual filesystem object (including device files)
@@  - *:                      Certain filesystem names can literally return anything, such
@@                            as `/proc/self/fd/1234',  which  is  more  like  `dup(1234)'
[cp] open:([tostr(FILENAME)] char const *filename, oflag_t oflags, [tostr(MODE_T:oflags)] mode_t mode) -> fd_t;
[cp][doc_alias(open)]
openat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, oflag_t oflags,
        [tostr(MODE_T:oflags)] mode_t mode) -> fd_t;
[cp] creat:([tostr(FILENAME)] char const *filename, mode_t mode) -> fd_t;

@@@param: type: Set of `R_OK|W_OK|X_OK' or `F_OK'
[cp] access:([tostr(FILENAME)] char const *filename,
             [tostr(ACCESS_TYPE)] syscall_ulong_t type) -> errno_t;

@@@param: type: Set of `R_OK | W_OK | X_OK' or `F_OK'
[cp] faccessat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                [tostr(ACCESS_TYPE)] syscall_ulong_t type) -> errno_t;

@@@param: type: Set of `R_OK | W_OK | X_OK' or `F_OK'
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_EACCESS | AT_DOSPATH'
faccessat2:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
            [tostr(ACCESS_TYPE)] syscall_ulong_t type,
            [tostr(ATFLAG__SYMLINK_NOFOLLOW__EACCESS__DOSPATH)] atflag_t flags) -> errno_t;

[cp] symlink:(char const *link_text, [tostr(FILENAME)] char const *target_path) -> errno_t;
[cp] symlinkat:([tostr(STRING)] char const *link_text, fd_t tofd,
                [tostr(FILENAME:tofd)] char const *target_path) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fsymlinkat:([tostr(STRING)] char const *link_text, fd_t tofd,
                 [tostr(FILENAME:tofd)] char const *target_path,
                 [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;

[cp] readlink:([tostr(FILENAME)] char const *path, [tostr(out:BUFFER:buflen)] char *buf, size_t buflen) -> ssize_t;
[cp] readlinkat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *path,
                 [tostr(out:BUFFER:buflen:return)] char *buf, size_t buflen) -> ssize_t;
@@@param: flags: Set of `0 | AT_READLINK_REQSIZE | AT_DOSPATH'
[cp] freadlinkat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *path,
                  [tostr(out:BUFFER:buflen:return)] char *buf, size_t buflen,
                  [tostr(ATFLAG__READLINK_REQSIZE__DOSPATH)] atflag_t flags) -> ssize_t;

[cp] link:([tostr(FILENAME)] char const *existing_file, [tostr(FILENAME)] char const *link_file) -> errno_t;
@@@param: flags: Set of `0 | AT_EMPTY_PATH | AT_SYMLINK_FOLLOW | AT_DOSPATH'
[cp] linkat:(fd_t fromfd, [tostr(FILENAME:fromfd)] char const *existing_file,
             fd_t tofd, [tostr(FILENAME:tofd)] char const *target_path,
             [tostr(ATFLAG__EMPTY_PATH__SYMLINK_FOLLOW__DOSPATH)] atflag_t flags) -> errno_t;

[cp] unlink:([tostr(FILENAME)] char const *filename) -> errno_t;
@@@param: flags: Set of `0 | AT_REMOVEDIR | AT_REMOVEREG | AT_DOSPATH'
[cp] unlinkat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *name,
               [tostr(ATFLAG__REMOVEDIR__REMOVEREG__DOSPATH)] atflag_t flags) -> errno_t;
rmdir:(char const *path) -> errno_t;

[cp] getcwd:([tostr(out:BUFFER:size:return)] char *buf, size_t size) -> ssize_t;

[cp] chdir:([tostr(FILENAME)] char const *path) -> errno_t;
[cp] fchdir:(fd_t fd) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fchdirat:(fd_t dirfd,
               [tostr(FILENAME:dirfd)] char const *path,
               [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;

[cp] mknod:([tostr(FILENAME)] char const *nodename, mode_t mode, [tostr(DEV_T:mode)] dev_t dev) -> errno_t;
[cp] mknodat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *nodename,
              mode_t mode, [tostr(DEV_T:mode)] dev_t dev) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fmknodat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *nodename,
               mode_t mode, [tostr(DEV_T:mode)] dev_t dev,
               [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;

[cp] chmod:([tostr(FILENAME)] char const *filename, mode_t mode) -> errno_t;
[cp] fchmod:(fd_t fd, mode_t mode) -> errno_t;
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] fchmodat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, mode_t mode,
               [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;

%[startgroup]
[cp] chown:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uid_t owner, [tostr(GID_T)] gid_t group) -> errno_t;
[cp] chown16:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint16_t owner, [tostr(GID_T)] uint16_t group) -> errno_t;
[cp] chown32:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint32_t owner, [tostr(GID_T)] uint32_t group) -> errno_t;
%[endgroup]

%[startgroup]
[cp] lchown:([tostr(FILENAME)] char const *filename, uid_t owner, gid_t group) -> errno_t;
[cp] lchown16:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint16_t owner, [tostr(GID_T)] uint16_t group) -> errno_t;
[cp] lchown32:([tostr(FILENAME)] char const *filename, [tostr(UID_T)] uint32_t owner, [tostr(GID_T)] uint32_t group) -> errno_t;
%[endgroup]

%[startgroup]
[cp] fchown:(fd_t fd, uid_t owner, gid_t group) -> errno_t;
[cp] fchown16:(fd_t fd, [tostr(UID_T)] uint16_t owner, [tostr(GID_T)] uint16_t group) -> errno_t;
[cp] fchown32:(fd_t fd, [tostr(UID_T)] uint32_t owner, [tostr(GID_T)] uint32_t group) -> errno_t;
%[endgroup]

@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] fchownat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, uid_t owner, gid_t group,
               [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;

[cp] mkdir:([tostr(FILENAME)] char const *pathname, mode_t mode) -> errno_t;
[cp] mkdirat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname, mode_t mode) -> errno_t;
@@@param: flags: Set of `0 | AT_DOSPATH'
[cp] fmkdirat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *pathname, mode_t mode,
               [tostr(ATFLAG__DOSPATH)] atflag_t flags) -> errno_t;

[cp] rename:([tostr(FILENAME)] char const *oldname,
             [tostr(FILENAME)] char const *newname_or_path) -> errno_t;
[cp] renameat:(fd_t oldfd, [tostr(FILENAME:oldfd)] char const *oldname,
               fd_t newfd, [tostr(FILENAME:newfd)] char const *newname_or_path) -> errno_t;
@@@param: flags: Set of `0 | AT_RENAME_NOREPLACE | AT_RENAME_EXCHANGE | AT_RENAME_WHITEOUT | AT_RENAME_MOVETODIR | AT_DOSPATH'
[cp] renameat2:(fd_t olddirfd, [tostr(FILENAME:olddirfd)] char const *oldpath,
                fd_t newdirfd, [tostr(FILENAME:newdirfd)] char const *newpath,
                [tostr(RENAMEAT2_FLAGS)] atflag_t flags) -> errno_t;

%[startgroup]
truncate:([tostr(FILENAME)] char const *filename, syscall_ulong_t length) -> errno_t;
truncate32:([tostr(FILENAME)] char const *filename, uint32_t length) -> errno_t;
truncate64:([tostr(FILENAME)] char const *filename, [reg64] uint64_t length) -> errno_t;
%[endgroup]

%[startgroup]
ftruncate:(fd_t fd, syscall_ulong_t length) -> errno_t;
ftruncate32:(fd_t fd, uint32_t length) -> errno_t;
ftruncate64:(fd_t fd, [reg64] uint64_t length) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: times: When NULL, set the current time
[cp] utime:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUF)] struct utimbuf const *times) -> errno_t;
[cp][doc_alias(utime)] utime32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUF32)] struct utimbuf32 const *times) -> errno_t;
[cp][doc_alias(utime)] utime64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUF64)] struct utimbuf64 const *times) -> errno_t;
[cp][doc_alias(utime)] utimex32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUFX32)] struct utimbufx32 const *times) -> errno_t;
[cp][doc_alias(utime)] utimex32_64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUFX32_64)] struct utimbufx32_64 const *times) -> errno_t;
[cp][doc_alias(utime)] utimex64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_UTIMBUFX64)] struct utimbufx64 const *times) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: times:    When NULL, set the current time
@@@param: times[0]: New access time
@@@param: times[1]: New last-modified time
[cp] utimes:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVAL_VEC2)] struct timeval const times[2]) -> errno_t;
[cp][doc_alias(utimes)] utimes32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVAL32_VEC2)] struct timeval32 const times[2]) -> errno_t;
[cp][doc_alias(utimes)] utimes64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVAL64_VEC2)] struct timeval64 const times[2]) -> errno_t;
[cp][doc_alias(utimes)] utimesx32:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVALX32_VEC2)] struct timevalx32 const times[2]) -> errno_t;
[cp][doc_alias(utimes)] utimesx32_64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVALX32_64_VEC2)] struct timevalx32_64 const times[2]) -> errno_t;
[cp][doc_alias(utimes)] utimesx64:([tostr(FILENAME)] char const *filename, [tostr(STRUCT_TIMEVALX64_VEC2)] struct timevalx64 const times[2]) -> errno_t;
%[endgroup]

%[startgroup]
[cp] futimesat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVAL_VEC2)] struct timeval const times[2]) -> errno_t;
[cp] futimesat32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVAL32_VEC2)] struct timeval32 const times[2]) -> errno_t;
[cp] futimesat64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVAL64_VEC2)] struct timeval64 const times[2]) -> errno_t;
[cp] futimesatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVALX32_VEC2)] struct timevalx32 const times[2]) -> errno_t;
[cp] futimesatx32_64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVALX32_64_VEC2)] struct timevalx32_64 const times[2]) -> errno_t;
[cp] futimesatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMEVALX64_VEC2)] struct timevalx64 const times[2]) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_CHANGE_BTIME | AT_DOSPATH'
[cp] utimensat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPEC_VEC2_OR_3:flags)] struct timespec const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_BTIME__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(utimensat)] utimensat32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPEC32_VEC2_OR_3:flags)] struct timespec32 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_BTIME__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(utimensat)] utimensat64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPEC64_VEC2_OR_3:flags)] struct timespec64 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_BTIME__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(utimensat)] utimensatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPECX32_VEC2_OR_3:flags)] struct timespecx32 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_BTIME__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(utimensat)] utimensatx32_64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPECX32_64_VEC2_OR_3:flags)] struct timespecx32_64 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_BTIME__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(utimensat)] utimensatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(STRUCT_TIMESPECX64_VEC2_OR_3:flags)] struct timespecx64 const times[2], [tostr(ATFLAG__SYMLINK_NOFOLLOW__CHANGE_BTIME__DOSPATH)] atflag_t flags) -> errno_t;
%[endgroup]

[cp] mount:([tostr(FILENAME)] char const *special_file,
            [tostr(FILENAME)] char const *dir,
            [tostr(STRING)] char const *fstype,
            [tostr(MOUNT_FLAGS)] syscall_ulong_t mountflags,
            [tostr(STRING)] void const *data) -> errno_t;
[cp] umount:([tostr(FILENAME)] char const *special_file) -> errno_t;
[cp][restart(must)] umount2:(char const *special_file, syscall_ulong_t flags) -> errno_t;

@@@param: swapflags: Set of `SWAP_FLAG_*'
swapon:([tostr(FILENAME)] char const *pathname, [tostr(SWAPFLAGS)] syscall_ulong_t swapflags) -> errno_t; /* UNIMPLEMENTED! */
swapoff:([tostr(FILENAME)] char const *pathname) -> errno_t;                                              /* UNIMPLEMENTED! */

acct:([tostr(FILENAME)] char const *filename) -> errno_t; /* UNIMPLEMENTED! */

[restart(must)] umask:(mode_t mode) -> mode_t;
[restart(must)] fsmode:([reg64][tostr(FSMODE)] uint64_t mode) -> [reg64][tostr(FSMODE)] uint64_t;
chroot:([tostr(FILENAME)] char const *path) -> errno_t;
ustat:([tostr(DEV_BLK)] dev_t dev, [tostr(out:STRUCT_USTAT)] struct ustat *ubuf) -> errno_t; /* UNIMPLEMENTED! */

%[startgroup]
statfs:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFS)] struct statfs *buf) -> errno_t;
statfs32:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFS32)] struct statfs32 *buf) -> errno_t;
statfs64:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFS64)] struct statfs64 *buf) -> errno_t;
statfsx32:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFSX32)] struct statfsx32 *buf) -> errno_t;
statfsx32_64:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFSX32_64)] struct statfsx32_64 *buf) -> errno_t;
statfsx64:([tostr(FILENAME)] char const *file, [tostr(out:STRUCT_STATFSX64)] struct statfsx64 *buf) -> errno_t;
%[endgroup]

%[startgroup]
fstatfs:(fd_t file, [tostr(out:STRUCT_STATFS)] struct statfs *buf) -> errno_t;
fstatfs32:(fd_t file, [tostr(out:STRUCT_STATFS32)] struct statfs32 *buf) -> errno_t;
fstatfs64:(fd_t file, [tostr(out:STRUCT_STATFS64)] struct statfs64 *buf) -> errno_t;
fstatfsx32:(fd_t file, [tostr(out:STRUCT_STATFSX32)] struct statfsx32 *buf) -> errno_t;
fstatfsx32_64:(fd_t file, [tostr(out:STRUCT_STATFSX32_64)] struct statfsx32_64 *buf) -> errno_t;
fstatfsx64:(fd_t file, [tostr(out:STRUCT_STATFSX64)] struct statfsx64 *buf) -> errno_t;
%[endgroup]

[cp] oldfstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                 [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf,
                 [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp] oldfstat:(fd_t fd, [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf) -> errno_t;
[cp] oldlstat:([tostr(FILENAME)] char const *filename,
               [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf) -> errno_t;
[cp] oldstat:([tostr(FILENAME)] char const *filename,
              [tostr(out:STRUCT_LINUX_OLDSTAT)] struct linux_oldstat *statbuf) -> errno_t;

%[startgroup]
@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] fstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(fstatat)] fstatat32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(fstatat)] fstatat64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(fstatat)] fstatatx32:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(fstatat)] fstatatx32_64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp][doc_alias(fstatat)] fstatatx64:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf, [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
%[endgroup]

%[startgroup]
[cp] fstat:(fd_t fd, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf) -> errno_t;
[cp] fstat32:(fd_t fd, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf) -> errno_t;
[cp] fstat64:(fd_t fd, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf) -> errno_t;
[cp] fstatx32:(fd_t fd, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf) -> errno_t;
[cp] fstatx32_64:(fd_t fd, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf) -> errno_t;
[cp] fstatx64:(fd_t fd, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf) -> errno_t;
%[endgroup]

%[startgroup]
[cp] lstat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf) -> errno_t;
[cp] lstat32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf) -> errno_t;
[cp] lstat64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf) -> errno_t;
[cp] lstatx32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf) -> errno_t;
[cp] lstatx32_64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf) -> errno_t;
[cp] lstatx64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf) -> errno_t;
%[endgroup]

%[startgroup]
[cp] stat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT)] struct linux_stat *statbuf) -> errno_t;
[cp] stat32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT32)] struct linux_stat32 *statbuf) -> errno_t;
[cp] stat64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STAT64)] struct linux_stat64 *statbuf) -> errno_t;
[cp] statx32:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32)] struct linux_statx32 *statbuf) -> errno_t;
[cp] statx32_64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX32_64)] struct linux_statx32_64 *statbuf) -> errno_t;
[cp] statx64:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_LINUX_STATX64)] struct linux_statx64 *statbuf) -> errno_t;
%[endgroup]


@@@param: flags: Set of `0 | AT_SYMLINK_NOFOLLOW | AT_DOSPATH'
[cp] kfstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
               [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf,
               [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t;
[cp] kfstat:(fd_t fd, [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf) -> errno_t;
[cp] klstat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf) -> errno_t;
[cp] kstat:([tostr(FILENAME)] char const *filename, [tostr(out:STRUCT_KOS_STAT)] struct __kos_stat *statbuf) -> errno_t;

[cp] newfstatat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                 [tostr(out:STRUCT_LINUX64_STAT32)] struct linux64_stat32 *statbuf,
                 [tostr(ATFLAG__SYMLINK_NOFOLLOW__DOSPATH)] atflag_t flags) -> errno_t; /* UNIMPLEMENTED! */


@@@param: flags: One of `0', `XATTR_CREATE' or `XATTR_REPLACE'
[cp] setxattr:([tostr(FILENAME)] char const *path,
               [tostr(STRING)] char const *name,
               [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
               [tostr(XATTR_FLAGS)] syscall_ulong_t flags) -> errno_t; /* UNIMPLEMENTED! */

@@@param: flags: One of `0', `XATTR_CREATE' or `XATTR_REPLACE'
[cp] lsetxattr:([tostr(FILENAME)] char const *path,
                [tostr(STRING)] char const *name,
                [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
                [tostr(XATTR_FLAGS)] syscall_ulong_t flags) -> errno_t; /* UNIMPLEMENTED! */

@@@param: flags: One of `0', `XATTR_CREATE' or `XATTR_REPLACE'
[cp] fsetxattr:(fd_t fd, [tostr(STRING)] char const *name,
                [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
                [tostr(XATTR_FLAGS)] syscall_ulong_t flags) -> errno_t; /* UNIMPLEMENTED! */

[cp] getxattr:([tostr(FILENAME)] char const *path,
               [tostr(STRING)] char const *name,
               [tostr(out:BUFFER:bufsize:return)] void *buf,
               size_t bufsize) -> ssize_t; /* UNIMPLEMENTED! */
[cp] lgetxattr:([tostr(FILENAME)] char const *path,
                [tostr(STRING)] char const *name,
                [tostr(out:BUFFER:bufsize:return)] void *buf,
                size_t bufsize) -> ssize_t; /* UNIMPLEMENTED! */
[cp] fgetxattr:(fd_t fd, [tostr(STRING)] char const *name,
                [tostr(out:BUFFER:bufsize:return)] void *buf,
                size_t bufsize) -> ssize_t; /* UNIMPLEMENTED! */
[cp] listxattr:([tostr(FILENAME)] char const *path,
                [tostr(out:BUFFER:listbufsize:return)] char *listbuf,
                size_t listbufsize) -> ssize_t; /* UNIMPLEMENTED! */
[cp] llistxattr:([tostr(FILENAME)] char const *path,
                 [tostr(out:BUFFER:listbufsize:return)] char *listbuf,
                 size_t listbufsize) -> ssize_t; /* UNIMPLEMENTED! */
[cp] flistxattr:(fd_t fd, [tostr(out:BUFFER:listbufsize:return)] char *listbuf,
                 size_t listbufsize) -> ssize_t; /* UNIMPLEMENTED! */
[cp] removexattr:([tostr(FILENAME)] char const *path,
                  [tostr(STRING)] char const *name) -> errno_t; /* UNIMPLEMENTED! */
[cp] lremovexattr:([tostr(FILENAME)] char const *path,
                   [tostr(STRING)] char const *name) -> errno_t; /* UNIMPLEMENTED! */
[cp] fremovexattr:(fd_t fd, [tostr(STRING)] char const *name) -> errno_t; /* UNIMPLEMENTED! */

@@Returns a bitset of all of the currently mounted dos-drives
[restart(must)] getdrives:() -> syscall_slong_t;

@@You may pass `AT_READLINK_REQSIZE' to always have the function return
@@the   required   buffer   size,   rather   than   the   used    size.
@@@param: flags: Set of `0 | AT_ALTPATH | AT_READLINK_REQSIZE | AT_DOSPATH'
[cp] frealpath4:(fd_t fd, [tostr(out:BUFFER:buflen:return)] char *resolved, size_t buflen,
                 [tostr(ATFLAG__ALTPATH__READLINK_REQSIZE__DOSPATH)] atflag_t flags) -> ssize_t;

@@Returns  the  absolute   filesystem  path  for   the  specified   file
@@When `AT_SYMLINK_NOFOLLOW' is given, a final symlink is  dereferenced,
@@causing the pointed-to file location to be retrieved. - Otherwise, the
@@location of the link is printed instead.
@@You may pass `AT_READLINK_REQSIZE' to always have the function return
@@the   required   buffer   size,   rather   than   the   used    size.
@@@param: flags: Set of `0 | AT_ALTPATH | AT_SYMLINK_NOFOLLOW | AT_READLINK_REQSIZE | AT_DOSPATH'
[cp] frealpathat:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename, char *buf, size_t buflen,
                  [tostr(ATFLAG__ALTPATH__SYMLINK_NOFOLLOW__READLINK_REQSIZE__DOSPATH)] atflag_t flags) -> ssize_t;

@@Create a new pseudo-terminal driver and store handles to both the
@@master  and slave ends  of the connection  in the given pointers.
openpty:([tostr(out:FD_T)] fd_t *amaster,
         [tostr(out:FD_T)] fd_t *aslave,
         [tostr(out:STRING)] char *name,
         [tostr(STRUCT_TERMIOS)] struct termios const *termp,
         [tostr(STRUCT_WINSIZE)] struct winsize const *winp) -> errno_t;

@@Create and return a new tty terminal controller connected to the given keyboard and display
@@The  newly created  device automatically gets  assigned an arbitrary  device number, before
@@being made available under a file `/dev/${name}'  (or rather: as ${name} within the  devfs)
@@@param: reserved: Reserved set of flags (Must pass `0'; for future expansion)
mktty:([tostr(STRING)] char const *name, fd_t keyboard, fd_t display, syscall_ulong_t rsvd) -> fd_t;

@@@param: flags: Set of `0 | AT_EMPTY_PATH | AT_SYMLINK_FOLLOW | AT_DOSPATH'
[cp]
name_to_handle_at:(fd_t dirfd, [tostr(FILENAME:dirfd)] char const *filename,
                   [tostr(out:STRUCT_FILE_HANDLE)] struct file_handle *handle,
                   [tostr(out:INT32_T)] int32_t *mnt_id,
                   [tostr(ATFLAG__EMPTY_PATH__SYMLINK_FOLLOW__DOSPATH)] atflag_t flags) -> errno_t; /* UNIMPLEMENTED! */
[cp]
open_by_handle_at:(fd_t mountdirfd, [tostr(STRUCT_FILE_HANDLE)] struct file_handle const *handle,
                   oflag_t flags) -> fd_t; /* UNIMPLEMENTED! */





/************************************************************************/
/* UID/GID                                                              */
/************************************************************************/
%[startgroup]
@@>> getuid(2)
@@@return: * : The UID of the calling thread (this is the so-called ~real~ UID)
[restart(must)] getuid:() -> uid_t;
[doc_alias(getuid)][restart(must)] getuid16:() -> [tostr(UID_T)] uint16_t;
[doc_alias(getuid)][restart(must)] getuid32:() -> [tostr(UID_T)] uint32_t;
%[endgroup]

%[startgroup]
@@>> setuid(2)
@@Set the UID of the calling thread (this is the so-called ~real~ UID)
@@@return: 0 : Success
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETUID: [...]
[restart(must)] setuid:(uid_t uid) -> errno_t;
[doc_alias(setuid)][restart(must)] setuid16:([tostr(UID_T)] uint16_t uid) -> errno_t;
[doc_alias(setuid)][restart(must)] setuid32:([tostr(UID_T)] uint32_t uid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> getgid(2)
@@@return: * : The GID of the calling thread (this is the so-called ~real~ GID)
[restart(must)] getgid:() -> gid_t;
[doc_alias(getgid)][restart(must)] getgid16:() -> [tostr(GID_T)] uint16_t;
[doc_alias(getgid)][restart(must)] getgid32:() -> [tostr(GID_T)] uint32_t;
%[endgroup]

%[startgroup]
@@>> setgid(2)
@@Set the GID of the calling thread (this is the so-called ~real~ GID)
@@@return: 0 : Success
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETGID: [...]
[restart(must)] setgid:(gid_t gid) -> errno_t;
[doc_alias(setgid)][restart(must)] setgid16:([tostr(GID_T)] uint16_t gid) -> errno_t;
[doc_alias(setgid)][restart(must)] setgid32:([tostr(GID_T)] uint32_t gid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> geteuid(2)
@@@return: * : The   effective  UID  of  the  calling  thread.
@@             This is the one used for most permission checks
[restart(must)] geteuid:() -> uid_t;
[doc_alias(geteuid)][restart(must)] geteuid16:() -> [tostr(UID_T)] uint16_t;
[doc_alias(geteuid)][restart(must)] geteuid32:() -> [tostr(UID_T)] uint32_t;
%[endgroup]

%[startgroup]
@@>> setreuid(2)
@@Set the real and effective UID of the calling thread.
@@@return: 0 : Success
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETUID: [...]
[restart(must)] setreuid:(uid_t ruid, uid_t euid) -> errno_t;
[doc_alias(setreuid)][restart(must)] setreuid16:([tostr(UID_T)] uint16_t ruid, [tostr(UID_T)] uint16_t euid) -> errno_t;
[doc_alias(setreuid)][restart(must)] setreuid32:([tostr(UID_T)] uint32_t ruid, [tostr(UID_T)] uint32_t euid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> getegid(2)
@@@return: * : The   effective  GID  of  the  calling  thread.
@@             This is the one used for most permission checks
[restart(must)] getegid:() -> gid_t;
[doc_alias(getegid)][restart(must)] getegid16:() -> [tostr(GID_T)] uint16_t;
[doc_alias(getegid)][restart(must)] getegid32:() -> [tostr(GID_T)] uint32_t;
%[endgroup]

%[startgroup]
@@>> setregid(2)
@@Set the real and effective GID of the calling thread.
@@@return: 0 : Success
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETGID: [...]
[restart(must)] setregid:(gid_t rgid, gid_t egid) -> errno_t;
[doc_alias(setregid)][restart(must)] setregid16:([tostr(GID_T)] uint16_t rgid, [tostr(GID_T)] uint16_t egid) -> errno_t;
[doc_alias(setregid)][restart(must)] setregid32:([tostr(GID_T)] uint32_t rgid, [tostr(GID_T)] uint32_t egid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> getresuid(2)
@@Get the real, effective, and saved UID of the calling thread.
@@@return: 0 : Success
[restart(must)] getresuid:([tostr(out:UID_T)] uid_t *ruid, [tostr(out:UID_T)] uid_t *euid, [tostr(out:UID_T)] uid_t *suid) -> errno_t;
[doc_alias(getresuid)][restart(must)] getresuid16:([tostr(out:UID16_T)] uint16_t *ruid, [tostr(out:UID16_T)] uint16_t *euid, [tostr(out:UID16_T)] uint16_t *suid) -> errno_t;
[doc_alias(getresuid)][restart(must)] getresuid32:([tostr(out:UID32_T)] uint32_t *ruid, [tostr(out:UID32_T)] uint32_t *euid, [tostr(out:UID32_T)] uint32_t *suid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> setresuid(2)
@@@return: 0 : Success
@@Set the real, effective, and saved UID of the calling thread.
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETUID: [...]
[restart(must)] setresuid:(uid_t ruid, uid_t euid, uid_t suid) -> errno_t;
[doc_alias(setresuid)][restart(must)] setresuid16:([tostr(UID_T)] uint16_t ruid, [tostr(UID_T)] uint16_t euid, [tostr(UID_T)] uint16_t suid) -> errno_t;
[doc_alias(setresuid)][restart(must)] setresuid32:([tostr(UID_T)] uint32_t ruid, [tostr(UID_T)] uint32_t euid, [tostr(UID_T)] uint32_t suid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> getresgid(2)
@@Get the real, effective, and saved GID of the calling thread.
@@@return: 0 : Success
[restart(must)] getresgid:([tostr(out:GID_T)] gid_t *rgid, [tostr(out:GID_T)] gid_t *egid, [tostr(out:GID_T)] gid_t *sgid) -> errno_t;
[doc_alias(getresgid)][restart(must)] getresgid16:([tostr(out:GID16_T)] uint16_t *rgid, [tostr(out:GID16_T)] uint16_t *egid, [tostr(out:GID16_T)] uint16_t *sgid) -> errno_t;
[doc_alias(getresgid)][restart(must)] getresgid32:([tostr(out:GID32_T)] uint32_t *rgid, [tostr(out:GID32_T)] uint32_t *egid, [tostr(out:GID32_T)] uint32_t *sgid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> setresgid(2)
@@Set the real, effective, and saved GID of the calling thread.
@@@return: 0 : Success
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETGID: [...]
[restart(must)] setresgid:(gid_t rgid, gid_t egid, gid_t sgid) -> errno_t;
[doc_alias(setresgid)][restart(must)] setresgid16:([tostr(GID_T)] uint16_t rgid, [tostr(GID_T)] uint16_t egid, [tostr(GID_T)] uint16_t sgid) -> errno_t;
[doc_alias(setresgid)][restart(must)] setresgid32:([tostr(GID_T)] uint32_t rgid, [tostr(GID_T)] uint32_t egid, [tostr(GID_T)] uint32_t sgid) -> errno_t;
%[endgroup]

%[startgroup]
@@@return: * :     [count == 0] The required number of groups
@@@return: * :     [count != 0] The number of groups that were actually returned
@@@throw: -EINVAL: [count != 0] There are more than `count' groups (NOTE: No exception is thrown for this case!)
[restart(must)] getgroups:(size_t count, [tostr(out:GID_VECTOR:count)] gid_t list[]) -> ssize_t;
[doc_alias(getgroups)][restart(must)] getgroups32:(size_t count, [tostr(out:GID_VECTOR32:count)] uint32_t list[]) -> ssize_t;
[doc_alias(getgroups)][restart(must)] getgroups16:(size_t count, [tostr(out:GID_VECTOR16:count)] uint16_t list[]) -> ssize_t;
%[endgroup]

%[startgroup]
[restart(must)] setgroups:(size_t count, [tostr(GID_VECTOR:count)] gid_t const *groups) -> errno_t;
[restart(must)] setgroups16:(size_t count, [tostr(GID_VECTOR16:count)] uint16_t const *groups) -> errno_t;
[restart(must)] setgroups32:(size_t count, [tostr(GID_VECTOR32:count)] uint32_t const *groups) -> errno_t;
%[endgroup]

%[startgroup]
@@>> setfsuid(2)
@@Set the  user ID  for the  cred-context (s.a.  `CLONE_CRED') of  the
@@calling thread. The calling thread needs the `CAP_SETUID' privilege.
@@@return: 0:  Success.
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETUID: [...]
[restart(must)] setfsuid:(uid_t uid) -> errno_t;
[doc_alias(setfsuid)][restart(must)] setfsuid16:([tostr(UID_T)] uint16_t uid) -> errno_t;
[doc_alias(setfsuid)][restart(must)] setfsuid32:([tostr(UID_T)] uint32_t uid) -> errno_t;
%[endgroup]

%[startgroup]
@@>> setfsgid(2)
@@Set the group  ID for  the cred-context (s.a.  `CLONE_CRED') of  the
@@calling thread. The calling thread needs the `CAP_SETGID' privilege.
@@@return: 0:  Success.
@@@throw: E_INSUFFICIENT_RIGHTS:CAP_SETGID: [...]
[restart(must)] setfsgid:(gid_t gid) -> errno_t;
[doc_alias(setfsgid)][restart(must)] setfsgid16:([tostr(GID_T)] uint16_t gid) -> errno_t;
[doc_alias(setfsgid)][restart(must)] setfsgid32:([tostr(GID_T)] uint32_t gid) -> errno_t;
%[endgroup]





/************************************************************************/
/* PID/Signal functions                                                 */
/************************************************************************/
[restart(must)] set_tid_address:(pid_t *tidptr) -> pid_t;
[restart(must)] gettid:() -> pid_t;
[restart(must)] getpid:() -> pid_t;
[restart(must)] getpgid:(pid_t pid) -> pid_t;
[restart(must)] setpgid:(pid_t pid, pid_t pgid) -> errno_t;
[restart(must)] getppid:() -> pid_t;
[restart(must)] getpgrp:() -> pid_t;
[restart(must)] getsid:(pid_t pid) -> pid_t;
[restart(must)] setsid:() -> pid_t;

kill:(pid_t pid, signo_t signo) -> errno_t;
tkill:(pid_t tid, signo_t signo) -> errno_t;
tgkill:(pid_t pid, pid_t tid, signo_t signo) -> errno_t;

%[startgroup]
signal:(signo_t signo, __sigaction_sa_handler_t handler) -> __sigaction_sa_handler_t;
signalx32:(signo_t signo, __sigactionx32_sa_handler_t handler) -> __sigactionx32_sa_handler_t;
signalx64:(signo_t signo, __sigactionx64_sa_handler_t handler) -> __sigactionx64_sa_handler_t;
%[endgroup]

%[startgroup]
sigaction:(signo_t signo, [tostr(STRUCT_OLD_KERNEL_SIGACTION)] struct __old_kernel_sigaction const *act, [tostr(out:STRUCT_OLD_KERNEL_SIGACTION)] struct __old_kernel_sigaction *oact) -> errno_t;
sigactionx32:(signo_t signo, [tostr(STRUCT_OLD_KERNEL_SIGACTIONX32)] struct __old_kernel_sigactionx32 const *act, [tostr(out:STRUCT_OLD_KERNEL_SIGACTIONX32)] struct __old_kernel_sigactionx32 *oact) -> errno_t;
sigactionx64:(signo_t signo, [tostr(STRUCT_OLD_KERNEL_SIGACTIONX64)] struct __old_kernel_sigactionx64 const *act, [tostr(out:STRUCT_OLD_KERNEL_SIGACTIONX64)] struct __old_kernel_sigactionx64 *oact) -> errno_t;
%[endgroup]

%[startgroup]
rt_sigaction:(signo_t signo, [tostr(STRUCT_KERNEL_SIGACTION:sigsetsize)] struct __kernel_sigaction const *act, [tostr(out:STRUCT_KERNEL_SIGACTION:sigsetsize)] struct __kernel_sigaction *oact, size_t sigsetsize) -> errno_t;
rt_sigactionx32:(signo_t signo, [tostr(STRUCT_KERNEL_SIGACTIONX32:sigsetsize)] struct __kernel_sigactionx32 const *act, [tostr(out:STRUCT_KERNEL_SIGACTIONX32:sigsetsize)] struct __kernel_sigactionx32 *oact, size_t sigsetsize) -> errno_t;
rt_sigactionx64:(signo_t signo, [tostr(STRUCT_KERNEL_SIGACTIONX64:sigsetsize)] struct __kernel_sigactionx64 const *act, [tostr(out:STRUCT_KERNEL_SIGACTIONX64:sigsetsize)] struct __kernel_sigactionx64 *oact, size_t sigsetsize) -> errno_t;
%[endgroup]

%[startgroup]
sigaltstack:([tostr(STRUCT_SIGALTSTACK)] struct sigaltstack const *ss, [tostr(out:STRUCT_SIGALTSTACK)] struct sigaltstack *oss) -> errno_t;
sigaltstackx32:([tostr(STRUCT_SIGALTSTACKX32)] struct __sigaltstackx32 const *ss, [tostr(out:STRUCT_SIGALTSTACKX32)] struct __sigaltstackx32 *oss) -> errno_t;
sigaltstackx64:([tostr(STRUCT_SIGALTSTACKX64)] struct __sigaltstackx64 const *ss, [tostr(out:STRUCT_SIGALTSTACKX64)] struct __sigaltstackx64 *oss) -> errno_t;
%[endgroup]

alarm:(syscall_ulong_t seconds) -> syscall_ulong_t; /* UNIMPLEMENTED! */

sgetmask:() -> [tostr(SIGMASK32)] uint32_t;
ssetmask:([tostr(SIGMASK32)] uint32_t sigmask) -> [tostr(SIGMASK32)] uint32_t;

@@@param: how: One of `SIG_BLOCK', `SIG_UNBLOCK' or `SIG_SETMASK'
sigprocmask:([tostr(SIGPROCMASK_HOW)] syscall_ulong_t how,
             [tostr(STRUCT_SIGSET)] struct __old_sigset_struct const *set,
             [tostr(out:STRUCT_SIGSET)] struct __old_sigset_struct *oset) -> errno_t;

@@@param: how: One of `SIG_BLOCK', `SIG_UNBLOCK' or `SIG_SETMASK'
rt_sigprocmask:([tostr(SIGPROCMASK_HOW)] syscall_ulong_t how,
                [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set,
                [tostr(out:STRUCT_SIGSET:sigsetsize)] struct __sigset_struct *oset,
                size_t sigsetsize) -> errno_t;

@@>> set_userprocmask_address(2)
@@Register the address of  the calling thread's userprocmask  controller.
@@This also  initializes `*ctl->pm_sigmask'  and `ctl->pm_pending',  such
@@that `*ctl->pm_sigmask' is filled with the current kernel-level  signal
@@mask, as would be returned by `sigprocmask(2)', while `ctl->pm_pending'
@@is filled in with the equivalent of `sigpending(2)'
@@Additionally,  the address  of `&ctl->pm_mytid'  is stored  as an override
@@for `set_tid_address(2)', and the kernel may read from `*ctl->pm_sigmask',
@@and write to `ctl->pm_pending' (using  atomic-or for the later) from  this
@@point forth.
@@NOTE: Before calling this function, the caller must:
@@      >> bzero(ctl, sizeof(struct userprocmask));
@@      >> ctl->pm_sigsize = sizeof(sigset_t);
@@      >> ctl->pm_sigmask = &initial_sigmask;
@@      Where the initial bzero() is needed to initialize potential
@@      additional,   arch-specific   fields    to   all    zeroes.
@@NOTE: This system call will then initialize:
@@      >> ctl->pm_mytid = gettid();
@@      >> sigprocmask(0, NULL, ctl->pm_sigmask);
@@      >> sigpending(&ctl->pm_pending);
@@NOTE: Passing `NULL' for `ctl' disables userprocmask-mode, though
@@      before this is done, the kernel will copy the  `pm_sigmask'
@@      of the previously set  controller into its internal  signal
@@      mask. (i.e. the one used outside of userprocmask-mode)
@@Note though  that  `pm_sigmask'  is ignored  for  `SIGKILL'  and  `SIGSTOP'
@@Note also  that  this  function replaces  `set_tid_address(2)',  such  that
@@it negates a  prior call  to said  function, while  a future  call to  said
@@function will once again disable userprocmask, same as passing `NULL' would
set_userprocmask_address:(struct userprocmask *ctl) -> errno_t;


%[startgroup]
[cp][restart(dont)] rt_sigtimedwait:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *info, [tostr(STRUCT_TIMESPEC)] struct timespec const *timeout, size_t sigsetsize) -> syscall_slong_t;
[cp][restart(dont)] rt_sigtimedwait32:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *info, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[cp][restart(dont)] rt_sigtimedwait64:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *info, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[cp][restart(dont)] rt_sigtimedwaitx32:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *info, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[cp][restart(dont)] rt_sigtimedwaitx32_64:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *info, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *timeout, size_t sigsetsize) -> syscall_slong_t;
[cp][restart(dont)] rt_sigtimedwaitx64:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set, [tostr(out:STRUCT_SIGINFOX64)] struct __siginfox64_struct *info, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *timeout, size_t sigsetsize) -> syscall_slong_t;
%[endgroup]

%[startgroup]
@@@param: usigno: The signal that should be sent
@@@param: uinfo:  [0..1] Additional signal information
@@@throw: E_INVALID_ARGUMENT_UNEXPECTED_COMMAND:E_INVALID_ARGUMENT_CONTEXT_SIGINFO_SIGNO: [...]
@@@throw: E_INVALID_ARGUMENT_BAD_VALUE:E_INVALID_ARGUMENT_CONTEXT_BAD_SIGNO:              [...]
@@@throw: E_INVALID_ARGUMENT_BAD_VALUE:E_INVALID_ARGUMENT_CONTEXT_RAISE_SIGINFO_BADCODE:  [...]
@@@throw: E_ILLEGAL_OPERATION:                                                            [...]
rt_sigqueueinfo:(pid_t pid, signo_t usigno, [tostr(STRUCT_SIGINFO)] struct __siginfo_struct const *uinfo) -> errno_t;
[doc_alias(rt_sigqueueinfo)] rt_sigqueueinfox32:(pid_t pid, signo_t usigno, [tostr(STRUCT_SIGINFOX32)] struct __siginfox32_struct const *uinfo) -> errno_t;
[doc_alias(rt_sigqueueinfo)] rt_sigqueueinfox64:(pid_t pid, signo_t usigno, [tostr(STRUCT_SIGINFOX64)] struct __siginfox64_struct const *uinfo) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: usigno: The signal that should be sent
@@@param: uinfo:  [0..1] Additional signal information
@@@throw: E_INVALID_ARGUMENT_UNEXPECTED_COMMAND:E_INVALID_ARGUMENT_CONTEXT_SIGINFO_SIGNO: [...]
@@@throw: E_INVALID_ARGUMENT_BAD_VALUE:E_INVALID_ARGUMENT_CONTEXT_BAD_SIGNO:              [...]
@@@throw: E_INVALID_ARGUMENT_BAD_VALUE:E_INVALID_ARGUMENT_CONTEXT_RAISE_SIGINFO_BADCODE:  [...]
@@@throw: E_ILLEGAL_OPERATION:                                                            [...]
rt_tgsigqueueinfo:(pid_t pid, pid_t tid, signo_t usigno, [tostr(STRUCT_SIGINFO)] struct __siginfo_struct const *uinfo) -> errno_t;
[doc_alias(rt_tgsigqueueinfo)] rt_tgsigqueueinfox32:(pid_t pid, pid_t tid, signo_t usigno, [tostr(STRUCT_SIGINFOX32)] struct __siginfox32_struct const *uinfo) -> errno_t;
[doc_alias(rt_tgsigqueueinfo)] rt_tgsigqueueinfox64:(pid_t pid, pid_t tid, signo_t usigno, [tostr(STRUCT_SIGINFOX64)] struct __siginfox64_struct const *uinfo) -> errno_t;
%[endgroup]

%[startgroup]
@@>> rpc_schedule(2)
@@Schedule an RPC program to-be executed by some other thread. This  function
@@cannot guaranty that  the RPC  program is  always executed,  as the  target
@@thread terminate before the  conditions for the RPC  to be served are  ever
@@met. Note that these  conditions depend on the  given `mode'. Note that  on
@@multi-arch  platforms (such as  x86), the register numbers,  as well as the
@@address size used by `program' depend on the execution mode of `target_tid'
@@
@@NOTE: Only a cancellation point when `RPC_JOIN_WAITFOR' is used!
@@
@@@param: target_tid:      The TID of the targeted thread
@@@param: mode:            One of `RPC_SYNCMODE_*',  optionally or'd  with
@@                         one of `RPC_SYSRESTART_*', optionally or'd with
@@                         one of `RPC_PRIORITY_*',  optionally or'd  with
@@                         one of  `RPC_DOMAIN_*',  optionally  or'd  with
@@                         one of `RPC_JOIN_*'
@@@param: program:         The RPC program to execute (sequences of `RPC_OP_*')
@@@param: params:          RPC program parameters (for `RPC_OP_push_param')
@@@param: max_param_count: The max # of `params' used by `program'
@@
@@@return: 0 :                Success
@@@throws: E_SEGFAULT:        Faulty pointers were given
@@@throws: E_INVALID_ARGUMENT:E_INVALID_ARGUMENT_CONTEXT_RPC_SCHEDULE_MODE:
@@                            The given `mode' is invalid.
@@@throws: E_INVALID_ARGUMENT:E_INVALID_ARGUMENT_CONTEXT_RPC_PROGRAM_INSTRUCTION:
@@                            The RPC program  contains illegal  instructions.
@@                            In this case, modifications made by instructions
@@                            encountered before the illegal one(s) will still
@@                            have  happened, meaning that the target thread's
@@                            state may have become inconsistent.
@@@throws: E_PROCESS_EXITED:  The target thread has already terminated, or
@@                            doesn't exist. Note  though that unless  the
@@                            thread  is  part  of your  own  process, are
@@                            still many reasons  outside of your  control
@@                            for why it  may terminate immediately  after
@@                            the RPC program finished.
[cp] rpc_schedule:(pid_t target_tid, [tostr(RPC_SCHEDULE_MODE)] syscall_ulong_t mode, void const *program, void const *const *params, size_t max_param_count) -> errno_t;
[cp][doc_alias(rpc_schedule)] rpc_schedulex32:(pid_t target_tid, [tostr(RPC_SCHEDULE_MODE)] syscall_ulong_t mode, void const *program, [tostr(VOID_VECTOR32:max_param_count)] __HYBRID_PTR32(void const) const *params, size_t max_param_count) -> errno_t;
[cp][doc_alias(rpc_schedule)] rpc_schedulex64:(pid_t target_tid, [tostr(RPC_SCHEDULE_MODE)] syscall_ulong_t mode, void const *program, [tostr(VOID_VECTOR64:max_param_count)] __HYBRID_PTR64(void const) const *params, size_t max_param_count) -> errno_t;
%[endgroup]

@@>> rpc_serve(2)
@@Check for pending signals and RPCs. This is a wrapper around the
@@kernel `task_serve()' function, which is always invoked before a
@@thread begins waiting for a blocking operation. All system calls
@@marked as cancellation  points probably  call `task_serve()'  at
@@some point.
@@Note that unlike (say) `pause(2)', this function doesn't  block,
@@and may be used to implement `pthread_testcancel(3)' (should KOS
@@RPCs be used to facility pthread cancellation points, as done by
@@KOS's builtin libc)
@@@return: 0:      Nothing was handled.
@@@return: -EINTR: RPCs (or posix signals) were handled.
[cp][restart(dont)] rpc_serve:() -> errno_t;

@@>> rpc_serve_sysret(2)
@@Very similar to `rpc_serve(2)', but with the addition that this one
@@will only serve RPCs that can be handled in `RPC_REASONCTX_SYSRET',
@@aka. `RPC_REASONCTX_ASYNC' contexts. Additionally, this system call
@@ignores the state of the  internal `TASK_FRPC' flag, and should  be
@@invoked  when  the calling  thread  makes use  of  the userprocmask
@@mechanism, and the  signal mask became  less restrictive while  the
@@`USERPROCMASK_FLAG_HASPENDING' flag was set.
@@
@@When userprocmask is disabled, this system call is pretty much just
@@a no-op (semantically speaking, it does nothing). But when enabled,
@@it  is really only usable in conjunction with the userprocmask. The
@@exact usage can be seen in `chkuserprocmask(3)'.
@@
@@@return: 0 : Always, unconditionally returned.
[restart(dont)] rpc_serve_sysret:() -> errno_t;

sigpending:(struct __old_sigset_struct *set) -> errno_t;
rt_sigpending:([tostr(out:STRUCT_SIGSET:sigsetsize)] struct __sigset_struct *set,
               size_t sigsetsize) -> errno_t;

@@>> sigsuspend(2), rt_sigsuspend(2)
@@Atomically save and  set the caller's  signal mask to  `set', then wait  for
@@one of the unmasked (iow: `!sigismember')-signals to arrive before restoring
@@the old signal mask.
@@@param: set: The set of signals on which to wait
@@@return: -1: [errno=EINTR] The signal handler for `signo' was executed.
[cp][restart(dont)]
sigsuspend:([tostr(STRUCT_SIGSET)] struct __old_sigset_struct const *set) -> errno_t;
[cp][restart(dont)][doc_alias(sigsuspend)]
rt_sigsuspend:([tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *set,
               size_t sigsetsize) -> errno_t;

vhangup:() -> errno_t; /* UNIMPLEMENTED! */

[restart(must)][noexcept] sigreturn:();    /* UNIMPLEMENTED! */
[restart(must)][noexcept] rt_sigreturn:(); /* UNIMPLEMENTED! */

%[startgroup]
[restart(must)][noexcept]
ksigreturn:([tostr(STRUCT_UCPUSTATE)] struct ucpustate const *restore_cpu,
            [tostr(STRUCT_FPUSTATE)] struct fpustate const *restore_fpu,
            [tostr(STRUCT_SIGSET_WITH_SIZE)] struct sigset_with_size const *restore_sigmask,
            [tostr(STRUCT_RPC_SYSCALL_INFO)] struct rpc_syscall_info const *restart_sc_info);
[restart(must)][noexcept]
ksigreturnx32:([tostr(STRUCT_FPUSTATE32)] struct fpustate32 const *restore_fpu,
               [tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *restore_cpu,
               [tostr(STRUCT_SIGSET_WITH_SIZE_X32)] struct __sigset_with_sizex32 const *restore_sigmask,
               [tostr(STRUCT_RPC_SYSCALL_INFO32)] struct rpc_syscall_info32 const *restart_sc_info);
[restart(must)][noexcept]
ksigreturnx64:([tostr(STRUCT_FPUSTATE64)] struct fpustate64 const *restore_fpu,
               [tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *restore_cpu,
               [tostr(STRUCT_SIGSET_WITH_SIZE_X64)] struct __sigset_with_sizex64 const *restore_sigmask,
               [tostr(STRUCT_RPC_SYSCALL_INFO64)] struct rpc_syscall_info64 const *restart_sc_info);
%[endgroup]

@@Wait for a child process:
@@ - `pid < -1':  Wait for any child process whose process group ID is `-PID'
@@ - `pid == -1': Wait for any child process
@@ - `pid == 0':  Wait for any child process whose process group ID is that of the caller
@@ - `pid > 0':   Wait for the child whose process ID is equal to `PID'
@@@param: options: Set of `WNOHANG | WUNTRACED | WCONTINUED' (as a KOS extension, `WNOWAIT' is also accepted)
[cp][restart(dont)]
waitpid:(pid_t pid, int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options) -> pid_t;

@@>> detach(2)
@@Detach the descriptor of `PID' from the thread that
@@would have received a signal when it changes state,
@@as well as prevent the  thread from turning into  a
@@zombie once it dies.
@@For simplicity, think of it like this:
@@  - pthread_create()  -->  clone()
@@  - pthread_join()    -->  wait()
@@  - pthread_detach()  -->  detach()  // Linux's missing link, now implemented
@@A total of 4 special cases exists to alter the behavior of this function:
@@  - PID == 0 || PID == gettid():
@@    Detach the calling  thread from  the set of  running children  within
@@    its own process.  Note however  that when this  is done  by the  main
@@    thread of the process, gettid() will equal getpid(), and the behavior
@@    will be different.
@@  - PID == getpid():
@@    Detach the calling process from its parent, essentially daemonizing
@@    the  calling   process   the   same  way   a   double-fork   would:
@@    >> if (fork() == 0) {
@@    >> 	if (fork() == 0) {
@@    >> 		// This is a daemonized process
@@    >> 		// aka. the parent process no longer knows
@@    >> 		// about us, and also can't wait(2) on us.
@@    >> 		...
@@    >> 	}
@@    >> 	exit(0);
@@    >> }
@@    Same as:
@@    >> if (fork() == 0) {
@@    >> 	detach(0); // or `detach(getpid())', since 0 --> gettid() and gettid() == getpid()
@@    >> 	// This is a daemonized process
@@    >> 	// aka. the parent process no longer knows
@@    >> 	// about us, and also can't wait(2) on us.
@@    >> 	...
@@    >> }
@@  - PID == -1:
@@    Detach all child processes/threads  of the calling process,  essentially
@@    turning its chain of children into a clean slate that no longer contains
@@    any wait(2)able child threads or processes.
@@    If no waitable children existed, `ECHILD' is set; else `0' is returned.
@@The given `pid' must be:
@@  - A thread without the caller's process
@@  - A child process of the caller's process
@@NOTE: If a thread is created using clone() with `CLONE_DETACHED' set,
@@      it will behave effectively as though this function had  already
@@      be called.
@@@return: -ECHILD:         `PID' was equal to `-1', but no waitable children existed
@@@throw: E_PROCESS_EXITED: No such  thread/process exists,  or  the thread  isn't  isn't
@@                          a thread in your process, or a child process of your process.
[restart(must)] detach:(pid_t pid) -> errno_t;

%[startgroup]
@@@param: idtype:  One of `P_ALL', `P_PID', `P_PGID'
@@@param: options: At least one of `WEXITED', `WSTOPPED', `WCONTINUED', optionally or'd with `WNOHANG | WNOWAIT'
[cp][restart(dont)]
waitid:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, struct __siginfo_struct *infop,
        [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE)] struct rusage *ru) -> errno_t;
[cp][restart(dont)][doc_alias(waitid)] waitid32:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *infop, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *ru) -> errno_t;
[cp][restart(dont)][doc_alias(waitid)] waitid64:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFO)] struct __siginfo_struct *infop, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *ru) -> errno_t;
[cp][restart(dont)][doc_alias(waitid)] waitidx32:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *infop, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *ru) -> errno_t;
[cp][restart(dont)][doc_alias(waitid)] waitidx32_64:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFOX32)] struct __siginfox32_struct *infop, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *ru) -> errno_t;
[cp][restart(dont)][doc_alias(waitid)] waitidx64:([tostr(IDTYPE_T)] syscall_ulong_t idtype, [tostr(ID_T:idtype)] id_t id, [tostr(out:STRUCT_SIGINFOX64)] struct __siginfox64_struct *infop, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *ru) -> errno_t;
%[endgroup]

%[startgroup]
@@Same as `waitpid(pid, STAT_LOC, OPTIONS)', though also fills in `USAGE' when non-NULL
@@@param: options: Set of `WNOHANG | WUNTRACED | WCONTINUED' (as a KOS extension, `WNOWAIT' is also accepted)
[cp][restart(dont)] wait4:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE)] struct rusage *usage) -> pid_t;
[cp][doc_alias(wait4)][restart(dont)] wait4_32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *usage) -> pid_t;
[cp][doc_alias(wait4)][restart(dont)] wait4_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *usage) -> pid_t;
[cp][doc_alias(wait4)][restart(dont)] wait4_x32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *usage) -> pid_t;
[cp][doc_alias(wait4)][restart(dont)] wait4_x32_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *usage) -> pid_t;
[cp][doc_alias(wait4)][restart(dont)] wait4_x64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *usage) -> pid_t;
%[endgroup]

%[startgroup]
@@@param: options: Set of `WNOHANG | WUNTRACED | WCONTINUED'
[cp][restart(dont)] oldwait4:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE)] struct rusage *usage) -> pid_t;                                         /* UNIMPLEMENTED! */
[cp][doc_alias(oldwait4)][restart(dont)] oldwait4_32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *usage) -> pid_t;             /* UNIMPLEMENTED! */
[cp][doc_alias(oldwait4)][restart(dont)] oldwait4_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *usage) -> pid_t;             /* UNIMPLEMENTED! */
[cp][doc_alias(oldwait4)][restart(dont)] oldwait4_x32:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *usage) -> pid_t;          /* UNIMPLEMENTED! */
[cp][doc_alias(oldwait4)][restart(dont)] oldwait4_x32_64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *usage) -> pid_t; /* UNIMPLEMENTED! */
[cp][doc_alias(oldwait4)][restart(dont)] oldwait4_x64:(pid_t pid, [tostr(out:UNION_WAIT)] int32_t *stat_loc, [tostr(WAITFLAGS)] syscall_ulong_t options, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *usage) -> pid_t;          /* UNIMPLEMENTED! */
%[endgroup]





/************************************************************************/
/* Scheduler functions                                                  */
/************************************************************************/
%[startgroup]
[cp][restart(dont)] nanosleep:([tostr(STRUCT_TIMESPEC)] struct timespec const *req, [tostr(out:STRUCT_TIMESPEC)] struct timespec *rem) -> errno_t;
[cp][restart(dont)] nanosleep32:([tostr(STRUCT_TIMESPEC32)] struct timespec32 const *req, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *rem) -> errno_t;
[cp][restart(dont)] nanosleep64:([tostr(STRUCT_TIMESPEC64)] struct timespec64 const *req, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *rem) -> errno_t;
[cp][restart(dont)] nanosleepx32:([tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *req, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *rem) -> errno_t;
[cp][restart(dont)] nanosleepx32_64:([tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *req, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *rem) -> errno_t;
[cp][restart(dont)] nanosleepx64:([tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *req, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *rem) -> errno_t;
%[endgroup]

getcpu:([tostr(out:UINT32_T)] uint32_t *cpu,
        [tostr(out:UINT32_T)] uint32_t *node,
        [tostr(out:STRUCT_GETCPU_CACHE)] struct getcpu_cache *tcache) -> errno_t; /* UNIMPLEMENTED! */

sched_setaffinity:(pid_t pid, size_t cpusetsize, [tostr(CPUSET:cpusetsize)] struct __cpu_set_struct const *cpuset) -> errno_t; /* UNIMPLEMENTED! */
sched_getaffinity:(pid_t pid, size_t cpusetsize, [tostr(out:CPUSET:cpusetsize)] struct __cpu_set_struct *cpuset) -> errno_t;   /* UNIMPLEMENTED! */

nice:(syscall_slong_t inc) -> errno_t; /* UNIMPLEMENTED! */

@@@param: which: One of `PRIO_PROCESS', `PRIO_PGRP' or `PRIO_USER'
getpriority:([tostr(SCHED_PRIORITY_WHICH)] syscall_ulong_t which, id_t who) -> syscall_slong_t; /* UNIMPLEMENTED! */

@@@param: which: One of `PRIO_PROCESS', `PRIO_PGRP' or `PRIO_USER'
setpriority:([tostr(SCHED_PRIORITY_WHICH)] syscall_ulong_t which, id_t who, syscall_ulong_t value) -> errno_t; /* UNIMPLEMENTED! */

sched_setparam:(pid_t pid, [tostr(STRUCT_SCHED_PARAM)] struct sched_param const *param) -> errno_t; /* UNIMPLEMENTED! */
sched_getparam:(pid_t pid, [tostr(out:STRUCT_SCHED_PARAM)] struct sched_param *param) -> errno_t;   /* UNIMPLEMENTED! */

@@@param: policy: One of `SCHED_OTHER', `SCHED_FIFO', `SCHED_RR', `SCHED_BATCH',
@@                `SCHED_IDLE',  optionally   or'd  with   `SCHED_RESET_ON_FORK'
sched_setscheduler:(pid_t pid, [tostr(SCHED_POLICY)] syscall_ulong_t policy,
                    [tostr(STRUCT_SCHED_PARAM)] struct sched_param const *param) -> errno_t; /* UNIMPLEMENTED! */
sched_getscheduler:(pid_t pid) -> [tostr(SCHED_POLICY)] syscall_slong_t; /* UNIMPLEMENTED! */

[restart(dont)] sched_yield:() -> errno_t;
sched_get_priority_max:([tostr(SCHED_POLICY)] syscall_ulong_t algorithm) -> syscall_slong_t; /* UNIMPLEMENTED! */
sched_get_priority_min:([tostr(SCHED_POLICY)] syscall_ulong_t algorithm) -> syscall_slong_t; /* UNIMPLEMENTED! */

%[startgroup]
sched_rr_get_interval:(pid_t pid, [tostr(out:STRUCT_TIMESPEC)] struct timespec *ts) -> errno_t;                   /* UNIMPLEMENTED! */
sched_rr_get_interval32:(pid_t pid, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *ts) -> errno_t;             /* UNIMPLEMENTED! */
sched_rr_get_interval64:(pid_t pid, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *ts) -> errno_t;             /* UNIMPLEMENTED! */
sched_rr_get_intervalx32:(pid_t pid, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *ts) -> errno_t;          /* UNIMPLEMENTED! */
sched_rr_get_intervalx32_64:(pid_t pid, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *ts) -> errno_t; /* UNIMPLEMENTED! */
sched_rr_get_intervalx64:(pid_t pid, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *ts) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]





/************************************************************************/
/* Time                                                                 */
/************************************************************************/
%[startgroup]
time:(time32_t *timer) -> time32_t;
time32:(time32_t *timer) -> time32_t;
time64:(time64_t *timer) -> [reg64] time64_t;
timex32:(int32_t *timer) -> [tostr(TIME_T)] int32_t;
timex64:(int64_t *timer) -> [reg64][tostr(TIME_T)] int64_t;
%[endgroup]

%[startgroup]
gettimeofday:([tostr(out:STRUCT_TIMEVAL)] struct timeval *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofday32:([tostr(out:STRUCT_TIMEVAL32)] struct timeval32 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofday64:([tostr(out:STRUCT_TIMEVAL64)] struct timeval64 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofdayx32:([tostr(out:STRUCT_TIMEVALX32)] struct timevalx32 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofdayx32_64:([tostr(out:STRUCT_TIMEVALX32_64)] struct timevalx32_64 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
gettimeofdayx64:([tostr(out:STRUCT_TIMEVALX64)] struct timevalx64 *tv, [tostr(out:STRUCT_TIMEZONE)] struct timezone *tz) -> errno_t;
%[endgroup]

%[startgroup]
settimeofday:([tostr(STRUCT_TIMEVAL)] struct timeval const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;                   /* UNIMPLEMENTED! */
settimeofday32:([tostr(STRUCT_TIMEVAL32)] struct timeval32 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;             /* UNIMPLEMENTED! */
settimeofday64:([tostr(STRUCT_TIMEVAL64)] struct timeval64 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;             /* UNIMPLEMENTED! */
settimeofdayx32:([tostr(STRUCT_TIMEVALX32)] struct timevalx32 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;          /* UNIMPLEMENTED! */
settimeofdayx32_64:([tostr(STRUCT_TIMEVALX32_64)] struct timevalx32_64 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t; /* UNIMPLEMENTED! */
settimeofdayx64:([tostr(STRUCT_TIMEVALX64)] struct timevalx64 const *tv, [tostr(STRUCT_TIMEZONE)] struct timezone const *tz) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
stime:([tostr(TIME32_T_PTR)] time32_t const *t) -> errno_t;   /* UNIMPLEMENTED! */
stime32:([tostr(TIME32_T_PTR)] time32_t const *t) -> errno_t;   /* UNIMPLEMENTED! */
stime64:([tostr(TIME64_T_PTR)] time64_t const *t) -> errno_t; /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
adjtimex:(struct timex *ntx) -> errno_t;
adjtimex32:(struct timex32 *ntx) -> errno_t;
adjtimex64:(struct timex64 *ntx) -> errno_t;
adjtimexx32:(struct timexx32 *ntx) -> errno_t;
adjtimexx32_64:(struct timexx32_64 *ntx) -> errno_t;
adjtimexx64:(struct timexx64 *ntx) -> errno_t;
%[endgroup]

%[startgroup]
ftime:([tostr(out:STRUCT_TIMEB)] struct timeb *tp) -> errno_t;
ftime32:([tostr(out:STRUCT_TIMEB32)] struct timeb32 *tp) -> errno_t;
ftime64:([tostr(out:STRUCT_TIMEB64)] struct timeb64 *tp) -> errno_t;
ftimex32:([tostr(out:STRUCT_TIMEBX32)] struct timebx32 *tp) -> errno_t;
ftimex32_64:([tostr(out:STRUCT_TIMEBX32_64)] struct timebx32_64 *tp) -> errno_t;
ftimex64:([tostr(out:STRUCT_TIMEBX64)] struct timebx64 *tp) -> errno_t;
%[endgroup]

%[startgroup]
times:([tostr(out:STRUCT_TMS)] struct tms *buf) -> clock_t;          /* UNIMPLEMENTED! */
timesx32:([tostr(out:STRUCT_TMSX32)] struct tmsx32 *buf) -> clock_t; /* UNIMPLEMENTED! */
timesx64:([tostr(out:STRUCT_TMSX64)] struct tmsx64 *buf) -> clock_t; /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
[cp] sysinfo:([tostr(out:STRUCT_SYSINFO)] struct sysinfo *info) -> errno_t;
[cp] sysinfox32:([tostr(out:STRUCT_SYSINFO)] struct __sysinfox32 *info) -> errno_t;
[cp] sysinfox64:([tostr(out:STRUCT_SYSINFO)] struct __sysinfox64 *info) -> errno_t;
%[endgroup]







/************************************************************************/
/* Clock                                                                */
/************************************************************************/
%[startgroup]
clock_settime:(clockid_t clock_id, [tostr(STRUCT_TIMESPEC)] struct timespec const *tp) -> errno_t;                   /* UNIMPLEMENTED! */
clock_settime32:(clockid_t clock_id, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *tp) -> errno_t;             /* UNIMPLEMENTED! */
clock_settime64:(clockid_t clock_id, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *tp) -> errno_t;             /* UNIMPLEMENTED! */
clock_settimex32:(clockid_t clock_id, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *tp) -> errno_t;          /* UNIMPLEMENTED! */
clock_settimex32_64:(clockid_t clock_id, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *tp) -> errno_t; /* UNIMPLEMENTED! */
clock_settimex64:(clockid_t clock_id, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *tp) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
clock_gettime:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC)] struct timespec *tp) -> errno_t;
clock_gettime32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *tp) -> errno_t;
clock_gettime64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *tp) -> errno_t;
clock_gettimex32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *tp) -> errno_t;
clock_gettimex32_64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *tp) -> errno_t;
clock_gettimex64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *tp) -> errno_t;
%[endgroup]

%[startgroup]
clock_getres:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC)] struct timespec *res) -> errno_t;
clock_getres32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *res) -> errno_t;
clock_getres64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *res) -> errno_t;
clock_getresx32:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *res) -> errno_t;
clock_getresx32_64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *res) -> errno_t;
clock_getresx64:(clockid_t clock_id, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *res) -> errno_t;
%[endgroup]

%[startgroup]
@@>> clock_nanosleep(2), clock_nanosleep64(2)
@@High-resolution sleep with the specified clock
@@@param: clock_id: One of `CLOCK_REALTIME, CLOCK_TAI, CLOCK_MONOTONIC, CLOCK_BOOTTIME, CLOCK_PROCESS_CPUTIME_ID'
@@                  Other clock IDs cannot be used with this system call!
@@@param: flags:    Set of `0 | TIMER_ABSTIME'
[cp][restart(dont)] clock_nanosleep:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPEC)] struct timespec const *requested_time, [tostr(out:STRUCT_TIMESPEC)] struct timespec *remaining) -> errno_t;
[cp][restart(dont)] clock_nanosleep32:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *requested_time, [tostr(out:STRUCT_TIMESPEC32)] struct timespec32 *remaining) -> errno_t;
[cp][restart(dont)] clock_nanosleep64:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *requested_time, [tostr(out:STRUCT_TIMESPEC64)] struct timespec64 *remaining) -> errno_t;
[cp][restart(dont)] clock_nanosleepx32:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *requested_time, [tostr(out:STRUCT_TIMESPECX32)] struct timespecx32 *remaining) -> errno_t;
[cp][restart(dont)] clock_nanosleepx32_64:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *requested_time, [tostr(out:STRUCT_TIMESPECX32_64)] struct timespecx32_64 *remaining) -> errno_t;
[cp][restart(dont)] clock_nanosleepx64:(clockid_t clock_id, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *requested_time, [tostr(out:STRUCT_TIMESPECX64)] struct timespecx64 *remaining) -> errno_t;
%[endgroup]





/************************************************************************/
/* Epoll                                                                */
/************************************************************************/
@@>> epoll_create(2)
@@Deprecated alias for `epoll_create1(0)' (the `size' argument is ignored)
@@@return: * : The newly created epoll control descriptor.
@@@return: -1: Error (s.a. `errno')
epoll_create:(syscall_ulong_t size) -> fd_t;

@@>> epoll_create1(2)
@@Create  a new epoll control descriptor which can be used for
@@monitoring of pollable events happening in registered files.
@@@param: flags: Set of `EPOLL_CLOEXEC | EPOLL_CLOFORK'
@@@return: * :   The newly created epoll control descriptor.
@@@throw: E_INVALID_ARGUMENT_UNKNOWN_FLAG:E_INVALID_ARGUMENT_CONTEXT_EPOLL_CREATE1_FLAGS: [...]
epoll_create1:([tostr(EPOLL_CREATE1_FLAGS)] syscall_ulong_t flags) -> fd_t;


@@>> epoll_ctl(2)
@@Manipulate a given  epoll controller  `epfd', as previously  returned by  `epoll_create1(2)'
@@in order to register (`EPOLL_CTL_ADD'), remove (`EPOLL_CTL_DEL') or modify (`EPOLL_CTL_MOD')
@@the file descriptors being monitored
@@@param: op:       One of `EPOLL_CTL_ADD', `EPOLL_CTL_DEL' or `EPOLL_CTL_MOD'
@@@param: fd:       The file descriptor to add/remove/modify
@@@param: info:     The new configuration for `fd' (ignored when `op' is `EPOLL_CTL_DEL')
@@@return: 0 :      Success
@@@return: -EEXIST: [op=EPOLL_CTL_ADD] The given `fd' (and its kernel object) has already been registered
@@@return: -ENOENT: [op=EPOLL_CTL_MOD|EPOLL_CTL_DEL] The given `fd' (and its kernel object) aren't registered
@@@throw: E_ILLEGAL_REFERENCE_LOOP: The  given  `fd'  is  another  epoll  that either
@@                                  forms a loop with `epfd', or has too many nested.
@@@throw: E_INVALID_ARGUMENT_UNKNOWN_COMMAND:E_INVALID_ARGUMENT_CONTEXT_EPOLL_CTL_OP: [...]
epoll_ctl:(fd_t epfd, [tostr(EPOLL_OP)] syscall_ulong_t op, fd_t fd,
           [tostr(STRUCT_EPOLL_EVENT)] struct epoll_event *info) -> errno_t;

[doc_alias(epoll_ctl)]
epoll_ctl_old:(fd_t epfd, [tostr(EPOLL_OP)] syscall_ulong_t op, fd_t fd,
               [tostr(STRUCT_EPOLL_EVENT)] struct epoll_event *info) -> errno_t;

@@>> epoll_wait(2)
@@Wait until at least one of the conditions monitored by `epfd' to be met.
@@@param: epfd:      The epoll controller on which to wait.
@@@param: events:    A buffer where the kernel can store information on the
@@                   events that actually took place.
@@@param: maxevents: The # of events that can be stored in `events' (must be >= 1)
@@@param: timeout:   The max amount of time (in milliseconds) before  returning
@@                   in the case where no event occurred in the mean time. When
@@                   set to `-1', wait indefinitely
@@@return: >= 1:     The # of events that happened (written to the first `return'
@@                   items of `events')
@@@return: 0:        No events happened before `timeout' expired.
@@@return: -1:       Error (s.a. `errno')
[cp][restart(dont)]
epoll_wait:(fd_t epfd, [tostr(out:STRUCT_EPOLL_EVENTS:maxevents)] struct epoll_event *events,
            size_t maxevents, syscall_slong_t timeout) -> ssize_t;
[cp][restart(dont)][doc_alias(epoll_wait)]
epoll_wait_old:(fd_t epfd, [tostr(out:STRUCT_EPOLL_EVENTS:maxevents)] struct epoll_event *events,
                size_t maxevents, syscall_slong_t timeout) -> ssize_t;

@@>> epoll_pwait(2)
@@Same as `epoll_wait(2)', but change the calling thread's signal mask to `ss' while
@@waiting.  Wait until at least one of the conditions monitored by `epfd' to be met.
@@@param: epfd:      The epoll controller on which to wait.
@@@param: events:    A buffer where the kernel can store information on the
@@                   events that actually took place.
@@@param: maxevents: The # of events that can be stored in `events' (must be >= 1)
@@@param: timeout:   The max amount of time (in milliseconds) before  returning
@@                   in the case where no event occurred in the mean time. When
@@                   set to `-1', wait indefinitely
@@@param: ss:        The signal mask to apply while waiting for an event to happen.
@@@return: >= 1:     The # of events that happened (written to the first `return'
@@                   items of `events')
@@@return: 0:        No events happened before `timeout' expired.
@@@return: -1:       Error (s.a. `errno')
[cp][restart(dont)]
epoll_pwait:(fd_t epfd, [tostr(out:STRUCT_EPOLL_EVENTS:maxevents)] struct epoll_event *events, size_t maxevents,
             syscall_slong_t timeout, [tostr(STRUCT_SIGSET:sigsetsize)] struct __sigset_struct const *ss, size_t sigsetsize) -> ssize_t;





/************************************************************************/
/* PidFd                                                                */
/************************************************************************/
@@Return a `HANDLE_TYPE_PIDFD' handle for the given `pid'
@@This system call exists for compatibility with linux, which does not  allow
@@this call to succeed when `pid' isn't a process leader (i.e. main() thread)
@@@param: flags: Must always be `0' (for now)
@@@return: * :   A handle for the process `pid'
@@@throw: E_PROCESS_EXITED:                                                                 [...]
@@@throw: E_INVALID_ARGUMENT_RESERVED_ARGUMENT:E_INVALID_ARGUMENT_CONTEXT_PIDFD_OPEN_FLAGS: [...]
@@@throw: E_BADALLOC_INSUFFICIENT_HANDLE_NUMBERS:                                           [...]
pidfd_open:(pid_t pid, syscall_ulong_t flags) -> fd_t;

@@Duplicate the  handle  of  a  foreign  process into  a  handle  for  the  caller.
@@This system call duplicates the functionality of `open("/proc/[pid]/fd/[fdno]")',
@@which may also be used to duplicate file handles from another process.
@@@param: pidfd: A `HANDLE_TYPE_PIDFD'-handle
@@@param: fd:    The FD-number of the handle to clone
@@@param: flags: Must always be `0' (for now)
@@@return: * :   The duplicated handle number
@@@throw: E_PROCESS_EXITED:                                                                  [...]
@@@throw: E_INVALID_ARGUMENT_RESERVED_ARGUMENT:E_INVALID_ARGUMENT_CONTEXT_PIDFD_GETFD_FLAGS: [...]
@@@throw: E_BADALLOC_INSUFFICIENT_HANDLE_NUMBERS:                                            [...]
@@@throw: E_INVALID_HANDLE_FILE:                                                             [...]
@@@throw: E_ILLEGAL_OPERATION:                                                               [...]
pidfd_getfd:(fd_t pidfd, fd_t foreign_fd, syscall_ulong_t flags) -> fd_t;

%[startgroup]
@@Send a signal to the process of a given pidfd
@@@param: pidfd:  A `HANDLE_TYPE_PIDFD'-handle
@@@param: usigno: The signal that should be sent
@@@param: uinfo:  [0..1] Additional signal information
@@@param: flags:  Must always be `0' (for now)
@@@throw: E_PROCESS_EXITED:                                                                  [...]
@@@throw: E_INVALID_ARGUMENT_RESERVED_ARGUMENT:E_INVALID_ARGUMENT_CONTEXT_PIDFD_GETFD_FLAGS: [...]
@@@throw: E_INVALID_ARGUMENT_UNEXPECTED_COMMAND:E_INVALID_ARGUMENT_CONTEXT_SIGINFO_SIGNO:    [...]
@@@throw: E_INVALID_ARGUMENT_BAD_VALUE:E_INVALID_ARGUMENT_CONTEXT_BAD_SIGNO:                 [...]
@@@throw: E_INVALID_ARGUMENT_BAD_VALUE:E_INVALID_ARGUMENT_CONTEXT_RAISE_SIGINFO_BADCODE:     [...]
@@@throw: E_INVALID_HANDLE_FILE:                                                             [...]
@@@throw: E_ILLEGAL_OPERATION:                                                               [...]
pidfd_send_signal:(fd_t pidfd, signo_t usigno, struct __siginfo_struct const *uinfo, syscall_ulong_t flags) -> errno_t;
[doc_alias(pidfd_send_signal)] pidfd_send_signalx32:(fd_t pidfd, signo_t usigno, struct __siginfox32_struct const *uinfo, syscall_ulong_t flags) -> errno_t;
[doc_alias(pidfd_send_signal)] pidfd_send_signalx64:(fd_t pidfd, signo_t usigno, struct __siginfox64_struct const *uinfo, syscall_ulong_t flags) -> errno_t;
%[endgroup]





/************************************************************************/
/* ITimer                                                               */
/************************************************************************/
%[startgroup]
@@@param: which: One of `ITIMER_REAL', `ITIMER_VIRTUAL' or `ITIMER_PROF'
setitimer:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVAL)] struct itimerval const *newval, struct itimerval *oldval) -> errno_t;                                                 /* UNIMPLEMENTED! */
[doc_alias(setitimer)] setitimer32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVAL32)] struct __itimerval32 const *newval, struct __itimerval32 *oldval) -> errno_t;              /* UNIMPLEMENTED! */
[doc_alias(setitimer)] setitimer64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVAL64)] struct __itimerval64 const *newval, struct __itimerval64 *oldval) -> errno_t;              /* UNIMPLEMENTED! */
[doc_alias(setitimer)] setitimerx32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVALX32)] struct __itimervalx32 const *newval, struct __itimervalx32 *oldval) -> errno_t;          /* UNIMPLEMENTED! */
[doc_alias(setitimer)] setitimerx64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVALX32_64)] struct __itimervalx64 const *newval, struct __itimervalx64 *oldval) -> errno_t;       /* UNIMPLEMENTED! */
[doc_alias(setitimer)] setitimerx32_64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(STRUCT_ITIMERVALX64)] struct __itimervalx32_64 const *newval, struct __itimervalx32_64 *oldval) -> errno_t; /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
@@@param: which: One of `ITIMER_REAL', `ITIMER_VIRTUAL' or `ITIMER_PROF'
getitimer:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVAL)] struct itimerval *curr_value) -> errno_t;                                            /* UNIMPLEMENTED! */
[doc_alias(getitimer)] getitimer32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVAL32)] struct __itimerval32 *curr_value) -> errno_t;             /* UNIMPLEMENTED! */
[doc_alias(getitimer)] getitimer64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVAL64)] struct __itimerval64 *curr_value) -> errno_t;             /* UNIMPLEMENTED! */
[doc_alias(getitimer)] getitimerx32:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVALX32)] struct __itimervalx32 *curr_value) -> errno_t;          /* UNIMPLEMENTED! */
[doc_alias(getitimer)] getitimerx32_64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVALX32_64)] struct __itimervalx32_64 *curr_value) -> errno_t; /* UNIMPLEMENTED! */
[doc_alias(getitimer)] getitimerx64:([tostr(ITIMER_WHICH)] syscall_ulong_t which, [tostr(out:STRUCT_ITIMERVALX64)] struct __itimervalx64 *curr_value) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]





/************************************************************************/
/* TimerFd                                                              */
/************************************************************************/
@@Return file descriptor for new interval timer source
@@@param: flags: Set of `0 | TFD_NONBLOCK | TFD_CLOEXEC | TFD_CLOFORK'
timerfd_create:(clockid_t clock_id, [tostr(TIMERFD_FLAGS)] syscall_ulong_t flags) -> fd_t; /* UNIMPLEMENTED! */

%[startgroup]
@@Set next expiration time of interval timer source `timerfd' to `utmr'.
@@If `flags'  has the  `TFD_TIMER_ABSTIME' flag  set the  timeout  value
@@is absolute. Optionally return the old expiration time in `otmr'
@@@param: flags: Set of `0 | TFD_TIMER_ABSTIME'
timerfd_settime:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC)] struct itimerspec const *utmr, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *otmr) -> errno_t;                                                            /* UNIMPLEMENTED! */
[doc_alias(timerfd_settime)] timerfd_settime32:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC32)] struct itimerspec32 const *utmr, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *otmr) -> errno_t;                     /* UNIMPLEMENTED! */
[doc_alias(timerfd_settime)] timerfd_settime64:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC64)] struct itimerspec64 const *utmr, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *otmr) -> errno_t;                     /* UNIMPLEMENTED! */
[doc_alias(timerfd_settime)] timerfd_settimex32:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32)] struct itimerspecx32 const *utmr, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *otmr) -> errno_t;                /* UNIMPLEMENTED! */
[doc_alias(timerfd_settime)] timerfd_settimex32_64:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 const *utmr, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *otmr) -> errno_t; /* UNIMPLEMENTED! */
[doc_alias(timerfd_settime)] timerfd_settimex64:(fd_t timerfd, [tostr(TIMERFD_TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX64)] struct itimerspecx64 const *utmr, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *otmr) -> errno_t;                /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
@@Return the next expiration time of UFD
timerfd_gettime:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *otmr) -> errno_t;                                                /* UNIMPLEMENTED! */
[doc_alias(timerfd_gettime)] timerfd_gettime32:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *otmr) -> errno_t;             /* UNIMPLEMENTED! */
[doc_alias(timerfd_gettime)] timerfd_gettime64:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *otmr) -> errno_t;             /* UNIMPLEMENTED! */
[doc_alias(timerfd_gettime)] timerfd_gettimex32:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *otmr) -> errno_t;          /* UNIMPLEMENTED! */
[doc_alias(timerfd_gettime)] timerfd_gettimex32_64:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *otmr) -> errno_t; /* UNIMPLEMENTED! */
[doc_alias(timerfd_gettime)] timerfd_gettimex64:(fd_t timerfd, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *otmr) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]





/************************************************************************/
/* Timer                                                                */
/************************************************************************/
timer_create:(clockid_t clock_id,
              [tostr(out:STRUCT_SIGEVENT)] struct sigevent *evp,
              [tostr(out:TIMER_T)] timer_t *timerid) -> errno_t; /* UNIMPLEMENTED! */

%[startgroup]
@@@param: flags: Set of `0 | TIMER_ABSTIME'
timer_settime:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC)] struct itimerspec const *value, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *ovalue) -> errno_t;                                                          /* UNIMPLEMENTED! */
[doc_alias(timer_settime)] timer_settime32:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC32)] struct itimerspec32 const *value, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *ovalue) -> errno_t;                     /* UNIMPLEMENTED! */
[doc_alias(timer_settime)] timer_settime64:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPEC64)] struct itimerspec64 const *value, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *ovalue) -> errno_t;                     /* UNIMPLEMENTED! */
[doc_alias(timer_settime)] timer_settimex32:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32)] struct itimerspecx32 const *value, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *ovalue) -> errno_t;                /* UNIMPLEMENTED! */
[doc_alias(timer_settime)] timer_settimex32_64:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 const *value, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *ovalue) -> errno_t; /* UNIMPLEMENTED! */
[doc_alias(timer_settime)] timer_settimex64:(timer_t timerid, [tostr(TIMER_FLAGS)] syscall_ulong_t flags, [tostr(STRUCT_ITIMERSPECX64)] struct itimerspecx64 const *value, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *ovalue) -> errno_t;                /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
timer_gettime:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPEC)] struct itimerspec *value) -> errno_t;                   /* UNIMPLEMENTED! */
timer_gettime32:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPEC32)] struct itimerspec32 *value) -> errno_t;             /* UNIMPLEMENTED! */
timer_gettime64:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPEC64)] struct itimerspec64 *value) -> errno_t;             /* UNIMPLEMENTED! */
timer_gettimex32:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPECX32)] struct itimerspecx32 *value) -> errno_t;          /* UNIMPLEMENTED! */
timer_gettimex32_64:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPECX32_64)] struct itimerspecx32_64 *value) -> errno_t; /* UNIMPLEMENTED! */
timer_gettimex64:(timer_t timerid, [tostr(out:STRUCT_ITIMERSPECX64)] struct itimerspecx64 *value) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]

timer_getoverrun:(timer_t timerid) -> syscall_slong_t; /* UNIMPLEMENTED! */
timer_delete:(timer_t timerid) -> errno_t;             /* UNIMPLEMENTED! */





/************************************************************************/
/* M-Queue                                                              */
/************************************************************************/
mq_open:(char const *name, oflag_t oflags, [tostr(MODE_T:oflags)] mode_t mode) -> fd_t; /* UNIMPLEMENTED! */
mq_unlink:(char const *name) -> errno_t;                                                /* UNIMPLEMENTED! */

%[startgroup]
[cp] mq_timedsend:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPEC)] struct timespec const *abs_timeout) -> errno_t;                   /* UNIMPLEMENTED! */
[cp] mq_timedsend32:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *abs_timeout) -> errno_t;             /* UNIMPLEMENTED! */
[cp] mq_timedsend64:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *abs_timeout) -> errno_t;             /* UNIMPLEMENTED! */
[cp] mq_timedsendx32:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *abs_timeout) -> errno_t;          /* UNIMPLEMENTED! */
[cp] mq_timedsendx32_64:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *abs_timeout) -> errno_t; /* UNIMPLEMENTED! */
[cp] mq_timedsendx64:(fd_t mqdes, [tostr(BUFFER:msg_len)] char const *msg_ptr, size_t msg_len, uint32_t msg_prio, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *abs_timeout) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]

%[startgroup]
[cp] mq_timedreceive:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPEC)] struct timespec const *abs_timeout) -> ssize_t;                   /* UNIMPLEMENTED! */
[cp] mq_timedreceive32:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *abs_timeout) -> ssize_t;             /* UNIMPLEMENTED! */
[cp] mq_timedreceive64:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *abs_timeout) -> ssize_t;             /* UNIMPLEMENTED! */
[cp] mq_timedreceivex32:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *abs_timeout) -> ssize_t;          /* UNIMPLEMENTED! */
[cp] mq_timedreceivex32_64:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *abs_timeout) -> ssize_t; /* UNIMPLEMENTED! */
[cp] mq_timedreceivex64:(fd_t mqdes, [tostr(out:BUFFER:msg_len:return)] char *msg_ptr, size_t msg_len, [tostr(out:UINT32_T)] uint32_t *pmsg_prio, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *abs_timeout) -> ssize_t;          /* UNIMPLEMENTED! */
%[endgroup]

mq_notify:(fd_t mqdes, [tostr(STRUCT_SIGEVENT)] struct sigevent const *notification) -> errno_t; /* UNIMPLEMENTED! */
mq_getsetattr:(fd_t mqdes, [tostr(STRUCT_MQ_ATTR)] struct mq_attr const *newattr,
               [tostr(out:STRUCT_MQ_ATTR)] struct mq_attr *oldattr) -> errno_t; /* UNIMPLEMENTED! */





/************************************************************************/
/* Resource/Premission control                                          */
/************************************************************************/
%[startgroup]
@@@param: resource: One of `RLIMIT_*' from <sys/resource.h>
getrlimit:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(out:STRUCT_RLIMIT)] struct rlimit *rlimits) -> errno_t;
[doc_alias(getrlimit)] getrlimit32:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(out:STRUCT_RLIMIT32)] struct rlimit32 *rlimits) -> errno_t;
[doc_alias(getrlimit)] getrlimit64:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(out:STRUCT_RLIMIT64)] struct rlimit64 *rlimits) -> errno_t;
[doc_alias(getrlimit)] getrlimitx32:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(out:STRUCT_RLIMITX32)] struct rlimitx32 *rlimits) -> errno_t;
[doc_alias(getrlimit)] getrlimitx32_64:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(out:STRUCT_RLIMITX32_64)] struct rlimitx32_64 *rlimits) -> errno_t;
[doc_alias(getrlimit)] getrlimitx64:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(out:STRUCT_RLIMITX64)] struct rlimitx64 *rlimits) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: resource: One of `RLIMIT_*' from <sys/resource.h>
setrlimit:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMIT)] struct rlimit const *rlimits) -> errno_t;
[doc_alias(setrlimit)] setrlimit32:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMIT32)] struct rlimit32 const *rlimits) -> errno_t;
[doc_alias(setrlimit)] setrlimit64:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMIT64)] struct rlimit64 const *rlimits) -> errno_t;
[doc_alias(setrlimit)] setrlimitx32:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMITX32)] struct rlimitx32 const *rlimits) -> errno_t;
[doc_alias(setrlimit)] setrlimitx32_64:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMITX32_64)] struct rlimitx32_64 const *rlimits) -> errno_t;
[doc_alias(setrlimit)] setrlimitx64:([tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMITX64)] struct rlimitx64 const *rlimits) -> errno_t;
%[endgroup]

%[startgroup]
@@@param: resource: One of `RLIMIT_*' from <sys/resource.h>
prlimit:(pid_t pid, [tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMIT)] struct rlimit const *new_limit, [tostr(out:STRUCT_RLIMIT64)] struct rlimit64 *old_limit) -> errno_t;
[doc_alias(prlimit)] prlimit32:(pid_t pid, [tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMIT32)] struct rlimit32 const *new_limit, [tostr(out:STRUCT_RLIMIT32)] struct rlimit32 *old_limit) -> errno_t;
[doc_alias(prlimit)] prlimit64:(pid_t pid, [tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMIT64)] struct rlimit64 const *new_limit, [tostr(out:STRUCT_RLIMIT64)] struct rlimit64 *old_limit) -> errno_t;
[doc_alias(prlimit)] prlimitx32:(pid_t pid, [tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMITX32)] struct rlimitx32 const *new_limit, [tostr(out:STRUCT_RLIMITX32)] struct rlimitx32 *old_limit) -> errno_t;
[doc_alias(prlimit)] prlimitx32_64:(pid_t pid, [tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMITX32_64)] struct rlimitx32_64 const *new_limit, [tostr(out:STRUCT_RLIMITX32_64)] struct rlimitx32_64 *old_limit) -> errno_t;
[doc_alias(prlimit)] prlimitx64:(pid_t pid, [tostr(RLIMIT_RESOURCE)] syscall_ulong_t resource, [tostr(STRUCT_RLIMITX64)] struct rlimitx64 const *new_limit, [tostr(out:STRUCT_RLIMITX64)] struct rlimitx64 *old_limit) -> errno_t;
%[endgroup]

@@NOTE: Linux calls `who' `which', and `id' `who' (refactored to prevent confusion)
@@@param: who: One of `IOPRIO_WHO_PROCESS', `IOPRIO_WHO_PGRP' or `IOPRIO_WHO_USER'
ioprio_get:([tostr(IOPRIO_WHO)] syscall_ulong_t who,
            [tostr(IOPRIO_ID:who)] syscall_ulong_t id) -> [tostr(IOPRIO_VALUE)] syscall_slong_t; /* UNIMPLEMENTED! */

@@NOTE: Linux calls `who' `which', and `id' `who' (refactored to prevent confusion)
@@@param: who: One of `IOPRIO_WHO_PROCESS', `IOPRIO_WHO_PGRP' or `IOPRIO_WHO_USER'
ioprio_set:([tostr(IOPRIO_WHO)] syscall_ulong_t who,
            [tostr(IOPRIO_ID:who)] syscall_ulong_t id,
            [tostr(IOPRIO_VALUE)] syscall_ulong_t ioprio) -> errno_t; /* UNIMPLEMENTED! */

%[startgroup]
@@@param: who: One of `RUSAGE_SELF', `RUSAGE_CHILDREN' or `RUSAGE_THREAD'
getrusage:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGE)] struct rusage *usage) -> errno_t;                                       /* UNIMPLEMENTED! */
[doc_alias(getrusage)] getrusage32:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGE32)] struct rusage32 *tv) -> errno_t;             /* UNIMPLEMENTED! */
[doc_alias(getrusage)] getrusage64:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGE64)] struct rusage64 *tv) -> errno_t;             /* UNIMPLEMENTED! */
[doc_alias(getrusage)] getrusagex32:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGEX32)] struct rusagex32 *tv) -> errno_t;          /* UNIMPLEMENTED! */
[doc_alias(getrusage)] getrusagex32_64:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGEX32_64)] struct rusagex32_64 *tv) -> errno_t; /* UNIMPLEMENTED! */
[doc_alias(getrusage)] getrusagex64:([tostr(GETRUSAGE_WHO)] syscall_slong_t who, [tostr(out:STRUCT_RUSAGEX64)] struct rusagex64 *tv) -> errno_t;          /* UNIMPLEMENTED! */
%[endgroup]

iopl:(syscall_ulong_t level) -> errno_t;
ioperm:(syscall_ulong_t from, syscall_ulong_t num, syscall_ulong_t turn_on) -> errno_t;





/************************************************************************/
/* Process/ABI control                                                  */
/************************************************************************/
@@>> prctl(2)
@@System process control interface. (Linux compatible)
@@@param: command: One of `PR_*' (from <linux/prctl.h>)
@@@param: ... : Up  to 4 additional arguments (dependent on `command')
@@              Note that some control codes  require you to pass  `0'
@@              for  all seemingly "unused" arguments. In these cases,
@@              the documentation for that command includes the number
@@              of unused, but required trailing 0s in its comment.
@@@return: * :  Return value depends on `command'
prctl:([tostr(PRCTL_COMMAND)] unsigned int command,
       syscall_ulong_t arg2, syscall_ulong_t arg3,
       syscall_ulong_t arg4, syscall_ulong_t arg5) -> syscall_slong_t;

%[startgroup]
@@>> arch_prctl(2)
@@Arch-dependent system process control interface. (But don't go and
@@think that the  normal `prctl(2)'  doesn't feature  arch-dependent
@@commands  -- honestly, this syscall shouldn't exist if you ask me,
@@but it does on linux, and so it must also on KOS...)
@@@param: command: One of `ARCH_*' (from <asm/prctl.h>)
@@@param: addr: Either a `syscall_ulong_t' or `syscall_ulong_t *', depending on `command'
@@@return: * :  Return value depends on `command'
arch_prctl:([tostr(ARCH_PRCTL_COMMAND)] unsigned int command, uintptr_t *addr) -> syscall_slong_t;
[doc_alias(arch_prctl)] arch_prctlx32:([tostr(ARCH_PRCTL_COMMAND)] unsigned int command, uint32_t *addr) -> syscall_slong_t;
[doc_alias(arch_prctl)] arch_prctlx64:([tostr(ARCH_PRCTL_COMMAND)] unsigned int command, uint64_t *addr) -> syscall_slong_t;
%[endgroup]
/* NOTE: We declare `arch_prctl()' with `uintptr_t *addr' so that the
 *       function isn't considered compatible with its compatibility-
 *       mode variant. -- We want 2 separate implementations for  32-
 *       bit, and 64-bit when compiling for x86_64! */





/************************************************************************/
/* Debugging                                                            */
/************************************************************************/
ptrace:(syscall_ulong_t request, pid_t pid, void *addr, void *data) -> syscall_slong_t; /* UNIMPLEMENTED! */

%[startgroup]
@@Trigger a debugger trap `trapno', optionally extended with  `regs'
@@at either the system call return location, or at the given `state'
@@In the later case, this system call will by default return to  the
@@given  `state', though given the purpose of this system call being
@@to inform a connected debugger  of some breakable event,  allowing
@@it to do whatever it wishes before execution is resumed.
@@@param: reason:   When non-NULL, the reason for the debug trap (else: use `SIGTRAP:DEBUGTRAP_REASON_NONE')
@@@param: state:    When non-NULL, the CPU state where the trap should return to by default
@@@return: -EOK:    `state' was NULL and the trap returned successfully
@@@return: -ENOENT: No debugger is connected to the calling process/process-group/system
debugtrap:([tostr(STRUCT_UCPUSTATE)] struct ucpustate const *state, [tostr(STRUCT_DEBUGTRAP_REASON)] struct debugtrap_reason const *reason) -> errno_t;
[doc_alias(debugtrap)] debugtrapx32:([tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *state, [tostr(STRUCT_DEBUGTRAP_REASON32)] struct debugtrap_reason32 const *reason) -> errno_t;
[doc_alias(debugtrap)] debugtrapx64:([tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *state, [tostr(STRUCT_DEBUGTRAP_REASON64)] struct debugtrap_reason64 const *reason) -> errno_t;
%[endgroup]

%[startgroup]
@@Trigger a coredump of the calling process.
@@@param: curr_state:       The  state as is still valid after any possible unwinding has already been done
@@                          Note that this state does not necessarily point to the location that originally
@@                          caused the problem that escalated into a coredump, but is the last valid stack-
@@                          unwind location at which unwinding could no longer continue.
@@                          When `NULL', `orig_state' is used instead, and `traceback_vector' and `traceback_length' are ignored.
@@@param: orig_state:       The original CPU state at where the associated `reason' got triggered
@@                          When `NULL', `curr_state' is used instead, and `traceback_vector' and `traceback_length' are ignored.
@@                          When   `curr_state'   is   also   `NULL',   then   the   current   CPU   state   is   used   instead.
@@@param: traceback_vector: (potentially  incomplete)   vector  of   additional  program   pointers  that   were
@@                          traversed   when   the  stack   was   walked  from   `orig_state'   to  `curr_state'
@@                          Note that earlier  entries within this  vector are further  up the call-stack,  with
@@                          traceback_vector[0] being meant to be the call-site of the function of `orig_state'.
@@                          Note that when `traceback_length != 0 && traceback_vector[traceback_length-1] == ucpustate_getpc(curr_state)',
@@                          it  can  be  assumed  that  the  traceback is  complete  and  contains  all  traversed  instruction locations.
@@                          In   this   case,  a   traceback  displayed   to   a  human   should  not   include   the  text   location  at
@@                          `traceback_vector[traceback_length-1]',    since    that    location    would    also    be    printed    when
@@                          unwinding is completed for the purposes of displaying a traceback.
@@@param: traceback_length: The number of program counters stored within `traceback_vector'
@@@param: reason:           The reason that resulted in the coredump (or `NULL' to get the same behavior as `E_OK')
@@                          For certain `unwind_error' values, this can also  point to other things, but is  always
@@                          allowed to be `NULL' to indicate default/stub values.
@@@param: unwind_error:     The  unwind  error that  caused the  coredump,  or `UNWIND_SUCCESS'  if unwinding
@@                          was  never  actually  performed,  and   `reason'  is  actually  a   `siginfo_t *'
@@                          Ignored when `reason == NULL', in which case `UNWIND_SUCCESS' is assumed instead.
[restart(must)]
coredump:([tostr(STRUCT_UCPUSTATE)] struct ucpustate const *curr_state,
          [tostr(STRUCT_UCPUSTATE)] struct ucpustate const *orig_state,
          [tostr(VOID_VECTOR:traceback_length)] void const *const *traceback_vector, size_t traceback_length,
          [tostr(STRUCT_EXCEPTION_DATA)] union coredump_info const *reason,
          unwind_errno_t unwind_error) -> errno_t;
[doc_alias(coredump)][restart(must)]
coredumpx32:([tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *curr_state,
             [tostr(STRUCT_UCPUSTATE32)] struct ucpustate32 const *orig_state,
             [tostr(VOID_VECTOR32:traceback_length)] __HYBRID_PTR32(void const) const *traceback_vector, size_t traceback_length,
             [tostr(STRUCT_EXCEPTION_DATA32)] union coredump_info32 const *reason,
             unwind_errno_t unwind_error) -> errno_t;
[doc_alias(coredump)][restart(must)]
coredumpx64:([tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *curr_state,
             [tostr(STRUCT_UCPUSTATE64)] struct ucpustate64 const *orig_state,
             [tostr(VOID_VECTOR64:traceback_length)] __HYBRID_PTR64(void const) const *traceback_vector, size_t traceback_length,
             [tostr(STRUCT_EXCEPTION_DATA64)] union coredump_info64 const *reason,
             unwind_errno_t unwind_error) -> errno_t;
%[endgroup]





/************************************************************************/
/* SOCKET                                                               */
/************************************************************************/
%[startgroup]
socketcall:([tostr(SOCKETCALL_CALL)] syscall_ulong_t call, [tostr(SOCKETCALL_ARGS:call)] syscall_ulong_t *args) -> syscall_slong_t;
socketcallx32:([tostr(SOCKETCALL_CALL)] __ULONG32_TYPE__ call, [tostr(SOCKETCALL_ARGS:call)] __ULONG32_TYPE__ *args) -> __LONG32_TYPE__;
socketcallx64:([tostr(SOCKETCALL_CALL)] __ULONG64_TYPE__ call, [tostr(SOCKETCALL_ARGS:call)] __ULONG64_TYPE__ *args) -> __LONG64_TYPE__;
%[endgroup]

@@Create a new socket for the given domain/type/protocol triple.
@@@param: domain:   Socket address domain/family (one of `AF_*' from `<sys/socket.h>')
@@@param: type:     Socket type (one of `SOCK_*' from `<sys/socket.h>')
@@                  May optionally be or'd with `SOCK_CLOEXEC | SOCK_CLOFORK | SOCK_NONBLOCK'
@@@param: protocol: Socket protocol (`0' for automatic). Available socket protocols mainly
@@                  depend on the selected `domain', and may be further specialized by the
@@                  `type' argument.  for  example,  `AF_INET' takes  one  of  `IPPROTO_*'
@@                  >> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
@@                  Also note that protocol IDs can be enumerated by `getprotoent(3)' from `<netdb.h>'
@@@return: * : A file descriptor for the newly created socket.
socket:([tostr(SOCKET_DOMAIN)] syscall_ulong_t domain,
        [tostr(SOCKET_TYPE)] syscall_ulong_t type,
        [tostr(SOCKET_PROTOCOL:domain)] syscall_ulong_t protocol) -> fd_t;

@@Create  pair of  connected sockets  with the  given domain/type/protocol triple
@@The sockets handles are stroed in `fds[0]' and `fds[1]', are already connected,
@@and are indistinguishable from each other.
@@@param: domain:   Socket address domain (one of `AF_*' from `<sys/socket.h>')
@@@param: type:     Socket type (one of `SOCK_*' from `<sys/socket.h>')
@@                  May optionally be or'd with `SOCK_CLOEXEC | SOCK_CLOFORK | SOCK_NONBLOCK'
@@@param: protocol: Socket protocol (`0' for automatic). Available socket protocols mainly
@@                  depend on the selected `domain', and may be further specialized by the
@@                  `type' argument.  for  example,  `AF_INET' takes  one  of  `IPPROTO_*'
@@                  >> socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
@@                  Also note that protocol IDs can be enumerated by `getprotoent(3)' from `<netdb.h>'
@@@return: 0 : Success (the sockets are stored in `fds[0]' and `fds[1]')
[doc_alias(socket)]
socketpair:([tostr(SOCKET_DOMAIN)] syscall_ulong_t domain,
            [tostr(SOCKET_TYPE)] syscall_ulong_t type,
            [tostr(SOCKET_PROTOCOL:domain)] syscall_ulong_t protocol,
            fd_t fds[2]) -> errno_t;

@@Bind the given socket `sockfd' to the specified local address.
@@@throw: E_NET_ADDRESS_IN_USE:E_NET_ADDRESS_IN_USE_CONTEXT_CONNECT
@@@throw: E_INVALID_ARGUMENT_UNEXPECTED_COMMAND:E_INVALID_ARGUMENT_CONTEXT_BIND_WRONG_ADDRESS_FAMILY
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_BIND_ALREADY_BOUND
@@@throw: E_NET_ADDRESS_NOT_AVAILABLE
@@@throw: E_BUFFER_TOO_SMALL   (`addr_len' is incorrect)
@@@return: 0 : Success
bind:(fd_t sockfd, [tostr(STRUCT_SOCKADDR:addr_len)] struct sockaddr const *addr, socklen_t addr_len) -> errno_t;

@@Connect to the specified address.
@@If the given `sockfd' isn't connection-oriented, this will set the address
@@that  will implicitly be  used as destination  by `send(2)' and `write(2)'
@@@throw: E_NET_ADDRESS_IN_USE:E_NET_ADDRESS_IN_USE_CONTEXT_CONNECT
@@@throw: E_INVALID_ARGUMENT_UNEXPECTED_COMMAND:E_INVALID_ARGUMENT_CONTEXT_BIND_WRONG_ADDRESS_FAMILY
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_BIND_ALREADY_BOUND
@@@throw: E_NET_ADDRESS_NOT_AVAILABLE
@@@throw: E_NET_CONNECTION_REFUSED
@@@throw: E_BUFFER_TOO_SMALL   (addr_len is incorrect)
@@@return: 0 : Success
[cp][restart(dont)]
connect:(fd_t sockfd, [tostr(STRUCT_SOCKADDR:addr_len)] struct sockaddr const *addr,
         socklen_t addr_len) -> errno_t;

@@Begin to listen for incoming client (aka. peer) connection requests.
@@@param: max_backlog: The max number of clients  pending to be accept(2)-ed,  before
@@                     the kernel will refuse to enqueue additional clients, and will
@@                     instead automatically refuse  any further  requests until  the
@@                     less than `max_backlog' clients are still pending.
@@@throw: E_NET_ADDRESS_IN_USE:E_NET_ADDRESS_IN_USE_CONTEXT_LISTEN
@@@throw: E_INVALID_HANDLE_NET_OPERATION:E_NET_OPERATION_LISTEN
@@@return: 0 : Success
listen:(fd_t sockfd, syscall_ulong_t max_backlog) -> errno_t;

@@Accept incoming client (aka. peer) connection requests.
@@@param: addr:       Peer address of the sender (or `NULL' when `addr_len' is `NULL')
@@@param: addr_len:   [NULL] Don't fill in the client's peer address
@@                    [in]   The amount of available memory starting at `addr'
@@                    [out]  The  amount  of required  memory for  the address.
@@                           This  may be  more than  was given,  in which case
@@                           the  address  was  truncated and  may  be invalid.
@@                           If this happens,  the caller  can still  determine
@@                           the correct address through use of `getpeername()'
@@@param: sock_flags: Set of `SOCK_NONBLOCK | SOCK_CLOEXEC | SOCK_CLOFORK'
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_ACCEPT_NOT_LISTENING
@@@throw: E_INVALID_HANDLE_NET_OPERATION:E_NET_OPERATION_ACCEPT
@@@throw: E_NET_CONNECTION_ABORT
@@@return: * : A file descriptor for the newly accept(2)-ed connection
[cp][restart(dont)]
accept4:(fd_t sockfd,
         [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
         [tostr(out:SOCKLEN_T)] socklen_t *addr_len,
         [tostr(ACCEPT4_FLAGS)] syscall_ulong_t sock_flags) -> fd_t;

@@Accept incoming client (aka. peer) connection requests.
@@@param: addr:      Peer address of the sender (or `NULL' when `addr_len' is `NULL')
@@@param: addr_len:  [NULL] Don't fill in the client's peer address
@@                   [in]   The amount of available memory starting at `addr'
@@                   [out]  The  amount  of required  memory for  the address.
@@                          This  may be  more than  was given,  in which case
@@                          the  address  was  truncated and  may  be invalid.
@@                          If this happens,  the caller  can still  determine
@@                          the correct address through use of `getpeername()'
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_ACCEPT_NOT_LISTENING
@@@throw: E_INVALID_HANDLE_NET_OPERATION:E_NET_OPERATION_ACCEPT
@@@throw: E_NET_CONNECTION_ABORT
@@@return: * : A file descriptor for the newly accept(2)-ed connection
[cp][restart(dont)]
accept:(fd_t sockfd,
        [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
        [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> fd_t;

@@Get the value of the named socket option `level:optname' and store it in `optval'
@@@param: level:   One of `SOL_*' (e.g.: `SOL_SOCKET')
@@@param: optname: Dependent on `level'
@@@param: optval:  Buffer for where to write the value of the socket option.
@@@param: optlen:  [in]  The amount of available memory starting at `optval'
@@                 [out] The amount of required memory for the option value.
@@                       This may be more than was given, in which case
@@                       the  contents  of   `optval'  are   undefined.
@@@throw: E_INVALID_ARGUMENT_SOCKET_OPT:E_INVALID_ARGUMENT_CONTEXT_GETSOCKOPT
@@@return: 0 : Success
getsockopt:(fd_t sockfd,
            [tostr(SOCKOPT_LEVEL)] syscall_ulong_t level,
            [tostr(SOCKOPT_OPTNAME:level)] syscall_ulong_t optname,
            [tostr(out:BUFFER:*optlen)] void *optval,
            [tostr(out:SOCKLEN_T)] socklen_t *optlen) -> errno_t;

@@Set the value of the named socket option `level:optname' from what is given in `optval'
@@@param: level:   One of `SOL_*' (e.g.: `SOL_SOCKET')
@@@param: optname: Dependent on `level'
@@@param: optval:  Buffer for where to write the value of the socket option.
@@@param: optlen:  The amount of available memory starting at `optval'
@@@throw: E_INVALID_ARGUMENT_SOCKET_OPT:E_INVALID_ARGUMENT_CONTEXT_SETSOCKOPT
@@@throw: E_BUFFER_TOO_SMALL  (The specified `optlen' is invalid for the given option)
@@@return: 0 : Success
[restart(dont)]
setsockopt:(fd_t sockfd,
            [tostr(SOCKOPT_LEVEL)] syscall_ulong_t level,
            [tostr(SOCKOPT_OPTNAME:level)] syscall_ulong_t optname,
            [tostr(SOCKOPT_OPTVAL:optlen)] void const *optval,
            [tostr(SOCKLEN_T:optname)] socklen_t optlen) -> errno_t;

@@Determine the local address (aka. name) for the given socket `sockfd'.
@@This  is usually the  same address as was  previously set by `bind(2)'
@@NOTE: Before the socket has actually be bound or connected, the exact
@@      address that is returned by this function is weakly  undefined.
@@      e.g.: For AF_INET, sin_addr=0.0.0.0, sin_port=0 is returned.
@@@param: addr:     [out] Buffer where to store the sock address.
@@@param: addr_len: [in]  The amount of available memory starting at `addr'
@@                  [out] The amount of required memory for the address.
@@                        This may be more than was given, in which case
@@                        the  address was truncated and may be invalid.
@@return: 0 : Success
getsockname:(fd_t sockfd,
             [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
             [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> errno_t;

@@Lookup the peer (remote) address of `sockfd' and store it in `*addr...+=*addr_len'
@@@param: addr:     [out] Buffer where to store the sock address.
@@@param: addr_len: [in]  The amount of available memory starting at `addr'
@@                  [out] The amount of required memory for the address.
@@                        This may be more than was given, in which case
@@                        the  address was truncated and may be invalid.
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_GETPEERNAME_NOT_CONNECTED
@@@return: 0 : Success
getpeername:(fd_t sockfd,
             [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
             [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> errno_t;

@@Send the contents of a given buffer over the given socket `sockfd'.
@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_SEND_NOT_CONNECTED
@@@throw: E_NET_MESSAGE_TOO_LONG
@@@throw: E_NET_CONNECTION_RESET
@@@throw: E_NET_SHUTDOWN
@@@return: * : [<= bufsize] The actual # of send bytes
[cp][restart(dont)]
send:(fd_t sockfd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
      [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;

@@Send the contents of a given buffer over this socket to the specified address
@@@param: buf:       Buffer of data to send (with a length of `bufsize' bytes)
@@@param: bufsize:   Size of `buf' (in bytes)
@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
@@@param: addr:      Address where to send data (or NULL when `addr_len' is 0)
@@@param: addr_len:  Size of `addr', or `0' to have this behave as an alias
@@                   for            `send(sockfd, buf, bufsize, msg_flags)'
@@@throw: E_INVALID_ARGUMENT_UNEXPECTED_COMMAND:E_INVALID_ARGUMENT_CONTEXT_SENDTO_WRONG_ADDRESS_FAMILY
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_SEND_NOT_CONNECTED
@@@throw: E_NET_MESSAGE_TOO_LONG
@@@throw: E_NET_CONNECTION_RESET
@@@throw: E_NET_SHUTDOWN
@@@throw: E_BUFFER_TOO_SMALL  (`addr_len' is incorrect)
@@@return: * : [<= bufsize] The actual # of send bytes
[cp][restart(dont)]
sendto:(fd_t sockfd, [tostr(BUFFER:bufsize)] void const *buf, size_t bufsize,
        [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags,
        [tostr(STRUCT_SOCKADDR:addr_len)] struct sockaddr const *addr, socklen_t addr_len) -> ssize_t;

%[startgroup]
@@Same as `send(2)' and `sendto(2)', but also allows for sending ancillary
@@data as well as  for data buffers  to be represented  by an IOV  vector.
@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
@@@throw: ... Same as for `send(2)' and `sendto(2)'
@@@return: * : [<= bufsize] The actual # of send payload bytes
[cp][restart(dont)] sendmsg:(fd_t sockfd, [tostr(STRUCT_MSGHDR)] struct msghdr const *message, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[cp][doc_alias(sendmsg)][restart(dont)] sendmsgx32:(fd_t sockfd, [tostr(STRUCT_MSGHDRX32)] struct msghdrx32 const *message, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[cp][doc_alias(sendmsg)][restart(dont)] sendmsgx64:(fd_t sockfd, [tostr(STRUCT_MSGHDRX64)] struct msghdrx64 const *message, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
%[endgroup]

%[startgroup]
@@Same as `sendmsg(2)', but may be used to send many
@@messages (datagrams)  with a  single system  call.
@@@param: msg_flags: Set of `MSG_CONFIRM | MSG_DONTROUTE | MSG_DONTWAIT |
@@                           MSG_EOR | MSG_MORE | MSG_NOSIGNAL | MSG_OOB'
@@@throw: ... Same as `sendmsg(2)'
@@@return: * : The # of datagrams successfully sent.
[cp][restart(dont)] sendmmsg:(fd_t sockfd, [tostr(STRUCT_MMSGHDR:vlen)] struct mmsghdr *vmessages, size_t vlen, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[cp][doc_alias(sendmmsg)][restart(dont)] sendmmsgx32:(fd_t sockfd, [tostr(STRUCT_MMSGHDRX32:vlen)] struct mmsghdrx32 *vmessages, size_t vlen, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
[cp][doc_alias(sendmmsg)][restart(dont)] sendmmsgx64:(fd_t sockfd, [tostr(STRUCT_MMSGHDRX64:vlen)] struct mmsghdrx64 *vmessages, size_t vlen, [tostr(SOCKET_SENDMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;
%[endgroup]

@@Receive data over the given socket `sockfd', and store the contents within the given buffer.
@@@param: msg_flags: Set of `MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK | MSG_TRUNC | MSG_WAITALL'
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_RECV_NOT_CONNECTED
@@@throw: E_NET_CONNECTION_REFUSED
@@@return: * : [<= bufsize] The actual # of received bytes
[cp][restart(dont)]
recv:(fd_t sockfd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize,
      [tostr(SOCKET_RECVMSG_FLAGS)] syscall_ulong_t msg_flags) -> ssize_t;

@@Receive data over this socket, and store the contents within the given buffer.
@@@param: buf:       Buffer to-be filled with up to `bufsize' bytes of received data
@@@param: bufsize:   Max # of bytes to receive
@@@param: msg_flags: Set of `MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK | MSG_TRUNC | MSG_WAITALL'
@@@param: addr:      Peer address of the sender (or `NULL' when `addr_len' is `NULL')
@@@param: addr_len:  [NULL] behave as an alias for `recv(sockfd, buf, bufsize, msg_flags)'
@@                   [in]   The amount of available memory starting at `addr'
@@                   [out]  The amount of required memory for the address.
@@                          This may be more than was given, in which case
@@                          the address was truncated and may be invalid.
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_RECV_NOT_CONNECTED
@@@throw: E_NET_CONNECTION_REFUSED
@@@throw: E_WOULDBLOCK (`MSG_DONTWAIT' was given, and the operation would have blocked)
@@@return: * : [<= bufsize] The actual # of received bytes
[cp][restart(dont)]
recvfrom:(fd_t sockfd, [tostr(out:BUFFER:bufsize:return)] void *buf, size_t bufsize,
          [tostr(SOCKET_RECVMSG_FLAGS)] syscall_ulong_t msg_flags,
          [tostr(out:STRUCT_SOCKADDR:*addr_len)] struct sockaddr *addr,
          [tostr(out:SOCKLEN_T)] socklen_t *addr_len) -> ssize_t;

%[startgroup]
@@Same as `recv(2)' and `recvfrom(2)', but also allows for receiving ancillary
@@data as  well as  for  data buffers  to be  represented  by an  IOV  vector.
@@@param: msg_flags: Set of `MSG_CMSG_CLOEXEC | MSG_CMSG_CLOFORK |
@@                           MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK  |  MSG_TRUNC  |  MSG_WAITALL'
@@@throw: ... Same as for `recv(2)' and `recvfrom(2)'
@@@return: * : [<= bufsize] The actual # of received payload bytes
[cp][restart(dont)]
recvmsg:(fd_t sockfd, struct msghdr *message,
         [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags) -> ssize_t;
[cp][doc_alias(recvmsg)][restart(dont)]
recvmsgx32:(fd_t sockfd, struct msghdrx32 *message,
            [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags) -> ssize_t;
[cp][doc_alias(recvmsg)][restart(dont)]
recvmsgx64:(fd_t sockfd, struct msghdrx64 *message,
            [tostr(SOCKET_RECVMSG_FLAGS2)] syscall_ulong_t msg_flags) -> ssize_t;
%[endgroup]

%[startgroup]
@@Same as `recvmsg(2)', but may be used to receive many
@@messages  (datagrams)  with  a  single  system  call.
@@@param: msg_flags: Set of `MSG_CMSG_CLOEXEC | MSG_CMSG_CLOFORK |
@@                           MSG_DONTWAIT | MSG_ERRQUEUE | MSG_OOB |
@@                           MSG_PEEK  |  MSG_TRUNC |  MSG_WAITALL |
@@                           MSG_WAITFORONE'
@@@throw: Error (s.a. `recvmsg(2)')
@@@return: * : The # of datagrams successfully received.
[cp][restart(dont)] recvmmsg:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDR:vlen:return)] struct mmsghdr *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS3)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPEC)] struct timespec const *tmo) -> ssize_t;
[cp][doc_alias(recvmmsg)][restart(dont)] recvmmsg32:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDR32:vlen:return)] struct mmsghdr *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS3)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPEC32)] struct timespec32 const *tmo) -> ssize_t;
[cp][doc_alias(recvmmsg)][restart(dont)] recvmmsg64:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDR64:vlen:return)] struct mmsghdr *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS3)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPEC64)] struct timespec64 const *tmo) -> ssize_t;
[cp][doc_alias(recvmmsg)][restart(dont)] recvmmsgx32:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX32:vlen:return)] struct mmsghdrx32 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS3)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPECX32)] struct timespecx32 const *tmo) -> ssize_t;
[cp][doc_alias(recvmmsg)][restart(dont)] recvmmsgx32_64:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX32:vlen:return)] struct mmsghdrx32 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS3)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPECX32_64)] struct timespecx32_64 const *tmo) -> ssize_t;
[cp][doc_alias(recvmmsg)][restart(dont)] recvmmsgx64:(fd_t sockfd, [tostr(out:STRUCT_MMSGHDRX64:vlen:return)] struct mmsghdrx64 *vmessages, size_t vlen, [tostr(SOCKET_RECVMSG_FLAGS3)] syscall_ulong_t msg_flags, [tostr(STRUCT_TIMESPECX64)] struct timespecx64 const *tmo) -> ssize_t;
%[endgroup]

@@Disallow further reception of data (causing `recv(2)' to return `0' as soon
@@as  all currently queued  data has been  read), and/or further transmission
@@of data (causing `send(2)' to throw an `E_NET_SHUTDOWN' exception)
@@@param: how: One of `SHUT_RD', `SHUT_WR' or `SHUT_RDWR'
@@@throw: E_ILLEGAL_BECAUSE_NOT_READY:E_ILLEGAL_OPERATION_CONTEXT_SOCKET_SHUTDOWN_NOT_CONNECTED
@@@return: 0 : Success
shutdown:(fd_t sockfd, [tostr(SOCKET_SHUTDOWN_HOW)] syscall_ulong_t how) -> errno_t;





/************************************************************************/
/* SHM                                                                  */
/************************************************************************/
shmget:(key_t key, size_t size, syscall_ulong_t shmflg) -> errno_t;                    /* UNIMPLEMENTED! */
shmat:(syscall_ulong_t shmid, void const *shmaddr, syscall_ulong_t shmflg) -> errno_t; /* UNIMPLEMENTED! */
shmctl:(syscall_ulong_t shmid, syscall_ulong_t cmd, struct shmid_ds *buf) -> errno_t;  /* UNIMPLEMENTED! */
shmdt:(void const *shmaddr) -> errno_t;                                                /* UNIMPLEMENTED! */





/************************************************************************/
/* RTM                                                                  */
/************************************************************************/
@@Begin  an  RTM operation.  Note that  if  the arch-specific  RTM driver
@@wasn't already loaded into the kernel, it will be loaded automatically,
@@though any error that may happen during this will result in `RTM_NOSYS'
@@begin returned.
@@Note that while an RTM  operation is in progress,  only a very small  hand
@@full  of system calls are allowed to  be used. Attempting to use arbitrary
@@system calls will most likely  result in an `RTM_ABORT_FAILED' error,  and
@@attempting to access too much system memory in general will result in this
@@function returning  with  `RTM_ABORT_CAPACITY',  rather  than  succeeding.
@@The following is  a list  of system calls  which are  whitelisted for  use
@@during a transaction:
@@  - sys_rtm_begin:  Nested RTM operation
@@  - sys_rtm_end:    End an RTM operation
@@  - sys_rtm_abort:  Abort an RTM operation
@@  - sys_rtm_test:   Check if an RTM operation is in progress (always returns `1')
@@Anything else will most likely result in this system call returning `RTM_ABORT_FAILED'
@@@return: RTM_STARTED : RTM operation was started.
@@@return: RTM_NOSYS   : RTM isn't supposed because the RTM driver is missing, or cannot be loaded.
@@@return: RTM_ABORT_* : RTM operation failed (s.a. code from `<kos/rtm.h>')
rtm_begin:() -> rtm_status_t;

@@End a transaction
@@If  the  transaction was  successful,  return normally  (by  returning `-EOK').
@@If    the   transaction   failed,   `sys_rtm_begin()'   returns   `RTM_ABORT_*'
@@If no transaction was in progress, an `E_ILLEGAL_OPERATION' exception is thrown
rtm_end:() -> errno_t;

@@Abort the current transaction  by having `sys_rtm_begin()' return  with
@@`RTM_ABORT_EXPLICIT | ((code << RTM_ABORT_CODE_S) & RTM_ABORT_CODE_M)'
@@If no transaction was in progress, behave as a no-op and return `-EOK'.
@@Otherwise,  this system call does not return normally, but returns from
@@the original `sys_rtm_begin()'
rtm_abort:(syscall_ulong_t code) -> errno_t;

@@Check if a transaction is currently in progress
@@@return: 0 : No RTM operation in progress
@@@return: 1 : An RTM operation is currently in progress
rtm_test:() -> syscall_ulong_t;





/************************************************************************/
/* System management                                                    */
/************************************************************************/
oldolduname:([tostr(out:STRUCT_LINUX_OLDOLDUNAME)] struct linux_oldolduname *name) -> errno_t;
olduname:([tostr(out:STRUCT_LINUX_OLDUNAME)] struct linux_olduname *name) -> errno_t;
uname:([tostr(out:STRUCT_UTSNAME)] struct utsname *name) -> errno_t;
sethostname:([tostr(STRING:len)] char const *name, size_t len) -> errno_t;
setdomainname:([tostr(STRING:len)] char const *name, size_t len) -> errno_t;

[cp] ksysctl:([tostr(KSYSCTL_COMMAND)] ioctl_t command,
              [tostr(KSYSCTL_ARG:command)] void *arg) -> syscall_slong_t;

@@Load a  kernel  driver  from an  ELF  image  `module_image...+=len'
@@This system call exists for linux compatibility, and is implemented
@@as an alias for  `KSYSCTL_DRIVER_INSMOD:KSYSCTL_DRIVER_FORMAT_BLOB'
@@
@@Note however that that is where linux compatibility ends. Since the
@@linux kernel does not implement any semblance of a stable ABI,  you
@@have to realize that on KOS, this system call can only load drivers
@@specifically built to run within the KOS kernel!
@@@param: uargs: The driver commandline
init_module:(void const *module_image, size_t len, char const *uargs) -> errno_t;

@@Load a  kernel  driver  from an  ELF  image  `module_image...+=len'
@@This system call exists for linux compatibility, and is implemented
@@as an alias for  `KSYSCTL_DRIVER_INSMOD:KSYSCTL_DRIVER_FORMAT_FILE'
@@
@@Note however that that is where linux compatibility ends. Since the
@@linux kernel does not implement any semblance of a stable ABI,  you
@@have to realize that on KOS, this system call can only load drivers
@@specifically built to run within the KOS kernel!
@@@param: uargs: The driver commandline
finit_module:(fd_t fd, char const *uargs, syscall_ulong_t flags) -> errno_t;

@@Try to unload a driver, given its `name'
@@This system call exists for linux compatibility, and is implemented
@@as an alias for  `KSYSCTL_DRIVER_DELMOD:KSYSCTL_DRIVER_FORMAT_FILE'
@@@param: name:  The name of the driver
@@@param: flags: Set of `O_NONBLOCK | O_TRUNC', where:
@@               - O_NONBLOCK: s.a. `KSYSCTL_DRIVER_DELMOD_FNONBLOCK'
@@               - O_TRUNC:    s.a. `KSYSCTL_DRIVER_DELMOD_FFORCE'
delete_module:(char const *name, oflag_t flags) -> errno_t;

@@@param: how: One of the `RB_*' constants from <sys/reboot.h>
reboot:([tostr(REBOOT_HOW)] syscall_ulong_t how) -> errno_t; /* UNIMPLEMENTED! */





/************************************************************************/
/* Misc                                                                 */
/************************************************************************/
[restart(must)] /* TODO: Implemented incompatible with linux! */
syslog:([tostr(SYSLOG_LEVEL)] syscall_ulong_t level,
        [tostr(STRING:len)] char const *str, size_t len) -> ssize_t;

@@@param: flags: Set of `0 | GRND_RANDOM | GRND_NONBLOCK'
getrandom:(void *buf, size_t num_bytes,
           [tostr(GETRANDOM_FLAGS)] syscall_ulong_t flags) -> ssize_t;

@@Set the exception handler mode for the calling thread.
@@Examples:
@@  - Set mode #3 from you `main()': `set_exception_handler(EXCEPT_HANDLER_MODE_SIGHAND, NULL, NULL)'
@@  - Set mode #4 (as done by libc): `set_exception_handler(EXCEPT_HANDLER_MODE_SIGHAND |
@@                                                          EXCEPT_HANDLER_FLAG_SETHANDLER,
@@                                                          &except_handler4, NULL)'
@@@param: mode:       One of `EXCEPT_HANDLER_MODE_*', optionally or'd with `EXCEPT_HANDLER_FLAG_*'
@@@param: handler:    When `EXCEPT_HANDLER_FLAG_SETHANDLER' is set, the address of the exception handler to use
@@@param: handler_sp: When `EXCEPT_HANDLER_FLAG_SETSTACK' is set, the address of the exception handler stack
@@@return: 0 :        Success.
@@@return: -1:EINVAL: The given `mode' is invalid
[restart(must)]
set_exception_handler:([tostr(EXCEPTION_HANDLER_MODE)] syscall_ulong_t mode, except_handler_t handler,
                       [tostr(EXCEPTION_HANDLER_SP:mode)] void *handler_sp) -> errno_t;

%[startgroup]
@@Get the current exception handler mode for the calling thread.
@@@param: pmode:       When non-`NULL', store the current mode, which is encoded as:
@@                      - One of `EXCEPT_HANDLER_MODE_(DISABLED|ENABLED|SIGHAND)'
@@                      - Or'd with a set of `EXCEPT_HANDLER_FLAG_(ONESHOT|SETHANDLER|SETSTACK)'
@@@param: phandler:    When   non-`NULL',   store  the   address   of  the   user-space   exception  handler.
@@                     Note that when no handler has been set (`!(*pmode & EXCEPT_HANDLER_FLAG_SETHANDLER)'),
@@                     then this pointer is set to `NULL'.
@@@param: phandler_sp: When non-`NULL', store the starting address of the user-space exception handler stack.
@@                     Note that  when no  stack has  been set  (`!(*pmode & EXCEPT_HANDLER_FLAG_SETSTACK)'),
@@                     or when the stack was defined to re-use the previous stack,
@@                     then this pointer is set to `EXCEPT_HANDLER_SP_CURRENT'.
@@@return: 0 :         Success.
@@@return: -1:EFAULT:  One of the given pointers is non-`NULL' and faulty
[restart(must)]
get_exception_handler:([tostr(out:EXCEPTION_HANDLER_MODE)] syscall_ulong_t *pmode,
                       [tostr(out:EXCEPT_HANDLER_T)] except_handler_t *phandler,
                       [tostr(out:POINTER)] void **phandler_sp) -> errno_t;
[doc_alias(get_exception_handler)][restart(must)]
get_exception_handlerx32:([tostr(out:EXCEPTION_HANDLER_MODE32)] __ULONG32_TYPE__ *pmode,
                          [tostr(out:EXCEPT_HANDLER32_T)] __except_handler32_t *phandler,
                          [tostr(out:POINTER32)] __HYBRID_PTR32(void) *phandler_sp) -> errno_t;
[doc_alias(get_exception_handler)][restart(must)]
get_exception_handlerx64:([tostr(out:EXCEPTION_HANDLER_MODE64)] __ULONG64_TYPE__ *pmode,
                          [tostr(out:EXCEPT_HANDLER64_T)] __except_handler64_t *phandler,
                          [tostr(out:POINTER64)] __HYBRID_PTR64(void) *phandler_sp) -> errno_t;
%[endgroup]

modify_ldt:(syscall_ulong_t func, void *ptr, syscall_ulong_t bytecount) -> syscall_slong_t;

pkey_alloc:(syscall_ulong_t flags, syscall_ulong_t access_rights) -> syscall_slong_t;          /* UNIMPLEMENTED! */
pkey_free:(syscall_ulong_t key) -> errno_t;                                                    /* UNIMPLEMENTED! */
pkey_mprotect:(void *addr, size_t len, syscall_ulong_t prot, syscall_ulong_t pkey) -> errno_t; /* UNIMPLEMENTED! */






/************************************************************************/
/* MISSING                                                              */
/************************************************************************/
quotactl:(int TODO_PROTOTYPE) -> errno_t;

vm86:(int TODO_PROTOTYPE) -> errno_t;
vm86old:(int TODO_PROTOTYPE) -> errno_t;

_sysctl:(int TODO_PROTOTYPE) -> errno_t;

nfsservctl:(int TODO_PROTOTYPE) -> errno_t;

capget:(int TODO_PROTOTYPE) -> errno_t;
capset:(int TODO_PROTOTYPE) -> errno_t;
ugetrlimit:(int TODO_PROTOTYPE) -> errno_t;

pivot_root:(int TODO_PROTOTYPE) -> errno_t;

set_thread_area:(int TODO_PROTOTYPE) -> errno_t;
get_thread_area:(int TODO_PROTOTYPE) -> errno_t;

io_setup:(int TODO_PROTOTYPE) -> errno_t;
io_destroy:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
[restart(dont)] io_getevents:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_getevents32:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_getevents64:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_geteventsx32:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_geteventsx32_64:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_geteventsx64:(int TODO_PROTOTYPE) -> errno_t;
%[endgroup]

io_submit:(int TODO_PROTOTYPE) -> errno_t;
io_cancel:(int TODO_PROTOTYPE) -> errno_t;

fadvise64:(int TODO_PROTOTYPE) -> errno_t;
fadvise64_64:(int TODO_PROTOTYPE) -> errno_t;
lookup_dcookie:(int TODO_PROTOTYPE) -> errno_t;

mbind:(int TODO_PROTOTYPE) -> errno_t;
get_mempolicy:(int TODO_PROTOTYPE) -> errno_t;
set_mempolicy:(int TODO_PROTOTYPE) -> errno_t;

add_key:(int TODO_PROTOTYPE) -> errno_t;
request_key:(int TODO_PROTOTYPE) -> errno_t;
keyctl:(int TODO_PROTOTYPE) -> errno_t;

fanotify_init:(int TODO_PROTOTYPE) -> errno_t;
fanotify_mark:(int TODO_PROTOTYPE) -> errno_t;

set_robust_list:(int TODO_PROTOTYPE) -> errno_t;
get_robust_list:(int TODO_PROTOTYPE) -> errno_t;

perf_event_open:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
clock_adjtime:(int TODO_PROTOTYPE) -> errno_t;
clock_adjtime32:(int TODO_PROTOTYPE) -> errno_t;
clock_adjtime64:(int TODO_PROTOTYPE) -> errno_t;
clock_adjtimex32:(int TODO_PROTOTYPE) -> errno_t;
clock_adjtimex32_64:(int TODO_PROTOTYPE) -> errno_t;
clock_adjtimex64:(int TODO_PROTOTYPE) -> errno_t;
%[endgroup]

sched_setattr:(int TODO_PROTOTYPE) -> errno_t;
sched_getattr:(int TODO_PROTOTYPE) -> errno_t;

membarrier:(int TODO_PROTOTYPE) -> errno_t;

kexec_load:(int TODO_PROTOTYPE) -> errno_t;
kexec_file_load:(int TODO_PROTOTYPE) -> errno_t;

semget:(int TODO_PROTOTYPE) -> errno_t;
semctl:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semop:(int TODO_PROTOTYPE) -> errno_t;

%[startgroup]
[restart(dont)] semtimedop:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semtimedop32:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semtimedop64:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semtimedopx32:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semtimedopx32_64:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] semtimedopx64:(int TODO_PROTOTYPE) -> errno_t;
%[endgroup]

%[startgroup]
[restart(dont)] io_pgetevents:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_pgetevents32:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_pgetevents64:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_pgeteventsx32:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_pgeteventsx32_64:(int TODO_PROTOTYPE) -> errno_t;
[restart(dont)] io_pgeteventsx64:(int TODO_PROTOTYPE) -> errno_t;
%[endgroup]

msgctl:(int TODO_PROTOTYPE) -> errno_t;
msgget:(int TODO_PROTOTYPE) -> errno_t;
[cp][restart(dont)] msgsnd:(int TODO_PROTOTYPE) -> errno_t;
[cp][restart(dont)] msgrcv:(int TODO_PROTOTYPE) -> errno_t;

migrate_pages:(int TODO_PROTOTYPE) -> errno_t;
move_pages:(int TODO_PROTOTYPE) -> errno_t;

bdflush:(int TODO_PROTOTYPE) -> errno_t;
bpf:(int TODO_PROTOTYPE) -> errno_t;
ipc:(int TODO_PROTOTYPE) -> errno_t;
personality:(int TODO_PROTOTYPE) -> errno_t;
seccomp:(int TODO_PROTOTYPE) -> errno_t;
sysfs:(int TODO_PROTOTYPE) -> errno_t;
rseq:(int TODO_PROTOTYPE) -> errno_t;
statx:(int TODO_PROTOTYPE) -> errno_t;
copy_file_range:(int TODO_PROTOTYPE) -> errno_t;
preadv2:(int TODO_PROTOTYPE) -> errno_t;
pwritev2:(int TODO_PROTOTYPE) -> errno_t;
io_uring_setup:(int TODO_PROTOTYPE) -> errno_t;
io_uring_enter:(int TODO_PROTOTYPE) -> errno_t;
io_uring_register:(int TODO_PROTOTYPE) -> errno_t;
open_tree:(int TODO_PROTOTYPE) -> errno_t;
move_mount:(int TODO_PROTOTYPE) -> errno_t;
fsopen:(int TODO_PROTOTYPE) -> errno_t;
fsconfig:(int TODO_PROTOTYPE) -> errno_t;
fsmount:(int TODO_PROTOTYPE) -> errno_t;
fspick:(int TODO_PROTOTYPE) -> errno_t;
openat2:(int TODO_PROTOTYPE) -> errno_t;
pciconfig_iobase:(int TODO_PROTOTYPE) -> errno_t;
pciconfig_read:(int TODO_PROTOTYPE) -> errno_t;
pciconfig_write:(int TODO_PROTOTYPE) -> errno_t;
vserve:(int TODO_PROTOTYPE) -> errno_t;
process_madvise:(int TODO_PROTOTYPE) -> errno_t;




























/* Syscall definition syntax
 * >> sysno:name
 * This is used as:
 * >> #define __NR_<name>  <sysno>      // In <asm/unistd.h>
 * >> #define SYS_<name>   __NR_<name>  // In <sys/syscall.h>
 * >> DEFINE_SYSCALLn(int, <name>, ...) // Somewhere in kernel-space
 * >> int <name>(...);                  // In <kos/syscalls.h>
 */



/* Generic system call numbers */
0:io_setup
1:io_destroy
2:io_submit
3:io_cancel
4:io_getevents
5:setxattr
6:lsetxattr
7:fsetxattr
8:getxattr
9:lgetxattr
10:fgetxattr
11:listxattr
12:llistxattr
13:flistxattr
14:removexattr
15:lremovexattr
16:fremovexattr
17:getcwd
18:lookup_dcookie
19:eventfd2
20:epoll_create1
21:epoll_ctl
22:epoll_pwait
23:dup
24:dup3
//25:__NR3264_fcntl
26:inotify_init1
27:inotify_add_watch
28:inotify_rm_watch
29:ioctl
30:ioprio_set
31:ioprio_get
32:flock
33:mknodat
34:mkdirat
35:unlinkat
36:symlinkat
37:linkat
38:renameat
39:umount2
40:mount
41:pivot_root
42:nfsservctl
//43:__NR3264_statfs
//44:__NR3264_fstatfs
//45:__NR3264_truncate
//46:__NR3264_ftruncate
47:fallocate
48:faccessat
49:chdir
50:fchdir
51:chroot
52:fchmod
53:fchmodat
54:fchownat
55:fchown
56:openat
57:close
58:vhangup
59:pipe2
60:quotactl
61:getdents64
//62:__NR3264_lseek
63:read
64:write
65:readv
66:writev
67:pread64
68:pwrite64
69:preadv
70:pwritev
//71:__NR3264_sendfile
72:pselect6
73:ppoll
74:signalfd4
75:vmsplice
76:splice
77:tee
78:readlinkat
//79:__NR3264_fstatat
//80:__NR3264_fstat
81:sync
82:fsync
83:fdatasync
84:sync_file_range
85:timerfd_create
86:timerfd_settime
87:timerfd_gettime
88:utimensat
89:acct
90:capget
91:capset
92:personality
93:exit
94:exit_group
95:waitid
96:set_tid_address
97:unshare
98:futex
99:set_robust_list
100:get_robust_list
101:nanosleep
102:getitimer
103:setitimer
104:kexec_load
105:init_module
106:delete_module
107:timer_create
108:timer_gettime
109:timer_getoverrun
110:timer_settime
111:timer_delete
112:clock_settime
113:clock_gettime
114:clock_getres
115:clock_nanosleep
116:syslog
117:ptrace
118:sched_setparam
119:sched_setscheduler
120:sched_getscheduler
121:sched_getparam
122:sched_setaffinity
123:sched_getaffinity
124:sched_yield
125:sched_get_priority_max
126:sched_get_priority_min
127:sched_rr_get_interval
128:restart_syscall
129:kill
130:tkill
131:tgkill
132:sigaltstack
133:rt_sigsuspend
134:rt_sigaction
135:rt_sigprocmask
136:rt_sigpending
137:rt_sigtimedwait
138:rt_sigqueueinfo
139:rt_sigreturn
140:setpriority
141:getpriority
142:reboot
143:setregid
144:setgid
145:setreuid
146:setuid
147:setresuid
148:getresuid
149:setresgid
150:getresgid
151:setfsuid
152:setfsgid
153:times
154:setpgid
155:getpgid
156:getsid
157:setsid
158:getgroups
159:setgroups
160:uname
161:sethostname
162:setdomainname
163:getrlimit
164:setrlimit
165:getrusage
166:umask
167:prctl
168:getcpu
169:gettimeofday
170:settimeofday
171:adjtimex
172:getpid
173:getppid
174:getuid
175:geteuid
176:getgid
177:getegid
178:gettid
179:sysinfo
180:mq_open
181:mq_unlink
182:mq_timedsend
183:mq_timedreceive
184:mq_notify
185:mq_getsetattr
186:msgget
187:msgctl
188:msgrcv
189:msgsnd
190:semget
191:semctl
192:semtimedop
193:semop
194:shmget
195:shmctl
196:shmat
197:shmdt
198:socket
199:socketpair
200:bind
201:listen
202:accept
203:connect
204:getsockname
205:getpeername
206:sendto
207:recvfrom
208:setsockopt
209:getsockopt
210:shutdown
211:sendmsg
212:recvmsg
213:readahead
214:brk
215:munmap
216:mremap
217:add_key
218:request_key
219:keyctl
220:clone
221:execve
//222:__NR3264_mmap
//223:__NR3264_fadvise64
224:swapon
225:swapoff
226:mprotect
227:msync
228:mlock
229:munlock
230:mlockall
231:munlockall
232:mincore
233:madvise
234:remap_file_pages
235:mbind
236:get_mempolicy
237:set_mempolicy
238:migrate_pages
239:move_pages
240:rt_tgsigqueueinfo
241:perf_event_open
242:accept4
243:recvmmsg
260:wait4
261:prlimit64
262:fanotify_init
263:fanotify_mark
264:name_to_handle_at
265:open_by_handle_at
266:clock_adjtime
267:syncfs
268:setns
269:sendmmsg
270:process_vm_readv
271:process_vm_writev
272:kcmp
273:finit_module
274:sched_setattr
275:sched_getattr
276:renameat2
277:seccomp
278:getrandom
279:memfd_create
280:bpf
281:execveat
282:userfaultfd
283:membarrier
284:mlock2
1024:open
1025:link
1026:unlink
1027:mknod
1028:chmod
1029:chown
1030:mkdir
1031:rmdir
1032:lchown
1033:access
1034:rename
1035:readlink
1036:symlink
1037:utimes
//1038:__NR3264_stat
//1039:__NR3264_lstat
1040:pipe
1041:dup2
1042:epoll_create
1043:inotify_init
1044:eventfd
1045:signalfd
1046:sendfile
1047:ftruncate
1048:truncate
1049:stat
1050:lstat
1051:fstat
1052:fcntl
1053:fadvise64
1054:newfstatat
1055:fstatfs
1056:statfs
1057:lseek
1058:mmap
1059:alarm
1060:getpgrp
1061:pause
1062:time
1063:utime
1064:creat
1065:getdents
1066:futimesat
1067:select
1068:poll
1069:epoll_wait
1070:ustat
1071:vfork
1072:oldwait4
1073:recv
1074:send
1075:bdflush
1076:umount
1077:uselib
1078:_sysctl
1079:fork
