/* Copyright (c) 2019 Griefer@Work                                            *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef GUARD_MODVGA_VGA_C
#define GUARD_MODVGA_VGA_C 1
#define _KOS_SOURCE 1

#include "vga.h"

#include <kernel/compiler.h>

#include <dev/char.h>
#include <kernel/driver.h>
#include <kernel/except.h>
#include <hybrid/atomic.h>
#include <kernel/printk.h>
#include <kernel/user.h>
#include <kernel/vm.h>
#include <sched/cpu.h>

#include <kos/dev.h>
#include <hybrid/limits.h>
#include <hybrid/align.h>

#include <assert.h>
#include <string.h>
#include <stdio.h>

DECL_BEGIN


INTERN_CONST struct vga_mode const vga_biosmode = {
	/* BAD! DON'T YOU DARE TO BLINK!
	 * Like literally, dis shit is dangerous to look at
	 * (Sorry, but even though I never actually had a seizure
	 *  from stupid $h1t like this, every time I see this blinking,
	 *  I can just feel that if I were to stare at it for too long,
	 *  I'd either throw up, or literally just die)
	 * Especially since I use the intensity attribute when the kernel
	 * panics, meaning that while this is still enabled, it'll blink
	 * when I was sitting here knowing that I had to look at it to
	 * figure out what happened.
	 * And I know I could have simply used regular colors at any point,
	 * but before starting this module and reading up on VGA I didn't
	 * see the connection and didn't understand why text was sometimes
	 * blinking.
	 * (And wiki.osdev's VGA TTY page neglects to mention the seizure-
	 *  inducing blinkyness that happens on real hardware and emulators
	 *  ~supporting~ the VgA sTaNdArT's GrEaT iDeA oF iNcLuDiNg ThIs FeAtUrE) */
	.vm_att_mode          = VGA_AT10_FDUP9 & ~(VGA_AT10_FBLINK),
	.vm_att_overscan      = 0x00,
	.vm_att_plane_enable  = 0x0f & VGA_AT12_FMASK,
	.vm_att_pel           = 0x08 & VGA_AT13_FMASK,
	.vm_att_color_page    = 0x00,
	.vm_mis               = VGA_MIS_FCOLOR|VGA_MIS_FENB_MEM_ACCESS|
	                        VGA_MIS_FVSYNCPOL|VGA_MIS_FHSYNCPOL|
	                        VGA_MIS_FSEL_HIGH_PAGE,
	.vm_gfx_sr_value      = 0x00,
	.vm_gfx_sr_enable     = 0x00,
	.vm_gfx_compare_value = 0x00,
	.vm_gfx_data_rotate   = 0x00,
	.vm_gfx_mode          = 0x10,
	.vm_gfx_misc          = 0x0e,
	.vm_gfx_compare_mask  = 0x0f,
	.vm_gfx_bit_mask      = 0xff,
	.vm_crt_h_total       = 0x5f,
	.vm_crt_h_disp        = 0x4f,
	.vm_crt_h_blank_start = 0x50,
	.vm_crt_h_blank_end   = 0x82,
	.vm_crt_h_sync_start  = 0x55,
	.vm_crt_h_sync_end    = 0x81,
	.vm_crt_v_total       = 0xbf,
	.vm_crt_overflow      = 0x1f,
	.vm_crt_preset_row    = 0x00,
	.vm_crt_max_scan      = 0x4f,
	.vm_crt_v_sync_start  = 0x9c,
	.vm_crt_v_sync_end    = 0x8e,
	.vm_crt_v_disp_end    = 0x8f,
	.vm_crt_offset        = 0x28,
	.vm_crt_underline     = 0x1f,
	.vm_crt_v_blank_start = 0x96,
	.vm_crt_v_blank_end   = 0xb9 & ~VGA_CR16_FRESERVED,
	.vm_crt_mode          = 0xa3,
	.vm_crt_line_compare  = 0xff,
	.vm_seq_clock_mode    = 0x00,
	.vm_seq_plane_write   = 0x03,
	.vm_seq_character_map = 0x00,
	.vm_seq_memory_mode   = 0x02,
};

INTERN_CONST struct vga_mode const vga_mode_gfx320x200_256 = {
	.vm_att_mode          = 0x41,
	.vm_att_overscan      = 0x00,
	.vm_att_plane_enable  = 0x0f,
	.vm_att_pel           = 0x00,
	.vm_att_color_page    = 0x00,
	.vm_mis               = VGA_MIS_FCOLOR|VGA_MIS_FENB_MEM_ACCESS|
	                        /*VGA_MIS_FVSYNCPOL|*/VGA_MIS_FHSYNCPOL|
	                        VGA_MIS_FSEL_HIGH_PAGE,
	.vm_gfx_sr_value      = 0x00,
	.vm_gfx_sr_enable     = 0x00,
	.vm_gfx_compare_value = 0x00,
	.vm_gfx_data_rotate   = 0x00,
	.vm_gfx_mode          = 0x40,
	.vm_gfx_misc          = 0x05, /* 0x01 */
	.vm_gfx_compare_mask  = 0x0f, /* 0x00 */
	.vm_gfx_bit_mask      = 0xff,
	.vm_crt_h_total       = 0x5f,
	.vm_crt_h_disp        = 0x4f,
	.vm_crt_h_blank_start = 0x50,
	.vm_crt_h_blank_end   = 0x82,
	.vm_crt_h_sync_start  = 0x54,
	.vm_crt_h_sync_end    = 0x80,
	.vm_crt_v_total       = 0xbf, /* 0x0d */
	.vm_crt_overflow      = 0x1f, /* 0x3e */
	.vm_crt_preset_row    = 0x00,
	.vm_crt_max_scan      = 0x41,
	.vm_crt_v_sync_start  = 0x9c, /* 0xea */
	.vm_crt_v_sync_end    = 0x8e, /* 0xac */
	.vm_crt_v_disp_end    = 0x8f, /* 0xdf */
	.vm_crt_offset        = 0x28,
	.vm_crt_underline     = 0x40, /* 0x00 */
	.vm_crt_v_blank_start = 0x96, /* 0xe7 */
	.vm_crt_v_blank_end   = 0xb9 & ~VGA_CR16_FRESERVED, /* 0x06 */
	.vm_crt_mode          = 0xa3, /* 0xe3 */
	.vm_crt_line_compare  = 0xff,
	.vm_seq_clock_mode    = 0x01,
	.vm_seq_plane_write   = VGA_SR02_FALL_PLANES,
	.vm_seq_character_map = 0x00,
	.vm_seq_memory_mode   = 0x0e, /* 0x06 */
};

INTERN_CONST struct vga_mode const vga_mode_gfx640x480_16 = {
	.vm_att_mode          = 0x01, // 0x01,
	.vm_att_overscan      = 0x00, // 0x00,
	.vm_att_plane_enable  = 0x0f, // 0x0f,
	.vm_att_pel           = 0x00, // 0x00,
	.vm_att_color_page    = 0x00, // 0x00,
	.vm_mis               = 0xe3, // 0xe3,
	.vm_gfx_sr_value      = 0x00, // 0x00,
	.vm_gfx_sr_enable     = 0x00, // 0x00,
	.vm_gfx_compare_value = 0x00, // 0x00,
	.vm_gfx_data_rotate   = 0x00, // 0x00,
	.vm_gfx_mode          = 0x00, // 0x00,
	.vm_gfx_misc          = 0x05, // 0x01,
	.vm_gfx_compare_mask  = 0x0f, // 0x00,
	.vm_gfx_bit_mask      = 0xff, // 0xff,
	.vm_crt_h_total       = 0x5f, // 0x5f,
	.vm_crt_h_disp        = 0x4f, // 0x4f,
	.vm_crt_h_blank_start = 0x50, // 0x50,
	.vm_crt_h_blank_end   = 0x82, // 0x82,
	.vm_crt_h_sync_start  = 0x54, // 0x54,
	.vm_crt_h_sync_end    = 0x80, // 0x80,
	.vm_crt_v_total       = 0x0b, // 0x0b,
	.vm_crt_overflow      = 0x3e, // 0x3e,
	.vm_crt_preset_row    = 0x00, // 0x00,
	.vm_crt_max_scan      = 0x40, // 0x40,
	.vm_crt_v_sync_start  = 0xea, // 0xea,
	.vm_crt_v_sync_end    = 0x8c, // 0x8c,
	.vm_crt_v_disp_end    = 0xdf, // 0xdf,
	.vm_crt_offset        = 0x28, // 0x28,
	.vm_crt_underline     = 0x00, // 0x00,
	.vm_crt_v_blank_start = 0xe7, // 0xe7,
	.vm_crt_v_blank_end   = 0x04, // 0x04,
	.vm_crt_mode          = 0xe3, // 0xe3,
	.vm_crt_line_compare  = 0xff, // 0xff,
	.vm_seq_clock_mode    = 0x01, // 0x01,
	.vm_seq_plane_write   = 0x0f, // 0x0f,
	.vm_seq_character_map = 0x00, // 0x00,
	.vm_seq_memory_mode   = 0x06, // VGA_SR04_FEXT_MEM/*|VGA_SR04_FSEQ_MODE*/,
};

INTERN_CONST struct vga_palette const vga_biospal = {{
#define C(r,g,b) {r<<2,g<<2,b<<2}
	C(0x00,0x00,0x00),C(0x00,0x00,0x2a),C(0x00,0x2a,0x00),C(0x00,0x2a,0x2a),C(0x2a,0x00,0x00),C(0x2a,0x00,0x2a),C(0x2a,0x2a,0x00),C(0x2a,0x2a,0x2a),
	C(0x00,0x00,0x15),C(0x00,0x00,0x3f),C(0x00,0x2a,0x15),C(0x00,0x2a,0x3f),C(0x2a,0x00,0x15),C(0x2a,0x00,0x3f),C(0x2a,0x2a,0x15),C(0x2a,0x2a,0x3f),
	C(0x00,0x15,0x00),C(0x00,0x15,0x2a),C(0x00,0x3f,0x00),C(0x00,0x3f,0x2a),C(0x2a,0x15,0x00),C(0x2a,0x15,0x2a),C(0x2a,0x3f,0x00),C(0x2a,0x3f,0x2a),
	C(0x00,0x15,0x15),C(0x00,0x15,0x3f),C(0x00,0x3f,0x15),C(0x00,0x3f,0x3f),C(0x2a,0x15,0x15),C(0x2a,0x15,0x3f),C(0x2a,0x3f,0x15),C(0x2a,0x3f,0x3f),
	C(0x15,0x00,0x00),C(0x15,0x00,0x2a),C(0x15,0x2a,0x00),C(0x15,0x2a,0x2a),C(0x3f,0x00,0x00),C(0x3f,0x00,0x2a),C(0x3f,0x2a,0x00),C(0x3f,0x2a,0x2a),
	C(0x15,0x00,0x15),C(0x15,0x00,0x3f),C(0x15,0x2a,0x15),C(0x15,0x2a,0x3f),C(0x3f,0x00,0x15),C(0x3f,0x00,0x3f),C(0x3f,0x2a,0x15),C(0x3f,0x2a,0x3f),
	C(0x15,0x15,0x00),C(0x15,0x15,0x2a),C(0x15,0x3f,0x00),C(0x15,0x3f,0x2a),C(0x3f,0x15,0x00),C(0x3f,0x15,0x2a),C(0x3f,0x3f,0x00),C(0x3f,0x3f,0x2a),
	C(0x15,0x15,0x15),C(0x15,0x15,0x3f),C(0x15,0x3f,0x15),C(0x15,0x3f,0x3f),C(0x3f,0x15,0x15),C(0x3f,0x15,0x3f),C(0x3f,0x3f,0x15),C(0x3f,0x3f,0x3f),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
#undef  C
}};

INTERN_CONST struct vga_palette const vga_pal_gfx16 = {{
#define C(r,g,b) {r<<2,g<<2,b<<2}
	C(0x00,0x00,0x00),C(0x00,0x00,0x2a),C(0x00,0x2a,0x00),C(0x00,0x2a,0x2a),C(0x2a,0x00,0x00),C(0x2a,0x00,0x2a),C(0x2a,0x2a,0x00),C(0x2a,0x2a,0x2a),
	C(0x00,0x00,0x15),C(0x00,0x00,0x3f),C(0x00,0x2a,0x15),C(0x00,0x2a,0x3f),C(0x2a,0x00,0x15),C(0x2a,0x00,0x3f),C(0x2a,0x2a,0x15),C(0x2a,0x2a,0x3f),
	C(0x00,0x15,0x00),C(0x00,0x15,0x2a),C(0x00,0x3f,0x00),C(0x00,0x3f,0x2a),C(0x2a,0x15,0x00),C(0x2a,0x15,0x2a),C(0x2a,0x3f,0x00),C(0x2a,0x3f,0x2a),
	C(0x00,0x15,0x15),C(0x00,0x15,0x3f),C(0x00,0x3f,0x15),C(0x00,0x3f,0x3f),C(0x2a,0x15,0x15),C(0x2a,0x15,0x3f),C(0x2a,0x3f,0x15),C(0x2a,0x3f,0x3f),
	C(0x15,0x00,0x00),C(0x15,0x00,0x2a),C(0x15,0x2a,0x00),C(0x15,0x2a,0x2a),C(0x3f,0x00,0x00),C(0x3f,0x00,0x2a),C(0x3f,0x2a,0x00),C(0x3f,0x2a,0x2a),
	C(0x15,0x00,0x15),C(0x15,0x00,0x3f),C(0x15,0x2a,0x15),C(0x15,0x2a,0x3f),C(0x3f,0x00,0x15),C(0x3f,0x00,0x3f),C(0x3f,0x2a,0x15),C(0x3f,0x2a,0x3f),
	C(0x15,0x15,0x00),C(0x15,0x15,0x2a),C(0x15,0x3f,0x00),C(0x15,0x3f,0x2a),C(0x3f,0x15,0x00),C(0x3f,0x15,0x2a),C(0x3f,0x3f,0x00),C(0x3f,0x3f,0x2a),
	C(0x15,0x15,0x15),C(0x15,0x15,0x3f),C(0x15,0x3f,0x15),C(0x15,0x3f,0x3f),C(0x3f,0x15,0x15),C(0x3f,0x15,0x3f),C(0x3f,0x3f,0x15),C(0x3f,0x3f,0x3f),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
#undef  C
}};

INTERN_CONST struct vga_palette const vga_pal_gfx256 = {{
#define C(r,g,b) {r<<2,g<<2,b<<2}
	C(0x00,0x00,0x00),C(0x00,0x00,0x2a),C(0x00,0x2a,0x00),C(0x00,0x2a,0x2a),C(0x2a,0x00,0x00),C(0x2a,0x00,0x2a),C(0x2a,0x15,0x00),C(0x2a,0x2a,0x2a),
	C(0x15,0x15,0x15),C(0x15,0x15,0x3f),C(0x15,0x3f,0x15),C(0x15,0x3f,0x3f),C(0x3f,0x15,0x15),C(0x3f,0x15,0x3f),C(0x3f,0x3f,0x15),C(0x3f,0x3f,0x3f),
	C(0x00,0x00,0x00),C(0x05,0x05,0x05),C(0x08,0x08,0x08),C(0x0b,0x0b,0x0b),C(0x0e,0x0e,0x0e),C(0x11,0x11,0x11),C(0x14,0x14,0x14),C(0x18,0x18,0x18),
	C(0x1c,0x1c,0x1c),C(0x20,0x20,0x20),C(0x24,0x24,0x24),C(0x28,0x28,0x28),C(0x2d,0x2d,0x2d),C(0x32,0x32,0x32),C(0x38,0x38,0x38),C(0x3f,0x3f,0x3f),
	C(0x00,0x00,0x3f),C(0x10,0x00,0x3f),C(0x1f,0x00,0x3f),C(0x2f,0x00,0x3f),C(0x3f,0x00,0x3f),C(0x3f,0x00,0x2f),C(0x3f,0x00,0x1f),C(0x3f,0x00,0x10),
	C(0x3f,0x00,0x00),C(0x3f,0x10,0x00),C(0x3f,0x1f,0x00),C(0x3f,0x2f,0x00),C(0x3f,0x3f,0x00),C(0x2f,0x3f,0x00),C(0x1f,0x3f,0x00),C(0x10,0x3f,0x00),
	C(0x00,0x3f,0x00),C(0x00,0x3f,0x10),C(0x00,0x3f,0x1f),C(0x00,0x3f,0x2f),C(0x00,0x3f,0x3f),C(0x00,0x2f,0x3f),C(0x00,0x1f,0x3f),C(0x00,0x10,0x3f),
	C(0x1f,0x1f,0x3f),C(0x27,0x1f,0x3f),C(0x2f,0x1f,0x3f),C(0x37,0x1f,0x3f),C(0x3f,0x1f,0x3f),C(0x3f,0x1f,0x37),C(0x3f,0x1f,0x2f),C(0x3f,0x1f,0x27),
	C(0x3f,0x1f,0x1f),C(0x3f,0x27,0x1f),C(0x3f,0x2f,0x1f),C(0x3f,0x37,0x1f),C(0x3f,0x3f,0x1f),C(0x37,0x3f,0x1f),C(0x2f,0x3f,0x1f),C(0x27,0x3f,0x1f),
	C(0x1f,0x3f,0x1f),C(0x1f,0x3f,0x27),C(0x1f,0x3f,0x2f),C(0x1f,0x3f,0x37),C(0x1f,0x3f,0x3f),C(0x1f,0x37,0x3f),C(0x1f,0x2f,0x3f),C(0x1f,0x27,0x3f),
	C(0x2d,0x2d,0x3f),C(0x31,0x2d,0x3f),C(0x36,0x2d,0x3f),C(0x3a,0x2d,0x3f),C(0x3f,0x2d,0x3f),C(0x3f,0x2d,0x3a),C(0x3f,0x2d,0x36),C(0x3f,0x2d,0x31),
	C(0x3f,0x2d,0x2d),C(0x3f,0x31,0x2d),C(0x3f,0x36,0x2d),C(0x3f,0x3a,0x2d),C(0x3f,0x3f,0x2d),C(0x3a,0x3f,0x2d),C(0x36,0x3f,0x2d),C(0x31,0x3f,0x2d),
	C(0x2d,0x3f,0x2d),C(0x2d,0x3f,0x31),C(0x2d,0x3f,0x36),C(0x2d,0x3f,0x3a),C(0x2d,0x3f,0x3f),C(0x2d,0x3a,0x3f),C(0x2d,0x36,0x3f),C(0x2d,0x31,0x3f),
	C(0x00,0x00,0x1c),C(0x07,0x00,0x1c),C(0x0e,0x00,0x1c),C(0x15,0x00,0x1c),C(0x1c,0x00,0x1c),C(0x1c,0x00,0x15),C(0x1c,0x00,0x0e),C(0x1c,0x00,0x07),
	C(0x1c,0x00,0x00),C(0x1c,0x07,0x00),C(0x1c,0x0e,0x00),C(0x1c,0x15,0x00),C(0x1c,0x1c,0x00),C(0x15,0x1c,0x00),C(0x0e,0x1c,0x00),C(0x07,0x1c,0x00),
	C(0x00,0x1c,0x00),C(0x00,0x1c,0x07),C(0x00,0x1c,0x0e),C(0x00,0x1c,0x15),C(0x00,0x1c,0x1c),C(0x00,0x15,0x1c),C(0x00,0x0e,0x1c),C(0x00,0x07,0x1c),
	C(0x0e,0x0e,0x1c),C(0x11,0x0e,0x1c),C(0x15,0x0e,0x1c),C(0x18,0x0e,0x1c),C(0x1c,0x0e,0x1c),C(0x1c,0x0e,0x18),C(0x1c,0x0e,0x15),C(0x1c,0x0e,0x11),
	C(0x1c,0x0e,0x0e),C(0x1c,0x11,0x0e),C(0x1c,0x15,0x0e),C(0x1c,0x18,0x0e),C(0x1c,0x1c,0x0e),C(0x18,0x1c,0x0e),C(0x15,0x1c,0x0e),C(0x11,0x1c,0x0e),
	C(0x0e,0x1c,0x0e),C(0x0e,0x1c,0x11),C(0x0e,0x1c,0x15),C(0x0e,0x1c,0x18),C(0x0e,0x1c,0x1c),C(0x0e,0x18,0x1c),C(0x0e,0x15,0x1c),C(0x0e,0x11,0x1c),
	C(0x14,0x14,0x1c),C(0x16,0x14,0x1c),C(0x18,0x14,0x1c),C(0x1a,0x14,0x1c),C(0x1c,0x14,0x1c),C(0x1c,0x14,0x1a),C(0x1c,0x14,0x18),C(0x1c,0x14,0x16),
	C(0x1c,0x14,0x14),C(0x1c,0x16,0x14),C(0x1c,0x18,0x14),C(0x1c,0x1a,0x14),C(0x1c,0x1c,0x14),C(0x1a,0x1c,0x14),C(0x18,0x1c,0x14),C(0x16,0x1c,0x14),
	C(0x14,0x1c,0x14),C(0x14,0x1c,0x16),C(0x14,0x1c,0x18),C(0x14,0x1c,0x1a),C(0x14,0x1c,0x1c),C(0x14,0x1a,0x1c),C(0x14,0x18,0x1c),C(0x14,0x16,0x1c),
	C(0x00,0x00,0x10),C(0x04,0x00,0x10),C(0x08,0x00,0x10),C(0x0c,0x00,0x10),C(0x10,0x00,0x10),C(0x10,0x00,0x0c),C(0x10,0x00,0x08),C(0x10,0x00,0x04),
	C(0x10,0x00,0x00),C(0x10,0x04,0x00),C(0x10,0x08,0x00),C(0x10,0x0c,0x00),C(0x10,0x10,0x00),C(0x0c,0x10,0x00),C(0x08,0x10,0x00),C(0x04,0x10,0x00),
	C(0x00,0x10,0x00),C(0x00,0x10,0x04),C(0x00,0x10,0x08),C(0x00,0x10,0x0c),C(0x00,0x10,0x10),C(0x00,0x0c,0x10),C(0x00,0x08,0x10),C(0x00,0x04,0x10),
	C(0x08,0x08,0x10),C(0x0a,0x08,0x10),C(0x0c,0x08,0x10),C(0x0e,0x08,0x10),C(0x10,0x08,0x10),C(0x10,0x08,0x0e),C(0x10,0x08,0x0c),C(0x10,0x08,0x0a),
	C(0x10,0x08,0x08),C(0x10,0x0a,0x08),C(0x10,0x0c,0x08),C(0x10,0x0e,0x08),C(0x10,0x10,0x08),C(0x0e,0x10,0x08),C(0x0c,0x10,0x08),C(0x0a,0x10,0x08),
	C(0x08,0x10,0x08),C(0x08,0x10,0x0a),C(0x08,0x10,0x0c),C(0x08,0x10,0x0e),C(0x08,0x10,0x10),C(0x08,0x0e,0x10),C(0x08,0x0c,0x10),C(0x08,0x0a,0x10),
	C(0x0b,0x0b,0x10),C(0x0c,0x0b,0x10),C(0x0d,0x0b,0x10),C(0x0f,0x0b,0x10),C(0x10,0x0b,0x10),C(0x10,0x0b,0x0f),C(0x10,0x0b,0x0d),C(0x10,0x0b,0x0c),
	C(0x10,0x0b,0x0b),C(0x10,0x0c,0x0b),C(0x10,0x0d,0x0b),C(0x10,0x0f,0x0b),C(0x10,0x10,0x0b),C(0x0f,0x10,0x0b),C(0x0d,0x10,0x0b),C(0x0c,0x10,0x0b),
	C(0x0b,0x10,0x0b),C(0x0b,0x10,0x0c),C(0x0b,0x10,0x0d),C(0x0b,0x10,0x0f),C(0x0b,0x10,0x10),C(0x0b,0x0f,0x10),C(0x0b,0x0d,0x10),C(0x0b,0x0c,0x10),
	C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),C(0x00,0x00,0x00),
#undef  C
}};

INTERN void KCALL
VGA_SetMode(VGA *__restrict self,
            struct vga_mode const *__restrict mode)
		THROWS(E_INVALID_ARGUMENT) {
	u8 temp, qr1;
	/* Validate the given mode. */
	if (mode->vm_att_mode & VGA_AT10_FRESERVED)
		goto invalid_mode;
	if (mode->vm_att_plane_enable & VGA_AT12_FRESERVED)
		goto invalid_mode;
	if (mode->vm_att_pel & VGA_AT13_FRESERVED)
		goto invalid_mode;
	if (mode->vm_att_color_page & VGA_AT14_FRESERVED)
		goto invalid_mode;
	if (mode->vm_mis & VGA_MIS_FRESERVED)
		goto invalid_mode;
	if (mode->vm_seq_plane_write & VGA_SR02_FRESERVED)
		goto invalid_mode;
	if (mode->vm_seq_character_map & VGA_SR03_FRESERVED)
		goto invalid_mode;
	if (mode->vm_seq_memory_mode & VGA_SR04_FRESERVED)
		goto invalid_mode;
	if (mode->vm_gfx_sr_value & VGA_GR00_FRESERVED)
		goto invalid_mode;
	if (mode->vm_gfx_sr_enable & VGA_GR01_FRESERVED)
		goto invalid_mode;
	if (mode->vm_gfx_compare_value & VGA_GR02_FRESERVED)
		goto invalid_mode;
	if (mode->vm_gfx_data_rotate & VGA_GR03_FRESERVED)
		goto invalid_mode;
	if (mode->vm_gfx_mode & VGA_GR05_FRESERVED)
		goto invalid_mode;
	if (mode->vm_gfx_misc & VGA_GR06_FRESERVED)
		goto invalid_mode;
	if (mode->vm_gfx_compare_mask & VGA_GR07_FRESERVED)
		goto invalid_mode;
	if (mode->vm_crt_preset_row & VGA_CR8_FRESERVED)
		goto invalid_mode;
	if (mode->vm_crt_v_sync_end & VGA_CR11_FRESERVED)
		goto invalid_mode;
	if (mode->vm_crt_v_blank_end & VGA_CR16_FRESERVED)
		goto invalid_mode;
	if (mode->vm_crt_mode & VGA_CR17_FRESERVED)
		goto invalid_mode;
	if (mode->vm_seq_clock_mode & VGA_SR01_FRESERVED)
		goto invalid_mode;

	sync_write(&self->v_lock);
	qr1 = vga_rseq(VGA_SEQ_CLOCK_MODE);

	/* Turn off the screen. */
	if (!(self->v_state & VGA_STATE_FSCREENOFF)) {
		vga_wseq(VGA_SEQ_RESET, 0x1);
		vga_wseq(VGA_SEQ_CLOCK_MODE, qr1 | VGA_SR01_FSCREEN_OFF);
		vga_wseq(VGA_SEQ_RESET, 0x3);
	}

	/* Enable graphics mode. */
	vga_r(VGA_IS1_RC), vga_w(VGA_ATT_W, 0x00);
	vga_r(VGA_IS1_RC), temp = vga_rattr(VGA_ATC_MODE);
	vga_r(VGA_IS1_RC), vga_wattr(VGA_ATC_MODE, (temp & VGA_AT10_FRESERVED) | mode->vm_att_mode);
	vga_r(VGA_IS1_RC), vga_wattr(VGA_ATC_OVERSCAN, mode->vm_att_overscan);
	vga_r(VGA_IS1_RC), temp = vga_rattr(VGA_ATC_PLANE_ENABLE);
	vga_r(VGA_IS1_RC), vga_wattr(VGA_ATC_PLANE_ENABLE, (temp & VGA_AT12_FRESERVED) | mode->vm_att_plane_enable);
	vga_r(VGA_IS1_RC), temp = vga_rattr(VGA_ATC_PEL);
	vga_r(VGA_IS1_RC), vga_wattr(VGA_ATC_PEL, (temp & VGA_AT13_FRESERVED) | mode->vm_att_pel);
	vga_r(VGA_IS1_RC), temp = vga_rattr(VGA_ATC_COLOR_PAGE);
	vga_r(VGA_IS1_RC), vga_wattr(VGA_ATC_COLOR_PAGE, (temp & VGA_AT14_FRESERVED) | mode->vm_att_color_page);
	vga_r(VGA_IS1_RC), vga_w(VGA_ATT_W, 0x20);

	temp = vga_r(VGA_MIS_R);
	vga_w(VGA_MIS_W, (temp & VGA_MIS_FRESERVED) | mode->vm_mis);

	temp = vga_rseq(VGA_SEQ_PLANE_WRITE);
	vga_wseq(VGA_SEQ_PLANE_WRITE, (temp & VGA_SR02_FRESERVED) | mode->vm_seq_plane_write);
	temp = vga_rseq(VGA_SEQ_CHARACTER_MAP);
	vga_wseq(VGA_SEQ_CHARACTER_MAP, (temp & VGA_SR03_FRESERVED) | mode->vm_seq_character_map);
	temp = vga_rseq(VGA_SEQ_MEMORY_MODE);
	vga_wseq(VGA_SEQ_MEMORY_MODE, (temp & VGA_SR04_FRESERVED) | mode->vm_seq_memory_mode);

	temp = vga_rgfx(VGA_GFX_SR_VALUE), vga_wgfx(VGA_GFX_SR_VALUE, (temp & VGA_GR00_FRESERVED) | mode->vm_gfx_sr_value);
	temp = vga_rgfx(VGA_GFX_SR_ENABLE), vga_wgfx(VGA_GFX_SR_ENABLE, (temp & VGA_GR01_FRESERVED) | mode->vm_gfx_sr_enable);
	temp = vga_rgfx(VGA_GFX_COMPARE_VALUE), vga_wgfx(VGA_GFX_COMPARE_VALUE, (temp & VGA_GR02_FRESERVED) | mode->vm_gfx_compare_value);
	temp = vga_rgfx(VGA_GFX_DATA_ROTATE), vga_wgfx(VGA_GFX_DATA_ROTATE, (temp & VGA_GR03_FRESERVED) | mode->vm_gfx_data_rotate);
	temp = vga_rgfx(VGA_GFX_MODE), vga_wgfx(VGA_GFX_MODE, (temp & VGA_GR05_FRESERVED) | mode->vm_gfx_mode);
	temp = vga_rgfx(VGA_GFX_MISC), vga_wgfx(VGA_GFX_MISC, (temp & VGA_GR06_FRESERVED) | mode->vm_gfx_misc);
	temp = vga_rgfx(VGA_GFX_COMPARE_MASK), vga_wgfx(VGA_GFX_COMPARE_MASK, (temp & VGA_GR07_FRESERVED) | mode->vm_gfx_compare_mask);
	vga_wgfx(VGA_GFX_BIT_MASK, mode->vm_gfx_bit_mask);

	/* Apply new graphics settings. */
	vga_wcrt(VGA_CRTC_H_TOTAL, mode->vm_crt_h_total);
	vga_wcrt(VGA_CRTC_H_DISP, mode->vm_crt_h_disp);
	vga_wcrt(VGA_CRTC_H_BLANK_START, mode->vm_crt_h_blank_start);
	vga_wcrt(VGA_CRTC_H_BLANK_END, mode->vm_crt_h_blank_end);
	vga_wcrt(VGA_CRTC_H_SYNC_START, mode->vm_crt_h_sync_start);
	vga_wcrt(VGA_CRTC_H_SYNC_END, mode->vm_crt_h_sync_end);
	vga_wcrt(VGA_CRTC_V_TOTAL, mode->vm_crt_v_total);
	vga_wcrt(VGA_CRTC_OVERFLOW, mode->vm_crt_overflow);
	temp = vga_rcrt(VGA_CRTC_PRESET_ROW);
	vga_wcrt(VGA_CRTC_PRESET_ROW, (temp & VGA_CR8_FRESERVED) | mode->vm_crt_preset_row);
	vga_wcrt(VGA_CRTC_MAX_SCAN, mode->vm_crt_max_scan);
	vga_wcrt(VGA_CRTC_V_SYNC_START, mode->vm_crt_v_sync_start);
	temp = vga_rcrt(VGA_CRTC_V_SYNC_END);
	vga_wcrt(VGA_CRTC_V_SYNC_END, (temp & VGA_CR11_FRESERVED) | mode->vm_crt_v_sync_end);
	vga_wcrt(VGA_CRTC_V_DISP_END, mode->vm_crt_v_disp_end);
	vga_wcrt(VGA_CRTC_OFFSET, mode->vm_crt_offset);
	vga_wcrt(VGA_CRTC_UNDERLINE, mode->vm_crt_underline);
	vga_wcrt(VGA_CRTC_V_BLANK_START, mode->vm_crt_v_blank_start);
	temp = vga_rcrt(VGA_CRTC_V_BLANK_END);
	vga_wcrt(VGA_CRTC_V_BLANK_END, (temp & VGA_CR16_FRESERVED) | mode->vm_crt_v_blank_end);
	temp = vga_rcrt(VGA_CRTC_MODE);
	vga_wcrt(VGA_CRTC_MODE, (temp & VGA_CR17_FRESERVED) | mode->vm_crt_mode);
	vga_wcrt(VGA_CRTC_LINE_COMPARE, mode->vm_crt_line_compare);

	/* Turn the screen back on. */
	if (!(self->v_state & VGA_STATE_FSCREENOFF)) {
		vga_wseq(VGA_SEQ_RESET, 0x1);
		vga_wseq(VGA_SEQ_CLOCK_MODE,
		         (qr1 & VGA_SR01_FRESERVED) |
		         (mode->vm_seq_clock_mode & ~VGA_SR01_FSCREEN_OFF));
		vga_wseq(VGA_SEQ_RESET, 0x3);
	} else {
		u8 new_mode;
		new_mode = mode->vm_seq_clock_mode | VGA_SR01_FSCREEN_OFF;
		new_mode &= ~VGA_SR01_FRESERVED;
		new_mode |= qr1 & VGA_SR01_FRESERVED;
		if (new_mode != qr1) {
			vga_wseq(VGA_SEQ_RESET, 0x1);
			vga_wseq(VGA_SEQ_CLOCK_MODE, new_mode);
			vga_wseq(VGA_SEQ_RESET, 0x3);
		}
	}
	sync_endwrite(&self->v_lock);
	return;
invalid_mode:
	THROW(E_INVALID_ARGUMENT);
}


INTERN void KCALL
VGA_GetMode(VGA *__restrict self,
            struct vga_mode *__restrict mode)
		THROWS(E_WOULDBLOCK) {
	sync_write(&self->v_lock);
	vga_r(VGA_IS1_RC), vga_w(VGA_ATT_W, 0x00);
	vga_r(VGA_IS1_RC), mode->vm_att_mode         = vga_rattr(VGA_ATC_MODE) & ~VGA_AT10_FRESERVED;
	vga_r(VGA_IS1_RC), mode->vm_att_overscan     = vga_rattr(VGA_ATC_OVERSCAN);
	vga_r(VGA_IS1_RC), mode->vm_att_plane_enable = vga_rattr(VGA_ATC_PLANE_ENABLE) & ~VGA_AT12_FRESERVED;
	vga_r(VGA_IS1_RC), mode->vm_att_pel          = vga_rattr(VGA_ATC_PEL) & ~VGA_AT13_FRESERVED;
	vga_r(VGA_IS1_RC), mode->vm_att_color_page   = vga_rattr(VGA_ATC_COLOR_PAGE) & ~VGA_AT14_FRESERVED;
	vga_r(VGA_IS1_RC), vga_w(VGA_ATT_W, 0x20);

	mode->vm_mis               = vga_r(VGA_MIS_R) & ~VGA_MIS_FRESERVED;
	mode->vm_gfx_sr_value      = vga_rgfx(VGA_GFX_SR_VALUE) & ~VGA_GR00_FRESERVED;
	mode->vm_gfx_sr_enable     = vga_rgfx(VGA_GFX_SR_ENABLE) & ~VGA_GR01_FRESERVED;
	mode->vm_gfx_compare_value = vga_rgfx(VGA_GFX_COMPARE_VALUE) & ~VGA_GR02_FRESERVED;
	mode->vm_gfx_data_rotate   = vga_rgfx(VGA_GFX_DATA_ROTATE) & ~VGA_GR03_FRESERVED;
	mode->vm_gfx_mode          = vga_rgfx(VGA_GFX_MODE) & ~VGA_GR05_FRESERVED;
	mode->vm_gfx_misc          = vga_rgfx(VGA_GFX_MISC) & ~VGA_GR06_FRESERVED;
	mode->vm_gfx_compare_mask  = vga_rgfx(VGA_GFX_COMPARE_MASK) & ~VGA_GR07_FRESERVED;
	mode->vm_gfx_bit_mask      = vga_rgfx(VGA_GFX_BIT_MASK);
	mode->vm_crt_h_total       = vga_rcrt(VGA_CRTC_H_TOTAL);
	mode->vm_crt_h_disp        = vga_rcrt(VGA_CRTC_H_DISP);
	mode->vm_crt_h_blank_start = vga_rcrt(VGA_CRTC_H_BLANK_START);
	mode->vm_crt_h_blank_end   = vga_rcrt(VGA_CRTC_H_BLANK_END);
	mode->vm_crt_h_sync_start  = vga_rcrt(VGA_CRTC_H_SYNC_START);
	mode->vm_crt_h_sync_end    = vga_rcrt(VGA_CRTC_H_SYNC_END);
	mode->vm_crt_v_total       = vga_rcrt(VGA_CRTC_V_TOTAL);
	mode->vm_crt_overflow      = vga_rcrt(VGA_CRTC_OVERFLOW);
	mode->vm_crt_preset_row    = vga_rcrt(VGA_CRTC_PRESET_ROW) & ~VGA_CR8_FRESERVED;
	mode->vm_crt_max_scan      = vga_rcrt(VGA_CRTC_MAX_SCAN);
	mode->vm_crt_v_sync_start  = vga_rcrt(VGA_CRTC_V_SYNC_START);
	mode->vm_crt_v_sync_end    = vga_rcrt(VGA_CRTC_V_SYNC_END) & ~VGA_CR11_FRESERVED;
	mode->vm_crt_v_disp_end    = vga_rcrt(VGA_CRTC_V_DISP_END);
	mode->vm_crt_offset        = vga_rcrt(VGA_CRTC_OFFSET);
	mode->vm_crt_underline     = vga_rcrt(VGA_CRTC_UNDERLINE);
	mode->vm_crt_v_blank_start = vga_rcrt(VGA_CRTC_V_BLANK_START);
	mode->vm_crt_v_blank_end   = vga_rcrt(VGA_CRTC_V_BLANK_END) & ~VGA_CR16_FRESERVED;
	mode->vm_crt_mode          = vga_rcrt(VGA_CRTC_MODE) & ~VGA_CR17_FRESERVED;
	mode->vm_crt_line_compare  = vga_rcrt(VGA_CRTC_LINE_COMPARE);
	mode->vm_seq_plane_write   = vga_rseq(VGA_SEQ_PLANE_WRITE) & ~VGA_SR02_FRESERVED;
	mode->vm_seq_character_map = vga_rseq(VGA_SEQ_CHARACTER_MAP) & ~VGA_SR03_FRESERVED;
	mode->vm_seq_memory_mode   = vga_rseq(VGA_SEQ_MEMORY_MODE) & ~VGA_SR04_FRESERVED;
	mode->vm_seq_clock_mode    = vga_rseq(VGA_SEQ_CLOCK_MODE) & ~VGA_SR01_FRESERVED;
	sync_endwrite(&self->v_lock);
}


INTERN void KCALL
VGA_SetPalette(VGA *__restrict self,
               USER CHECKED struct vga_palette const *__restrict pal)
		THROWS(E_WOULDBLOCK) {
	unsigned int i = 0;
	sync_write(&self->v_lock);
	TRY {
		vga_w(VGA_PEL_MSK, 0xff);
		vga_w(VGA_PEL_IW, 0x00);
		for (; i < 768; ++i)
			vga_w(VGA_PEL_D, ((u8 *)pal)[i] >> 2);
	} EXCEPT {
		/* Must complete the operation. - VGA wouldn't understand otherwise. */
		for (; i < 768; ++i)
			vga_w(VGA_PEL_D, 0);
		sync_endwrite(&self->v_lock);
		RETHROW();
	}
	sync_endwrite(&self->v_lock);
}

INTERN void KCALL
VGA_GetPalette(VGA *__restrict self,
               USER CHECKED struct vga_palette *__restrict pal)
		THROWS(E_WOULDBLOCK) {
	unsigned int i = 0;
	sync_write(&self->v_lock);
	TRY {
		vga_w(VGA_PEL_MSK, 0xff);
		vga_w(VGA_PEL_IR, 0x00);
		for (; i < 768; ++i)
			((u8 *)pal)[i] = vga_r(VGA_PEL_D) << 2;
	} EXCEPT {
		/* Must complete the operation. - VGA wouldn't understand otherwise. */
		for (; i < 768; ++i)
			vga_r(VGA_PEL_D);
		sync_endwrite(&self->v_lock);
		RETHROW();
	}
	sync_endwrite(&self->v_lock);
}

INTERN void KCALL
VGA_ScreenOn(VGA *__restrict self)
		THROWS(E_WOULDBLOCK) {
	u8 qr1;
	sync_write(&self->v_lock);
	qr1 = vga_rseq(VGA_SEQ_CLOCK_MODE);
	qr1 &= ~VGA_SR01_FSCREEN_OFF;
	vga_wseq(VGA_SEQ_RESET, 0x1);
	vga_wseq(VGA_SEQ_CLOCK_MODE, qr1);
	vga_wseq(VGA_SEQ_RESET, 0x3);
	self->v_state &= ~VGA_STATE_FSCREENOFF;
	sync_endwrite(&self->v_lock);
}

INTERN void KCALL
VGA_ScreenOff(VGA *__restrict self)
		THROWS(E_WOULDBLOCK) {
	u8 qr1;
	sync_write(&self->v_lock);
	qr1 = vga_rseq(VGA_SEQ_CLOCK_MODE);
	qr1 |= VGA_SR01_FSCREEN_OFF;
	vga_wseq(VGA_SEQ_RESET, 0x1);
	vga_wseq(VGA_SEQ_CLOCK_MODE, qr1);
	vga_wseq(VGA_SEQ_RESET, 0x3);
	self->v_state |= VGA_STATE_FSCREENOFF;
	sync_endwrite(&self->v_lock);
}



PRIVATE NOBLOCK ATTR_FREETEXT void
NOTHROW(KCALL vga_disable_annoying_blinking)(void) {
	u8 qr1;
	qr1 = vga_rseq(VGA_SEQ_CLOCK_MODE);
	vga_wseq(VGA_SEQ_RESET, 0x1);
	vga_wseq(VGA_SEQ_CLOCK_MODE, qr1 | VGA_SR01_FSCREEN_OFF);
	vga_wseq(VGA_SEQ_RESET, 0x3);

	vga_r(VGA_IS1_RC);
	vga_w(VGA_ATT_W, 0x00);

	vga_r(VGA_IS1_RC);
	u8 temp = vga_rattr(VGA_ATC_MODE);
	vga_r(VGA_IS1_RC);
	vga_wattr(VGA_ATC_MODE, temp & ~(VGA_AT10_FBLINK));

	vga_r(VGA_IS1_RC);
	vga_w(VGA_ATT_W, 0x20);

	vga_wseq(VGA_SEQ_RESET, 0x1);
	vga_wseq(VGA_SEQ_CLOCK_MODE, qr1 & ~VGA_SR01_FSCREEN_OFF);
	vga_wseq(VGA_SEQ_RESET, 0x3);
}





/* Conversion table: LATIN-1 --> CP437 */
PRIVATE u8 const cp437_from_latin1[256] = {
/*[[[deemon
local l = [0] * 256;
l[0x00] = 0;
l[0x20] = 32;
l[0x21] = 33;
l[0x22] = 34;
l[0x23] = 35;
l[0x24] = 36;
l[0x25] = 37;
l[0x26] = 38;
l[0x27] = 39;
l[0x28] = 40;
l[0x29] = 41;
l[0x2A] = 42;
l[0x2B] = 43;
l[0x2C] = 44;
l[0x2D] = 45;
l[0x2E] = 46;
l[0x2F] = 47;
l[0x30] = 48;
l[0x31] = 49;
l[0x32] = 50;
l[0x33] = 51;
l[0x34] = 52;
l[0x35] = 53;
l[0x36] = 54;
l[0x37] = 55;
l[0x38] = 56;
l[0x39] = 57;
l[0x3A] = 58;
l[0x3B] = 59;
l[0x3C] = 60;
l[0x3D] = 61;
l[0x3E] = 62;
l[0x3F] = 63;
l[0x40] = 64;
l[0x41] = 65;
l[0x42] = 66;
l[0x43] = 67;
l[0x44] = 68;
l[0x45] = 69;
l[0x46] = 70;
l[0x47] = 71;
l[0x48] = 72;
l[0x49] = 73;
l[0x4A] = 74;
l[0x4B] = 75;
l[0x4C] = 76;
l[0x4D] = 77;
l[0x4E] = 78;
l[0x4F] = 79;
l[0x50] = 80;
l[0x51] = 81;
l[0x52] = 82;
l[0x53] = 83;
l[0x54] = 84;
l[0x55] = 85;
l[0x56] = 86;
l[0x57] = 87;
l[0x58] = 88;
l[0x59] = 89;
l[0x5A] = 90;
l[0x5B] = 91;
l[0x5C] = 92;
l[0x5D] = 93;
l[0x5E] = 94;
l[0x5F] = 95;
l[0x60] = 96;
l[0x61] = 97;
l[0x62] = 98;
l[0x63] = 99;
l[0x64] = 100;
l[0x65] = 101;
l[0x66] = 102;
l[0x67] = 103;
l[0x68] = 104;
l[0x69] = 105;
l[0x6A] = 106;
l[0x6B] = 107;
l[0x6C] = 108;
l[0x6D] = 109;
l[0x6E] = 110;
l[0x6F] = 111;
l[0x70] = 112;
l[0x71] = 113;
l[0x72] = 114;
l[0x73] = 115;
l[0x74] = 116;
l[0x75] = 117;
l[0x76] = 118;
l[0x77] = 119;
l[0x78] = 120;
l[0x79] = 121;
l[0x7A] = 122;
l[0x7B] = 123;
l[0x7C] = 124;
l[0x7D] = 125;
l[0x7E] = 126;
l[0xA0] = 255;
l[0xA1] = 173;
l[0xA2] = 155;
l[0xA3] = 156;
l[0xA5] = 157;
l[0xA7] = 21;
l[0xAA] = 166;
l[0xAB] = 174;
l[0xAC] = 170;
l[0xB0] = 248;
l[0xB1] = 241;
l[0xB2] = 253;
l[0xB5] = 230;
l[0xB6] = 20;
l[0xB7] = 250;
l[0xBA] = 167;
l[0xBB] = 175;
l[0xBC] = 172;
l[0xBD] = 171;
l[0xBF] = 168;
l[0xC4] = 142;
l[0xC5] = 143;
l[0xC6] = 146;
l[0xC7] = 128;
l[0xC9] = 144;
l[0xD1] = 165;
l[0xD6] = 153;
l[0xDC] = 154;
l[0xDF] = 225;
l[0xE0] = 133;
l[0xE1] = 160;
l[0xE2] = 131;
l[0xE4] = 132;
l[0xE5] = 134;
l[0xE6] = 145;
l[0xE7] = 135;
l[0xE8] = 138;
l[0xE9] = 130;
l[0xEA] = 136;
l[0xEB] = 137;
l[0xEC] = 141;
l[0xED] = 161;
l[0xEE] = 140;
l[0xEF] = 139;
l[0xF1] = 164;
l[0xF2] = 149;
l[0xF3] = 162;
l[0xF4] = 147;
l[0xF6] = 148;
l[0xF7] = 246;
l[0xF9] = 151;
l[0xFA] = 163;
l[0xFB] = 150;
l[0xFC] = 129;
l[0xFF] = 152;
#include <util>
print "\t",;
for (local i,x: util.enumerate(l)) {
	if (i) {
		print ",",;
		if ((i % 16) == 0) {
			print;
			print "\t",;
		}
	}
	print "0x%.2I8x" % x,;
}
]]]*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
	0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
	0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
	0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xff,0xad,0x9b,0x9c,0x00,0x9d,0x00,0x15,0x00,0x00,0xa6,0xae,0xaa,0x00,0x00,0x00,
	0xf8,0xf1,0xfd,0x00,0x00,0xe6,0x14,0xfa,0x00,0x00,0xa7,0xaf,0xac,0xab,0x00,0xa8,
	0x00,0x00,0x00,0x00,0x8e,0x8f,0x92,0x80,0x00,0x90,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xa5,0x00,0x00,0x00,0x00,0x99,0x00,0x00,0x00,0x00,0x00,0x9a,0x00,0x00,0xe1,
	0x85,0xa0,0x83,0x00,0x84,0x86,0x91,0x87,0x8a,0x82,0x88,0x89,0x8d,0xa1,0x8c,0x8b,
	0x00,0xa4,0x95,0xa2,0x93,0x00,0x94,0xf6,0x00,0x97,0xa3,0x96,0x81,0x00,0x00,0x98
//[[[end]]]
};


/* Encode the given unicode character `ch' using cp437 (the codepage
 * used by VGA) If the character can't be encoded, return 0 instead.
 * s.a.: https://en.wikipedia.org/wiki/Code_page_437  */
LOCAL u8 NOTHROW(KCALL cp437_encode)(/*utf-32*/u32 ch) {
	u8 result;
	if (ch <= 0xff) {
		result = cp437_from_latin1[ch];
		if (result)
			return result;
	} else {
		switch (ch) {
		case 0x0192: result = 159; break;
		case 0x0393: result = 226; break;
		case 0x0398: result = 233; break;
		case 0x03A3: result = 228; break;
		case 0x03A6: result = 232; break;
		case 0x03A9: result = 234; break;
		case 0x03B1: result = 224; break;
		case 0x03B4: result = 235; break;
		case 0x03B5: result = 238; break;
		case 0x03C0: result = 227; break;
		case 0x03C3: result = 229; break;
		case 0x03C4: result = 231; break;
		case 0x03C6: result = 237; break;
		case 0x2022: result = 7; break;
		case 0x203C: result = 19; break;
		case 0x207F: result = 252; break;
		case 0x20A7: result = 158; break;
		case 0x2190: result = 27; break;
		case 0x2191: result = 24; break;
		case 0x2192: result = 26; break;
		case 0x2193: result = 25; break;
		case 0x2194: result = 29; break;
		case 0x2195: result = 18; break;
		case 0x21A8: result = 23; break;
		case 0x2219: result = 249; break;
		case 0x221A: result = 251; break;
		case 0x221E: result = 236; break;
		case 0x221F: result = 28; break;
		case 0x2229: result = 239; break;
		case 0x2248: result = 247; break;
		case 0x2261: result = 240; break;
		case 0x2264: result = 243; break;
		case 0x2265: result = 242; break;
		case 0x2302: result = 127; break;
		case 0x2310: result = 169; break;
		case 0x2320: result = 244; break;
		case 0x2321: result = 245; break;
		case 0x2500: result = 196; break;
		case 0x2502: result = 179; break;
		case 0x250C: result = 218; break;
		case 0x2510: result = 191; break;
		case 0x2514: result = 192; break;
		case 0x2518: result = 217; break;
		case 0x251C: result = 195; break;
		case 0x2524: result = 180; break;
		case 0x252C: result = 194; break;
		case 0x2534: result = 193; break;
		case 0x253C: result = 197; break;
		case 0x2550: result = 205; break;
		case 0x2551: result = 186; break;
		case 0x2552: result = 213; break;
		case 0x2553: result = 214; break;
		case 0x2554: result = 201; break;
		case 0x2555: result = 184; break;
		case 0x2556: result = 183; break;
		case 0x2557: result = 187; break;
		case 0x2558: result = 212; break;
		case 0x2559: result = 211; break;
		case 0x255A: result = 200; break;
		case 0x255B: result = 190; break;
		case 0x255C: result = 189; break;
		case 0x255D: result = 188; break;
		case 0x255E: result = 198; break;
		case 0x255F: result = 199; break;
		case 0x2560: result = 204; break;
		case 0x2561: result = 181; break;
		case 0x2562: result = 182; break;
		case 0x2563: result = 185; break;
		case 0x2564: result = 209; break;
		case 0x2565: result = 210; break;
		case 0x2566: result = 203; break;
		case 0x2567: result = 207; break;
		case 0x2568: result = 208; break;
		case 0x2569: result = 202; break;
		case 0x256A: result = 216; break;
		case 0x256B: result = 215; break;
		case 0x256C: result = 206; break;
		case 0x2580: result = 223; break;
		case 0x2584: result = 220; break;
		case 0x2588: result = 219; break;
		case 0x258C: result = 221; break;
		case 0x2590: result = 222; break;
		case 0x2591: result = 176; break;
		case 0x2592: result = 177; break;
		case 0x2593: result = 178; break;
		case 0x25A0: result = 254; break;
		case 0x25AC: result = 22; break;
		case 0x25B2: result = 30; break;
		case 0x25BA: result = 16; break;
		case 0x25BC: result = 31; break;
		case 0x25C4: result = 17; break;
		case 0x25CB: result = 9; break;
		case 0x25D8: result = 8; break;
		case 0x25D9: result = 10; break;
		case 0x263A: result = 1; break;
		case 0x263B: result = 2; break;
		case 0x263C: result = 15; break;
		case 0x2640: result = 12; break;
		case 0x2642: result = 11; break;
		case 0x2660: result = 6; break;
		case 0x2663: result = 5; break;
		case 0x2665: result = 3; break;
		case 0x2666: result = 4; break;
		case 0x266A: result = 13; break;
		case 0x266B: result = 14; break;
		default: result = 0; break;
		}
	}
	return result;
}






LOCAL void KCALL vga_enable_cursor(VGA *__restrict vga)
		THROWS(E_WOULDBLOCK) {
	if (!(vga->v_state & VGA_STATE_FCURSOR)) {
		sync_write(&vga->v_lock);
		COMPILER_READ_BARRIER();
		if (!(vga->v_state & VGA_STATE_FCURSOR)) {
			vga_wcrt(VGA_CRTC_CURSOR_START, vga_rcrt(VGA_CRTC_CURSOR_START) & ~(VGA_CRA_FCURSOR_DISABLE));
			vga->v_state |= VGA_STATE_FCURSOR;
		}
		sync_endwrite(&vga->v_lock);
	}
}

LOCAL void KCALL vga_disable_cursor(VGA *__restrict vga)
		THROWS(E_WOULDBLOCK) {
	if (vga->v_state & VGA_STATE_FCURSOR) {
		sync_write(&vga->v_lock);
		COMPILER_READ_BARRIER();
		if (vga->v_state & VGA_STATE_FCURSOR) {
			vga_wcrt(VGA_CRTC_CURSOR_START, vga_rcrt(VGA_CRTC_CURSOR_START) | VGA_CRA_FCURSOR_DISABLE);
			vga->v_state &= ~VGA_STATE_FCURSOR;
		}
		sync_endwrite(&vga->v_lock);
	}
}


PRIVATE void KCALL
vga_update_cursor_pos(VGA *__restrict vga)
		THROWS(E_WOULDBLOCK) {
	if (vga->v_textptr >= vga->v_textend) {
		vga_disable_cursor(vga);
	} else {
		unsigned int pos;
		pos = (unsigned int)(vga->v_textptr - vga->v_textbase);
		sync_write(&vga->v_lock);
		vga_wcrt(VGA_CRTC_CURSOR_HI, (pos >> 8));
		vga_wcrt(VGA_CRTC_CURSOR_LO, (u8)pos);
		COMPILER_READ_BARRIER();
		if (!(vga->v_state & VGA_STATE_FCURSOR)) {
			vga_wcrt(VGA_CRTC_CURSOR_START, vga_rcrt(VGA_CRTC_CURSOR_START) & ~(VGA_CRA_FCURSOR_DISABLE));
			vga->v_state |= VGA_STATE_FCURSOR;
		}
		sync_endwrite(&vga->v_lock);
	}
}

#define TABSIZE 8

#define VGA_CHR(vga, ch) ((u16)(ch) | ((u16)(vga)->at_ansi.at_color << 8))

#define UNENCODABLE_START  "["
#define UNENCODABLE_END    "]"
#define UNENCODABLE(x)     UNENCODABLE_START x UNENCODABLE_END

PRIVATE NOBLOCK NONNULL((1)) void
NOTHROW(LIBANSITTY_CC vga_putcp437)(VGA *__restrict vga, u8 ch) {
	u16 *oldptr;
	/* VGA terminal output */
	for (;;) {
		oldptr = ATOMIC_READ(vga->v_textptr);
		if (oldptr >= vga->v_textend) {
			/* Scroll down */
			if (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, vga->v_textlline))
				continue;
			memmovew(vga->v_textbase, vga->v_text2line,
			         (vga->v_textsizey - 1) * vga->v_textsizex);
			memsetw(vga->v_textlline, VGA_CHR(vga, ' '), vga->v_textsizex);
			continue;
		}
		if (vga->at_ansi.at_ttyflag & ANSITTY_MODE_NOLINEWRAP) {
			if (((size_t)(oldptr - vga->v_textbase) % vga->v_textsizex) != (vga->v_textsizex - 1))
				goto do_increment_oldptr;
		} else {
do_increment_oldptr:
			if (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, oldptr + 1))
				continue;
		}
		*oldptr = VGA_CHR(vga, ch);
		break;
	}
}

PRIVATE NOBLOCK void
NOTHROW(KCALL invert_current_line_colors)(VGA *__restrict self) {
	unsigned int cur_x;
	u16 *line_start, *line_end;
	line_start  = ATOMIC_READ(self->v_textptr);
	cur_x       = ((size_t)(line_start - self->v_textbase) % self->v_textsizex);
	line_start -= cur_x;
	line_end    = line_start + self->v_textsizex;
	for (; line_start < line_end; ++line_start)
		*line_start ^= 0xff00;
}

PRIVATE void KCALL do_flash_screen_pause(void) THROWS(E_WOULDBLOCK, ...) {
	qtime_t tmo = quantum_time();
	tmo.add_milliseconds(70);
	task_waitfor(&tmo);
}


PRIVATE void KCALL flash_current_line_pause(void) THROWS(E_WOULDBLOCK, ...) {
	if unlikely(task_isconnected()) {
		struct task_connections con;
		task_pushconnections(&con);
		assert(!task_isconnected());
		TRY {
			do_flash_screen_pause();
		} EXCEPT {
			assert(!task_isconnected());
			task_popconnections(&con);
			RETHROW();
		}
		assert(!task_isconnected());
		task_popconnections(&con);
	} else {
		do_flash_screen_pause();
	}
}

PRIVATE void KCALL flash_current_line(VGA *__restrict self) THROWS(E_WOULDBLOCK, ...) {
	invert_current_line_colors(self);
	flash_current_line_pause();
	invert_current_line_colors(self);
}

PRIVATE NONNULL((1)) void LIBANSITTY_CC
VGA_Putc(struct ansitty *__restrict self, char32_t ch)
		THROWS(E_WOULDBLOCK, ...) {
	VGA *vga = container_of(self, VGA, at_ansi);
	u8 cp_ch;
	cp_ch = cp437_encode(ch);
	if (cp_ch) {
		vga_putcp437(vga, cp_ch);
	} else {
		switch (ch) {

		case 7: /* BEL */
			/* Visual bell */
			if (PREEMPTION_ENABLED())
				flash_current_line(vga);
			break;

		case '\t': {
			u16 *oldptr;
			unsigned int cur_x;
			unsigned int num_space;
			unsigned int max_space;
			do {
				oldptr = ATOMIC_READ(vga->v_textptr);
				if (oldptr >= vga->v_textend) {
					/* Scroll down */
					if (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, vga->v_textlline))
						continue;
					memmovew(vga->v_textbase, vga->v_text2line,
					         (vga->v_textsizey - 1) * vga->v_textsizex);
					memsetw(vga->v_textlline, VGA_CHR(vga, ' '), vga->v_textsizex);
					continue;
				}
				cur_x     = (oldptr - vga->v_textbase) % vga->v_textsizex;
				num_space = TABSIZE - (cur_x % TABSIZE);
				max_space = vga->v_textsizex - cur_x;
				if (num_space > max_space)
					num_space = max_space;
			} while (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, oldptr + num_space));
			/* Output space characters. */
			memsetw(oldptr, VGA_CHR(vga, ' '), num_space);
		}	break;

		case '\b': {
			u16 *oldptr;
			do {
				oldptr = ATOMIC_READ(vga->v_textptr);
				if (oldptr <= vga->v_textbase)
					return;
			} while (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, oldptr - 1));
		}	break;

		case '\r': {
			/* Return to the start of the current line. */
			u16 *oldptr;
			size_t cur_x;
			do {
				oldptr = ATOMIC_READ(vga->v_textptr);
				cur_x  = ((size_t)(oldptr - vga->v_textbase) % vga->v_textsizex);
			} while (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, oldptr - cur_x));
			if (vga->at_ansi.at_ttymode & ANSITTY_MODE_NEWLINE_CLRFREE)
				memsetw(oldptr, VGA_CHR(vga, ' '), vga->v_textsizex - cur_x);
		}	break;

		case '\n': {
			for (;;) {
				u16 *oldptr;
				size_t cur_x;
				oldptr = ATOMIC_READ(vga->v_textptr);
				cur_x  = ((size_t)(oldptr - vga->v_textbase) % vga->v_textsizex);
				if (cur_x == 0 && cp437_encode(vga->v_lastch) != 0) {
					/* Special case: The previous line was filled entirely, and the cursor had to be wrapped
					 *               to the next line, however the first character then printed was also a
					 *               linefeed. - In this case, don't wrap the line, as the linefeed requested
					 *               by the caller already happened implicitly, thus not creating an entirely
					 *               empty line and wasting what little screen space we only have. */
				} else {
					/* Clear the remainder of the old line */
					u16 *lline = ATOMIC_READ(vga->v_scrlllin);
					if (oldptr >= lline) {
						if (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, lline))
							continue;
						/* Scroll down */
						memmovew(vga->v_scrlbase, vga->v_scrl2lin, vga->v_scrlsize);
						memsetw(lline, VGA_CHR(vga, ' '), vga->v_textsizex);
					} else {
						size_t tail = (size_t)(vga->v_textsizex - cur_x);
						if (!ATOMIC_CMPXCH(vga->v_textptr, oldptr, oldptr + tail))
							continue;
						if (vga->at_ansi.at_ttymode & ANSITTY_MODE_NEWLINE_CLRFREE)
							memsetw(oldptr, VGA_CHR(vga, ' '), tail);
					}
				}
				break;
			}
		}	break;

		default: {
			size_t i, len;
			char buf[32];
			if (ch <= 0x1f) {
				len = sprintf(buf, "^%c", ch + '@');
			} else {
				len = sprintf(buf, UNENCODABLE_START "U+%I32X" UNENCODABLE_END, ch);
			}
			for (i = 0; i < len; ++i)
				vga_putcp437(vga, buf[i]);
		}	break;
		}
	}
	if (!(vga->at_ansi.at_ttymode & ANSITTY_MODE_HIDECURSOR))
		vga_update_cursor_pos(vga);
	vga->v_lastch = ch;
}

PRIVATE NONNULL((1)) void LIBANSITTY_CC
VGA_SetTTYMode(struct ansitty *__restrict self,
	           uint16_t new_ttymode)
		THROWS(E_WOULDBLOCK) {
	VGA *vga = container_of(self, VGA, at_ansi);
	if (new_ttymode & ANSITTY_MODE_HIDECURSOR) {
		vga_disable_cursor(vga);
	} else {
		vga_update_cursor_pos(vga);
	}
}

PRIVATE NONNULL((1)) void LIBANSITTY_CC
VGA_SetScrollRegion(struct ansitty *__restrict self,
                    ansitty_coord_t start_line,
                    ansitty_coord_t end_line) {
	VGA *vga = container_of(self, VGA, at_ansi);
	u16 *base = ATOMIC_READ(vga->v_textbase);
	u16 *end  = ATOMIC_READ(vga->v_textend);
	size_t sizex = ATOMIC_READ(vga->v_textsizex);
	u16 *new_scrlbase, *new_scrlllin;
	new_scrlbase = base + start_line * sizex;
	new_scrlllin = base + end_line * sizex;
	if (new_scrlbase > end)
		new_scrlbase = end;
	if (new_scrlbase < base)
		new_scrlbase = base;
	if (new_scrlllin > end)
		new_scrlllin = end;
	new_scrlllin -= sizex;
	if (new_scrlllin < base)
		new_scrlllin = base;
	if (new_scrlllin < new_scrlbase)
		new_scrlllin = new_scrlbase;
	vga->v_scrlbase = new_scrlbase;
	vga->v_scrl2lin = new_scrlbase + sizex;
	vga->v_scrlllin = new_scrlllin;
	vga->v_scrlend  = new_scrlllin + sizex;
	vga->v_scrlsize = (size_t)(new_scrlllin - new_scrlbase);
	vga->v_lastch   = 0; /* Prevent the hidden-newline feature from triggering. */
}



/* Get/Set the current on-screen cursor position. */
PRIVATE NONNULL((1)) void LIBANSITTY_CC
VGA_SetCursor(struct ansitty *__restrict self,
              ansitty_coord_t x, ansitty_coord_t y,
              bool update_hw_cursor)
		THROWS(E_WOULDBLOCK) {
	VGA *vga;
	unsigned int pos;
	vga = container_of(self, VGA, at_ansi);
	if (x < 0)
		x = 0;
	else if (x >= vga->v_textsizex) {
		x = vga->v_textsizex - 1;
	}
	if (y < 0)
		y = 0;
	else if (y >= vga->v_textsizey) {
		y = vga->v_textsizey - 1;
	}
	pos = (unsigned int)x + (unsigned int)y * vga->v_textsizex;
	vga->v_textptr = vga->v_textbase + pos;
	if (update_hw_cursor && !(vga->at_ansi.at_ttymode & ANSITTY_MODE_HIDECURSOR))
		vga_update_cursor_pos(vga);
}

PRIVATE NOBLOCK NONNULL((1, 2)) void
NOTHROW(LIBANSITTY_CC VGA_GetCursor)(struct ansitty *__restrict self,
                                     ansitty_coord_t ppos[2]) {
	VGA *vga = container_of(self, VGA, at_ansi);
	u16 *ptr = ATOMIC_READ(vga->v_textptr);
	size_t offset = (size_t)(ptr - ATOMIC_READ(vga->v_textbase));
	size_t sizex = ATOMIC_READ(vga->v_textsizex);
	ppos[0] = (ansitty_coord_t)(offset % sizex);
	ppos[1] = (ansitty_coord_t)(offset / sizex);
}

PRIVATE NOBLOCK NONNULL((1, 2)) void
NOTHROW(LIBANSITTY_CC VGA_GetSize)(struct ansitty *__restrict self,
                                   ansitty_coord_t psize[2]) {
	VGA *vga = container_of(self, VGA, at_ansi);
	psize[0] = ATOMIC_READ(vga->v_textsizex);
	psize[1] = ATOMIC_READ(vga->v_textsizey);
}

PRIVATE NOBLOCK NONNULL((1)) void
NOTHROW(LIBANSITTY_CC VGA_CopyCell)(struct ansitty *__restrict self,
                                    ansitty_offset_t dst_offset,
                                    ansitty_coord_t count) {
	VGA *vga  = container_of(self, VGA, at_ansi);
	u16 *base = ATOMIC_READ(vga->v_textbase);
	u16 *src  = ATOMIC_READ(vga->v_textptr);
	u16 *end  = ATOMIC_READ(vga->v_textend);
	u16 *ptr, *copyend;
	ptr = src + dst_offset;
	if (ptr < base) {
		size_t underflow;
		underflow = base - ptr;
		if (underflow >= count)
			return;
		ptr = base;
		count -= underflow;
	}
	copyend = ptr + count;
	if (copyend < ptr) {
		count = (size_t)(end - ptr);
	} else {
		if (copyend > end)
			count = copyend - ptr;
	}
	copyend = src + count;
	if (copyend > end)
		count = (size_t)(end - src);
	memmovew(ptr, src, count);
}

PRIVATE NOBLOCK NONNULL((1)) void
NOTHROW(LIBANSITTY_CC VGA_FillCell)(struct ansitty *__restrict self,
                                    char32_t ch,
                                    ansitty_coord_t count) {
	ansitty_coord_t used_count;
	VGA *vga  = container_of(self, VGA, at_ansi);
	u16 *ptr, *end, *copyend, cell;
	char cpch = cp437_encode((u32)ch);
	if unlikely(!cpch)
		cpch = '?';
	cell = VGA_CHR(vga, cpch);
	do {
		ptr = ATOMIC_READ(vga->v_textptr);
		end = ATOMIC_READ(vga->v_textend);
		used_count = count;
		copyend = ptr + used_count;
		if (copyend > end)
			used_count = (size_t)(end - ptr);
	} while (!ATOMIC_CMPXCH_WEAK(vga->v_textptr, ptr, ptr + used_count));
	memsetw(ptr, cell, used_count);
}



PRIVATE struct ansitty_operators const vga_ansi_operators = {
	/* .ato_putc         = */&VGA_Putc,
	/* .ato_setcursor    = */&VGA_SetCursor,
	/* .ato_getcursor    = */&VGA_GetCursor,
	/* .ato_getsize      = */&VGA_GetSize,
	/* .ato_copycell     = */&VGA_CopyCell,
	/* .ato_fillcell     = */&VGA_FillCell,
	/* .ato_scroll       = */NULL, /* TODO */
	/* .ato_cls          = */NULL, /* TODO */
	/* .ato_el           = */NULL, /* TODO */
	/* .ato_setcolor     = */NULL,
	/* .ato_setattrib    = */NULL,
	/* .ato_setttymode   = */&VGA_SetTTYMode,
	/* .ato_scrollregion = */&VGA_SetScrollRegion,
};



PRIVATE NONNULL((1)) syscall_slong_t KCALL
VGA_Ioctl(struct character_device *__restrict self, syscall_ulong_t cmd,
          USER UNCHECKED void *arg, iomode_t mode) THROWS(...) {
	VGA *me = (VGA *)self;
	(void)mode;
	switch (cmd) {

		(void)me;
		(void)arg;
		/* TODO */

	default:
		/* Fallback: Try to service a generic ANSITTY ioctl() */
		return ansitty_device_ioctl(self, cmd, arg, mode);
		break;
	}
	return 0;
}



#define HINT_ADDR(x,y) x
#define HINT_MODE(x,y) y
#define HINT_GETADDR(x) HINT_ADDR x
#define HINT_GETMODE(x) HINT_MODE x

PRIVATE REF VGA *vga = NULL;

PRIVATE DRIVER_INIT void init(void) {
	vga_disable_annoying_blinking();
	vga = CHARACTER_DEVICE_ALLOC(VGA);
	TRY {
		vm_vpage_t vram_page;
		vga->v_vram_addr = (vm_phys_t)0xA0000;
		vga->v_vram_size = 8192 * 4 * 4; /* 128K */
		vram_page = vm_map(&vm_kernel,
		                   (vm_vpage_t)HINT_GETADDR(KERNEL_VMHINT_DEVICE),
		                   CEILDIV(vga->v_vram_size, PAGESIZE),
		                   1, HINT_GETMODE(KERNEL_VMHINT_DEVICE),
		                   &vm_datablock_physical,
		                   (vm_vpage64_t)(vm_ppage_t)VM_ADDR2PAGE(vga->v_vram_addr),
		                   VM_PROT_READ | VM_PROT_WRITE,
		                   VM_NODE_FLAG_NORMAL, 0);
		TRY {
			vga->v_vram = (byte_t *)VM_PAGE2ADDR(vram_page) +
			              (uintptr_t)(vga->v_vram_addr & (PAGESIZE - 1));
			vga->v_crt_i = VGA_CRT_IC;
			vga->v_crt_d = VGA_CRT_DC;
			vga->v_is1_r = VGA_IS1_RC;
			if (!(vga_r(VGA_MIS_R) & VGA_MIS_FCOLOR)) {
				vga->v_crt_i = VGA_CRT_IM;
				vga->v_crt_d = VGA_CRT_DM;
				vga->v_is1_r = VGA_IS1_RM;
			}
			/* Initialize the ANSI layer */
			ansitty_device_cinit(vga, &vga_ansi_operators);
			vga->cd_type.ct_ioctl = &VGA_Ioctl;
			/* TODO: mmap() support */

			strcpy(vga->cd_name, "vga");

			vga->v_textbase  = (u16 *)(vga->v_vram + 0x18000);
			vga->v_textsizex = 80;
			vga->v_textsizey = 25;
			vga->v_text2line = vga->v_textbase + vga->v_textsizex;
			vga->v_textlline = vga->v_textbase + ((vga->v_textsizey - 1) * vga->v_textsizex);
			vga->v_textend   = vga->v_textbase + (vga->v_textsizey * vga->v_textsizex);
			vga->v_textptr   = vga->v_textbase;
			vga->v_scrlbase  = vga->v_textbase;
			vga->v_scrl2lin  = vga->v_text2line;
			vga->v_scrlllin  = vga->v_textlline;
			vga->v_scrlend   = vga->v_textend;
			vga->v_scrlsize  = ((vga->v_textsizey - 1) * vga->v_textsizex);

			/* Register the VGA adapter device. */
			character_device_register_auto(vga);
		} EXCEPT {
			vm_unmap(&vm_kernel, vram_page, CEILDIV(vga->v_vram_size, PAGESIZE));
			RETHROW();
		}
	} EXCEPT {
		destroy(vga);
		vga = NULL;
		RETHROW();
	}
}

PRIVATE DRIVER_FINI void fini(void) {
	if (vga) {
		character_device_unregister(vga);
		decref(vga);
	}
}

DECL_END

#endif /* !GUARD_MODVGA_VGA_C */
