/* Copyright (c) 2019-2021 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2021 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */


import * from deemon;

#define WEAK
#define REF
#define MNODE_F_SHARED 0x0020

global MFile;
global MPart;
global MNode;
global MMan;

class MFile {
	public member mf_parts: REF MPart | none;
};

class MPart {
	public member mp_lhs: REF MPart | none;
	public member mp_rhs: REF MPart | none;
	public member mp_file: REF MFile;
	public member mp_copy: {MNode...};
	public member mp_share: {MNode...};
};


/* NOTES:
 *   - Because any MNode can only ever be parent to 2 other
 *     MNodes, it is possible to use intrusive linked lists
 *     to form the list of nodes apart of the `mn_par' list.
 *   - Because any MMan can only ever be parent to a single
 *     MNode, we can easily use intrusive linked lists to
 *     form the list of MMans associated with some given node!
 */

class MNode {
	public member mn_flags: int;
	public member mn_lhs: REF MNode | none;
	public member mn_rhs: REF MNode | none;
	/* @invariant(this.const_if(refcnt(this) > 1));
	 *    EXCEPTION: The `mn_par' and `mn_mman' can always
	 *               be modified (both addition & removal) */
	/* @invariant(mn_par || mn_mman); */
	/* @refcnt(this) = #mn_par + #mn_mman; */
	public member mn_par: {MNode...};
	public member mn_mman: {WEAK REF MMan...};
	public member mn_part: REF MPart | none;

	public property refcnt: int = { get() { return #mn_par + #mn_mman; } }

	@@Enumerate all memory managers that have mappings of @this node
	@@The enumerated list has arbirary order, but is complete, and only
	@@enumerates every mman using this node exactly once.
	public property all_memory_managers: {MMan...} = {
		get(): {MMan...} {
			yield mn_mman...;
			for (local p: mn_par)
				yield p.all_memory_managers...;
		}
	}

	public function unshare_for_mman(mm: MMan): MNode {
		assert this.refcnt >= 2;
		assert mm in this.mn_mman;
		local result: MNode = this._unshare_for_impl();
		this.mn_mman.remove(mm);
		result.mn_par  = [];
		result.mn_mman = [mm];
		return result;
	}
	public function unshare_for_parent(par: MPart): MNode {
		assert this.refcnt >= 2;
		assert par in this.mn_par;
		local result: MNode = this._unshare_for_impl();
		this.mn_par.remove(par);
		result.mn_par  = [par];
		result.mn_mman = [];
		return result;
	}
	public function _unshare_for_impl(): MNode {
		local result: MNode = copy this;
		if (result.mn_lhs !is none)
			result.mn_lhs.mn_par.append(result);
		if (result.mn_rhs !is none)
			result.mn_rhs.mn_par.append(result);
		if (result.mn_part !is none) {
			if (result.mn_flags & MNODE_F_SHARED) {
				result.mn_part.mp_copy.append(result);
			} else {
				result.mn_part.mp_share.append(result);
			}
		}
		return result;
	}
};

class MMan {
	/* @invariant(this in mn_mappings.mn_mman); */
	/* @invariant(this !in mn_mappings.mn_mman.[[mn_lhs|mn_rhs]...].mn_mman); */
	public member mn_mappings: REF MNode | none;

	public function fork(): MMan {
		local result: MMan = MMan();
		result.mn_mappings = this.mn_mappings;
		if (result.mn_mappings !is none)
			result.mn_mappings.mn_mman.append(result);
		return result;
	}

	public function unshareNodeWithPath(path: {MNode...}): {MNode...} {
		local result = [];
		local parent = this;
		for (local p: path) {
			assert p.refcnt > 0;
			if (p.refcnt > 1) {
				if (parent === this) {
					p = p.unshare_for_mman(this);
					this.mn_mappings = p;
				} else {
					local repl: MNode;
					repl = p.unshare_for_parent(parent);
					assert parent.refcnt == 1;
					assert parent.mn_lhs === p ||
					       parent.mn_rhs === p;
					if (parent.mn_lhs === p) {
						parent.mn_lhs = p;
					} else {
						parent.mn_rhs = p;
					}
					p = repl;
				}
				p = repl;
			}
			assert p.refcnt == 1;
			result.append(p);
			parent = p;
		}
		return result;
	}

	public function insert(node: MNode) {
		/* << R/B-tree impl >>
		 * When needing to write the mp_lhs/mp_rhs/mp_par[i] field of
		 * some node, it is necessary to use `unshare_for_mman()' for
		 * the root-node, and `unshare_for_parent()' for all others
		 * nodes.
		 * This must be done recursively through:
		 * >> local path: {MNode...} = PATH_TO_NODE_TO_MODIFY;
		 * >> assert path && path.last == NODE_TO_MODIFY;
		 * >> path = unshareNodeWithPath(path);
		 * >> NODE_TO_MODIFY = path.last;
		 */

		/* ... */
	}
};


