/* Copyright (c) 2019-2021 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2021 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef GUARD_LIBICONV_ICONV_CTEST
#define GUARD_LIBICONV_ICONV_CTEST 1
#define _KOS_SOURCE 1
#undef NDEBUG

#include <hybrid/compiler.h>

#include <kos/types.h>
#include <system-test/ctest.h>

#include <assert.h>
#include <dlfcn.h>
#include <format-printer.h>
#include <string.h>
#include <unicode.h>

#include <libiconv/codec.h>
#include <libiconv/iconv.h>
#include <libiconv/transliterate.h>


DECL_BEGIN

PRIVATE _LPICONV_TRANSCODE_INIT _iconv_transcode_init = NULL;
PRIVATE LPICONV_DECODE_ISSHIFTZERO iconv_decode_isshiftzero = NULL;
PRIVATE LPICONV_ENCODE_FLUSH iconv_encode_flush = NULL;
PRIVATE LPICONV_CODECBYNAME iconv_codecbyname = NULL;
PRIVATE LPICONV_GETCODECNAMES iconv_getcodecnames = NULL;
PRIVATE LPICONV_DETECT_CODEC iconv_detect_codec = NULL;
PRIVATE LPICONV_TRANSLITERATE iconv_transliterate = NULL;

PRIVATE void convertz(char const *from_codec, char const *to_codec,
                      unsigned int error_mode, char const *from_text,
                      size_t from_len, char *to_buf) {
	struct iconv_transcode tc;
	struct iconv_printer in;
	int error;
	ssize_t status;
	tc.it_encode.ice_output.ii_printer = &format_sprintf_printer;
	tc.it_encode.ice_output.ii_arg     = &to_buf;
	tc.it_encode.ice_flags             = error_mode;

	/* Initialize the transcoder */
	error = (*_iconv_transcode_init)(&tc, &in, from_codec, to_codec);
	assertf(error == 0, "error = %d", error);

	/* Print data */
	status = (*in.ii_printer)(in.ii_arg, from_text, from_len);
	assertf(status >= 0, "status = %" PRIdSIZ, status);

	/* Make sure that the decoder is left in a 0-shift state. */
	assertf((*iconv_decode_isshiftzero)(&tc.it_decode),
	        "decoder (codec=%q) not in 0-shift state after pasing %$q",
	        from_codec, from_len, from_text);

	/* As per recommendations, flush data once everything has been printed. */
	status = (*iconv_encode_flush)(&tc.it_encode);
	assertf(status >= 0, "status = %" PRIdSIZ, status);

	/* NUL-terminate. */
	*to_buf = 0;
}

PRIVATE void convert(char const *from_codec, char const *to_codec,
                     unsigned int error_mode, char const *from_text,
                     char *to_buf) {
	convertz(from_codec, to_codec, error_mode, from_text, strlen(from_text), to_buf);
}

PRIVATE bool has_transliteration(char32_t ch, char const *translit) {
	char utf8_buf[UNICODE_32TO8_MAXBUF(ICONV_TRANSLITERATE_MAXLEN) + 1];
	char32_t buf[ICONV_TRANSLITERATE_MAXLEN];
	size_t len, nth;
	for (nth = 0;; ++nth) {
		len = iconv_transliterate(buf, ch, nth);
		if (len == (size_t)-1)
			break;
		*unicode_32to8(utf8_buf, buf, len) = '\0';
		if (strcmp(utf8_buf, translit) == 0)
			return true;
	}
	return false;
}


DEFINE_TEST(iconv) {
	char buf[256];
	void *libiconv;
	libiconv = dlopen(LIBICONV_LIBRARY_NAME, RTLD_LOCAL);
	assertf(libiconv, "dlerror(): %s", dlerror());
#define DLSYM(x) (*(void **)&x = dlsym(libiconv, #x), assertf(x, "dlerror(): %s", dlerror()))
	DLSYM(_iconv_transcode_init);
	DLSYM(iconv_decode_isshiftzero);
	DLSYM(iconv_encode_flush);
	DLSYM(iconv_codecbyname);
	DLSYM(iconv_getcodecnames);
	DLSYM(iconv_detect_codec);
	DLSYM(iconv_transliterate);
#undef DLSYM

	assert(has_transliteration(0x00E4, "a")); /* ä */
	assert(has_transliteration(0x00F6, "o")); /* ö */
	assert(has_transliteration(0x00FC, "u")); /* ü */
	assert(has_transliteration(0x00C4, "A")); /* Ä */
	assert(has_transliteration(0x00D6, "O")); /* Ö */
	assert(has_transliteration(0x00DC, "U")); /* Ü */


	convert("latin-1", "de", ICONV_ERR_ERRNO, "aou: \xE4\xF6\xFC!", buf);
	assertf(strcmp(buf, "aou: \x7B\x7C\x7D!") == 0, "buf = %q", buf);

	convert("de", "ascii", ICONV_ERR_ERRNO | ICONV_ERR_TRANSLIT, "ss: \x7E!", buf);
	assertf(strcmp(buf, "ss: ss!") == 0, "buf = %q", buf);

	convert("de", "ascii", ICONV_ERR_ERRNO | ICONV_ERR_TRANSLIT, "aou: \x7B\x7C\x7D!", buf);
	assertf(strcmp(buf, "aou: aou!") == 0, "buf = %q", buf);
	convert("latin-1", "ascii", ICONV_ERR_ERRNO | ICONV_ERR_TRANSLIT, "aou: \xE4\xF6\xFC!", buf);
	assertf(strcmp(buf, "aou: aou!") == 0, "buf = %q", buf);

	convert("utf-8", "iso-ir-182", ICONV_ERR_ERRNO, "Yy: \u0176\u0177!", buf);
	assertf(strcmp(buf, "Yy: \xDE\xFE!") == 0, "buf = %q", buf);
	convert("iso-ir-182", "utf-8", ICONV_ERR_ERRNO, "Yy: \xDE\xFE!", buf);
	assertf(strcmp(buf, "Yy: \u0176\u0177!") == 0, "buf = %q", buf);

	{
		char buf2[64];
		convert("utf-8", "bcdic", ICONV_ERR_ERRNO, "ABCD", buf2);
		assertf(strcmp(buf2, "\x31\x32\x33\x34") == 0, "buf2 = %q", buf2);
		convert("bcdic", "utf-8", ICONV_ERR_ERRNO, buf2, buf);
		assertf(strcmp(buf, "ABCD") == 0, "buf = %q", buf);
	}


	/* Also test multi-byte decode functionality. */
	convertz("utf-16", "utf-8", ICONV_ERR_ERRNO, (char *)u"Hello", 10, buf);
	assertf(strcmp(buf, "Hello") == 0, "buf = %q", buf);


#define ASSERT_DETECTED_CODEC(name, data) \
	ASSERT_DETECTED_CODEC_Z(name, data, sizeof(data) - 1)
#define ASSERT_DETECTED_CODEC_Z(name, data, size)                           \
	do {                                                                    \
		iconv_codec_t _dec, _cd = iconv_codecbyname(name);                  \
		assertf(_cd != ICONV_CODEC_UNKNOWN, "Unknown codec: %q", name);     \
		_dec = iconv_detect_codec(data, size);                              \
		assertf(_dec != ICONV_CODEC_UNKNOWN, "Failed to detect any codec"); \
		assertf(_dec == _cd, "Detected %u:%q instead of %q",                \
		        _dec, iconv_getcodecnames(_dec), name);                     \
	}	__WHILE0


	/* Test special cases. */
	assert(iconv_detect_codec("", 0) == ICONV_CODEC_UNKNOWN);
	{
		void *volatile null = NULL;
		assert(iconv_detect_codec(null, 0) == ICONV_CODEC_UNKNOWN);
	}

	/* Test simple input data. Anything beyond this would rely too much on the
	 * internal ASCII-text heuristic to allow  for any safety during  testing. */
	ASSERT_DETECTED_CODEC_Z("utf-8", "Hello World!", 12);
	ASSERT_DETECTED_CODEC_Z("utf-16", u"Hello World!", 24);
	ASSERT_DETECTED_CODEC_Z("utf-32", U"Hello World!", 48);

	/* Test the auto codec detection functionality. */
	ASSERT_DETECTED_CODEC("de",
	                      "Text before the codec marker # codec: de\n"
	                      "Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de",
	                      "Text before the codec marker  codec: de\n"
	                      "Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker /* codec: de */ Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker (* codec: de *) Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker /*codec: de*/ Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker (*codec: de*) Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker /*codec de*/ Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker (*codec de*) Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker /* \t*#@+!$/codec: de \t*#@+!$/*/ Pure ascii!\n");
	ASSERT_DETECTED_CODEC("de", "Text before the codec marker (* \t*#@+!$/codec: de \t*#@+!$/*) Pure ascii!\n");
	ASSERT_DETECTED_CODEC("latin-1", "<meta charset=\"latin-1\"/>\n"
	                                 "<html>\n"
	                                 "\tHello World! aou: \xE4\xF6\xFC\n"
	                                 "</html>\n");

#define ICONV_DETECT_CODEC(s) iconv_detect_codec(s, sizeof(s) - 1)
	EQu(ICONV_DETECT_CODEC("<meta charset=\xE4\"latin-1\"/>\n"
	                       "<html>\n"
	                       "\tHello World! aou: \xE4\xF6\xFC\n"
	                       "</html>\n"),
	    ICONV_CODEC_UNKNOWN);
	EQu(ICONV_DETECT_CODEC("\xE4#codec l1\n"
	                       "Hello World! aou: \xE4\xF6\xFC\n"),
	    ICONV_CODEC_UNKNOWN);
	ASSERT_DETECTED_CODEC("l1",
	                      "#codec l1\n\xE4"
	                      "Hello World! aou: \xE4\xF6\xFC\n");

	/* Test conversion to c-escape (and its variants) */


	/* When encoding a unicode character that isn't printable, it will be escaped in output. */
	convert("utf-8", "c-escape", ICONV_ERR_ERRNO, "Hello\uFFFF\nWorld", buf);
	assertf(strcmp(buf, "Hello\\uFFFF\\nWorld") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-chr", ICONV_ERR_ERRNO, "Hello\uFFFF\nWorld", buf);
	assertf(strcmp(buf, "'Hello\\uFFFF\\nWorld'") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-str", ICONV_ERR_ERRNO, "Hello\uFFFF\nWorld", buf);
	assertf(strcmp(buf, "\"Hello\\uFFFF\\nWorld\"") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes", ICONV_ERR_ERRNO, "Hello\uFFFF\nWorld", buf);
	assertf(strcmp(buf, "Hello\\xEF\\xBF\\xBF\\nWorld") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-chr", ICONV_ERR_ERRNO, "Hello\uFFFF\nWorld", buf);
	assertf(strcmp(buf, "'Hello\\xEF\\xBF\\xBF\\nWorld'") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-str", ICONV_ERR_ERRNO, "Hello\uFFFF\nWorld", buf);
	assertf(strcmp(buf, "\"Hello\\xEF\\xBF\\xBF\\nWorld\"") == 0, "buf = %q", buf);

	/* When a unicode character is printable, it's simply re-printed as-is
	 * HINT: '\u263A' == '☺' (which is considered printable, and should show up as a smiley) */
	convert("utf-8", "c-escape", ICONV_ERR_ERRNO, "Hello\u263A\nWorld", buf);
	assertf(strcmp(buf, "Hello\u263A\\nWorld") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-chr", ICONV_ERR_ERRNO, "Hello\u263A\nWorld", buf);
	assertf(strcmp(buf, "'Hello\u263A\\nWorld'") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-str", ICONV_ERR_ERRNO, "Hello\u263A\nWorld", buf);
	assertf(strcmp(buf, "\"Hello\u263A\\nWorld\"") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes", ICONV_ERR_ERRNO, "Hello\u263A\nWorld", buf);
	assertf(strcmp(buf, "Hello\\xE2\\x98\\xBA\\nWorld") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-chr", ICONV_ERR_ERRNO, "Hello\u263A\nWorld", buf);
	assertf(strcmp(buf, "'Hello\\xE2\\x98\\xBA\\nWorld'") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-str", ICONV_ERR_ERRNO, "Hello\u263A\nWorld", buf);
	assertf(strcmp(buf, "\"Hello\\xE2\\x98\\xBA\\nWorld\"") == 0, "buf = %q", buf);

	convert("utf-8", "c-escape-bytes", ICONV_ERR_ERRNO, "\xAB" "AB", buf);
	assertf(strcmp(buf, "\\xAB\\x41\\x42") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-str", ICONV_ERR_ERRNO, "\xAB" "AB", buf);
	assertf(strcmp(buf, "\"\\xAB\" \"AB\"") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-chr", ICONV_ERR_ERRNO, "\xAB" "AB", buf);
	assertf(strcmp(buf, "\'\\xAB\' \'AB\'") == 0, "buf = %q", buf);

	convert("utf-8", "c-escape", ICONV_ERR_ERRNO, "\\", buf);
	assertf(strcmp(buf, "\\\\") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-str", ICONV_ERR_ERRNO, "\\", buf);
	assertf(strcmp(buf, "\"\\\\\"") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-chr", ICONV_ERR_ERRNO, "\\", buf);
	assertf(strcmp(buf, "\'\\\\\'") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes", ICONV_ERR_ERRNO, "\\", buf);
	assertf(strcmp(buf, "\\\\") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-str", ICONV_ERR_ERRNO, "\\", buf);
	assertf(strcmp(buf, "\"\\\\\"") == 0, "buf = %q", buf);
	convert("utf-8", "c-escape-bytes-chr", ICONV_ERR_ERRNO, "\\", buf);
	assertf(strcmp(buf, "\'\\\\\'") == 0, "buf = %q", buf);

	convert("c-escape", "c-escape-bytes", ICONV_ERR_ERRNO, "Hello\\u263A\\nWorld", buf);
	assertf(strcmp(buf, "Hello\\xE2\\x98\\xBA\\nWorld") == 0, "buf = %q", buf);

	/* The c-escape parser is also able to correctly deal with escaped line-feeds */
	convert("c-escape", "utf-8", ICONV_ERR_ERRNO, "Hello\\nWorld", buf); /* Not escaped */
	assertf(strcmp(buf, "Hello\nWorld") == 0, "buf = %q", buf);
	convert("c-escape", "utf-8", ICONV_ERR_ERRNO, "Hello\\\nWorld", buf); /* Escaped */
	assertf(strcmp(buf, "HelloWorld") == 0, "buf = %q", buf);
	convert("c-escape", "utf-8", ICONV_ERR_ERRNO, "Hello\\\rWorld", buf); /* Escaped */
	assertf(strcmp(buf, "HelloWorld") == 0, "buf = %q", buf);
	convert("c-escape", "utf-8", ICONV_ERR_ERRNO, "Hello\\\r\nWorld", buf); /* Escaped */
	assertf(strcmp(buf, "HelloWorld") == 0, "buf = %q", buf);
	convert("c-escape", "utf-8", ICONV_ERR_ERRNO, "\"Hello\\\r\nWorld\"", buf); /* Escaped */
	assertf(strcmp(buf, "HelloWorld") == 0, "buf = %q", buf);


	/* Test the zero-shift integration for decoding c-escape */
	{
		struct iconv_transcode tc;
		struct iconv_printer in;
		int error;
		ssize_t status;
		char *ptr = buf;
		tc.it_encode.ice_output.ii_printer = &format_sprintf_printer;
		tc.it_encode.ice_output.ii_arg     = &ptr;
		tc.it_encode.ice_flags             = ICONV_ERR_ERRNO;
		error = (*_iconv_transcode_init)(&tc, &in, "c-escape", "utf-8");
		assertf(error == 0, "error = %d", error);
#define PRINT(s)                                                      \
		(status = (*in.ii_printer)(in.ii_arg, s, COMPILER_STRLEN(s)), \
		 assertf(status >= 0, "status = %" PRIdSIZ, status))

		/* The c-escape decoder is only is 0-shift state while outside of a string literal!
		 * NOTE: This also tests that feeding the codec its data piece-wise works correctly. */
		assert((*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("\"");
		assert(!(*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("Hello\\");
		assert(!(*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("\r");
		assert(!(*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("\n");
		assert(!(*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("\"");
		assert((*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("   \t  \n \r \r\n \t  "); /* Only whitespace is allowed to appear here; anything else causes errors! */
		assert((*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("\"");
		assert(!(*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("World");
		assert(!(*iconv_decode_isshiftzero)(&tc.it_decode));
		PRINT("\"");

		/* As per recommendations, flush data once everything has been printed. */
		status = (*iconv_encode_flush)(&tc.it_encode);
		assertf(status >= 0, "status = %" PRIdSIZ, status);

		/* NUL-terminate. */
		*ptr = 0;

		/* Ensure that the correct data was decoded. */
		assertf(strcmp(buf, "HelloWorld") == 0, "buf = %q", buf);
	}


	/* Test the xml-escape codec. */
	convert("xml-escape", "utf-8", ICONV_ERR_ERRNO, "Foo&quot;&amp;&apos;&lt;&gt;Bar", buf);
	assertf(strcmp(buf, "Foo\"&\'<>Bar") == 0, "buf = %q", buf);
	convert("utf-8", "xml-escape", ICONV_ERR_ERRNO, "Foo\"&\'<>Bar", buf);
	/* Depending on  configuration, libiconv  may either  use
	 * entity names or (where doing so is shorter), decimals. */
	assertf(strcmp(buf, "Foo&quot;&amp;&apos;&lt;&gt;Bar") == 0 ||
	        strcmp(buf, "Foo&#34;&#38;&#39;&#60;&#62;Bar") == 0,
	        "buf = %q", buf);
	convert("xml-escape", "utf-8", ICONV_ERR_ERRNO, "A&nbspB", buf); /* The trailing ';' is optional for '&nbsp' */
	assertf(strcmp(buf, "A\u00A0B") == 0, "buf = %q", buf);
	convert("xml-escape", "utf-8", ICONV_ERR_ERRNO, "A&nbsp;B", buf);
	assertf(strcmp(buf, "A\u00A0B") == 0, "buf = %q", buf);
	convert("xml-escape", "utf-8", ICONV_ERR_ERRNO, "A&nbsp", buf);
	assertf(strcmp(buf, "A\u00A0") == 0, "buf = %q", buf);
	convert("xml-escape", "utf-8", ICONV_ERR_ERRNO, "A&nbsp;", buf);
	assertf(strcmp(buf, "A\u00A0") == 0, "buf = %q", buf);


	/* Test the uri-escape codec. */
	convert("ascii", "uri-escape", ICONV_ERR_ERRNO, "Hello World", buf);
	assertf(strcmp(buf, "Hello%20World") == 0, "buf = %q", buf);
	convert("uri-escape", "ascii", ICONV_ERR_ERRNO, "Hello%20World", buf);
	assertf(strcmp(buf, "Hello World") == 0, "buf = %q", buf);


	/* Test the hex codec. */
	convert("ascii", "hex", ICONV_ERR_ERRNO, "Hello World", buf);
	assertf(strcmp(buf, "48656C6C6F20576F726C64") == 0, "buf = %q", buf);
	convert("ascii", "hex-upper", ICONV_ERR_ERRNO, "Hello World", buf);
	assertf(strcmp(buf, "48656C6C6F20576F726C64") == 0, "buf = %q", buf);
	convert("ascii", "hex-lower", ICONV_ERR_ERRNO, "Hello World", buf);
	assertf(strcmp(buf, "48656c6c6f20576f726c64") == 0, "buf = %q", buf);
	convert("hex", "ascii", ICONV_ERR_ERRNO, "48656C6C6F20576F726C64", buf);
	assertf(strcmp(buf, "Hello World") == 0, "buf = %q", buf);
	convert("hex", "ascii", ICONV_ERR_ERRNO, "48656c6c6f20576f726c64", buf);
	assertf(strcmp(buf, "Hello World") == 0, "buf = %q", buf);



	dlclose(libiconv);
}


DECL_END

#endif /* !GUARD_LIBICONV_ICONV_CTEST */
