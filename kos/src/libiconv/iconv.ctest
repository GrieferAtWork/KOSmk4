/* Copyright (c) 2019-2021 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2021 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */
#ifndef GUARD_LIBICONV_ICONV_CTEST
#define GUARD_LIBICONV_ICONV_CTEST 1
#define _KOS_SOURCE 1
#undef NDEBUG

#include <hybrid/compiler.h>

#include <kos/types.h>
#include <system-test/ctest.h>

#include <assert.h>
#include <dlfcn.h>
#include <format-printer.h>
#include <string.h>

#include <libiconv/iconv.h>


DECL_BEGIN

PRIVATE _LPICONV_TRANSCODE_INIT _iconv_transcode_init = NULL;
PRIVATE LPICONV_ENCODE_FLUSH iconv_encode_flush = NULL;
;

PRIVATE void convertz(char const *from_codec, char const *to_codec,
                      unsigned int error_mode, char const *from_text,
                      size_t from_len, char *to_buf) {
	struct iconv_transcode tc;
	struct iconv_printer in;
	int error;
	ssize_t status;
	tc.it_encode.ice_output.ii_printer = &format_sprintf_printer;
	tc.it_encode.ice_output.ii_arg     = &to_buf;
	tc.it_encode.ice_flags             = error_mode;

	/* Initialize the transcoder */
	error = (*_iconv_transcode_init)(&tc, &in, from_codec, to_codec);
	assertf(error == 0, "error = %d", error);

	/* Print data */
	status = (*in.ii_printer)(in.ii_arg, from_text, from_len);
	assertf(status >= 0, "status = %" PRIdSIZ, status);

	/* As per recommendations, flush data once everything has been printed. */
	status = (*iconv_encode_flush)(&tc.it_encode);
	assertf(status >= 0, "status = %" PRIdSIZ, status);

	/* NUL-terminate. */
	*to_buf = 0;
}

PRIVATE void convert(char const *from_codec, char const *to_codec,
                     unsigned int error_mode, char const *from_text,
                     char *to_buf) {
	convertz(from_codec, to_codec, error_mode, from_text, strlen(from_text), to_buf);
}


DEFINE_TEST(iconv) {
	char buf[256];
	void *libiconv;
	libiconv = dlopen(LIBICONV_LIBRARY_NAME, RTLD_LOCAL);
	assertf(libiconv, "dlerror(): %s", dlerror());
#define DLSYM(x) (*(void **)&x = dlsym(libiconv, #x), assertf(x, "dlerror(): %s", dlerror()))
	DLSYM(_iconv_transcode_init);
	DLSYM(iconv_encode_flush);
#undef DLSYM

	convert("latin-1", "de", ICONV_ERR_ERRNO, "aou: \xE4\xF6\xFC!", buf);
	assertf(strcmp(buf, "aou: \x7B\x7C\x7D!") == 0, "buf = %q", buf);

	convert("de", "ascii", ICONV_ERR_ERRNO | ICONV_ERR_TRANSLIT, "ss: \x7E!", buf);
	assertf(strcmp(buf, "ss: ss!") == 0, "buf = %q", buf);

	convert("utf-8", "iso-ir-182", ICONV_ERR_ERRNO, "Yy: \u0176\u0177!", buf);
	assertf(strcmp(buf, "Yy: \xDE\xFE!") == 0, "buf = %q", buf);
	convert("iso-ir-182", "utf-8", ICONV_ERR_ERRNO, "Yy: \xDE\xFE!", buf);
	assertf(strcmp(buf, "Yy: \u0176\u0177!") == 0, "buf = %q", buf);

	{
		char buf2[64];
		convert("utf-8", "bcdic", ICONV_ERR_ERRNO, "ABCD", buf2);
		assertf(strcmp(buf2, "\x31\x32\x33\x34") == 0, "buf2 = %q", buf2);
		convert("bcdic", "utf-8", ICONV_ERR_ERRNO, buf2, buf);
		assertf(strcmp(buf, "ABCD") == 0, "buf = %q", buf);
	}


	/* Also test multi-byte decode functionality. */
	convertz("utf-16", "utf-8", ICONV_ERR_ERRNO, (char *)u"Hello", 10, buf);
	assertf(strcmp(buf, "Hello") == 0, "buf = %q", buf);

	dlclose(libiconv);
}


DECL_END

#endif /* !GUARD_LIBICONV_ICONV_CTEST */
