/* Copyright (c) 2019-2021 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2021 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .util;
import fs;
import util;


global final CP_CLASS_8      = 0;
global final CP_CLASS_7L     = 1;
global final CP_CLASS_7H     = 2;
global final CP_CLASS_ISO646 = 3;

global final ISO646_OVERRIDE_ORDINALS = {
	0x21, 0x22, 0x23, 0x24, 0x26, 0x3a, 0x3f, 0x40, 0x5b,
	0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d, 0x7e
};

class CodecAlias {
	this = default;
	public member ppCond: string = "1";
	public member name: string;
}

class Codec {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];
}

class CodePage {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];
	public member table: {int...} = List([0] * 256);

	@@Returns one of `CP_CLASS_*`
	public function getCpClass(): int {
		if (table[:128] == [:128])
			return CP_CLASS_7H;
		if (!(table[128:256] + ...)) {
			/* Check for ISO646 */
			local iso646_table = List([:128]);
			for (local i: ISO646_OVERRIDE_ORDINALS)
				iso646_table[i] = table[i];
			if (iso646_table == table[:128])
				return CP_CLASS_ISO646;
			return CP_CLASS_7L;
		}
		return CP_CLASS_8;
	}
}

class StatefulCodec {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];

	@@Single-byte table
	public member sb_table: {int...} = List([0] * 256);

	@@Double-byte table
	public member db_table: {int: int | {int...}} = Dict();
}



function getEncodeTable(table: {int...}, shift: int): {int: int} {
	local result = Dict();
	for (local encoded, decoded: util.enumerate(table))
		result.setdefault(decoded, encoded + shift);
	return result;
}

function dbFieldName(name: string): string {
	if (name.startswith("CODEC_"))
		return "db_" + name[6:];
	return "db_" + name;
}


function parseCodecAlias(s: string): CodecAlias {
	local ppCond = "1";
	s = s.strip();
	if (s.startswith("[")) {
		s = s[1:].lstrip();
		if (!s.startswith("if"))
			throw Error("Expected 'if' after '['");
		s = s[2:].lstrip();
		if (!s.startswith("("))
			throw Error("Expected '(' after '[if'");
		s = s[1:].lstrip();
		local condEnd = s.findmatch("(", ")");
		if (condEnd < 0)
			throw Error("Missing ')' after '[if('");
		ppCond = s[:condEnd].strip();
		s = s[condEnd+1:].lstrip();
		if (!s.startswith("]"))
			throw Error("Expected ']' after '[if(...)'");
		s = s[1:].lstrip();
	}
	return CodecAlias(ppCond: ppCond, name:
		normalizeCodecName(s.decode("c-escape")));
}

function constructCodecObject(typ: Type, arg: string): Object {
	local name, none, aliases = arg.partition(":")...;
	return typ(name: name, aliases: Tuple(
		for (local x: aliases.split(","))
			parseCodecAlias(x)));
}


function parseDBFilename(filename: string): {string: Object} {
	print File.stderr: "Loading database:", repr filename;
	local result = Dict();
	local data = File.open(filename, "r").read().decode("utf-8");
	local newData = File.Writer();
	function errAt(i: int, msg: string) {
		local sol = data.rfind("\n", 0, i) + 1;
		local line = data.count("\n", 0, sol) + 1;
		local col = 1 + (i - sol);
		print(filename, "(", line, ",", col, ") : ", msg);
		throw Error(msg);
	}
	local currentItem = none;
	local currentIndex = none;
	local currentTable = none;
	local i = 0, len = #data, flushStart = 0;
	local usedNames = HashSet();
	while (i < len) {
		local ch = data[i];
		if (ch.isspace()) {
			++i;
			continue;
		}
		if (ch == "#") {
			i = data.find("\n", i);
			if (i < 0)
				i = len;
			else {
				++i;
			}
			continue;
		}
		if (ch == "@") {
			++i;
			if (i >= len || !data.issymstrt(i))
				errAt(i, "Expected keyword after '@'");
			local kwdStart = i;
			++i;
			while (i < len && data.issymcont(i))
				++i;
			local kwd = data[kwdStart:i];
			while (i < len && data.isspace(i))
				++i;
			local arg = none;
			local argStart = none;
			if (i < len && data[i] == "(") {
				argStart = i + 1;
				local argEnd = data.findmatch("(", ")", argStart);
				if (argEnd < 0)
					errAt(i, "Unmatched '('");
				arg = data[argStart:argEnd];
				i = argEnd + 1;
			}
			function constructCurrentItem(typ: Type): Object {
				local obj = constructCodecObject(typ, arg);
				if (obj.name in result)
					errAt(argStart, "Codec " + obj.name + " already defined");
				result[obj.name] = obj;
				for (local a: obj.aliases) {
					if (a.ppCond != "1")
						continue;
					local lower_a = a.name.lower();
					if (lower_a in usedNames)
						errAt(argStart, "Alias " + a.name + " already defined");
					usedNames.insert(lower_a);
				}
				return obj;
			}

			switch (kwd.lower()) {

			case "include": {
				local argFilename = arg.decode("c-escape").replace("\\", "/");
				while (argFilename.startswith("./"))
					argFilename = argFilename[2:];
				local otherFilename = fs.joinpath(fs.headof(filename), argFilename);
				result.update(parseDBFilename(otherFilename));
			}	break;

			case "codec":
				currentItem  = constructCurrentItem(Codec);
				currentIndex = 0;
				currentTable = none;
				break;

			case "cp":
				currentItem  = constructCurrentItem(CodePage);
				currentIndex = 0;
				currentTable = currentItem.table;
				break;

			case "codec_stateful":
				currentItem  = constructCurrentItem(StatefulCodec);
				currentIndex = 0;
				currentTable = none;
				break;

			case "sb":
				if (currentItem !is StatefulCodec)
					errAt(argStart, "@SB is only allowed for @CODEC_STATEFUL");
				currentIndex = 0;
				currentTable = currentItem.sb_table;
				break;

			case "db":
				if (currentItem !is StatefulCodec)
					errAt(argStart, "@SB is only allowed for @CODEC_STATEFUL");
				currentIndex = 0;
				currentTable = currentItem.db_table;
				break;

			case "ord": {
				local oldIndex = currentIndex;
				try {
					currentIndex = int(arg);
				} catch (...) {
					errAt(argStart, "Expected integer for @ord, but got " + repr arg);
				}
				if (currentItem is CodePage && oldIndex == 0) {
					for (local i: [oldIndex:currentIndex]) {
						if (currentItem.table[i] == 0)
							currentItem.table[i] = i;
					}
				}
			}	break;

			default:
				errAt(kwdStart, "Unknown command: " + repr kwd);
			}
			continue;
		}
		if (ch.isalnum()) {
			if (currentTable is none)
				errAt(i, "Unable to define ordinals at this time");
			if (currentTable is List) {
				local lineIds = [];
				local lineStart = i;
				for (;;) {
					local uniStart = i;
					++i;
					while (i < len && data.isalnum(i))
						++i;
					local uni;
					local istr = data[uniStart:i].lower();
					if (istr.startswith("0x"))
						istr = istr[2:];
					try {
						uni = int("0x" + istr);
					} catch (...) {
						errAt(uniStart, "Invalid hex integer: " + repr data[uniStart:i]);
					}
					lineIds.append(uni);
					if (currentIndex >= 256)
						errAt(uniStart, "Character index out-of-bounds");
					currentTable[currentIndex] = uni;
					++currentIndex;
					while (i < len && data.isspace(i) && !data.islf(i))
						++i;
					if (i < len && data[i] == ",") {
						do {
							++i;
						} while (i < len && data.isspace(i) && !data.islf(i));
					}
					if (i >= len || !data.isalnum(i))
						break;
				}
				if (i >= len || data[i] in "#\n") {
					while (i > 0 && data.isspace(i - 1) && !data.islf(i - 1))
						--i;
					i = data.find("\n", i);
					if (i < 0)
						i = len;
					newData << data[flushStart:lineStart];
					for (local uni: lineIds)
						newData << uni.hex()[2:].upper().zfill(4) << " ";
					newData << "  # "
						<< (currentIndex - #lineIds).hex()[2:].upper().zfill(2)
						<< "-" << (currentIndex - 1).hex()[2:].upper().zfill(2)
						<< "  ";
					for (local uni: lineIds)
						newData << " " << uniEscape(uni);
					newData << " #";
					flushStart = i;
				}
				continue;
			} else if (currentTable is Dict) {
				/* Supported:
				 *   - ABCD    = 1234       // Single code-point
				 *   - ABCD+FF = 1234       // Map 255 consecutive points from ABCD to 1234+0, +1, +2, ...
				 *   - ABCD    = 1234,1235  // Map code point to a sequence of unicode characters */
				local ordStart = i;
				do {
					++i;
				} while (i < len && data.isalnum(i));
				local cp_ord, count = 1;
				try {
					cp_ord = int("0x" + data[ordStart:i]);
				} catch (...) {
					errAt(ordStart, "Invalid hex integer: " + repr data[ordStart:i]);
				}
				while (i < len && data.isspace(i))
					++i;
				if (i < len && data[i] == "+") {
					do {
						++i;
					} while (i < len && data.isspace(i));
					if (i >= len || !data.isalnum(i))
						errAt(i, "Expected digit after 'ABCD+'");
					local countStart = i;
					do {
						++i;
					} while (i < len && data.isalnum(i));
					try {
						count = int("0x" + data[countStart:i]);
					} catch (...) {
						errAt(countStart, "Invalid hex integer: " + repr data[countStart:i]);
					}
					while (i < len && data.isspace(i))
						++i;
				}
				if (i >= len || data[i] != "=")
					errAt(i, "Expected '=' after 'ABCD[+123]'");
				do {
					++i;
				} while (i < len && data.isspace(i));
				if (i >= len || !data.isalnum(i))
					errAt(i, "Expected digit after 'ABCD[+123]='");
				local uniOrds = [];
				for (;;) {
					local uniStart = i;
					do {
						++i;
					} while (i < len && data.isalnum(i));
					try {
						uniOrds.append(int("0x" + data[uniStart:i]));
					} catch (...) {
						errAt(uniStart, "Invalid hex integer: " + repr data[uniStart:i]);
					}
					while (i < len && data.isspace(i))
						++i;
					if (i >= len || data[i] != ",")
						break;
					do {
						++i;
					} while (i < len && data.isspace(i));
					if (i >= len || !data.isalnum(i))
						errAt(i, "Expected digit after 'ABCD=6789,'");
				}
				if (#uniOrds <= 1)
					uniOrds = uniOrds.first;
				else {
					uniOrds = Tuple(uniOrds);
				}
				if (count == 1) {
					currentTable[cp_ord] = uniOrds;
				} else {
					if (uniOrds !is int)
						errAt(ordStart, "Cannot encode multiple unicode characters range mappings");
					for (local offset: [:count])
						currentTable[cp_ord + offset] = uniOrds + offset;
				}
				continue;
			}
			errAt(i, "Unsupported type of currentTable: " + str(type(currentTable)));
			continue;
		}
		errAt(i, "Unexpected character: " + repr ch);
	}
	newData << data[flushStart:];
	newData = newData.string;
	if (newData != data) {
		newData = newData.encode("utf-8");
		with (local fp = File.open(filename, "w"))
			fp.write(newData);
	}

	local byTable = Dict();
	for (local none, tab: result) {
		if (tab is CodePage) {
			tab.table = Tuple(tab.table);
			if (tab.table == [:256])
				throw Error("Codec " + repr tab.name + " is just latin-1");
			if (tab.table == ([:128] + {0} * 128))
				throw Error("Codec " + repr tab.name + " is just ascii");
			local rp = repr tab.table;
			if (rp in byTable) {
				throw Error("Duplicate table: " +
					tab.name + " and " +
					byTable[rp].name + " (" + repr rp + ")");
			}
			byTable[rp] = tab;
		}
	}
	return result;
}

function parseDB(): {string: Object} {
	return parseDBFilename(fs.joinpath(fs.headof(__FILE__), "db"));
}

global final CODECS = parseDB();

/* Hacky way to work around deemon taking forever to exit (XXX: might be a deemon bug?) */
Error.AppExit.atexit([]{ Error.AppExit.exit(0); });

function printCodecEnums() {
	local codecs_custom = [];
	local codecs_cp8 = [];
	local codecs_cp7l = [];
	local codecs_cp7h = [];
	local codecs_iso646 = [];
	local codecs_stateful = [];
	for (local name, codec: CODECS) {
		if (codec is CodePage) {
			switch (codec.getCpClass()) {
			case CP_CLASS_8:
				codecs_cp8.append(name);
				break;
			case CP_CLASS_7L:
				codecs_cp7l.append(name);
				break;
			case CP_CLASS_7H:
				codecs_cp7h.append(name);
				break;
			case CP_CLASS_ISO646:
				codecs_iso646.append(name);
				break;
			}
		} else if (codec is StatefulCodec) {
			codecs_stateful.append(name);
		} else {
			codecs_custom.append(name);
		}
	}

	function printCodec(name: string, len: int) {
		local codec = CODECS[name];
		print("	", name, ",", " " * (len - #name),
			" /* ", ", ".join(
				for (local x: codec.aliases)
					if (x.ppCond == "1")
						repr(x.name)),
			" */");
	}

	function printCodecs(names: {string...}) {
		local maxLen = names.each.length > ...;
		for (local name: names)
			printCodec(name, maxLen);
	}

	codecs_custom.sort();
	codecs_cp8.sort();
	codecs_cp7l.sort();
	codecs_cp7h.sort();
	codecs_iso646.sort();
	codecs_stateful.sort();

	print("	/* Custom codecs */");
	printCodecs(codecs_custom);

	print;
	print("	/* 8-bit codepage codecs */");
	print("#define CODEC_CP_COUNT ", #codecs_cp8);
	if (codecs_cp8) {
		print("#define CODEC_CP_MIN ", codecs_cp8.first);
		printCodecs(codecs_cp8);
		print("#define CODEC_CP_MAX ", codecs_cp8.last);
	}

	print;
	print("	/* 7l codepage codecs */");
	print("#define CODEC_CP7L_COUNT ", #codecs_cp7l);
	if (codecs_cp7l) {
		print("#define CODEC_CP7L_MIN ", codecs_cp7l.first);
		printCodecs(codecs_cp7l);
		print("#define CODEC_CP7L_MAX ", codecs_cp7l.last);
	}

	print;
	print("	/* 7h codepage codecs */");
	print("#define CODEC_CP7H_COUNT ", #codecs_cp7h);
	if (codecs_cp7h) {
		print("#define CODEC_CP7H_MIN ", codecs_cp7h.first);
		printCodecs(codecs_cp7h);
		print("#define CODEC_CP7H_MAX ", codecs_cp7h.last);
	}

	print;
	print("	/* iso646 codepage codecs */");
	print("#define CODEC_ISO646_COUNT ", #codecs_iso646);
	if (codecs_iso646) {
		print("#define CODEC_ISO646_MIN ", codecs_iso646.first);
		printCodecs(codecs_iso646);
		print("#define CODEC_ISO646_MAX ", codecs_iso646.last);
	}

	print;
	print("	/* Stateful codepage codecs */");
	print("#define CODEC_STATEFUL_COUNT ", #codecs_stateful);
	if (codecs_stateful) {
		print("#define CODEC_STATEFUL_MIN ", codecs_stateful.first);
		printCodecs(codecs_stateful);
		print("#define CODEC_STATEFUL_MAX ", codecs_stateful.last);
	}
}



function printCodecNameDB() {
	local longestAliasLength = 0;
	@@Maps alias -> ppCond -> codec
	local aliasToCodecMapping: {string: {string: Object}} = Dict();
	print("struct codec_name_db_struct {");
	print("	char _hdr_nul[2];");
	local longestDbNameLength = 0;
	for (local name: CODECS.keys.sorted()) {
		local codec = CODECS[name];
		print;
		print("	/* ", name, " */");
		local base = dbFieldName(name);
		local longestAliasNameLenLen = #str((codec.aliases.each.name.length + 1) > ...);
		local prevPpCond = "1";
		for (local i, alias: util.enumerate(codec.aliases)) {
			local name = alias.name;
			local lenPlusOne = str(#name+1);
			if (prevPpCond != alias.ppCond) {
				if (prevPpCond != "1")
					print("#endif /* ", prevPpCond, " */");
				if (alias.ppCond != "1")
					print("#if ", alias.ppCond);
				prevPpCond = alias.ppCond;
			}
			local dbName = "{}_{}".format({ base, i });
			if (longestDbNameLength < #dbName)
				longestDbNameLength = #dbName;
			print("	char ", dbName, "[", lenPlusOne, "]; ",
				" " * (longestAliasNameLenLen - #lenPlusOne),
				"/* ", repr name, " */");
			local map = aliasToCodecMapping.get(name);
			if (map is none)
				aliasToCodecMapping[name] = map = Dict();
			assert alias.ppCond !in map,
				"name:" + repr name + "\n"
				"map: " + repr map.keys + "\n"
				"ppCond:" + repr alias.ppCond;
			map[alias.ppCond] = codec;
		}
		if (prevPpCond != "1")
			print("#endif /* ", prevPpCond ?: "...", " */");
		print("	char ", base, "_nul;");
	}
	print("};");
	print;
	print("/* Name database */");
	print("PRIVATE struct codec_name_db_struct const codec_name_db = {");
	print("	{ 0, 0 },");
	for (local name: CODECS.keys.sorted()) {
		local codec = CODECS[name];
		print;
		print("	/* ", name, " */");
		local prevPpCond = "1";
		for (local i, alias: util.enumerate(codec.aliases)) {
			local name = alias.name;
			local lenPlusOne = str(#name+1);
			if (prevPpCond != alias.ppCond) {
				if (prevPpCond != "1")
					print("#endif /* ", prevPpCond, " */");
				if (alias.ppCond != "1")
					print("#if ", alias.ppCond);
				prevPpCond = alias.ppCond;
			}
			print("	", repr name, ",");
		}
		if (prevPpCond != "1")
			print("#endif /* ", prevPpCond ?: "...", " */");
		print("	0,");
	}
	print("};");
	print;
	print("STATIC_ASSERT((codec_name_db_offset_t)-1 >= sizeof(struct codec_name_db_struct));");
	/* Offset tables. */
	local longestAliasLength = aliasToCodecMapping.keys.each.length > ...;
	print("#define CODE_NAME_MAXLEN ", longestAliasLength);
	print("struct codec_db_entry {");
	print("	codec_name_db_offset_t cdbe_name;  /* Offset to name within `codec_name_db' */");
	print("	iconv_codec_t          cdbe_codec; /* The associated codec. */");
	print("};");
	print;
	print("PRIVATE struct codec_db_entry const codec_db[] = {");
	for (local name: aliasToCodecMapping.keys.sorted()) {
		local lastPpCond = none;
		for (local ppCond, codec: aliasToCodecMapping[name]) {
			if (lastPpCond is none) {
				if (ppCond != "1") {
					print("#if ", ppCond);
					lastPpCond = ppCond;
				}
			} else if (ppCond != "1") {
				lastPpCond = "";
				print("#elif ", ppCond);
			}
			local index = (codec.aliases.each.name as Sequence).index(name);
			local dbName = "{}_{}".format({ dbFieldName(codec.name), index });
			print("	{ offsetof(struct codec_name_db_struct, ", dbName, "),",
				" /* ", " " * (longestDbNameLength - #dbName),
				repr name, " " * (longestAliasLength - #name),
				" */ ", codec.name, " },");
		}
		if (lastPpCond !is none)
			print("#endif /* ", lastPpCond ?: "..." , " */");
	}
	print("};");
}

function printCodepageDatabase(kind: int) {
	local cpInsert = {
		CP_CLASS_8  : "",
		CP_CLASS_7L : "7l",
		CP_CLASS_7H : "7h",
	}[kind];
	local cpInsertUpper = cpInsert.upper();
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is CodePage && codec.getCpClass() == kind)
			codecs.append(codec);
	}
	codecs.sort(CodePage.name);
	print("/* Codepage database blob. */");
	print("struct iconv_cp", cpInsert, "_database {");
	for (local cp: codecs) {
		local table = cp.table;
		local shift = 0;
		if (kind == CP_CLASS_7L) {
			table = table[:128];
		} else if (kind == CP_CLASS_7H) {
			table = table[128:];
			shift = 128;
		}
		local encode_table = getEncodeTable(table, shift);
		local len = str(#encode_table);
		print("	struct { char16_t _d[", #table, "]; struct iconv_codepage_encode_entry _e[", len, "]; ",
			" " * (3 - #len), " } ", dbFieldName(cp.name), ";");
	}
	print("};");

	print;
	print("/* Codepage database offsets. */");
	print("STATIC_ASSERT((libiconv_cp", cpInsert, "_offset_t)-1 >= sizeof(struct iconv_cp", cpInsert, "_database));");
	print("STATIC_ASSERT(CODEC_CP", cpInsertUpper, "_MIN + ", (#codecs-1), " == CODEC_CP", cpInsertUpper, "_MAX);");
	print("INTERN_CONST libiconv_cp", cpInsert, "_offset_t const libiconv_cp", cpInsert, "_offsets[", #codecs, "] = {");
	for (local cp: codecs) {
		print("	[", cp.name, " - CODEC_CP", cpInsertUpper, "_MIN] = offsetof(struct iconv_cp", cpInsert, "_database, ", dbFieldName(cp.name), "),");
	}
	print("};");

	print;
	print("/* The actual codepage database. */");
	print("INTERN_CONST struct iconv_cp", cpInsert, "_database const libiconv_cp", cpInsert, "_db = {");
	for (local cp: codecs) {
		local table = cp.table;
		local shift = 0;
		if (kind == CP_CLASS_7L) {
			table = table[:128];
		} else if (kind == CP_CLASS_7H) {
			table = table[128:];
			shift = 128;
		}
		local encode_table = getEncodeTable(table, shift);
		print("	.", dbFieldName(cp.name), " = { {");
		for (local i, l: util.enumerate(table.segments(8))) {
			local lo = shift + (i * 8);
			print("		", ", ".join(for (local x: l) "0x" + x.hex()[2:].zfill(4)), ", /* ",
				lo.hex()[2:].zfill(2), "h-",
				(lo + 7).hex()[2:].zfill(2), "h */");
		}
		print("	}, {");
		for (local i, ord: util.enumerate(encode_table.keys.sorted())) {
			if ((i % 4) == 0)
				print("		"),;
			local cp_ord = encode_table[ord];
			print("{ 0x", ord.hex()[2:].zfill(4), ", 0x", cp_ord.hex()[2:].zfill(2)),;
			if (i == 0) {
				local count = #encode_table;
				if (kind == CP_CLASS_8)
					--count;
				print(", ", count),;
			} else if (i == 1 && kind != CP_CLASS_7H) {
				local repl_char = encode_table.get("?".ord());
				if (repl_char is none) repl_char = encode_table.get(".".ord());
				if (repl_char is none) repl_char = encode_table.get("-".ord());
				if (repl_char is none) repl_char = 0;
				print(", 0x", repl_char.hex()[2:].zfill(2)),;
			}
			print(" },"),;
			if ((i % 4) == 3)
				print;
			else if (i != #encode_table - 1) {
				print(" "),;
			}
		}
		if ((#encode_table % 4) != 0)
			print;
		print("	} },");
	}
	print("};");
}

function printCp8Database() -> printCodepageDatabase(CP_CLASS_8);
function printCp7lDatabase() -> printCodepageDatabase(CP_CLASS_7L);
function printCp7hDatabase() -> printCodepageDatabase(CP_CLASS_7H);

function printCpIso646Database() {
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is CodePage && codec.getCpClass() == CP_CLASS_ISO646)
			codecs.append(codec);
	}
	codecs.sort(CodePage.name);
	print("INTERN_CONST struct iconv_iso646_codepage const libiconv_iso646_pages[", #codecs, "] = {");
	local longestNameLen = codecs.each.name.length > ...;
	for (local codec: codecs) {
		print("	[", codec.name, " - CODEC_ISO646_MIN]",
			" " * (longestNameLen - #codec.name), " = { { ",
			", ".join(
				for (local x: ISO646_OVERRIDE_ORDINALS)
					"0x" + codec.table[x].hex()[2:].zfill(4)),
			" } },");
	}
	print("};");
}


class ExStatefulCodec {
	this = default;
	public member codec: StatefulCodec;
	public member isc_rab_minoff: int;
	public member isc_rab_maxoff: int;
	public member isc_db_ranges: {(int, int)...} = [];
	public member isc_rab: {int...} = [];
	public member isc_u16: {int...} = [];
	public member isc_u32: {int...} = [];
	public member isc_encode_rab_minoff: int;
	public member isc_encode_rab_maxoff: int;
	public member isc_encode_repl: int;
	public member isc_encode_ranges: {(int, int)...} = [];
	public member isc_encode_rab: {int...} = [];
	public member isc_encode_tab: {int...} = [];
	public member isc_encode_2ch: {(int, int)...} = [];
	public member isc_encode_c32: {(int, int)...} = [];
}


function printCpStatefulDatabase() {
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is StatefulCodec)
			codecs.append(codec);
	}
	codecs.sort(StatefulCodec.name);
	local exCodecs: {ExStatefulCodec...} = [];

	/* Generate extended codec data. */
	for (local codec: codecs) {
		@@List of (cp_min, count, uni_min | {uni_ord...})
		local ranges: (int, int, int) = [];
		for (local cp_ord = 0; cp_ord <= 0xffff;) {
			local uni_ord = codec.db_table.get(cp_ord, 0);
			if (uni_ord !is int) {
				ranges.append((cp_ord, 1, (uni_ord,)));
				++cp_ord;
				continue;
			}
			if (uni_ord > 0xffff)
				goto do_random_range;
			local count = 1;
			for (;;) {
				local cp_next = cp_ord + count;
				if (cp_next > 0xffff)
					break;
				local uni_next = codec.db_table.get(cp_next, 0);
				if (uni_next !is int || uni_next > 0xffff)
					break;
				if (uni_next != (uni_ord ? uni_ord + count : 0))
					break;
				++count;
			}
			if (count == 1) {
do_random_range:
				local randomRangeStart = cp_ord;
				local randomRangeUnicode = [uni_ord];
				for (;;) {
					++cp_ord;
					local uni_ord_0 = codec.db_table.get(cp_ord, 0);
					local uni_ord_1 = codec.db_table.get(cp_ord+1, 0);
					local uni_ord_2 = codec.db_table.get(cp_ord+2, 0);
					if (uni_ord_0 !is int || (uni_ord_0 > 0xffff != uni_ord > 0xffff))
						break;
					if (uni_ord_1 is int && uni_ord_2 is int &&
					    ((uni_ord_0 == 0 && uni_ord_1 == 0 && uni_ord_2 == 0) ||
					     (uni_ord_0+1 == uni_ord_1 && uni_ord_1+1 == uni_ord_2)))
						break;
					randomRangeUnicode.append(uni_ord_0);
				}
				randomRangeUnicode = Tuple(randomRangeUnicode);
				if (#randomRangeUnicode == 1 && uni_ord <= 0xffff &&
				    !(uni_ord == randomRangeStart && randomRangeStart != 0)) {
					cp_ord = randomRangeStart;
					goto do_add_identity_range;
				}
				assert cp_ord - randomRangeStart == #randomRangeUnicode;
				ranges.append((randomRangeStart, #randomRangeUnicode, randomRangeUnicode));
			} else {
do_add_identity_range:
				if (uni_ord == cp_ord && cp_ord != 0)
					goto do_random_range; /* unicode-offset == 0 has special meaning!  */
				assert uni_ord <= 0xffff;
				ranges.append((cp_ord, count, uni_ord));
				cp_ord += count;
			}
		}
		local uniOffsetsInUse = [];
		local random_access_count = 0;
		local random_access_blocks = 0;
		for (local cp_min, count, content: ranges) {
			if (content is int && content <= 0xffff) {
				assert content != cp_min || cp_min == 0,
					"This should have been handled by `goto do_random_range'";
				local unicode_offset = content ? (content - cp_min) & 0xffff : 0;
				uniOffsetsInUse.append(unicode_offset);
			} else {
				random_access_count += count;
				++random_access_blocks;
			}
		}

		/* Find the largest range of free slots between uniOffsetsInUse
		 * This range must be large enough to hold random_access_blocks */
		uniOffsetsInUse.sort();
		local largestRangeStart = 0;
		local largestRangeSize = 0;
		for (local i = 0; i < #uniOffsetsInUse; ++i) {
			local start = uniOffsetsInUse[i] + 1;
			local end = (i+1) >= #uniOffsetsInUse ? 0x10000 : uniOffsetsInUse[i+1];
			local count = end - start;
			if (largestRangeSize < count) {
				largestRangeStart = start;
				largestRangeSize = count;
			}
		}
		if (random_access_blocks > largestRangeSize) {
			throw Error(codec.name + ": Largest range size " + largestRangeSize +
				" is smaller than # of random access block " + random_access_blocks);
		}

		local exCodec = ExStatefulCodec(codec: codec);
		exCodecs.append(exCodec);

		/* Calculate extended codec data. */
		for (local cp_min, count, content: ranges) {
			if (content is int && content <= 0xffff) {
				assert content != cp_min || cp_min == 0,
					"This should have been handled by `goto do_random_range'";
				local unicode_offset = content ? (content - cp_min) & 0xffff : 0;
				assert !(unicode_offset >= largestRangeStart &&
				         unicode_offset < largestRangeStart + largestRangeSize);
				/* Unicode identity range */
				exCodec.isc_db_ranges.append((cp_min, unicode_offset));
			} else if (content is int) {
				assert content > 0xffff; /* 32-bit unicode character */
				assert !(content & 0x80000000), "Not allowed";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
				exCodec.isc_u32.append(content | 0x80000000);
			} else if (#content == 1 && content.first !is int) {
				/* Decode-to-2-character sequence */
				local a, b = content.first...;
				assert !(a & 0x8000), "Not allowed";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
				exCodec.isc_u32.append((a << 16) | b);
			} else {
				/* Random access range. */
				local is32 = content.first > 0xffff;
				for (local x: content)
					assert (x > 0xffff) == is32, "All entires must share the same is32 property!";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				if (is32) {
					exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
					for (local x: content)
						exCodec.isc_u32.append(x | 0x80000000);
				} else {
					exCodec.isc_rab.append(#exCodec.isc_u16);
					exCodec.isc_u16.extend(content);
				}
			}
		}

		assert exCodec.isc_db_ranges.first.first == 0, "The range table must start with CP_ORD=0";
		assert #exCodec.isc_rab <= largestRangeSize, "Somehow we used more than we thought?";
		exCodec.isc_rab_minoff = largestRangeStart;
		exCodec.isc_rab_maxoff = exCodec.isc_rab_minoff + #exCodec.isc_rab - 1;

		/* Relocate RAB offsets to use use the correct u16 table size */
		for (local i: [:#exCodec.isc_rab]) {
			local offset = exCodec.isc_rab[i];
			if (offset >= 0x80000000) {
				offset -= 0x80000000;
				offset += #exCodec.isc_u16;
				exCodec.isc_rab[i] = offset;
			}
		}

		/* Generate encode data */

		@@Sorted list of (uni_ord, cp_ord)
		local encodeTable: {int: int} = Dict();
		local encodeTable32: {int: int} = Dict();
		local encodeTable2Char: {int: {int: int}} = Dict();
		for (local cp_ord, uni_ord: codec.db_table) {
			if (uni_ord !is int) {
				assert #uni_ord == 2;
				assert uni_ord.first <= 0xffff;
				assert uni_ord.last <= 0xffff;
				local subDict = encodeTable2Char.get(uni_ord.first);
				if (subDict is none)
					encodeTable2Char[uni_ord.first] = subDict = Dict();
				subDict[uni_ord.last] = cp_ord;
				continue;
			}
			if (cp_ord == 0)
				continue;
			local usedTable = uni_ord > 0xffff ? encodeTable32 : encodeTable;
			if (uni_ord in usedTable)
				cp_ord = { cp_ord, usedTable[uni_ord] } < ...;
			usedTable[uni_ord] = cp_ord;
		}
		for (local i: [:256]) {
			local uni = codec.sb_table[i];
			if (uni != 0)
				encodeTable[uni] = i;
		}
		encodeTable[0] = 0;

		@@List of (uni_ord, count, cp_ord | {cp_ord...})
		@@When `cp_ord' is 0, it's an undefined range
		local encodeRanges: {(int, int, int | {int...})...} = [];
		for (local uni_ord = 0; uni_ord <= 0xffff;) {
			local cp_ord = encodeTable.get(uni_ord, 0);
			local count = 1;
			local twochar = encodeTable2Char.get(uni_ord);
			if (twochar) {
				/* Handle multi-char sequences. */
				assert cp_ord != 0;
				encodeRanges.append((uni_ord, 1, 0x80000000 + #exCodec.isc_encode_2ch));
				for (local uni2_ord: twochar.keys.sorted()) {
					exCodec.isc_encode_2ch.append((uni2_ord, twochar[uni2_ord]));
				}
				/* Fallback when the follow-up character isn't one of the special ones. */
				exCodec.isc_encode_2ch.append((0, cp_ord));
				++uni_ord;
				continue;
			}
			for (;;) {
				local uni_next = uni_ord + count;
				if (uni_next > 0xffff)
					break;
				if (uni_next in encodeTable2Char)
					break;
				local cp_next = encodeTable.get(uni_next, 0);
				if (cp_next != (cp_ord ? cp_ord + count : 0))
					break;
				++count;
			}
			if (count == 1) {
do_encode_random_range:
				local randomRangeStart = uni_ord;
				local randomRangeCp = [cp_ord];
				for (;;) {
					++uni_ord;
					if (uni_ord in encodeTable2Char)
						break;
					local cp_ord_0 = encodeTable.get(uni_ord, 0);
					local cp_ord_1 = encodeTable.get(uni_ord+1, 0);
					local cp_ord_2 = encodeTable.get(uni_ord+2, 0);
					if (cp_ord_0 == 0 && cp_ord_1 == 0 && cp_ord_2 == 0)
						break;
					if (cp_ord_0+1 == cp_ord_1 && cp_ord_1+1 == cp_ord_2 && cp_ord_0 != uni_ord)
						break;
					randomRangeCp.append(cp_ord_0);
				}
				randomRangeCp = Tuple(randomRangeCp);
				if (#randomRangeCp == 1 && !(cp_ord == randomRangeStart)) {
					uni_ord = randomRangeStart;
					goto do_add_encode_identity_range;
				}
				assert uni_ord - randomRangeStart == #randomRangeCp;
				encodeRanges.append((randomRangeStart, #randomRangeCp, randomRangeCp));
			} else {
do_add_encode_identity_range:
				if (uni_ord == cp_ord)
					goto do_encode_random_range; /* cp-offset == 0 has special meaning!  */
				encodeRanges.append((uni_ord, count, cp_ord));
				uni_ord += count;
			}
		}

		local cpOffsetsInUse = [];
		local random_access_count = 0;
		local random_access_blocks = 0;
		for (local uni_min, count, content: encodeRanges) {
			if (content is int && !(content & 0x80000000)) {
				assert content != uni_min,
					"This should have been handled by `goto do_encode_random_range'";
				local cp_offset = content ? (content - uni_min) & 0xffff : 0;
				cpOffsetsInUse.append(cp_offset);
			} else {
				random_access_count += count;
				++random_access_blocks;
			}
		}

		/* Find the largest range of free slots between cpOffsetsInUse
		 * This range must be large enough to hold TODO:random_access_count/random_access_blocks */
		cpOffsetsInUse.sort();
		local largestRangeStart = 0;
		local largestRangeSize = 0;
		for (local i = 0; i < #cpOffsetsInUse; ++i) {
			local start = cpOffsetsInUse[i] + 1;
			local end = (i+1) >= #cpOffsetsInUse ? 0x10000 : cpOffsetsInUse[i+1];
			local count = end - start;
			if (largestRangeSize < count) {
				largestRangeStart = start;
				largestRangeSize = count;
			}
		}

		/* Generate encode ranges. */
		for (local uni_min, count, content: encodeRanges) {
			if (content is int) {
				if (content & 0x80000000) {
					/* 2-character entry. */
					assert count == 1;
					exCodec.isc_encode_ranges.append((uni_min,
						largestRangeStart + #exCodec.isc_encode_rab));
					exCodec.isc_encode_rab.append(content);
				} else {
					local cp_offset = content ? (content - uni_min) & 0xffff : 0;
					assert !(cp_offset >= largestRangeStart &&
					         cp_offset < largestRangeStart + largestRangeSize);
					exCodec.isc_encode_ranges.append((uni_min, cp_offset));
				}
			} else {
				/* Random access range. */
				exCodec.isc_encode_ranges.append((uni_min,
					largestRangeStart + #exCodec.isc_encode_rab));
				exCodec.isc_encode_rab.append(#exCodec.isc_encode_tab);
				exCodec.isc_encode_tab.extend(content);
			}
		}
		assert exCodec.isc_encode_ranges.first.first == 0, "The encode range table must start with UNI_ORD=0";
		exCodec.isc_encode_rab_minoff = largestRangeStart;
		exCodec.isc_encode_rab_maxoff = largestRangeStart + #exCodec.isc_encode_rab - 1;
		local repl_char = encodeTable.get("?".ord());
		if (repl_char is none || repl_char > 0xff) repl_char = encodeTable.get(".".ord());
		if (repl_char is none || repl_char > 0xff) repl_char = encodeTable.get("-".ord());
		if (repl_char is none || repl_char > 0xff) repl_char = 0;
		exCodec.isc_encode_repl = repl_char;
		
		assert #exCodec.isc_encode_rab <= largestRangeSize;

		/* Relocate 2-character entry offsets. */
		for (local i: [:#exCodec.isc_encode_rab]) {
			local offset = exCodec.isc_encode_rab[i];
			if (offset & 0x80000000) {
				offset = (offset & ~0x80000000) + #exCodec.isc_encode_tab;
				exCodec.isc_encode_rab[i] = offset;
			}
		}

		/* Generate the encode-uni32 table. */
		for (local uni: encodeTable32.keys.sorted()) {
			exCodec.isc_encode_c32.append((uni, encodeTable32[uni]));
		}
		assert #exCodec.isc_encode_2ch <= 0xff;
		assert #exCodec.isc_encode_c32 <= 0xffff;

		/* Ensure that tables containing 32-bit integers are properly aligned. */
		local offset = 22 +                /* offsetof(isc_db_ranges) */
			(#exCodec.isc_db_ranges * 4) + /* sizeof(isc_db_ranges) */
			2 +                            /* sizeof(isc_db_ranges_end) */
			(#exCodec.isc_rab * 2) +       /* sizeof(isc_rab) */
			(#exCodec.isc_u16 * 2);        /* sizeof(isc_u16) */
		if (exCodec.isc_u32) {
			/* Ensure that `isc_u32' is aligned. */
			if (offset & 2) {
				/* Add an unused no-op entry to `isc_u16' */
				exCodec.isc_u16.append(0);
				offset += 2;
			}
			offset += (#exCodec.isc_u32 * 4); /* sizeof(isc_u32) */
		}
		offset += (#exCodec.isc_encode_ranges * 4);  /* sizeof(isc_encode_ranges) */
		offset += 2;                                 /* sizeof(isc_encode_ranges_end) */
		offset += (#exCodec.isc_encode_rab * 2);     /* sizeof(isc_encode_rab) */
		offset += (#exCodec.isc_encode_tab * 2);     /* sizeof(isc_encode_tab) */
		offset += (#exCodec.isc_encode_2ch * 4);     /* sizeof(isc_encode_2ch) */
		if (exCodec.isc_encode_c32) {
			/* Ensure that `isc_encode_c32' is aligned. */
			if (offset & 2) {
				/* Add an unused no-op entry to `isc_encode_tab' */
				exCodec.isc_encode_tab.append(0);
				offset += 2;
			}
			offset += (#exCodec.isc_encode_c32 * 8); /* sizeof(isc_encode_c32) */
		}
	}

	/* With everything calculated, print the database controller. */
	print("struct iconv_stateful_database {");
	for (local exCodec: exCodecs) {
		print;
		print("	/* ", exCodec.codec.name, " */");
		print("	struct {");
		/* For safety, manually count the # of different ranges. */
		local numRandomAccess = 0;
		local numIdentity = 0;
		for (local isr_cp_ord, isr_uni_off: exCodec.isc_db_ranges) {
			if (isr_uni_off >= exCodec.isc_rab_minoff &&
			    isr_uni_off <= exCodec.isc_rab_maxoff)
				++numRandomAccess;
			else {
				++numIdentity;
			}
		}
		/* Then verify that the expected numbers are correct! */
		assert numRandomAccess == #exCodec.isc_rab;
		assert numRandomAccess + numIdentity == #exCodec.isc_db_ranges;
		print("		/* Random access ranges: ", numRandomAccess.hex());
		print("		 * Identity ranges:      ", numIdentity.hex(), " */");
		print("		char16_t                           _sb[256];");
		print("		uint16_t                           _db_count;          /* == ", (#exCodec.isc_db_ranges).hex(), " */");
		print("		uint16_t                           _u16_count;         /* == ", (#exCodec.isc_u16).hex(), " */");
		print("		uint16_t                           _u32_count;         /* == ", (#exCodec.isc_u32).hex(), " */");
		print("		uint16_t                           _rab_minoff;        /* == ", exCodec.isc_rab_minoff.hex(), " */");
		print("		uint16_t                           _rab_maxoff;        /* == ", exCodec.isc_rab_maxoff.hex(), " */");
		print("		uint16_t                           _encode_count;      /* == ", (#exCodec.isc_encode_ranges).hex(), " */");
		print("		uint16_t                           _encode_tab_count;  /* == ", (#exCodec.isc_encode_tab).hex(), " */");
		print("		uint16_t                           _encode_rab_minoff; /* == ", exCodec.isc_encode_rab_minoff.hex(), " */");
		print("		uint16_t                           _encode_rab_maxoff; /* == ", exCodec.isc_encode_rab_maxoff.hex(), " */");
		print("		uint8_t                            _encode_repl;       /* == ", exCodec.isc_encode_repl.hex(), " */");
		print("		uint8_t                            _encode_2ch_count;  /* == ", (#exCodec.isc_encode_2ch).hex(), " */");
		print("		uint16_t                           _encode_c32_count;  /* == ", (#exCodec.isc_encode_c32).hex(), " */");
		print("		struct iconv_stateful_range        _db_ranges[", (#exCodec.isc_db_ranges).hex(), "];");
		print("		uint16_t                           _db_ranges_end;");
		print("		uint16_t                           _rab[", (#exCodec.isc_rab).hex(), "];");
		print("		char16_t                           _u16[", (#exCodec.isc_u16).hex(), "];");
		if (exCodec.isc_u32) {
			print("		uint32_t                           _u32[", (#exCodec.isc_u32).hex(), "];");
		}
		print("		struct iconv_stateful_encode_range _encode_ranges[", (#exCodec.isc_encode_ranges).hex(), "];");
		print("		uint16_t                           _encode_ranges_end;");
		print("		uint16_t                           _encode_rab[", (#exCodec.isc_encode_rab).hex(), "];");
		print("		uint16_t                           _encode_tab[", (#exCodec.isc_encode_tab).hex(), "];");
		if (exCodec.isc_encode_2ch) {
			print("		struct iconv_stateful_2char_encode _encode_2ch[", (#exCodec.isc_encode_2ch).hex(), "];");
		}
		if (exCodec.isc_encode_c32) {
			print("		struct iconv_stateful_c32_encode   _encode_c32[", (#exCodec.isc_encode_c32).hex(), "];");
		}
		print("	} ", dbFieldName(exCodec.codec.name), ";");
	}
	print("};");

	/* Print the offset table. */
	print("INTERN_CONST libiconv_stateful_offset_t const libiconv_stateful_offsets[", #exCodecs, "] = {");
	for (local exCodec: exCodecs)
		print("	[", exCodec.codec.name, " - CODEC_STATEFUL_MIN] = offsetof(struct iconv_stateful_database, ", dbFieldName(exCodec.codec.name), "),");
	print("};");

	/* Now print the database controller contents. */
	print("INTERN_CONST struct iconv_stateful_database const libiconv_stateful_db = {");
	function printCompressed(items: {Object...}, linePrefix: string, maxLineLen: int = 256) {
		local indent = #linePrefix;
		local isFirst = true;
		for (local x: items) {
			if (!isFirst) {
				print(","),;
				++indent;
			}
			isFirst = false;
			if (indent >= maxLineLen) {
				print;
				print(linePrefix),;
				indent = #linePrefix;
			}
			x = str(x);
			indent += #x;
			print(x),;
		}
	}

	for (local exCodec: exCodecs) {
		print;
		print("	/* ", exCodec.codec.name, " */");
		print("	.", dbFieldName(exCodec.codec.name), " = {");
		print("		._sb = {"),;
		printCompressed(exCodec.codec.sb_table, "		        ");
		print("},");
		print("		._db_count = ", #exCodec.isc_db_ranges, ",");
		print("		._u16_count = ", #exCodec.isc_u16, ",");
		print("		._u32_count = ", #exCodec.isc_u32, ",");
		print("		._rab_minoff = ", exCodec.isc_rab_minoff, ",");
		print("		._rab_maxoff = ", exCodec.isc_rab_maxoff, ",");
		print("		._encode_count = ", (#exCodec.isc_encode_ranges).hex(), ",");
		print("		._encode_tab_count = ", (#exCodec.isc_encode_tab).hex(), ",");
		print("		._encode_rab_minoff = ", exCodec.isc_encode_rab_minoff.hex(), ",");
		print("		._encode_rab_maxoff = ", exCodec.isc_encode_rab_maxoff.hex(), ",");
		print("		._encode_repl = ", exCodec.isc_encode_repl.hex(), ",");
		print("		._encode_2ch_count = ", (#exCodec.isc_encode_2ch).hex(), ",");
		print("		._encode_c32_count = ", (#exCodec.isc_encode_c32).hex(), ",");
		print("		._db_ranges = {"),;
		printCompressed(
			(for (local isr_cp_ord, isr_uni_off: exCodec.isc_db_ranges)
				"{" + isr_cp_ord + "," + isr_uni_off + "}"),
			"		               ");
		print("},"),;
		print("		._db_ranges_end = 0xffff,");
		print("		._rab = {"),;
		printCompressed(exCodec.isc_rab, "		         ");
		print("},");
		print("		._u16 = {"),;
		printCompressed(exCodec.isc_u16, "		         ");
		print("},");
		if (exCodec.isc_u32) {
			print("		._u32 = {"),;
			printCompressed(exCodec.isc_u32, "		         ");
			print("},");
		}
		print("		._encode_ranges = {"),;
		printCompressed(
			(for (local iser_uni_ord, iser_cp_off: exCodec.isc_encode_ranges)
				"{" + iser_uni_ord + "," + iser_cp_off + "}")
			, "		                   ");
		print("},");
		print("		._encode_ranges_end = 0xffff,");
		print("		._encode_rab = {"),;
		printCompressed(exCodec.isc_encode_rab, "		                ");
		print("},");
		print("		._encode_tab = {"),;
		printCompressed(exCodec.isc_encode_tab, "		                ");
		print("},");
		if (exCodec.isc_encode_2ch) {
			print("		._encode_2ch = {"),;
			printCompressed(
				(for (local is2ce_uni2, is2ce_cp: exCodec.isc_encode_2ch)
					"{" + is2ce_uni2 + "," + is2ce_cp + "}")
				, "		                ");
			print("},");
		}
		if (exCodec.isc_encode_c32) {
			print("		._encode_c32 = {"),;
			printCompressed(
				(for (local isc32e_uni, isc32e_cp: exCodec.isc_encode_c32)
					"{" + isc32e_uni + "," + isc32e_cp + "}")
				, "		                ");
			print("},");
		}
		print("	},");
	}
	print("};");
}

