/* Copyright (c) 2019-2021 Griefer@Work                                       *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement (see the following) in the product     *
 *    documentation is required:                                              *
 *    Portions Copyright (c) 2019-2021 Griefer@Work                           *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 */

import * from deemon;
import * from .util;
import fs;
import util;


global final CP_CLASS_8      = 0;
global final CP_CLASS_7L     = 1;
global final CP_CLASS_7H     = 2;
global final CP_CLASS_ISO646 = 3;

global final ISO646_OVERRIDE_ORDINALS = {
	0x21, 0x22, 0x23, 0x24, 0x26, 0x3a, 0x3f, 0x40, 0x5b,
	0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d, 0x7e
};

class CodecAlias {
	this = default;
	public member ppCond: string = "1";
	public member name: string;
}

class Codec {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];
}

class CodePage {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];
	public member table: {int...} = List([0] * 256);

	@@Returns one of `CP_CLASS_*`
	public function getCpClass(): int {
		if (table[:128] == [:128])
			return CP_CLASS_7H;
		if (!(table[128:256] + ...)) {
			/* Check for ISO646 */
			local iso646_table = List([:128]);
			for (local i: ISO646_OVERRIDE_ORDINALS)
				iso646_table[i] = table[i];
			if (iso646_table == table[:128])
				return CP_CLASS_ISO646;
			return CP_CLASS_7L;
		}
		return CP_CLASS_8;
	}
}

class StatefulCodec {
	this = default;
	public member name: string;
	public member aliases: {CodecAlias...} = [];

	@@Single-byte table
	public member sb_table: {int...} = List([0] * 256);

	@@Double-byte table
	public member db_table: {int: int | {int...}} = Dict();
}



function getEncodeTable(table: {int...}, shift: int): {int: int} {
	local result = Dict();
	for (local encoded, decoded: util.enumerate(table))
		result.setdefault(decoded, encoded + shift);
	return result;
}

function dbFieldName(name: string): string {
	if (name.startswith("CODEC_"))
		return "db_" + name[6:];
	return "db_" + name;
}


function parseCodecAlias(s: string): CodecAlias {
	local ppCond = "1";
	s = s.strip();
	if (s.startswith("[")) {
		s = s[1:].lstrip();
		if (!s.startswith("if"))
			throw Error("Expected 'if' after '['");
		s = s[2:].lstrip();
		if (!s.startswith("("))
			throw Error("Expected '(' after '[if'");
		s = s[1:].lstrip();
		local condEnd = s.findmatch("(", ")");
		if (condEnd < 0)
			throw Error("Missing ')' after '[if('");
		ppCond = s[:condEnd].strip();
		s = s[condEnd+1:].lstrip();
		if (!s.startswith("]"))
			throw Error("Expected ']' after '[if(...)'");
		s = s[1:].lstrip();
	}
	return CodecAlias(ppCond: ppCond, name:
		normalizeCodecName(s.decode("c-escape")));
}

function constructCodecObject(typ: Type, arg: string): Object {
	local name, none, aliases = arg.partition(":")...;
	return typ(name: name, aliases: Tuple(
		for (local x: aliases.split(","))
			parseCodecAlias(x)));
}


function parseDBFilename(filename: string): {string: Object} {
	print File.stderr: "Loading database:", repr filename;
	local result = Dict();
	local data = File.open(filename, "r").read().decode("utf-8");
	local newData = File.Writer();
	function errAt(i: int, msg: string) {
		local sol = data.rfind("\n", 0, i) + 1;
		local line = data.count("\n", 0, sol) + 1;
		local col = 1 + (i - sol);
		print(filename, "(", line, ",", col, ") : ", msg);
		throw Error(msg);
	}
	local currentItem = none;
	local currentIndex = none;
	local currentTable = none;
	local i = 0, len = #data, flushStart = 0;
	local usedNames = HashSet();
	while (i < len) {
		local ch = data[i];
		if (ch.isspace()) {
			++i;
			continue;
		}
		if (ch == "#") {
			i = data.find("\n", i);
			if (i < 0)
				i = len;
			else {
				++i;
			}
			continue;
		}
		if (ch == "@") {
			++i;
			if (i >= len || !data.issymstrt(i))
				errAt(i, "Expected keyword after '@'");
			local kwdStart = i;
			++i;
			while (i < len && data.issymcont(i))
				++i;
			local kwd = data[kwdStart:i];
			while (i < len && data.isspace(i))
				++i;
			local arg = none;
			local argStart = none;
			if (i < len && data[i] == "(") {
				argStart = i + 1;
				local argEnd = data.findmatch("(", ")", argStart);
				if (argEnd < 0)
					errAt(i, "Unmatched '('");
				arg = data[argStart:argEnd];
				i = argEnd + 1;
			}
			function constructCurrentItem(typ: Type): Object {
				local obj = constructCodecObject(typ, arg);
				if (obj.name in result)
					errAt(argStart, "Codec " + obj.name + " already defined");
				result[obj.name] = obj;
				for (local a: obj.aliases) {
					if (a.ppCond != "1")
						continue;
					local lower_a = a.name.lower();
					if (lower_a in usedNames)
						errAt(argStart, "Alias " + a.name + " already defined");
					usedNames.insert(lower_a);
				}
				return obj;
			}

			switch (kwd.lower()) {

			case "include": {
				local argFilename = arg.decode("c-escape").replace("\\", "/");
				while (argFilename.startswith("./"))
					argFilename = argFilename[2:];
				local otherFilename = fs.joinpath(fs.headof(filename), argFilename);
				result.update(parseDBFilename(otherFilename));
			}	break;

			case "codec":
				currentItem  = constructCurrentItem(Codec);
				currentIndex = 0;
				currentTable = none;
				break;

			case "cp":
				currentItem  = constructCurrentItem(CodePage);
				currentIndex = 0;
				currentTable = currentItem.table;
				break;

			case "codec_stateful":
				currentItem  = constructCurrentItem(StatefulCodec);
				currentIndex = 0;
				currentTable = none;
				break;

			case "sb":
				if (currentItem !is StatefulCodec)
					errAt(argStart, "@SB is only allowed for @CODEC_STATEFUL");
				currentIndex = 0;
				currentTable = currentItem.sb_table;
				break;

			case "db":
				if (currentItem !is StatefulCodec)
					errAt(argStart, "@SB is only allowed for @CODEC_STATEFUL");
				currentIndex = 0;
				currentTable = currentItem.db_table;
				break;

			case "ord": {
				local oldIndex = currentIndex;
				try {
					currentIndex = int(arg);
				} catch (...) {
					errAt(argStart, "Expected integer for @ord, but got " + repr arg);
				}
				if (currentItem is CodePage && oldIndex == 0) {
					for (local i: [oldIndex:currentIndex]) {
						if (currentItem.table[i] == 0)
							currentItem.table[i] = i;
					}
				}
			}	break;

			default:
				errAt(kwdStart, "Unknown command: " + repr kwd);
			}
			continue;
		}
		if (ch.isalnum()) {
			if (currentTable is none)
				errAt(i, "Unable to define ordinals at this time");
			if (currentTable is List) {
				local lineIds = [];
				local lineStart = i;
				for (;;) {
					local uniStart = i;
					++i;
					while (i < len && data.isalnum(i))
						++i;
					local uni;
					local istr = data[uniStart:i].lower();
					if (istr.startswith("0x"))
						istr = istr[2:];
					try {
						uni = int("0x" + istr);
					} catch (...) {
						errAt(uniStart, "Invalid hex integer: " + repr data[uniStart:i]);
					}
					lineIds.append(uni);
					if (currentIndex >= 256)
						errAt(uniStart, "Character index out-of-bounds");
					currentTable[currentIndex] = uni;
					++currentIndex;
					while (i < len && data.isspace(i) && !data.islf(i))
						++i;
					if (i < len && data[i] == ",") {
						do {
							++i;
						} while (i < len && data.isspace(i) && !data.islf(i));
					}
					if (i >= len || !data.isalnum(i))
						break;
				}
				if (i >= len || data[i] in "#\n") {
					while (i > 0 && data.isspace(i - 1) && !data.islf(i - 1))
						--i;
					i = data.find("\n", i);
					if (i < 0)
						i = len;
					newData << data[flushStart:lineStart];
					for (local uni: lineIds)
						newData << uni.hex()[2:].upper().zfill(4) << " ";
					newData << "  # "
						<< (currentIndex - #lineIds).hex()[2:].upper().zfill(2)
						<< "-" << (currentIndex - 1).hex()[2:].upper().zfill(2)
						<< "  ";
					for (local uni: lineIds)
						newData << " " << uniEscape(uni);
					newData << " #";
					flushStart = i;
				}
				continue;
			} else if (currentTable is Dict) {
				/* Supported:
				 *   - ABCD    = 1234       // Single code-point
				 *   - ABCD+FF = 1234       // Map 255 consecutive points from ABCD to 1234+0, +1, +2, ...
				 *   - ABCD    = 1234,1235  // Map code point to a sequence of unicode characters */
				local ordStart = i;
				do {
					++i;
				} while (i < len && data.isalnum(i));
				local cp_ord, count = 1;
				try {
					cp_ord = int("0x" + data[ordStart:i]);
				} catch (...) {
					errAt(ordStart, "Invalid hex integer: " + repr data[ordStart:i]);
				}
				while (i < len && data.isspace(i))
					++i;
				if (i < len && data[i] == "+") {
					do {
						++i;
					} while (i < len && data.isspace(i));
					if (i >= len || !data.isalnum(i))
						errAt(i, "Expected digit after 'ABCD+'");
					local countStart = i;
					do {
						++i;
					} while (i < len && data.isalnum(i));
					try {
						count = int("0x" + data[countStart:i]);
					} catch (...) {
						errAt(countStart, "Invalid hex integer: " + repr data[countStart:i]);
					}
					while (i < len && data.isspace(i))
						++i;
				}
				if (i >= len || data[i] != "=")
					errAt(i, "Expected '=' after 'ABCD[+123]'");
				do {
					++i;
				} while (i < len && data.isspace(i));
				if (i >= len || !data.isalnum(i))
					errAt(i, "Expected digit after 'ABCD[+123]='");
				local uniOrds = [];
				for (;;) {
					local uniStart = i;
					do {
						++i;
					} while (i < len && data.isalnum(i));
					try {
						uniOrds.append(int("0x" + data[uniStart:i]));
					} catch (...) {
						errAt(uniStart, "Invalid hex integer: " + repr data[uniStart:i]);
					}
					while (i < len && data.isspace(i))
						++i;
					if (i >= len || data[i] != ",")
						break;
					do {
						++i;
					} while (i < len && data.isspace(i));
					if (i >= len || !data.isalnum(i))
						errAt(i, "Expected digit after 'ABCD=6789,'");
				}
				if (#uniOrds <= 1)
					uniOrds = uniOrds.first;
				else {
					uniOrds = Tuple(uniOrds);
				}
				if (count == 1) {
					currentTable[cp_ord] = uniOrds;
				} else {
					if (uniOrds !is int)
						errAt(ordStart, "Cannot encode multiple unicode characters range mappings");
					for (local offset: [:count])
						currentTable[cp_ord + offset] = uniOrds + offset;
				}
				continue;
			}
			errAt(i, "Unsupported type of currentTable: " + str(type(currentTable)));
			continue;
		}
		errAt(i, "Unexpected character: " + repr ch);
	}
	newData << data[flushStart:];
	newData = newData.string;
	if (newData != data) {
		newData = newData.encode("utf-8");
		with (local fp = File.open(filename, "w"))
			fp.write(newData);
	}

	local byTable = Dict();
	for (local none, tab: result) {
		if (tab is CodePage) {
			tab.table = Tuple(tab.table);
			if (tab.table == [:256])
				throw Error("Codec " + repr tab.name + " is just latin-1");
			if (tab.table == ([:128] + {0} * 128))
				throw Error("Codec " + repr tab.name + " is just ascii");
			local rp = repr tab.table;
			if (rp in byTable) {
				throw Error("Duplicate table: " +
					tab.name + " and " +
					byTable[rp].name + " (" + repr rp + ")");
			}
			byTable[rp] = tab;
		}
	}
	return result;
}

function parseDB(): {string: Object} {
	return parseDBFilename(fs.joinpath(fs.headof(__FILE__), "db"));
}

global final CODECS = parseDB();

/* Hacky way to work around deemon taking forever to exit (XXX: might be a deemon bug?) */
Error.AppExit.atexit([]{ Error.AppExit.exit(0); });

function printCodecEnums() {
	local codecs_custom = [];
	local codecs_cp8 = [];
	local codecs_cp7l = [];
	local codecs_cp7h = [];
	local codecs_iso646 = [];
	local codecs_stateful = [];
	for (local name, codec: CODECS) {
		if (codec is CodePage) {
			switch (codec.getCpClass()) {
			case CP_CLASS_8:
				codecs_cp8.append(name);
				break;
			case CP_CLASS_7L:
				codecs_cp7l.append(name);
				break;
			case CP_CLASS_7H:
				codecs_cp7h.append(name);
				break;
			case CP_CLASS_ISO646:
				codecs_iso646.append(name);
				break;
			}
		} else if (codec is StatefulCodec) {
			codecs_stateful.append(name);
		} else {
			codecs_custom.append(name);
		}
	}

	function printCodec(name: string, len: int) {
		local codec = CODECS[name];
		print("	", name, ",", " " * (len - #name),
			" /* ", ", ".join(
				for (local x: codec.aliases)
					if (x.ppCond == "1")
						repr(x.name)),
			" */");
	}

	function printCodecs(names: {string...}) {
		local maxLen = names.each.length > ...;
		for (local name: names)
			printCodec(name, maxLen);
	}

	codecs_custom.sort();
	codecs_cp8.sort();
	codecs_cp7l.sort();
	codecs_cp7h.sort();
	codecs_iso646.sort();
	codecs_stateful.sort();

	print("	/* Custom codecs */");
	printCodecs(codecs_custom);

	print;
	print("	/* 8-bit codepage codecs */");
	print("#define CODEC_CP_COUNT ", #codecs_cp8);
	if (codecs_cp8) {
		print("#define CODEC_CP_MIN ", codecs_cp8.first);
		printCodecs(codecs_cp8);
		print("#define CODEC_CP_MAX ", codecs_cp8.last);
	}

	print;
	print("	/* 7l codepage codecs */");
	print("#define CODEC_CP7L_COUNT ", #codecs_cp7l);
	if (codecs_cp7l) {
		print("#define CODEC_CP7L_MIN ", codecs_cp7l.first);
		printCodecs(codecs_cp7l);
		print("#define CODEC_CP7L_MAX ", codecs_cp7l.last);
	}

	print;
	print("	/* 7h codepage codecs */");
	print("#define CODEC_CP7H_COUNT ", #codecs_cp7h);
	if (codecs_cp7h) {
		print("#define CODEC_CP7H_MIN ", codecs_cp7h.first);
		printCodecs(codecs_cp7h);
		print("#define CODEC_CP7H_MAX ", codecs_cp7h.last);
	}

	print;
	print("	/* iso646 codepage codecs */");
	print("#define CODEC_ISO646_COUNT ", #codecs_iso646);
	if (codecs_iso646) {
		print("#define CODEC_ISO646_MIN ", codecs_iso646.first);
		printCodecs(codecs_iso646);
		print("#define CODEC_ISO646_MAX ", codecs_iso646.last);
	}

	print;
	print("	/* Stateful codepage codecs */");
	print("#define CODEC_STATEFUL_COUNT ", #codecs_stateful);
	if (codecs_stateful) {
		print("#define CODEC_STATEFUL_MIN ", codecs_stateful.first);
		printCodecs(codecs_stateful);
		print("#define CODEC_STATEFUL_MAX ", codecs_stateful.last);
	}
}



function printCodecNameDB() {
	local longestAliasLength = 0;
	@@Maps alias -> ppCond -> codec
	local aliasToCodecMapping: {string: {string: Object}} = Dict();
	print("struct codec_name_db_struct {");
	print("	char _hdr_nul[2];");
	local longestDbNameLength = 0;
	for (local name: CODECS.keys.sorted()) {
		local codec = CODECS[name];
		print;
		print("	/* ", name, " */");
		local base = dbFieldName(name);
		local longestAliasNameLenLen = #str((codec.aliases.each.name.length + 1) > ...);
		local prevPpCond = "1";
		for (local i, alias: util.enumerate(codec.aliases)) {
			local name = alias.name;
			local lenPlusOne = str(#name+1);
			if (prevPpCond != alias.ppCond) {
				if (prevPpCond != "1")
					print("#endif /* ", prevPpCond, " */");
				if (alias.ppCond != "1")
					print("#if ", alias.ppCond);
				prevPpCond = alias.ppCond;
			}
			local dbName = "{}_{}".format({ base, i });
			if (longestDbNameLength < #dbName)
				longestDbNameLength = #dbName;
			print("	char ", dbName, "[", lenPlusOne, "]; ",
				" " * (longestAliasNameLenLen - #lenPlusOne),
				"/* ", repr name, " */");
			local map = aliasToCodecMapping.get(name);
			if (map is none)
				aliasToCodecMapping[name] = map = Dict();
			assert alias.ppCond !in map,
				"name:" + repr name + "\n"
				"map: " + repr map.keys + "\n"
				"ppCond:" + repr alias.ppCond;
			map[alias.ppCond] = codec;
		}
		if (prevPpCond != "1")
			print("#endif /* ", prevPpCond ?: "...", " */");
		print("	char ", base, "_nul;");
	}
	print("};");
	print;
	print("/* Name database */");
	print("PRIVATE struct codec_name_db_struct const codec_name_db = {");
	print("	{ 0, 0 },");
	for (local name: CODECS.keys.sorted()) {
		local codec = CODECS[name];
		print;
		print("	/* ", name, " */");
		local prevPpCond = "1";
		for (local i, alias: util.enumerate(codec.aliases)) {
			local name = alias.name;
			local lenPlusOne = str(#name+1);
			if (prevPpCond != alias.ppCond) {
				if (prevPpCond != "1")
					print("#endif /* ", prevPpCond, " */");
				if (alias.ppCond != "1")
					print("#if ", alias.ppCond);
				prevPpCond = alias.ppCond;
			}
			print("	", repr name, ",");
		}
		if (prevPpCond != "1")
			print("#endif /* ", prevPpCond ?: "...", " */");
		print("	0,");
	}
	print("};");
	print;
	print("STATIC_ASSERT((codec_name_db_offset_t)-1 >= sizeof(struct codec_name_db_struct));");
	/* Offset tables. */
	local longestAliasLength = aliasToCodecMapping.keys.each.length > ...;
	print("#define CODE_NAME_MAXLEN ", longestAliasLength);
	print("struct codec_db_entry {");
	print("	codec_name_db_offset_t cdbe_name;  /* Offset to name within `codec_name_db' */");
	print("	iconv_codec_t          cdbe_codec; /* The associated codec. */");
	print("};");
	print;
	print("PRIVATE struct codec_db_entry const codec_db[] = {");
	for (local name: aliasToCodecMapping.keys.sorted()) {
		local lastPpCond = none;
		for (local ppCond, codec: aliasToCodecMapping[name]) {
			if (lastPpCond is none) {
				if (ppCond != "1") {
					print("#if ", ppCond);
					lastPpCond = ppCond;
				}
			} else if (ppCond != "1") {
				lastPpCond = "";
				print("#elif ", ppCond);
			}
			local index = (codec.aliases.each.name as Sequence).index(name);
			local dbName = "{}_{}".format({ dbFieldName(codec.name), index });
			print("	{ offsetof(struct codec_name_db_struct, ", dbName, "),",
				" /* ", " " * (longestDbNameLength - #dbName),
				repr name, " " * (longestAliasLength - #name),
				" */ ", codec.name, " },");
		}
		if (lastPpCond !is none)
			print("#endif /* ", lastPpCond ?: "..." , " */");
	}
	print("};");
}

function printCodepageDatabase(kind: int) {
	local cpInsert = {
		CP_CLASS_8  : "",
		CP_CLASS_7L : "7l",
		CP_CLASS_7H : "7h",
	}[kind];
	local cpInsertUpper = cpInsert.upper();
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is CodePage && codec.getCpClass() == kind)
			codecs.append(codec);
	}
	codecs.sort(CodePage.name);
	print("/* Codepage database blob. */");
	print("struct iconv_cp", cpInsert, "_database {");
	for (local cp: codecs) {
		local table = cp.table;
		local shift = 0;
		if (kind == CP_CLASS_7L) {
			table = table[:128];
		} else if (kind == CP_CLASS_7H) {
			table = table[128:];
			shift = 128;
		}
		local encode_table = getEncodeTable(table, shift);
		local len = str(#encode_table);
		print("	struct { char16_t _d[", #table, "]; struct iconv_codepage_encode_entry _e[", len, "]; ",
			" " * (3 - #len), " } ", dbFieldName(cp.name), ";");
	}
	print("};");

	print;
	print("/* Codepage database offsets. */");
	print("STATIC_ASSERT((libiconv_cp", cpInsert, "_offset_t)-1 >= sizeof(struct iconv_cp", cpInsert, "_database));");
	print("STATIC_ASSERT(CODEC_CP", cpInsertUpper, "_MIN + ", (#codecs-1), " == CODEC_CP", cpInsertUpper, "_MAX);");
	print("INTERN_CONST libiconv_cp", cpInsert, "_offset_t const libiconv_cp", cpInsert, "_offsets[", #codecs, "] = {");
	for (local cp: codecs) {
		print("	[", cp.name, " - CODEC_CP", cpInsertUpper, "_MIN] = offsetof(struct iconv_cp", cpInsert, "_database, ", dbFieldName(cp.name), "),");
	}
	print("};");

	print;
	print("/* The actual codepage database. */");
	print("INTERN_CONST struct iconv_cp", cpInsert, "_database const libiconv_cp", cpInsert, "_db = {");
	for (local cp: codecs) {
		local table = cp.table;
		local shift = 0;
		if (kind == CP_CLASS_7L) {
			table = table[:128];
		} else if (kind == CP_CLASS_7H) {
			table = table[128:];
			shift = 128;
		}
		local encode_table = getEncodeTable(table, shift);
		print("	.", dbFieldName(cp.name), " = { {");
		for (local i, l: util.enumerate(table.segments(8))) {
			local lo = shift + (i * 8);
			print("		", ", ".join(for (local x: l) "0x" + x.hex()[2:].zfill(4)), ", /* ",
				lo.hex()[2:].zfill(2), "h-",
				(lo + 7).hex()[2:].zfill(2), "h */");
		}
		print("	}, {");
		for (local i, ord: util.enumerate(encode_table.keys.sorted())) {
			if ((i % 4) == 0)
				print("		"),;
			local cp_ord = encode_table[ord];
			print("{ 0x", ord.hex()[2:].zfill(4), ", 0x", cp_ord.hex()[2:].zfill(2)),;
			if (i == 0) {
				local count = #encode_table;
				if (kind == CP_CLASS_8)
					--count;
				print(", ", count),;
			} else if (i == 1 && kind != CP_CLASS_7H) {
				local repl_char = encode_table.get("?".ord());
				if (repl_char is none) repl_char = encode_table.get(".".ord());
				if (repl_char is none) repl_char = encode_table.get("-".ord());
				if (repl_char is none) repl_char = 0;
				print(", 0x", repl_char.hex()[2:].zfill(2)),;
			}
			print(" },"),;
			if ((i % 4) == 3)
				print;
			else if (i != #encode_table - 1) {
				print(" "),;
			}
		}
		if ((#encode_table % 4) != 0)
			print;
		print("	} },");
	}
	print("};");
}

function printCp8Database() -> printCodepageDatabase(CP_CLASS_8);
function printCp7lDatabase() -> printCodepageDatabase(CP_CLASS_7L);
function printCp7hDatabase() -> printCodepageDatabase(CP_CLASS_7H);

function printCpIso646Database() {
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is CodePage && codec.getCpClass() == CP_CLASS_ISO646)
			codecs.append(codec);
	}
	codecs.sort(CodePage.name);
	print("INTERN_CONST struct iconv_iso646_codepage const libiconv_iso646_pages[", #codecs, "] = {");
	local longestNameLen = codecs.each.name.length > ...;
	for (local codec: codecs) {
		print("	[", codec.name, " - CODEC_ISO646_MIN]",
			" " * (longestNameLen - #codec.name), " = { { ",
			", ".join(
				for (local x: ISO646_OVERRIDE_ORDINALS)
					"0x" + codec.table[x].hex()[2:].zfill(4)),
			" } },");
	}
	print("};");
}


class ExStatefulCodec {
	this = default;
	public member codec: StatefulCodec;
	public member isc_rab_minoff: int;
	public member isc_rab_maxoff: int;
	public member isc_db_ranges: {(int, int)...} = [];
	public member isc_rab: {int...} = [];
	public member isc_u16: {int...} = [];
	public member isc_u32: {int...} = [];
}


function printCpStatefulDatabase() {
	local codecs = [];
	for (local none, codec: CODECS) {
		if (codec is StatefulCodec)
			codecs.append(codec);
	}
	codecs.sort(StatefulCodec.name);
	local exCodecs: {ExStatefulCodec...} = [];

	/* Generate extended codec data. */
	for (local codec: codecs) {
		@@List of (cp_min, count, uni_min | {uni_ord...})
		local ranges: (int, int, int) = [];
		for (local cp_ord = 0; cp_ord <= 0xffff;) {
			local uni_ord = codec.db_table.get(cp_ord, 0);
			if (uni_ord !is int) {
				ranges.append((cp_ord, 1, (uni_ord,)));
				++cp_ord;
				continue;
			}
			if (uni_ord > 0xffff)
				goto do_random_range;
			local count = 1;
			for (;;) {
				local cp_next = cp_ord + count;
				if (cp_next > 0xffff)
					break;
				local uni_next = codec.db_table.get(cp_next, 0);
				if (uni_next !is int || uni_next > 0xffff)
					break;
				if (uni_next != (uni_ord ? uni_ord + count : 0))
					break;
				++count;
			}
			if (count == 1) {
do_random_range:
				local randomRangeStart = cp_ord;
				local randomRangeUnicode = [uni_ord];
				for (;;) {
					++cp_ord;
					local uni_ord_0 = codec.db_table.get(cp_ord, 0);
					local uni_ord_1 = codec.db_table.get(cp_ord+1, 0);
					local uni_ord_2 = codec.db_table.get(cp_ord+2, 0);
					if (uni_ord_0 !is int || (uni_ord_0 > 0xffff != uni_ord > 0xffff))
						break;
					if (uni_ord_1 is int && uni_ord_2 is int &&
					    ((uni_ord_0 == 0 && uni_ord_1 == 0 && uni_ord_2 == 0) ||
					     (uni_ord_0+1 == uni_ord_1 && uni_ord_1+1 == uni_ord_2)))
						break;
					randomRangeUnicode.append(uni_ord_0);
				}
				randomRangeUnicode = Tuple(randomRangeUnicode);
				if (#randomRangeUnicode == 1 && uni_ord <= 0xffff &&
				    !(uni_ord == cp_ord && cp_ord != 0))
					goto do_add_identity_range;
				assert cp_ord - randomRangeStart == #randomRangeUnicode;
				ranges.append((randomRangeStart, #randomRangeUnicode, randomRangeUnicode));
			} else {
do_add_identity_range:
				if (uni_ord == cp_ord && cp_ord != 0)
					goto do_random_range; /* unicode-offset == 0 has special meaning!  */
				assert uni_ord <= 0xffff;
				ranges.append((cp_ord, count, uni_ord));
				cp_ord += count;
			}
		}
		local uniOffsetsInUse = [];
		local random_access_count = 0;
		local random_access_blocks = 0;
		for (local cp_min, count, content: ranges) {
			if (content is int && content <= 0xffff) {
				assert content != cp_min || cp_min == 0,
					"This should have been handled by `goto do_random_range'";
				local unicode_offset = content ? (content - cp_min) & 0xffff : 0;
				uniOffsetsInUse.append(unicode_offset);
			} else {
				random_access_count += count;
				++random_access_blocks;
			}
		}

		/* Find the largest range of free slots between uniOffsetsInUse
		 * This range must be large enough to hold TODO:random_access_count/random_access_blocks */
		uniOffsetsInUse.sort();
		local largestRangeStart = 0;
		local largestRangeSize = 0;
		for (local i = 0; i < #uniOffsetsInUse; ++i) {
			local start = uniOffsetsInUse[i] + 1;
			local end = (i+1) >= #uniOffsetsInUse ? 0x10000 : uniOffsetsInUse[i+1];
			local count = end - start;
			if (largestRangeSize < count) {
				largestRangeStart = start;
				largestRangeSize = count;
			}
		}
		if (random_access_blocks > largestRangeSize) {
			throw Error(codec.name + ": Largest range size " + largestRangeSize +
				" is smaller than # of random access block " + random_access_blocks);
		}

		local exCodec = ExStatefulCodec(codec: codec);
		exCodecs.append(exCodec);

		/* Calculate extended codec data. */
		for (local cp_min, count, content: ranges) {
			if (content is int && content <= 0xffff) {
				assert content != cp_min || cp_min == 0,
					"This should have been handled by `goto do_random_range'";
				local unicode_offset = content ? (content - cp_min) & 0xffff : 0;
				assert !(unicode_offset >= largestRangeStart &&
				         unicode_offset < largestRangeStart + largestRangeSize);
				/* Unicode identity range */
				exCodec.isc_db_ranges.append((cp_min, unicode_offset));
			} else if (content is int) {
				assert content > 0xffff; /* 32-bit unicode character */
				assert !(content & 0x80000000), "Not allowed";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
				exCodec.isc_u32.append(content | 0x80000000);
			} else if (#content == 1 && content.first !is int) {
				/* Decode-to-2-character sequence */
				local a, b = content.first...;
				assert !(a & 0x8000), "Not allowed";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
				exCodec.isc_u32.append((a << 16) | b);
			} else {
				/* Random access range. */
				local is32 = content.first > 0xffff;
				for (local x: content)
					assert (x > 0xffff) == is32, "All entires must share the same is32 property!";
				exCodec.isc_db_ranges.append((cp_min, largestRangeStart + #exCodec.isc_rab));
				if (is32) {
					exCodec.isc_rab.append(0x80000000 + #exCodec.isc_u32);
					for (local x: content)
						exCodec.isc_u32.append(x | 0x80000000);
				} else {
					exCodec.isc_rab.append(#exCodec.isc_u16);
					exCodec.isc_u16.extend(content);
				}
			}
		}

		assert #exCodec.isc_rab <= largestRangeSize, "Somehow we used more than we thought?";
		exCodec.isc_rab_minoff = largestRangeStart;
		exCodec.isc_rab_maxoff = exCodec.isc_rab_minoff + #exCodec.isc_rab - 1;

		/* Relocate RAB offsets to use use the correct u16 table size */
		for (local i: [:#exCodec.isc_rab]) {
			local offset = exCodec.isc_rab[i];
			if (offset >= 0x80000000) {
				offset -= 0x80000000;
				offset += #exCodec.isc_u16;
				exCodec.isc_rab[i] = offset;
			}
		}
	}

	/* With everything calculated, print the database controller. */
	print("struct iconv_stateful_database {");
	for (local exCodec: exCodecs) {
		print;
		print("	/* ", exCodec.codec.name, " */");
		print("	struct {");
		/* For safety, manually count the # of different ranges. */
		local numRandomAccess = 0;
		local numIdentity = 0;
		for (local isr_cp_ord, isr_uni_off: exCodec.isc_db_ranges) {
			if (isr_uni_off >= exCodec.isc_rab_minoff &&
			    isr_uni_off <= exCodec.isc_rab_maxoff)
				++numRandomAccess;
			else {
				++numIdentity;
			}
		}
		/* Then verify that the expected numbers are correct! */
		assert numRandomAccess == #exCodec.isc_rab;
		assert numRandomAccess + numIdentity == #exCodec.isc_db_ranges;
		print("		/* Random access ranges: ", numRandomAccess.hex());
		print("		 * Identity ranges:      ", numIdentity.hex(), " */");
		print("		char16_t                    _sb[256];");
		print("		uint16_t                    _db_count;   /* == ", (#exCodec.isc_db_ranges).hex(), " */");
		print("		uint16_t                    _u16_count;  /* == ", (#exCodec.isc_u16).hex(), " */");
		print("		uint16_t                    _rab_minoff; /* == ", exCodec.isc_rab_minoff.hex(), " */");
		print("		uint16_t                    _rab_maxoff; /* == ", exCodec.isc_rab_maxoff.hex(), " */");
		print("		struct iconv_stateful_range _db_ranges[", (#exCodec.isc_db_ranges).hex(), "];");
		print("		uint16_t                    _db_ranges_end;");
		print("		uint16_t                    _rab[", (#exCodec.isc_rab).hex(), "];");
		print("		char16_t                    _u16[", (#exCodec.isc_u16).hex(), "];");
		if (exCodec.isc_u32) {
			print("		uint32_t                    _u32[", (#exCodec.isc_u32).hex(), "];");
		}
		print("	} ", dbFieldName(exCodec.codec.name), ";");
	}
	print("};");

	/* Print the offset table. */
	print("INTERN_CONST libiconv_stateful_offset_t const libiconv_stateful_offsets[", #exCodecs, "] = {");
	for (local exCodec: exCodecs)
		print("	[", exCodec.codec.name, " - CODEC_STATEFUL_MIN] = offsetof(struct iconv_stateful_database, ", dbFieldName(exCodec.codec.name), "),");
	print("};");

	/* Now print the database controller contents. */
	print("INTERN_CONST struct iconv_stateful_database const libiconv_stateful_db = {");
	function printCompressed(items: {Object...}, linePrefix: string, maxLineLen: int = 256) {
		local indent = #linePrefix;
		local isFirst = true;
		for (local x: items) {
			if (!isFirst) {
				print(","),;
				++indent;
			}
			isFirst = false;
			if (indent >= maxLineLen) {
				print;
				print(linePrefix),;
				indent = #linePrefix;
			}
			x = str(x);
			indent += #x;
			print(x),;
		}
	}
	
	for (local exCodec: exCodecs) {
		print;
		print("	/* ", exCodec.codec.name, " */");
		print("	.", dbFieldName(exCodec.codec.name), " = {");
		print("		._sb = {"),;
		printCompressed(exCodec.codec.sb_table, "		        ");
		print("},");
		print("		._db_count = ", #exCodec.isc_db_ranges, ",");
		print("		._u16_count = ", #exCodec.isc_u16, ",");
		print("		._rab_minoff = ", exCodec.isc_rab_minoff, ",");
		print("		._rab_maxoff = ", exCodec.isc_rab_maxoff, ",");
		print("		._db_ranges = {"),;
		printCompressed(
			(for (local isr_cp_ord, isr_uni_off: exCodec.isc_db_ranges)
				"{" + isr_cp_ord + "," + isr_uni_off + "}"),
			"		               ");
		print("},"),;
		print("		._db_ranges_end = 0xffff,");
		print("		._rab = {"),;
		printCompressed(exCodec.isc_rab, "		         ");
		print("},");
		print("		._u16 = {"),;
		printCompressed(exCodec.isc_u16, "		         ");
		print("},");
		if (exCodec.isc_u32) {
			print("		._u32 = {"),;
			printCompressed(exCodec.isc_u32, "		         ");
			print("},");
		}
		print("	},");
	}
	print("};");
}

